from __future__ import annotations
from typing import *
from . import utils


class Check:
    """

    A Check is the type of object created from the many functions that create ANSA
    checks. All these functions are in ansa.base.checks module. You should never
    create a Check object directly through its constructor. For example, to create
    a Penetration Distance Range check, you can use the following code snippet:

    pen_distance_range = checks.penetration.DistanceRange()

    A Check, depending on the function used to create it, may have attributes to be
    set. For example, the Length check contains a lower_limit and an upper_limit
    attribute. After setting the attributes, you can run a check, by calling the
    method execute, e.g

    pen_distance_range.execute()

    See Also
    --------
    CheckReport

    Examples
    --------
    ::

            import ansa
            from ansa import base

            ######EXAMPLE 1:


            def main():
                length = base.checks.general.Length()
                length.lower_limit = 10.0
                length.upper_limit = 20.0

                length.execute(exec_mode=base.Check.EXEC_ON_ALL, report=base.Check.REPORT_NONE)


            ######EXAMPLE 2:

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def runCheck():
                objectFreeOpposEdges = base.checks.mesh.TripleBounds()
                errorsList = objectFreeOpposEdges.execute(
                    exec_mode=base.Check.EXEC_ON_ALL, report=base.Check.REPORT_NONE
                )

                return errorsList


            def getEntitiesWithError(checkReports):
                entities = []
                for checkReport in checkReports:
                    for issue in checkReport.issues:
                        if checkReport.has_fix == True:
                            try:
                                checkReport.try_fix(False)
                            except RunTimeError:
                                print("Did not fix header:", header.description)
                        for entity in issue.entities:
                            entities.append(entity)
                return entities


            def main():
                result = runCheck()
                entities = getEntitiesWithError(result)
                set = base.CreateEntity(constants.NASTRAN, "SET")
                base.AddToSet(set, entities)
                print(entities)


            if __name__ == "__main__":
                main()

    """

    EXEC_ON_ALL: int = None
    """
	Defines the execution mode. The execution mode resembles 
	the "Execute on" column in Checks Manages.

	"""

    EXEC_ON_VIS: int = None
    """
	Defines the execution mode. The execution mode resembles 
	the "Execute on" column in Checks Manager.

	"""

    EXEC_ON_MODEL: int = None
    """
	Defines the execution mode. The execution mode resembles 
	the "Execute on" column in Checks Manager.

	"""

    EXEC_ON_SELECTED: int = None
    """
	Defines the execution mode. A sequence of ANSA entities should be also given.

	"""

    REPORT_ALWAYS: int = None
    """
	Defines when the Checks List should appear. With this option 
	the Checks List appears always.

	"""

    REPORT_IF_ERROR: int = None
    """
	Defines when the Checks List should appear. With this option 
	the Checks List appears if errors or warnings exist.

	"""

    REPORT_NONE: int = None
    """
	Defines when the Checks List (the list with the reported issues) should appear. 
	With this option the Checks List never appears.

	"""

    KEEP_OLD: int = None
    """
	Defines whether old items in Checks List Should be purged or not.

	"""

    CLEAR_OLD: int = None
    """
	Defines whether old items in Checks List should be purged or not.

	"""

    DO_NOT_SHOW_RESULTS: int = None
    """
	Defines whether the Checks Manager will show the results (if any) or not. It should be used in combination with REPORT_IF_ERROR and REPORT_ALWAYS options, e.g
	
	some_check.execute(report=Check.REPORT_ALWAYS | Check.DO_NOT_SHOW_RESULTS)

	"""

    active: bool = None
    """
	Defines whether the Check is active in the current template.

	"""

    FIX_APPLIED: int = None
    """
	Denotes that the fix has been applied succesfully.

	"""

    FIX_CANCELED: int = None
    """
	Denotes that the fix hasn't been applied succesfully.

	"""

    FIX_APPLIED_REQUEST_RERUN: int = None
    """
	Triggers the automatic rerun of the check.

	"""

    def execute(
        self, exec_mode: int, entities: object, report: int, history: int
    ) -> object:
        """

        Executes the check.


        Parameters
        ----------
        exec_mode : int, optional
                The execution mode, which can be Check.EXEC_ON_ALL(default), Check.EXEC_ON_VIS, Check.EXEC_ON_MODEL, Check.EXEC_ON_SELECTED. The execution mode resembles the "Execute on" column in Checks Manager.

        entities : object, optional
                A sequence of ANSA entities to be considered by the
                check. This sequence is only considered if `exec_mode'
                is Check.EXEC_ON_SELECTED.

        report : int, optional
                Define when should the Checks List (the list with the reported issues)
                should appear. There are three (3) options. Use Check.REPORT_NONE so that
                the Checks List never appears, Check.REPORT_IF_ERROR to show the
                Checks List only if errors or warnings exist,
                and Check.REPORT_ALWAYS (default) to always show the list.

        history : int, optional
                An optional argument that defines whether old items in Checks List
                should be purged or not. The accepted values are Check.CLEAR_OLD,
                to clear the old check results, if any, and Check.KEEP_OLD (default).

        Returns
        -------
        object
                Returns a list of CheckReport objects.

        """

    def is_available_in_deck(self, deck: int) -> bool:
        """

        Returns if the check is available on a given deck.


        Parameters
        ----------
        deck : int
                eg ansa.constants.NASTRAN

        Returns
        -------
        bool

        """

    def get_name(self) -> str:
        """

        Returns the ANSA check name of the object


        Returns
        -------
        str

        """

    def parameters(self) -> dict:
        """

        Provides information for the parameters of the check


        Returns
        -------
        dict
                Returns a dictionary with the parameters of the check, with their current values.

        """


def AbqStepCollectOutputRequests(step: object) -> list:
    """

    Collects all Output Requests from a STEP.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be retrieved from a previous call to GetEntity.

    Returns
    -------
    list
            It returns a list containing all the output requests of the selected STEP.

    See Also
    --------
    AbqStepInsertOutputRequest, AbqStepDeleteOutputRequest, AbqStepCopyOutputRequest, AbqStepUpdateOutputRequest, AbqStepGetOutputRequestName, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                requests = base.AbqStepCollectOutputRequests(p_step)
                print(len(requests))
                for request in requests:
                    base.AbqStepUpdateOutputRequest(p_step, request, "FREQUENCY", "10")
                    print(base.AbqStepGetOutputRequestName(request))


    """


def AbqStepCopyOutputRequest(step: object, output_request: object) -> int:
    """

    Copies an Output Request from a STEP.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be retrieved from a previous call to GetEntity.

    output_request : object
            A reference to the output request to be copied.

    Returns
    -------
    int
            It returns 0 if the output requests are copied, 1 otherwise.

    See Also
    --------
    AbqStepInsertOutputRequest, AbqStepDeleteOutputRequest, AbqStepUpdateOutputRequest, AbqStepCollectOutputRequests, AbqStepGetOutputRequestName, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                if p_step:
                    request = base.AbqStepInsertOutputRequest(p_step, "*NODE FILE")

                    if base.AbqStepCopyOutputRequest(p_step, request):
                        print("Step Output Request cannot be copied")


    """


def AbqStepDeleteModalDampingParam(step: object, modal_parameter: object) -> int:
    """

    Deletes Modal Damping mode numbers of a STEP's *MODAL DAMPING History Data

    Parameters
    ----------
    step : object
            A reference to a STEP that can be retrieved from a previous call to GetEntity.

    modal_parameter : object
            A reference to a Modal Parameter that can be retrieved from a previous call to AbqStepInsertModalDampingParam or by its index number.

    Returns
    -------
    int
            It returns 1 in case of success or 0 in case of failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                base.AbqStepSetAnalysisType(p_step, "*VISCO")
                base.AbqStepSetHistoryData(
                    p_step, "*MODAL DAMPING", {"define": "YES", "PARAMETER": "MODAL=DIRECT"}
                )

                modal_param1 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 1, "Highest Mode": 2, "Critical Damping Factor": 1.5}
                )
                base.AbqStepDeleteModalDampingParam(step=p_step, modal_parameter=modal_param1)

                modal_param1 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 1, "Highest Mode": 2, "Critical Damping Factor": 1.5}
                )
                base.AbqStepDeleteModalDampingParam(p_step, 0)

                modal_param1 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 1, "Highest Mode": 2, "Critical Damping Factor": 1.5}
                )
                modal_param2 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 2, "Highest Mode": 3, "Critical Damping Factor": 2.5}
                )
                array = [modal_param1, modal_param2]

                base.AbqStepDeleteModalDampingParam(step=p_step, modal_parameter=array)

                modal_param1 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 1, "Highest Mode": 2, "Critical Damping Factor": 1.5}
                )
                modal_param2 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 2, "Highest Mode": 3, "Critical Damping Factor": 2.5}
                )
                array = [0, 0]
                base.AbqStepDeleteModalDampingParam(p_step, array)


    """


def AbqStepDeleteOutputRequest(step: object, output_request: object) -> int:
    """

    Deletes one Output Request from a STEP.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be retrieved from a previous call to GetEntity.

    output_request : object
            A reference to the output request to be deleted.

    Returns
    -------
    int
            It returns 0 if output request is deleted, 1 otherwise.

    See Also
    --------
    AbqStepInsertOutputRequest, AbqStepCopyOutputRequest, AbqStepUpdateOutputRequest, AbqStepCollectOutputRequests, AbqStepGetOutputRequestName, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                if p_step:
                    request = base.AbqStepInsertOutputRequest(p_step, "*NODE FILE")

                    if base.AbqStepDeleteOutputRequest(p_step, request):
                        print("Step Output Request cannot be deleted")


    """


def AbqStepGetAnalysisType(step: object) -> str:
    """

    Returns the analysis type of a STEP as a string.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be retrieved from a previous call to GetEntity.

    Returns
    -------
    str
            It returns the analysis type of a STEP as a string or an empty string in case of failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                print(base.AbqStepGetAnalysisType(p_step))


    """


def AbqStepGetOutputRequestName(output_request: object) -> str:
    """

    Returns the name of the requested Output Request.

    Parameters
    ----------
    output_request : object
            A reference to the output request.

    Returns
    -------
    str
            It returns the output request's name.

    See Also
    --------
    AbqStepInsertOutputRequest, AbqStepDeleteOutputRequest, AbqStepCopyOutputRequest, AbqStepUpdateOutputRequest, AbqStepCollectOutputRequests, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                requests = base.AbqStepCollectOutputRequests(p_step)

                for request in requests:
                    print(base.AbqStepGetOutputRequestName(request))


    """


def AbqStepGetSetsFromOutputRequest(output_request: object) -> object:
    """

    Returns all sets defined for the selected output request.

    Parameters
    ----------
    output_request : object
            A reference to the output request.

    Returns
    -------
    object
            It returns a list containing all the sets of the selected output request.

    See Also
    --------
    AbqStepCollectOutputRequests, AbqStepInsertOutputRequest, AbqStepDeleteOutputRequest, AbqStepCopyOutputRequest, AbqStepUpdateOutputRequest, AbqStepGetOutputRequestName, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                requests = base.AbqStepCollectOutputRequests(p_step)
                for request in requests:
                    sets = base.AbqStepGetSetsFromOutputRequest(request)
                    for set in sets:
                        ret = base.GetEntityCardValues(constants.ABAQUS, set, ("Name",))
                        print(ret["Name"])


    """


def AbqStepInsertModalDampingParam(step: object, fields: object) -> object:
    """

    Inserts Modal Damping mode numbers into a STEP's *MODAL DAMPING History Data.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be retrieved from a previous call to GetEntity.

    fields : object, optional
            A dictionary of params-values pairs (MODAL, RAYLEIGH and STRUCTURAL parameters of *MODAL DAMPING).

    Returns
    -------
    object
            It returns a reference to the created modal param or None in case of failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                base.AbqStepSetAnalysisType(p_step, "*VISCO")
                base.AbqStepSetHistoryData(
                    p_step, "*MODAL DAMPING", {"define": "YES", "PARAMETER": "MODAL=DIRECT"}
                )
                modal_param1 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 1, "Highest Mode": 2, "Critical Damping Factor": 1.5}
                )
                modal_param2 = base.AbqStepInsertModalDampingParam(
                    step=p_step,
                    fields={"Lowest Mode": 2, "Highest Mode": 3, "Critical Damping Factor": 2.5},
                )

                if modal_param1:
                    print("Modal Param 1 inserted")
                else:
                    print("Modal Param 1 failed")
                if modal_param2:
                    print("Modal Param 2 inserted")
                else:
                    print("Modal Param 2 failed")


    """


def AbqStepInsertOutputRequest(
    step: object, output_request: str, *varlen: object
) -> object:
    """

    Inserts an Output Request to a STEP.

    Parameters
    ----------
    step : object
            A reference to a Step that can be retrieved from a previous call to GetEntity

    output_request : str
            The name of the output request (e.g. "*NODE FILE").

    *varlen : object
            These arguments need to be pairs of labels - values. The labels are taken from the fields in the edit card. These fields are then assigned their respective values.

    Returns
    -------
    object
            It returns a reference to the created output request or None in case of failure.

    See Also
    --------
    AbqStepDeleteOutputRequest, AbqStepCopyOutputRequest, AbqStepUpdateOutputRequest, AbqStepCollectOutputRequests, AbqStepGetOutputRequestName, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parameters = {"Name": "my new step", "STEP ID": 1}
                p_step = base.CreateEntity(constants.ABAQUS, "STEP", parameters)
                if p_step:
                    print("OK STEP created")
                else:
                    print("NO STEP")
                val = ["A1", "A3", "CF1"]
                param = base.AbqStepInsertOutputRequest(
                    p_step,
                    "*NODE FILE",
                    "NSET",
                    1,
                    "FREQUENCY",
                    "1",
                    "MODE",
                    "2",
                    "GLOBAL",
                    "NO",
                    "Identifying Keys",
                    val,
                )
                if param:
                    print("*NODE FILE created")
                else:
                    print("*NODE FILE cannot be created")
                xyz = [1.1, 2.1, 3.1]

                param = base.AbqStepInsertOutputRequest(
                    p_step,
                    "*SECTION PRINT",
                    "NAME",
                    "section",
                    "SURFACE",
                    21,
                    "AXES",
                    "LOCAL",
                    "ANCHOR POINT NODE",
                    1,
                    "A POINT COORDS",
                    xyz,
                    "B POINT COORDS",
                    5.5,
                )
                if param:
                    print("*SECTION PRINT created")
                else:
                    print("*SECTION PRINT can not be created")
                a = [1.1, 2.2, 3.3]
                b = [7.1, 6.2, 5.3]
                xyz = [a, b]
                param = base.AbqStepInsertOutputRequest(
                    p_step,
                    "*MODAL DAMPING",
                    "PARAMETER",
                    "MODAL=DIRECT",
                    "DEFINITION",
                    "MODE NUMBERS",
                    "DATA LINES",
                    xyz,
                )
                if param:
                    print("*MODAL DAMPING created")
                else:
                    print("*MODAL DAMPING cannot be created!")
                contact_ids = [1, 2]
                param = base.AbqStepInsertOutputRequest(
                    p_step,
                    "*MODEL CHANGE",
                    "PARAM",
                    "ADD",
                    "TYPE",
                    "CONTACT",
                    "CONTACT",
                    contact_ids,
                )

                section_points = []
                for i in range(0, 16):
                    section_points.append(i + 1)
                param1 = base.AbqStepInsertOutputRequest(
                    p_step,
                    "*ELEMENT OUTPUT",
                    "Identifying Keys",
                    "S",
                    "SECTION POINTS",
                    section_points,
                )

                param2 = base.AbqStepInsertOutputRequest(
                    p_step, "*ELEMENT OUTPUT", "Identifying Keys", "S", "SECTION POINTS", "all"
                )


    """


def AbqStepSetAnalysisType(step: object, analysis_type: str) -> int:
    """

    Sets the analysis type of a STEP.

    Parameters
    ----------
    step : object
            A reference to a Step that can be retrieved from a previous call to GetEntity.

    analysis_type : str
            The name of the analysis type (e.g. "*STATIC", "*BUCKLE", "*VISCO", "*DYNAMIC",
            "*DYNAMIC TEMPERATURE-DISPLACEMENT", "*STEADY STATE DYNAMICS", "*FREQUENCY",
            "*COMPLEX FREQUENCY", "*MODAL DYNAMIC", "*RANDOM RESPONSE", "*STEADY STATE
            TRANSPORT", "*HEAT TRANSFER", "*COUPLED TEMPERATURE-DISPLACEMENT", "*MASS
            DIFFUSION", "*GEOSTATIC", "*DYNAMIC,EXPLICIT", "*SUBSTRUCTURE GENERATE",
            "*MAGNETOSTATIC", "*ELECTROMAGNETIC", "*CFD").

    Returns
    -------
    int
            It returns 1 in case of success or 0 in case of failure.

    See Also
    --------
    AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                if base.AbqStepSetAnalysisType(p_step, "*VISCO"):
                    print("Success")
                else:
                    print("Failed")


    """


def AbqStepSetHistoryData(step: object, type: str, fields: object) -> int:
    """

    Sets the History Data parameters of a STEP.

    Parameters
    ----------
    step : object
            A reference to a Step that can be retrieved from a previous call to GetEntity.

    type : str
            The history data name (e.g. "*RESTART", "*DIAGNOSTICS", "*INERTIA RELIEF", "*BULK
            VISCOSITY", "*GLOBAL DAMPING", "*MODAL DAMPING", "*SELECT EIGENMODES").

    fields : object, optional
            A dictionary of labels - values: The labels are taken from the fields in the edit cards.
            These fields are then assigned the respective values.

    Returns
    -------
    int
            It returns 1 in case of success or 0 in case of failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                base.AbqStepSetAnalysisType(p_step, "*STATIC")
                base.AbqStepSetHistoryData(
                    step=p_step,
                    type="*RESTART",
                    {"WRITE": "ON", "FREQUENCY": 1, "OVERLAY": "OVERLAY"},
                )

                p_step = base.GetEntity(constants.ABAQUS, "STEP", 2)
                base.AbqStepSetAnalysisType(p_step, "*STATIC")
                base.AbqStepSetHistoryData(
                    p_step,
                    "*INERTIA RELIEF",
                    {
                        "define": "YES",
                        "PARAM": "ORIENTATION",
                        "coordinate": 1,
                        "DOF1": "YES",
                        "DOF3": "YES",
                        "X": 1.1,
                        "Y": 2.2,
                        "Z": 3.3,
                    },
                )

                p_step = base.GetEntity(constants.ABAQUS, "STEP", 3)
                base.AbqStepSetAnalysisType(p_step, "*DYNAMIC,EXPLICIT")
                base.AbqStepSetHistoryData(p_step, "*BULK VISCOSITY", {"B1": 1, "B2": 2})

                p_step = base.GetEntity(constantsABAQUS, "STEP", 4)
                base.AbqStepSetAnalysisType(p_step, "*STEADY STATE DYNAMICS")
                base.AbqStepSetHistoryData(
                    p_step,
                    "*GLOBAL DAMPING",
                    {"FIELD": "ALL", "ALPHA": 1.1, "BETA": 2.2, "STRUCTURAL": 3.3},
                )

                p_step = base.GetEntity(constants.ABAQUS, "STEP", 5)
                base.AbqStepSetAnalysisType(p_step, "*DYNAMIC,EXPLICIT")
                base.AbqStepSetHistoryData(
                    p_step,
                    "*DIAGNOSTICS",
                    {
                        "ADAPTIVE MESH": "STEP SUMMARY",
                        "CONTACT INIT.OVERCLOSURE": "DETAIL",
                        "CUTOFF RAT.": 1.1,
                        "DEFORM. SPEED CHECK": "SUMMARY",
                        "DETECT CROSSED SURF.": "ON",
                        "PLASTICITY": "SUMMARY",
                        "WARN.RATIO": 2.2,
                        "WARPED SURFACE": "SUMMARY",
                        "CRITICAL ELEM.": 1,
                        "DEEP PENETR.FACTOR": 3.3,
                    },
                )

                p_step = base.GetEntity(constants.ABAQUS, "STEP", 6)
                base.AbqStepSetAnalysisType(p_step, "*DYNAMIC")
                base.AbqStepSetHistoryData(
                    p_step,
                    "*SELECT EIGENMODES",
                    {
                        "DEFINITION": "MODE NUMBERS",
                        "No.of.Modes": 10,
                        "M1": 1,
                        "M2": 2,
                        "M3": 3,
                        "M4": 4,
                        "M5": 5,
                        "M6": 6,
                        "M7": 7,
                        "M8": 8,
                        "M9": 9,
                        "M10": 10,
                    },
                )

                p_step = base.GetEntity(constants.ABAQUS, "STEP", 7)
                base.AbqStepSetAnalysisType(p_step, "*BUCKLE")
                base.AbqStepSetHistoryData(
                    p_step,
                    "*MODAL DAMPING",
                    "define",
                    "YES",
                    "PARAMETER",
                    "MODAL=DIRECT",
                    "DEFINITION",
                    "FREQUENCY",
                    "FIELD",
                    "ACOUSTIC",
                )


    """


def AbqStepUpdateModalDampingParam(
    step: object, modal_parameter: object, fields: object
) -> int:
    """

    Updates Modal Damping mode numbers of a STEP's *MODAL DAMPING History Data.

    Parameters
    ----------
    step : object
            A reference to a Step that can be retrieved from a previous call to GetEntity.

    modal_parameter : object
            A reference to a Modal Parameter that can be retrieved from a previous call to AbqStepInsertModalDampingParam or by its index number.

    fields : object, optional
            A dictionary with pairs of labels - values. The labels depend on the MODAL, RAYLEIGH and STRUCTURAL parameters of *MODAL DAMPING.

    Returns
    -------
    int
            It returns 1 in case of success or 0 in case of failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                base.AbqStepSetAnalysisType(p_step, "*VISCO")
                base.AbqStepSetHistoryData(
                    p_step, "*MODAL DAMPING", {"define": "YES", "PARAMETER": "MODAL=DIRECT"}
                )
                modal_param1 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 1, "Highest Mode": 2, "Critical Damping Factor": 1.5}
                )  # index == 0
                modal_param2 = base.AbqStepInsertModalDampingParam(
                    p_step, {"Lowest Mode": 2, "Highest Mode": 3, "Critical Damping Factor": 2.5}
                )  # index == 1
                base.AbqStepUpdateModalDampingParam(
                    step=p_step,
                    modal_parameter=modal_param1,
                    fields={"Lowest Mode": 10, "Highest Mode": 20, "Critical Damping Factor": 15.5},
                )
                base.AbqStepUpdateModalDampingParam(p_step, 1, {"Lowest Mode": 22})


    """


def AbqStepUpdateOutputRequest(step: object, output_request: object, varlen) -> int:
    """

    Changes the parameters of an Output Request.

    Parameters
    ----------
    step : object
            A reference to a Step that can be retrieved from a previous call to GetEntity.

    output_request : object
            A reference to the output request to update

    varlen :
            The function's arguments are pairs of labels - values: The labels are taken from the fields
            in the edit card. These fields are then assigned the respective values.

    Returns
    -------
    int
            It returns 0 on success, 1 otherwise.

    See Also
    --------
    AbqStepDeleteOutputRequest, AbqStepCopyOutputRequest, AbqStepInsertOutputRequest, AbqStepCollectOutputRequests, AbqStepGetOutputRequestName, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parameters = {"Name": "my new step", "STEP ID": 1}
                p_step = base.CreateEntity(constants.ABAQUS, "STEP", parameters)
                if p_step:
                    print("OK STEP created")
                else:
                    print("NO STEP")
                    return
                param = base.AbqStepInsertOutputRequest(
                    p_step, "*NODE FILE", "NSET", 1, "FREQUENCY", "1"
                )
                if param:
                    base.AbqStepUpdateOutputRequest(p_step, param, "FREQUENCY", "10")
                section_points = []
                for i in range(0, 16):
                    section_points.append(i + 1)
                param1 = base.AbqStepInsertOutputRequest(
                    p_step,
                    "*ELEMENT OUTPUT",
                    "Identifying Keys",
                    "S",
                    "SECTION POINTS",
                    section_points,
                )

                base.AbqStepUpdateOutputRequest(p_step, param1, "SECTION POINTS", "all")


    """


def AddConsToBC(bc: object, cons: object) -> int:
    """

    Adds an entity or a list of CONS entities to a Fluent2D BC.

    Parameters
    ----------
    bc : object
            A Fluent BC.

    cons : object
            A list with CONS entities.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    Examples
    --------
    ::

            # In the following example a new BC is created and filled with CONS from FACE with id 1.

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                bc = base.CreateEntity(
                    constants.FLUENT2D,
                    "BOUNDARY CONDITIONS",
                    {"Name": "New BC", "EID": 5, "TYPE": "inlet-vent"},
                )
                face = base.GetEntity(constants.FLUENT2D, "FACE", 1)
                cons = base.CollectEntities(constants.FLUENT2D, face, "CONS")
                base.AddConsToBC(bc, cons)


    """


def AddLinkedPartsToGroup(SrcParts: object, DestGroup: object) -> int:
    """

    Creates a link of each part or group of the list SrcParts, to the destination group, DestGroup.

    Parameters
    ----------
    SrcParts : object
            A list of parts.

    DestGroup : object
            The reference to the destination group.

    Returns
    -------
    int
            Returns the number of links successfully created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # create links of parts 1 & 2 into groups 3
                src = list()
                src.append(base.GetPartFromModuleId(1))
                src.append(base.GetPartFromModuleId(2))
                dest = base.GetPartFromModuleId(3)

                ret = base.AddLinkedPartsToGroup(src, dest)
                if ret:
                    print("Error creating links")


    """


def AddToBCSet(bcset: object, entity: object, factors: object) -> int:
    """

    Adds an entity or a matrix containing entities, to a set.
    Use "AddToBCSet(BCSet, Entity)" for MPCADD or SPCADD.
    Use "AddToBCSet(BCSet, Entity, factors=FACTORS)" for A_DLOADSET or A_LOADSET.

    Parameters
    ----------
    bcset : object
            A reference to a bcset.

    entity : object
            An entity or a list of entities to be added.

    factors : object, optional
            A list with floats.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    Examples
    --------
    ::

            # In the following example 4 "MPCADD" entities are created. The first three are kept
            # in a matrix and added to the last one.

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                id = []
                deck = constants.NASTRAN
                id.append(base.CreateEntity(deck, "MPCADD", {"Name": "MPCADD1"}))
                id.append(base.CreateEntity(deck, "MPCADD", {"Name": "MPCADD2"}))
                id.append(base.CreateEntity(deck, "MPCADD", {"Name": "MPCADD3"}))
                id.append(base.CreateEntity(deck, "MPCADD", {"Name": "MPCADD4"}))
                base.AddToBCSet(el, id)


    """


def AddToHighlight(container: object, entities: object, colors: object) -> int:
    """

    Add one or more entities, that are included into the list, into the HighlightContainer.
    The user is able to select the color according to which the highlight will be painted.
    As input, a single color or a list containing color keywords can be given.
    If a list with colors is given, then every entity will be painted with different color,
    thus the number of containing colors must be equal to the number of given entities.
    The color keywords are the following: BLACK, RED, GREEN, BLUE, CYAN, YELLOW, BROWN,
    LIGHT_BROWN, GRAY, LIGHT_BLUE, LIGHT_GREEN, LIGHT_CYAN, LIGHT_RED, LIGHT_MAGENTA
    MAGENTA, WHITE.

    Parameters
    ----------
    container : object
            A reference to the highlight container entity.

    entities : object
            A list with the entities to be highlighted.

    colors : object, optional
            A list of colors.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = list()

                ents.append(base.GetEntity(constants.ABAQUS, "SHELL", 1))
                ents.append(base.GetEntity(constants.ABAQUS, "SHELL", 2))
                ents.append(base.GetEntity(constants.ABAQUS, "SHELL", 3))
                ents.append(base.GetEntity(constants.ABAQUS, "SHELL", 4))

                colors_matrix = ("RED", "GREEN", "MAGENTA", "GRAY", "WHITE")

                container = base.CreateEntity(constants.ABAQUS, "HIGHLIGHT_CONTAINER")

                if base.AddToHighlight(container, ents, colors=colors_matrix):
                    base.RedrawAll()


    """


def AddToInclude(include: Entity, entities: Entity | Iterable) -> int:
    """

    Adds an entity or a list containing entities to an Include file.

    Parameters
    ----------
    include : Entity
            A reference to the include entity.

    entities : Entity | Iterable
            An object or a list of objects of ANSA entities to be added to the include.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    See Also
    --------
    RemoveFromInclude

    Examples
    --------
    ::

            # In the following example an Include file 'new_include_file.nas' is created
            # and filled with the grids with NID: 1,2,..,10

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                m = []
                for i in range(1, 11):
                    ent = base.GetEntity(constants.NASTRAN, "GRID", i)
                    m.append(ent)
                include = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE", {"Name": "new_include_file.nas"}
                )
                base.AddToInclude(include, m)


            # ...or...


            def main():
                include = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE", {"Name": "new_include_file.nas"}
                )
                for i in range(1, 11):
                    base.AddToInclude(include, base.GetEntity(constants.NASTRAN, "GRID", i))


    """


def AddToLview(lock_view: object, entities: object) -> int:
    """

    Adds an entity or a matrix containing entities, to a lock view. The AddToLview
    function performs significantly faster when entities are added in the lock view
    massively, through a list.

    Parameters
    ----------
    lock_view : object
            A reference to a lock view entity.

    entities : object
            A reference or a list of references of ansa entities.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    Examples
    --------
    ::

            # In the following example a lock view named 'new lview' is created and filled

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                m = []
                lview = base.CreateEntity(constants.NASTRAN, "LOCK_VIEW", {"Name": "new lview"})
                for i in range(1, 10):
                    m.append(base.GetEntity(constants.NASTRAN, "GRID", i))
                base.AddToLview(lview, m)


    """


def AddToSet(
    set: Entity,
    entities: Entity | Iterable,
    as_excluded: bool = False,
    as_intersected: bool = False,
) -> int:
    """

    Adds an entity or a list containing entities, to a set.
    The AddToSet function performs significantly faster when entities are added in the set massively, through a list.
    The element(s) can also be added as excluded if appropriate options are specified.

    Parameters
    ----------
    set : Entity
            The set entity reference.

    entities : Entity | Iterable
            A list of references or a single reference of the entities that will be added to the set.

    as_excluded : bool, optional
            True or False to specify if the entities will be used as excluded.

    as_intersected : bool, optional
            Applicable when a "nested" set is added to the parent set and controls whether a boolean operation of type "intersect" is being defined. See example below.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            # In the following example a set named 'new set' is created and filled


            def main():
                m = list()
                for i in range(1, 10):
                    ent = base.GetEntity(constants.NASTRAN, "GRID", i)
                    m.append(ent)

                set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "new set"})
                base.AddToSet(set, m)
                # use base.AddToSet(set, m, as_excluded=True) #to add them as excluded entities


            # ...or...


            def main():
                set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "new set"})
                for i in range(1, 10):
                    base.AddToSet(set, base.GetEntity(constants.NASTRAN, "GRID", i))


            # The following example shows how to handle sets via Boolean Operations
            def main():
                nested_set1 = list()
                nested_set1.append(base.GetEntity(constants.ABAQUS, "SET", 1))

                nested_set2 = list()
                nested_set2.append(base.GetEntity(constants.ABAQUS, "SET", 2))

                vals = {"Name": "union", "Output as:": "Surface", "BOOLEAN OPERATION": "YES"}
                # The keyword BOOLEAN OPERATION affects the set only in ABAQUS deck, where
                # it has an effect on how a set that contains sub-sets is output.
                # Using BOOLEAN OPERATION = NO, the Set created below is output as a SURFACE of TYPE=ELEMENT,
                # while, when BOOLEAN OPERATION=YES, it is output as a SURFACE with COMBINE=UNION.
                union_set = base.CreateEntity(constants.ABAQUS, "SET", vals)
                base.AddToSet(union_set, nested_set1)
                base.AddToSet(union_set, nested_set2)

                vals = {"Name": "intersect", "Output as:": "Surface"}
                intersect_set = base.CreateEntity(constants.ABAQUS, "SET", vals)
                base.AddToSet(intersect_set, nested_set1, as_intersected=True)
                base.AddToSet(intersect_set, nested_set2, as_intersected=True)

                vals = {"Name": "diff", "Output as:": "Surface"}
                diff_set = base.CreateEntity(constants.ABAQUS, "SET", vals)
                base.AddToSet(diff_set, nested_set1)
                base.AddToSet(diff_set, nested_set2, as_excluded=True)


    """


def AirbagCreator(
    DECK: int, GROUP_1: object, GROUP_2: object, RECON: object, PART: object
) -> object:
    """

    Fill the gap between two sets of shells. The function automatically keeps the outer most perimeter of each set and tries to fill the gap between the two perimeters. It fills the inner holes and duplicates the initial shells. All created elements are stored into a new set.

    Parameters
    ----------
    DECK : int
            One of LSDYNA, PAMCRASH, ABAQUS, RADIOSS.

    GROUP_1 : object
            A list with references of input data for the first set.

    GROUP_2 : object
            A list with references of input data for the second set. (the above pointers are: shell property, shell,set, include, ansapart or ansagroup)

    RECON : object
            The reconstruction flag (not equal to 0: reconstruction will take place, equal to 0: no reconstruction).

    PART : object
            A reference to an ansapart, on which the function will store the results, or int PART_ID
            is the module id of that part. If the 'id' is equal to 0 or there is no part with the specified
            module id, the script function creates a new one.

    Returns
    -------
    object
            Returns a reference to the set, that contains the created references.
            In case of invalid input data or failure, it returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                group_1 = list()
                group_2 = list()
                group_1.append(base.GetPartFromModuleId("100"))
                group_1.append(base.GetEntity(constants.NASTRAN, "SHELL", 256))
                group_1.append(base.GetEntity(constants.NASTRAN, "PSHELL", 6))
                group_2.append(base.GetPartFromModuleId("25R"))
                group_2.append(base.GetEntity(constants.NASTRAN, "SET", 2))
                part = base.NewPart("New_Part", "123")
                ret_val = base.AirbagCreator(constants.ABAQUS, group_1, group_2, 0, part)


    """


def AlignGrids(
    nodes: object,
    target_entities: object,
    distance: float,
    offset: float,
    align_to: str,
    use_vector: str,
    dX: float,
    dY: float,
    dZ: float,
    align_to_midplane: bool,
    isospace_grids: bool,
    copy_grids: bool,
    redraw: bool,
    align_on_geometry: bool,
) -> int:
    """

    The function aligns grids to target elements. This functions behaves exactly the same as the Grids->Align function found in GUI. It receives, as input, a container that holds the grids to be aligned and a container that holds the target objects (entities such as shells or facets, grids or geometry objects such as faces or coons) upon which the grids will be aligned.

    Parameters
    ----------
    nodes : object
            A list of nodes to be moved.

    target_entities : object
            A list of target entities.

    distance : float, optional
            The maximum distance that the algorithm will search in order to position the grids
            (default 10). In case Align upon grids plane or line is chosen if a distance is not
            given alignment will always be occuring, regardless distance.

    offset : float, optional
            The offset from the exact aligned position of the grids. (default 0)

    align_to : str, optional
            Choose if the target container holds elements, geometry or grids. (default = grids)

    use_vector : str, optional
            Choose if the projection will be in the user's choice direction or in the normal
            vector direction of the elements or the current screen direction.
            Respective values are user_defined, normal_vector and screen_vector.

    dX : float, optional
            The user can choose a vector for the direction of the alignment.
            If none or zero given, a vertical vector will be used to the target.

    dY : float, optional
            The user can choose a vector for the direction of the alignment.
            If none or zero given, a vertical vector will be used to the target.

    dZ : float, optional
            The user can choose a vector for the direction of the alignment.
            If none or zero given, a vertical vector will be used to the target.

    align_to_midplane : bool, optional
            Choose if the alignment should be implemented upon the midplane
            of the element instead of its skin. (default = False)

    isospace_grids : bool, optional
            If True, the grids will be positioned in equal intervals on their new
            position.(default = True)

    copy_grids : bool, optional
            If True, the function will copy the given
            grids and reposition the ones it created.
            (default = True)

    redraw : bool, optional
            if true the model will be redrawn after alignment.
            (default = False)

    align_on_geometry : bool, optional
            If True and the target entities contain faces or elements of geometry
            the alignment will be done on the face's surface and not on the element's.
            (default = True)

    Returns
    -------
    int
            The function returns 1 on success or 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                grids_set = base.GetEntity(constants.ABAQUS, "SET", 1)  # /SET ID = 1 holds grids.
                trgt_set = base.GetEntity(constants.ABAQUS, "SET", 2)  # SET ID = 2 holds grids.

                base.AlignGrids(
                    grids_set,
                    trgt_set,
                    align_to="grids",
                    distance=100.0,
                    offset=0.0,
                    isopace_grids=True,
                    copy_grids=False,
                    redraw=False,
                )


            def main():
                grids_set = base.GetEntity(constants.ABAQUS, "SET", 1)  # /SET ID = 1 holds grids.
                trgt_facets = base.PickEntities(
                    constants.ABAQUS, ("SOLIDFACET",)
                )  # PyList holding solid facets.

                base.AlignGrids(
                    grids_set,
                    trgt_facets,
                    align_to="grids",
                    distance=100.0,
                    offset=0.0,
                    isopace_grids=True,
                    copy_grids=False,
                    redraw=False,
                )


    """


def All(models: object) -> int:
    """

    This function sets visible all entities of current window, or all entities of a model, or all entities of a list of models, or all existing models to be visible on the screen.

    Parameters
    ----------
    models : object, optional
            a model, or a list of models to set all entities of the referenced model(s) visible.
            or "all models" : in order to set all entities of all existing models (in all ansa windows)                                visible on the screen.

            If there is no argument defined then all entities of current window will be visible

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                model1 = base.GetEntity(constants.NASTRAN, "MODEL", 1)
                base.All(model1)


    """


def AnalyticalSurfaceDeleteLine(surface: object, position: int) -> int:
    """

    The AnalyticalSurfaceDeleteLine function deletes the line at position "position" in analytical surface's "surface" profile. If only two data lines exist in the profile (starting point, and one more) they cannot be deleted.

    Parameters
    ----------
    surface : object
            The existing analytical surface from which the line will be deleted.

    position : int
            Index in surface's profile, that specifies which line will be deleted.
            Position cannot be set to 1 since the first line that describes the starting points is mandatory.

    Returns
    -------
    int
            Returns 0 on succes, otherwise 1.

    See Also
    --------
    AnalyticalSurfaceProfileInfo, AnalyticalSurfaceInsertLine, AnalyticalSurfaceModifyLine

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.AnalyticalSurfaceDeleteLine(surface_1, 2)


    """


def AnalyticalSurfaceInsertLine(surface: object, fields: object) -> int:
    """

    The AnalyticalSurfaceInsertLine function inserts a new data line after the last line in surface's profile.

    Parameters
    ----------
    surface : object
            The existing analytical surface entity to which the line will be inserted.

    fields : object
            The values of the new line, defined in pairs of field - value :
            FIELD - VALUES
            -"type" - "START" | "LINE" | "CIRCL" | "PARAB"], each type has the following keys with float values.
            -"START": "xs", "ys".
            -"LINE": "xe", "ye".
            -"CIRCL": "xe", "ye", "xc", "yc".
            -"PARAB": "xm", "ym", "xe", "ye".

    Returns
    -------
    int
            Returns 0 on succes, otherwise 1.

    See Also
    --------
    AnalyticalSurfaceProfileInfo, AnalyticalSurfaceModifyLine, AnalyticalSurfaceDeleteLine

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.AnalyticalSurfaceInsertLine(surface, {"type": "START", "xs": 0, "ys": -13})
                base.AnalyticalSurfaceInsertLine(
                    surface, {"type": "CIRCL", "xe": 75, "ye": 52, "xc": 7.06897, "yc": 54.61273}
                )


    """


def AnalyticalSurfaceModifyLine(surface: object, fields: object, position: int) -> int:
    """

    The AnalyticalSurfaceModifyLine function changes the specified values of the line in position "position", in the analytical surface "surface".

    Parameters
    ----------
    surface : object
            The existing analytical surface entity, upon which the line will be modified.

    fields : object
            The values of the new line, defined in pairs  of field - value:
            -"type" - "START" | "LINE" | "CIRCL" | "PARAB"], each type has the following keys with float values.
            -"START": "xs", "ys".
            -"LINE": "xe", "ye".
            -"CIRCL": "xe", "ye", "xc", "yc".
            -"PARAB": "xm", "ym", "xe", "ye".

    position : int
            Index in analytical surface's profile matrix, that specifies which line will be modified.
            It must be a positive number.
            Index 1 corresponds to the STARTing points.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    AnalyticalSurfaceProfileInfo, AnalyticalSurfaceInsertLine, AnalyticalSurfaceDeleteLine

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.AnalyticalSurfaceModifyLine(
                    surface, {"type": "START", "xs": 0, "ys": 0}, position=1
                )
                base.AnalyticalSurfaceModifyLine(
                    ent, {"type": "START", "yc": 154.61273}, position=2
                )


    """


def AnalyticalSurfaceProfileInfo(surface: object) -> object:
    """

    Gets the values of the data lines that define the various line, circular, and parabolic segments that form the profile of the analytical surface.

    Parameters
    ----------
    surface : object
            The analytical surface entity, to get info from.

    Returns
    -------
    object
            Returns a dictionary on success, otherwise None.

            The dictionary's first entry has a key "type" with data ["START" | "LINE" | "CIRCL" | "PARAB"].
            For each case the rest of the dictionary's entries have the following keys with float values:
            - "START" : "xs", "ys".
            - "LINE"  : "xe", "ye".
            - "CIRCL" : "xe", "ye", "xc", "yc".
            - "PARAB" : "xm", "ym", "xe", "ye".

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                surface = base.GetEntity(constants.ABAQUS, "SURFACE", 1)
                print(base.AnalyticalSurfaceProfileInfo(surface))


    """


def And(
    entities: Entity | Iterable = None,
    deck: int = None,
    keyword: str = None,
    id: int or Iterable = None,
    apply_on_contents: bool = True,
) -> int:
    """

    This function sets the entities matching the criteria defined by the
    arguments to be visible on screen.

    Parameters
    ----------
    entities : Entity | Iterable, optional
            A list of entities to appear on screen.
            NOTE: This argument can be ommited, if the arguments 'keyword'
            and 'id' are defined.

    deck : int, optional
            The deck type of the entities which will be visible,
            e.g. deck = constants.NASTRAN.

    keyword : str, optional
            The entity type for the specified id (i.e. "PSHELL").

    id : int or Iterable, optional
            The ID of the specified entity, or a list with the IDs of the
            entities to be removed from the screen.

    apply_on_contents : bool, optional
            If set to True, it will also apply the focus command
            on the contents of the given entity, else it will not.
            (Default: True)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = []
                ents.append(base.GetEntity(constants.NASTRAN, "MAT1", 23))
                ents.append(base.GetEntity(constants.NASTRAN, "MAT1", 25))
                status = base.And(ents)

                # ...or...

                status = base.And(keyword="MAT1", id=[23, 25])


    """


def ApplyConnectors(connectors: object) -> int:
    """

    This function applies the corresponding connector, or all the connectors contained in a list.

    A single connector can be retrieved from a previous call to GetEntity.
    A list of connectors can be retrieved from a previous call to CollectEntities.

    Parameters
    ----------
    connectors : object
            A single connector entity or a list of connector entities.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, or 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                #  In case of a single Connector
                connector = base.GetEntity(constants.NASTRAN, "CONNECTOR_ENTITY", 1)
                ret_val = base.ApplyConnectors(connector)
                print(ret_val)

                # In case of a list of Connectors
                all_connectors = base.CollectEntities(constants.NASTRAN, None, "CONNECTOR_ENTITY")
                ret_val = base.ApplyConnectors(all_connectors)
                print(ret_val)


    """


def ApplyGenericEntities(entities: object) -> int:
    """

    This function applies the corresponding Generic Entity, or all the Generic entities contained in a matrix.
    An entity is a reference to an element.It can be retrieved from a previous call to GetEntity.

    Parameters
    ----------
    entities : object
            A Generic Entity object or a list of objects to be applied.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, or 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                geb_bc = base.GetEntity(constants.NASTRAN, "GEB_BC", 1)
                ret_val = base.ApplyGenericEntities(geb_bc)
                print(ret_val)


            # or for a matrix...


            def main():
                all_geb_bc = base.CollectEntities(constants.NASTRAN, None, "GEB_BC")
                ret_val = base.ApplyGenericEntities(all_geb_bc)
                print(ret_val)


    """


def ApplySubcontainerRules(includes: object) -> int:
    """

    This function applies subcontainer rules for the specified includes.

    Parameters
    ----------
    includes : object
            A reference to an include or a list with references to includes.

    Returns
    -------
    int
            The function returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                includes = list()
                includes.append(base.GetEntity(constants.NASTRAN, "INCLUDE", 1))
                includes.append(base.GetEntity(constants.NASTRAN, "INCLUDE", 2))

                base.ApplySubcontainerRules(includes)


            # ...or...


            def main():
                base.ApplySubcontainerRules(None)  # Apply All will be used


    """


def AutoCalculateOrientation(entities: object, grey_outside_volume: bool) -> int:
    """

    The function searches for inverted areas and corrects their orientation.

    Parameters
    ----------
    entities : object
            A list of properties, parts, shells or faces. Accepted values are a list of properties, parts or faces, "Visible".

    grey_outside_volume : bool, optional
            Used to declare whether grey areas will point outside of the volume or not.

    Returns
    -------
    int
            Returns 0 when the orientation is succesful. Otherwise the user should check the result.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL", False)
                base.AutoCalculateOrientation(props, True)


    """


def AutoSurfs() -> int:
    """

    Automatically creates surfaces and faces from a wire base.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.AutoSurfs()


    """


def AutoSurfsMatrix(CURVES: object) -> int:
    """

    This function automatically creates a surface with face.

    Parameters
    ----------
    CURVES : object
            A list of curves. The function takes all the contents of the list and creates
            a surface with face. Else if the variable is FALSE (0 or NULL or anything else) then
            the function takes all the visible curves of database and creates a surface with face.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves = base.CollectEntities(constants.NASTRAN, None, "CURVE", False)
                base.AutoSurfsMatrix(curves)


    """


def BoundBox(entities: object) -> list:
    """

    Get a list with the minimum and maximum 3D coordinates of the entity.

    Parameters
    ----------
    entities : object
            The entities for which the bound box will be calculated.

    Returns
    -------
    list
            Returns a list with 6 floats, containing the minimum and maximum 3D coordinates of the entity.
            If the respective entity doesn't support bounding functionality, None is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                bbox = base.BoundBox(ent)
                if bbox:
                    base.CreateEntity(
                        constants.LSDYNA,
                        "DEFINE_BOX",
                        {
                            "Name": "my bounding box",
                            "XMN": bbox[0],
                            "XMX": bbox[3],
                            "YMN": bbox[1],
                            "YMX": bbox[4],
                            "ZMN": bbox[2],
                            "ZMX": bbox[5],
                        },
                    )


    """


def BranchEntity(entity: object, node_ids: int, action: str, dof: int) -> object:
    """

    Modifies the nodes of an element that has a main-secondary node connectivity or create a branch entity.

    Parameters
    ----------
    entity : object
            is a reference to the element entity to be modified or the element type "RBE2" or "RBE3",
            in case a new entity is to be generated.

    node_ids : int
            A list of node ids to be searched for and branched.

    action : str, optional
            Is one of "add" or "remove". Use one of these to add or remove nodes from the ENTITY.
            Use the option "add" when creating new entities.

    dof : int, optional
            Applies only in case of EXTRN. Defines the degrees of freedom for the defined nodes.
            (Default value: 123456)

    Returns
    -------
    object
            Returns the entity if the branch operation was successful.
            None is returned if an error occurs or the entity is deleted for reasons previously described.

    Examples
    --------
    ::


            For the following example an RBE2 element with 7 nodes (Main node: 1,Secondary nodes: 2,3,..,7)
            and EID: 1 is assumed, as well as the nodes with NID: 10,11,..,50.


            import ansa
            from ansa import base
            from ansa import constants


            def main():
                rbe2 = base.GetEntity(constants.NASTRAN, "RBE2", 1)
                m = list()
                for i in range(10, 50):
                    m.append(i)
                # Add to the RBE2 element the secondary nodes 10,11,..,50
                base.BranchEntity(rbe2, m, "add")

                # Remove the initial nodes from the RBE2
                base.BranchEntity(rbe2, (1, 2, 3, 4, 5, 6, 7), "remove")

                # Create a new RBE3 from nodes 10, 12, 14, 16
                base.BranchEntity("RBE3", [10, 12, 14, 16], "add")


    """


def BreakSurfsAuto(
    faces: object,
    discontinuity: bool,
    patches: bool,
    const_curvature: bool,
    peaks_curvature: bool,
    hot_points: bool,
    twisted_faces_only: bool,
    threshold: float,
) -> int:
    """

    Breaks faces at positions where there are discontinuities or large additive variation of surface curvature.
    Works on visible faces.

    Parameters
    ----------
    faces : object, optional
            A list of faces. If empty or zero, works on visible.

    discontinuity : bool, optional
            If 1 detect discontinuities, otherwise 0.

    patches : bool, optional
            If 1 detect surface patches borders, otherwise 0.

    const_curvature : bool, optional
            If 1 detect constant curvature, otherwise 0.

    peaks_curvature : bool, optional
            If 1 detect maximum curvature peak, otherwise 0.

    hot_points : bool, optional
            If 1 break at hot-points, otherwise 0.

    twisted_faces_only : bool, optional
            If 1 and "peaks_curvature" 1 will break curvature peaks with twist.

    threshold : float, optional
            Real number in [0, 1] if "peaks_curvature" thresholds curvature peaks per face
            with respect to the maximum curvature peak.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                # Example No.1
                # - Take all visible faces.
                # - Break at positions with discontinuity.
                base.BreakSurfsAuto(0)

                # Example No.2
                # - Take all visible faces.
                # - Break at surface patches borders.
                base.BreakSurfsAuto("visible", False, True)

                # Example No.3
                # - Take all data-base faces.
                # - Detect faces with constant curvature and break at the middle of the
                #   parameter.
                base.BreakSurfsAuto("all", False, False, True)

                # Example No.4
                # - Take all visible faces.
                # - Break at positions with largest additive variation of surface curvature
                #   per face.
                base.BreakSurfsAuto(0, False, False, False, True)

                # Example No.5
                # - Take all visible faces.
                # - Break at positions with large additive variation of surface curvature.
                # - Break only variations that exceed the 90% of the maximum variation per
                #   face.
                base.BreakSurfsAuto(False, False, False, False, True, False, False, 0.9)

                # Example No.6
                # - Take all visible faces.
                # - Break at hot-points.
                base.BreakSurfsAuto([], False, False, False, False, True)

                # Example No.7
                # - Take faces with IDs 1, 2, and 3.
                # - Break at positions with large additive variation of surface curvature.
                # - Consider only faces with twists.
                base.BreakSurfsAuto([1, 2, 3], False, False, False, True, False, True)


    """


def SaveFileAsStep(filename: str) -> int:
    """

    This function saves all visible entities to a CAD file with extension .step or .stp.

    Parameters
    ----------
    filename : str
            A filesystem path.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SaveFileAsStep("F:/user/temp/data.step")


    """


def SaveFileAsVda(filename: str) -> int:
    """

    This function saves all visible entities to a CAD file with extension .vda or .vdafs.

    Parameters
    ----------
    filename : str
            A filesystem path.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                base.SaveFileAsVda("F:/user/temp/data.vda")


    """


def ChangeElementsOrder(
    type: str,
    change_order: str,
    entities: object,
    auto_transition: bool,
    variation: str,
) -> int:
    """

    Changes the order of shell and solid elements.

    Parameters
    ----------
    type : str, optional
            The element type can be Shells, Solids or Shells&Solids.
            If not given, the default is Shells&Solids.

    change_order : str, optional
            The type of change can be 1to2,  2to1, 1to3 or 1to4.
            If not given, the default is 1to2.

    entities : object, optional
            The entities that will be selected. It can be a list of elements, a set or None.
            If None or not given, all entities are selected.

    auto_transition : bool, optional
            Boolean that sets the Auto transition flag.

    variation : str, optional
            The variation of high order elements can be Mid-edge, Mid-face or Interior.
            If not given, the default is Mid-edge.

    Returns
    -------
    int
            It returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ChangeElementsOrder("shells", "2to1", None, True)


    """


def ConsMatchingDistance(MATCH_DISTANCE: float) -> int:
    """

    This function sets the curves tolerances with which the automatic Topology takes place in ANSA. This is one of the two Tolerance values that ANSA uses during Topology. The Tolerance for curves is refered to as the CONS Matching Distance and the minimum for this is calculated to be 10E-09.

    Parameters
    ----------
    MATCH_DISTANCE : float

    Returns
    -------
    int
            It returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ConsMatchingDistance(0.2)


    """


def CalcElementMass(entities: object, no_nsm: bool, deck: int) -> object:
    """

    Calculates the mass properties of an entity. Calculated values are returned in a list.

    Parameters
    ----------
    entities : object
            The entities where the calculations will take place.

    no_nsm : bool, optional
            If True, the NSM mass will be ignored.

    deck : int, optional
            The deck where the given entities belong. Some keywords work for specific decks.

    Returns
    -------
    object
            Returns a list upon success, 0 otherwise.
            The list is as follows:

            matrix[0]       mass
            matrix[1]       X coordinate of center of gravity
            matrix[2]       Y coordinate of center of gravity
            matrix[3]       Z coordinate of center of gravity
            matrix[4]       Ixx moment of Inertia
            matrix[5]       Iyy moment of Inertia
            matrix[6]       Izz moment of Inertia
            matrix[7]       Ixy product of Inertia
            matrix[8]       Ixz product of Inertia
            matrix[9]       Iyz product of Inertia
            matrix[10]      I1 principal moment of Inertia
            matrix[11]      I2 principal moment of Inertia
            matrix[12]      I3 principal moment of Inertia
            matrix[13]      e1x x component of unit vector e1 along axis 1
            matrix[14]      e2x x component of unit vector e2 along axis 2
            matrix[15]      e3x x component of unit vector e3 along axis 3
            matrix[16]      e1y y component of unit vector e1 along axis 1
            matrix[17]      e2y y component of unit vector e2 along axis 2
            matrix[18]      e3y y component of unit vector e3 along axis 3
            matrix[19]      e1z z component of unit vector e1 along axis 1
            matrix[20]      e2z z component of unit vector e2 along axis 2
            matrix[21]      e3z z component of unit vector e3 along axis 3

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 110801)
                mass_info = base.CalcElementMass(entity, deck=constants.LSDYNA)
                for i in range(len(mass_info)):
                    print(mass_info[i])


    """


def CalcQCHECK(
    ENTS: object, SKEWNESS_FLAG: bool, WARPING_FLAG: bool, ASPECT_FLAG: bool
) -> float:
    """

    Calculates the total QCHECK value of all components included in the list.

    Parameters
    ----------
    ENTS : object
            A list of entities that should contain shells, faces or PSHELL properties.

    SKEWNESS_FLAG : bool
            Flag for skewness criterion.

    WARPING_FLAG : bool
            Flag for warping criterion.

    ASPECT_FLAG : bool
            Flag for aspect criterion.

    Returns
    -------
    float
            Returns the calculated QCHECK value or 0 if no calculation could be done.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # for all visible shells use:
            def main():
                ents = base.CollectEntities(constants.NASTRAN, None, "SHELL", filter_visible=True)
                val = base.CalcQCHECK(ents, True, False, False)
                print("QCHECK (skewness): ", val)
                val = base.CalcQCHECK(ents, False, True, False)
                print("QCHECK (warping): ", val)
                val = base.CalcQCHECK(ents, False, False, True)
                print("QCHECK (aspect): ", val)
                val = base.CalcQCHECK(ents, True, True, True)
                print("QCHECK (total): ", val)


            # for all shells of a property use:
            def main():
                prop = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                val = base.CalcQCHECK(prop, True, True, True)
                print("total QCHECK value of PID 1 = ", val)


    """


def CalcShellArea(ENTITY: object) -> float:
    """

    Calculates the area of a shell element, solid facet, or shell like element.
    Shell like elements supported:
                    (RIGID, SURFACE, GASKET_LINE, ACOUSTIC, SEGMENT, CAABSF3/4)

    Parameters
    ----------
    ENTITY : object
            A shell like entity object that can be first or second order or a solid facet.

    Returns
    -------
    float
            Returns the value of the area of the shell like entity or solid facet.
            Returns 0 if the input entity is not supported.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "SHELL", 1224)
                area = base.CalcShellArea(ent)
                print(area)

                facet = base.Entity(ansa.constants.NASTRAN, 11, "SOLID", facet=1)
                areafacet = base.CalcShellArea(facet)
                print(areafacet)

                caabsf = base.GetEntity(ansa.constants.NASTRAN, "CAABSF3/4", 15)
                areacaabsf = base.CalcShellArea(caabsf)
                print(areacaabsf)


    """


def CalcSolidVolume(entity: object) -> float:
    """

    Calculates the volume of a solid element or an ANSA volume entity.

    Parameters
    ----------
    entity : object
            A solid entity object that can be first or second order or an ANSA volume entity.

    Returns
    -------
    float
            Returns the value of the volume of the solid or the ANSA volume entity.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "SOLID", 1224)
                volume = base.CalcSolidVolume(ent)
                print(volume)
                ent = base.GetEntity(constants.NASTRAN, "VOLUME", 3)
                volume = base.CalcSolidVolume(ent)
                print(volume)


    """


def CalculateGridsThickness(
    nodes: object,
    target_entities: object,
    distance: float,
    factor: float,
    calculate_to: str,
    use_vector: str,
    dX: float,
    dY: float,
    dZ: float,
    calculate_to_midplane: bool,
    redraw: bool,
) -> int:
    """

    A function that calculates the nodal thickness according to the projection upon the target elements. This functions behaves exactly the same as the Grids->THICKNESS->Calc. Thickness function found in GUI.

    Parameters
    ----------
    nodes : object
            A list of grids where thickness will be calculated.

    target_entities : object
            A list of entities, grids or geometry objects, such as faces or coons,
            according to which the thickness will be calculated.

    distance : float, optional
            The maximum distance that the algorithm will search in order to position
            the grids.
            (Default: 10.)

    factor : float, optional
            The factor with which the calculated thickness will be multiplied.
            (Default: 1.)

    calculate_to : str, optional
            Choose if the target container holds elements, geometry or grids.
            (Default: 'grids')

    use_vector : str, optional
            Choose between 'user_defined', 'normal_vector' or 'screen_vector'.

    dX : float, optional
            The user can choose a vector for the direction of the calculation.
            If none or zero given, a vertical vector, to the target, will be used.

    dY : float, optional
            The user can choose a vector for the direction of the calculation.
            If none or zero given, a vertical vector, to the target, will be used.

    dZ : float, optional
            The user can choose a vector for the direction of the calculation.
            If none or zero given, a vertical vector, to the target, will be used.

    calculate_to_midplane : bool, optional
            Choose if the calculation should be implemented upon the midplane
            of the element instead of its skin.
            (Default: False)

    redraw : bool, optional
            If true the model will be redrawn after alignment.
            (Default: False)

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                grids_set = base.GetEntity(constants.ABAQUS, "SET", 1)  # SET ID = 1 holds grids.
                trgt_set = base.GetEntity(constants.ABAQUS, "SET", 2)  # SET ID = 2 holds grids.

                if base.CalculateGridsThickness(
                    grids_set, trgt_set, calculate_to="grids", distance=100.0, factor=1.0
                ):
                    print("Alignment done !")


            # ------------------------------------------------------------------------------------------


            def main():
                grids_set = base.GetEntity(constants.ABAQUS, "SET", 1)  # SET ID = 1 holds grids.
                entities = (
                    base.GetEntity(constants.ABAQUS, "SHELL", 1),
                    base.GetEntity(constants.ABAQUS, "SHELL", 2),
                    base.GetEntity(constants.ABAQUS, "SHELL", 3),
                )
                CalculateGridsThickness(
                    grids_set,
                    entities,
                    calculate_to="elements",
                    distance=50.0,
                    factor=3.0,
                    dX=0.747,
                    dY=0.747,
                    dZ=0.747,
                    calculate_to_midplane=True,
                    redraw=False,
                )


            # ------------------------------------------------------------------------------------------


            def main():
                grids_set = base.GetEntity(constants.ABAQUS, "SET", 2)
                face = base.GetEntity(constants.ABAQUS, "FACE", 11)
                base.CalculateGridsThickness(
                    grids_set,
                    face,
                    calculate_to="elements",
                    distance=50.0,
                    calculate_to_midplane=True,
                )


    """


def CalculateOffElements(entities: object, details: bool) -> object:
    """

    Calculates the off elements of the database according to the active quality criteria.

    Accepted entities are batch mesh sessions, batch mesh scenarios, part,
    properties, volumes, macros, shells or solids. In case of a batch mesh session the quality
    criteria of the session are used. In case of a batch mesh scenario the
    quality criteria of the sessions are used.
    In all other cases the quality criteria specified in the
    Presentation Parameters window are used.

    In case no argument is given the function will return the off elements
    of visible elements.

    Parameters
    ----------
    entities : object, optional
            "Shells", "Solids", or any list of items suitable for quality calculation.
            Accepted items are: batch mesh scenarios and sessions, parts, properties, volumes, shells, solids, and macros.
            If not given, all visible elements are considered.

    details : bool, optional
            Defines the level of details required from the function.
            Default value is "False"

            If set to "False", only the "TOTAL OFF" number is exact. The per-criterion information about violations is not. This happens because each element, is counted only by the first criterion it violates.
            If set to "True", all numbers are exact, for all criteria. This offers a higher level of detail, suitable when the number of violations are needed per-criterion.

    Returns
    -------
    object
            Returns a dictionary with keys the criteria names, and data the number of off elements
            in the particular criterion.

            e.g.: {'ANGLE': 2, 'TOTAL OFF': 10, 'SKEW': 8, 'WARP': 0}

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # example 1
            def PrintNumOffVisible():
                off_elements = base.CalculateOffElements()
                print(off_elements["TOTAL OFF"])


            # example 2 (like example 1, but more detailed output)
            def PrintNumOffVisiblePerCriterion():
                off_elements = base.CalculateOffElements(details=True)
                print(off_elements)


            # example 3
            def PrintNumOffSolids():
                off_elements = base.CalculateOffElements("Solids")
                print(off_elements["TOTAL OFF"])


            # example 4 (like example 3, but more detailed output)
            def PrintNumOffSolidsPerCriterion():
                off_elements = base.CalculateOffElements("Solids", True)
                print(off_elements)


            def main():
                parts_array = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                for part in parts_array:
                    off_element_dict = base.CalculateOffElements(part)
                    print(off_element_dict)
                # Function will print the total off elements calculated on visible
                PrintOffVisible()

                # Function will print the off solids per criterion calculated on whole model
                PrintNumOffSolidsPerCriterion()


    """


def ChangeCP(CORD: object, GRID: object) -> int:
    """

    This function changes the coordinate system associated to a GRID or a collection of GRIDs.

    Parameters
    ----------
    CORD : object
            A reference to the new coordinate system to be associated to GRID.
            Insert None to switch to the global coordinate system.

    GRID : object
            A reference to a single GRID or a collection/matrix of GRIDs.

    Returns
    -------
    int
            Returns 1 on success or 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            # In the following example we assume that a coordinate system (CORD_NODES_R) exists
            # and its ID is 1.


            def main():
                set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "new set"})
                m = list()
                for i in range(1, 10):
                    m.append(base.GetEntity(constants.NASTRAN, "GRID", i))
                base.AddToSet(set, m)
                contr = (set,)
                types = ("GRID",)
                nodes = base.CollectEntities(constants.NASTRAN, contr, types, recursive=True)
                cord = base.GetEntity(constants.NASTRAN, "CORD_NODES_R", 1)
                base.ChangeCP(cord, nodes)


    """


def ChangeElemType(
    deck: int,
    element: object,
    target_name: str,
    user_part_name: str,
    target_part_name: str,
    pid: int,
    many_nodes: str,
) -> int:
    """

    Changes the element's type from a source type to a destination type.

    Parameters
    ----------
    deck : int
            The deck for which the type of the element will be changed.

    element : object
            A list of elements to change their type.

    target_name : str
            The target element type. The type string must be written as it appears
            in the function ELEMENTs>Util>Change Type.

    user_part_name : str, optional
            The source part name (deprecated).

    target_part_name : str, optional
            Assign new element to a specific part.

    pid : int, optional
            Assign a specific PID in the new element.

    many_nodes : str, optional
            Applicable when target_name is RBE2 or RBE3. Controls if 2-noded elements having a common central node are to be converted to a single RBE with many nodes or to many RBEs with two nodes. (default="off")

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # Apply changes to elements of type CBAR, with IDs 1,2 and 3
            def main():
                m = list()
                for i in range(1, 3):
                    m.append(base.GetEntity(constants.NASTRAN, "CBAR", i))
                base.ChangeElemType(
                    constants.NASTRAN,
                    m,
                    target_name="CROD",
                    user_part_name="grp2",
                    target_part_name="grp3",
                )


            # Apply changes to CBAR with ID 1
            def main():
                base.ChangeElemType(
                    constants.NASTRAN,
                    base.GetEntity(constants.NASTRAN, "CBAR", 1),
                    target_name="CROD",
                )


    """


def ChangeRepresentationToDontUse(parts: object, incl_connectors: bool) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`ChangeRepresentation` instead.


    Changes the representation of a given list of ANSA PARTS, to the "Don't Use" one.

    Parameters
    ----------
    parts : object
            A list that contains the parts that will
            be assigned a "Don't Use" representation.

    incl_connectors : bool
            A boolean that defines whether the external
            connectors should be included in the
            "Don't Use" representation or not.

    Returns
    -------
    int
            Returns 1 on failure and 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = list()
                parts.append(base.GetPartFromModuleId("55"))
                parts.append(base.GetPartFromModuleId("68FRONT"))
                base.ChangeRepresentationToDontUse(parts, True)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: ChangeRepresentation instead.",
        DeprecationWarning,
    )


def ChangeRepresentationToLumpedMass(
    parts: object, incl_connectors: bool, rbe_opt: str
) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`ChangeRepresentation` instead.


    Changes the representation of a given list of ANSA PARTS, to the Lumped Mass one.

    Parameters
    ----------
    parts : object
            that contains ANSA Parts

    incl_connectors : bool
            Determines whether the external connectors will be included in the Lumped Mass representation.

    rbe_opt : str
            Determines the type of the connecting element that will be used.
            Valid types are: "RBE2", "RBE3"

    Returns
    -------
    int
            Returns 1 on failure and 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = [base.GetPartFromModuleId("55"), base.GetPartFromModuleId("68FRONT")]
                base.ChangeRepresentationToLumpedMass(parts, True, "RBE3")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: ChangeRepresentation instead.",
        DeprecationWarning,
    )


def ChangeRepresentationToSPC(
    parts: object, incl_connectors: bool, spc_dofs: int
) -> int:
    """

    Changes the representation of a given list of parts, to an SPC representation.

    Parameters
    ----------
    parts : object
            A list that contains parts whose representation
            will change to SPC.

    incl_connectors : bool
            A boolean that determines if the external connectors
            will be included or not in the SPC representation

    spc_dofs : int, optional
            Integer that specifies the affected Degrees Of Freedom.

    Returns
    -------
    int
            Returns 1 on failure and 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = [base.GetPartFromModuleId("55"), base.GetPartFromModuleId("68FRONT")]
                base.ChangeRepresentationToSPC(parts, True, spc_dofs=123456)


    """


def ChangeRepresentationToTrim(
    parts: object, incl_connectors: bool, distance: float, mass: float, deck: str
) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`ChangeRepresentation` instead.


    The function changes the representation of a given list of ANSA PARTS, to the "Trim" one.

    Parameters
    ----------
    parts : object
            A list that contains the ANSA parts that
            will be assigned a "Trim" representation.

    incl_connectors : bool
            Determines whether external connectors will
            be included in the "Trim" representation.

    distance : float
            Search distance of the respective GEB_MT.

    mass : float
            Mass field of the respective GEB_MT.

    deck : str
            A string that describes the deck.

    Returns
    -------
    int
            Returns 1 on failure and 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("55"), base.GetPartFromModuleId("68FRONT"))
                base.ChangeRepresentationToTrim(parts, 1, 10, 0.005, "NASTRAN")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: ChangeRepresentation instead.",
        DeprecationWarning,
    )


def ChangeRepresentationToUse(parts: object) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`ChangeRepresentation` instead.


    Changes the representation of a list of ANSA PARTS, to the Use one.

    Parameters
    ----------
    parts : object
            A list that contains ANSA parts whose
            representation will change to the "Use" one.

    Returns
    -------
    int
            Returns 1 on failure and 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = (base.GetPartFromModuleId("55"), base.GetPartFromModuleId("68FRONT"))
                base.ChangeRepresentationToUse(parts)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: ChangeRepresentation instead.",
        DeprecationWarning,
    )


def CheckAndFixGeometry(
    input: object,
    options: object,
    fix_options: object,
    return_one_matrix_for_every_error: bool,
    remaining_errors: bool,
) -> object:
    """

    This function performs geometry checks and fixes them.

    Parameters
    ----------
    input : object
            An entity or a list of entities, parts, properties, materials,
            sets or faces.
            If 0 is given visible entities will be taken into account.

    options : object
            A list with check options "UNMESHED MACROS", "UNCHECKED FACES",
            "NEEDLE FACES", "COLLAPSED CONS", "TRIPLE CONS", "OVERLAPS",
            "CRACKS", "SINGLE CONS", "SHARP EDGES".

    fix_options : object
            A list with 1 or 0 corresponding to the options and denotes
            if the errors will be fixed or not.

    return_one_matrix_for_every_error : bool, optional
            Returns a list with lists for each error
            containing the failed entities.

    remaining_errors : bool, optional
            Returns a list with the types of the errors.

    Returns
    -------
    object
            Returns the following dictionary:
            key: 'failed'           values: list of failed entities.
            key: 'per_error'        values: list with lists of failed entities.
            key: 'remaining_errors' values: list with remaining error strings.

            None in case of no error.

    Examples
    --------
    ::

            # Check for problems with faces
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                property = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                options = [
                    "CRACKS",
                    "OVERLAPS",
                    "NEEDLE FACES",
                    "COLLAPSED CONS",
                    "UNCHECKED FACES",
                    "UNMESHED MACROS",
                ]
                fix = [1, 1, 1, 1, 1, 0]
                ret = base.CheckAndFixGeometry(property, options, fix, True, True)
                if ret != None:
                    print("Total remaining errors: ", len(ret["failed"]))
                    print("Type of remaining errors: ", len(ret["remaining_errors"]))


            # Check for problems in bounds for visible fe shells
            def main():
                options = ["SINGLE BOUNDS", "TRIPLE BOUNDS"]
                fix = [0, 0]
                ret = base.CheckAndFixGeometry(0, options, fix, True)
                if ret != None:
                    print("Total errors: ", len(ret["failed"]))


    """


def CheckAndFixPenetrations(
    type: int,
    fast_run: bool,
    factor: float,
    fix: bool,
    user_thic: float,
    max_dist: float,
    min_dist: float,
    chk_same_pid: bool,
    use_const_len: bool,
    orientation_based: bool,
    orientation_mode: int,
    max_angle: float,
    return_regions: bool,
) -> object:
    """

    Checks the existence of intersections and thickness penetrations between elements.

    Parameters
    ----------
    type : int
            Defines the type of penetration check:
            1 = intersections
            2 = property thickness
            3 = user thickness
            4 = distance range
            5 = proximities

    fast_run : bool
            True: the function will exit on first intersection it finds.
            False: the function will search for all intersections.

    factor : float, optional
            The scale factor for the element thicknesses.

    fix : bool, optional
            A flag for fixing existing penetrations (True or False).

    user_thic : float, optional
            The needed user defined thickness.

    max_dist : float, optional
            The needed maximum distance.

    min_dist : float, optional
            The needed minimum distance.

    chk_same_pid : bool, optional
            A flag for self-proximities check (True or False).

    use_const_len : bool, optional
            A flag for absolute distance check.
            (False = element length factor check , True = absolute distance check ).

    orientation_based : bool, optional
            The old flag that defined orientation mode (True = grey-grey, False = everything).
            This flag is ignored if orientation_mode is defined.

    orientation_mode : int, optional
            A flag for orientation mode (1 = grey-grey, 2 = yellow-yellow, 0 = everything).

    max_angle : float, optional
            The value for maximum allowed angle between proximity elements.

    return_regions : bool, optional
            True : The final penetrated and/or intersected elements will be grouped
            to penetration region areas ( defined by edge neighbourhoud ).
            The returning list will contain sublists with the entities of each such area.
            False: The returning list contains all the penetrated and/or intersected elements.

    Returns
    -------
    object
            Returns:
            -1: If there is an error in input data.
            None: If no penetrations/intersections are found.
            1: If any penetrations/intersections are found and fast_run is True.
            A list containing all penetrated/intersected elements: If fast_run is False.

    Examples
    --------
    ::

            import ansa

            # Intersections check:
            ansa.base.CheckAndFixPenetrations(type=1, fast_run=True)
            # will perform penetrations check and exit on the first intersection found returning 1.

            # Property thickness check:
            ansa.base.CheckAndFixPenetrations(type=2, fast_run=False, factor=1.2, fix=True)
            # will perform full property thickness check with factor = 1.2 and attempt to fix existing penetrations.If any penetrations/intersections are left they will be return in matrix.

            # User thickness check :
            ansa.base.CheckAndFixPenetrations(
                type=3, fast_run=True, user_thic=2.12, fix=False, return_regions=True
            )
            # will perform fast user thickness penetration check with user thickness = 2.12 and will not attempt to fix existing penetrations. Final penetrations will be grouped in regions.

            # Distance range check :
            ansa.base.CheckAndFixPenetrations(type=4, fast_run=True, max_dist=3.17, min_dist=1.24)
            # will perform fast distance range penetration check with maximum distance = 3.17 and minimum distance = 1.24.

            # Proximities Check :
            ansa.base.CheckAndFixPenetrations(
                type=5,
                fast_run=False,
                factor=0.5,
                chk_same_pid=True,
                use_const_len=False,
                orientation_mode=1,
                max_angle=30,
                fix=True,
            )
            # will perform proximities penetration check with element length factor 0,5 , self proximity = ON , orientation mode = grey-grey, maximum angle = 30 degrees.
            # After checking, it will attempt to fix any penetrations found by refining the mesh.


    """


def CheckAndFixRigidDependencies(log: int) -> int:
    """

    Checks the existence of rigid dependencies under LS-DYNA and RADIOSS decks and fixes them.
    The check will run on non-visible entities also.

    Parameters
    ----------
    log : int, optional
            Log results on info box. Values are 0 and 1. Default is 0.

    Returns
    -------
    int
            The function returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            # example 1
            def main():
                base.CheckAndFixRigidDependencies()  # do not log


            # example 2
            def main():
                base.CheckAndFixRigidDependencies(1)  # log results on info box.


    """


def CheckConnections(
    InputConnectionsArray: object,
    InputCheckDataArray: object,
    OutputCheckReportArray: object,
) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`Check` instead.


    This function is deprecated please use base.Check() instead.

    Checks connections (spotwelds or spotlines) for specific violations.

    Parameters
    ----------
    InputConnectionsArray : object
            A list that contains the connections to check.
            If empty or undefined the check will run on visible.

    InputCheckDataArray : object
            A list that contains the description of checks to be done
            and their variables. Filled from the user. This list must contain
            one list for every check to be done. Every check-submatrix must
            contain the check's name at the first position (to define that
            this check will be performed) and then the name of a variable
            and the value of it. The available checks and their variables
            are the following:
            "Check number of parts < 2"
            "Check maximum distance", "method", "factor", "distance"
            ( method : 1 = search by factor , 2 = search by distance ).
            "Check minimum distance", "method", "factor", "distance"
            ( method : 1 = search by factor , 2 = search by distance ).
            "Check flanges angle", "angle". "Check projections proximity",
            "proximity". "Check total thickness", "total_thic".
            "Check intersecting parts". "Check spider positioning",
            "diameter", "zone_width", "zone_index", "perim_dist",
            "distance_from_feature","feat_angle" ( zone_index : 1 = absolute, 2: *diameter )
            "Check connections outside flange". "Check double", "equivalent_connectivity",
            "same_type", "curves_faces_distance" (dist > 0), "similarity" (sim>=0 and sim <=100),
            "average_thickness_factor" or "spot_distance" (value > 0)
            "sdist" : value for "Check projections success" but we don't need to define
            the name of this check because it is always performed first.
            If a variable is not/wrongly defined, it will have it's default ANSA value.

    OutputCheckReportArray : object
            Contains the results of the check(s), it is filled from the check.
            This list contains one matrix for every failed check. Every submatrix
            contains the violation name at the first position and then the violating
            connections. In case of failed "Check projections proximity" the list
            will contain pairs of violating connections. The possible violation
            messages are the following:
            "No connectivity parts defined"
            "Only one part defined"
            "Missing parts/properties"
            "Connection failed to project".
            "Bad maximum distance between outer parts".
            "Bad maximum distance between inner parts".
            "Bad minimum distance between outer parts".
            "Bad minimum distance between inner parts".
            "Bad connecting flanges angle".
            "Bad total thickness of connecting parts".
            "Connection is outside flange".
            "Bad Spider positioning".
            "Intersecting parts between connection flanges".
            "Connections have too close projections on flange".
            "Double connections".

    Returns
    -------
    int
            Returns the number of the connections that failed a test.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                InputConnectionsArray = base.CollectEntities(
                    constants.NASTRAN, None, "SpotweldPoint_Type"
                )
                InputCheckDataArray = [
                    ["Check maximum distance", "method", 1, "factor", 3.5],
                    ["Check flanges angle", "angle", 15],
                    [
                        "Check projections proximity",
                        "Check intersecting parts",
                        "Check total thickness",
                    ],
                ]
                errors = base.CheckConnections(
                    InputConnectionsArray, InputCheckDataArray, OutputCheckReportArray
                )


            # This would run for all database spotweld points and perform :
            # Projection success with default sdist.
            # "Check maximum distance" defined by factor = 3,5.
            # "Check flanges angle" with angle = 15.
            # "Check projections proximity" with default proximity value.
            # "Check total thickness" with default total thickness value.
            # "Check intersecting parts".
            # No check will be performed for :
            # "Check minimum distance", "Check connections outside flange".


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: Check instead.",
        DeprecationWarning,
    )


def CheckDMUpdates(parts: object, data: object) -> object:
    """

    This function checks for updates of a list of parts in DM or searches DM
    according to specific criteria.

    Parameters
    ----------
    parts : object
            A list of entities to check for, or an ANSA Type to be queried.

    data : object
            This argument can be either a dictionary or a list.
            In case "data" is a dictionary, it is used to check for DM Updates.
            When "data" is a list, it is used to search DM with specific filters.

    Returns
    -------
    object
            The function returns a dictionary:
            key='error'     values: 0(Success), 1(Nothing found), 2(No DM ROOT set), 3(No access to DM ROOT), 4(Error in filters)
            key='output'    values: A list with lists of results for each part of the input list

            The list returned under the "output" key has the same size as the parts list (input argument)
            disregarding any empty or multi-instanciated parts. For each part there is a corresponding result.

            If nothing was found for one part, then the corresponding entry in the list is 0.
            Otherwise, in the corresponding position of the output list, a sub-list is returned, which
            references ANSA DM Items in a similar manner to the DM Browser. Each ANSA DM Item that was returned
            from the function has an Attribute with the name "DM Updates" which describes the
            type of the update(e.g. "Newer File", "Newer Version"). These items can be downloaded using the
            DownloadPartsFromDM() function, and any information needed about them can be retrieved using GetEntityCardValues().

    See Also
    --------
    DownloadPartsFromDM

    Examples
    --------
    ::

            import ansa
            from ansa import base


            # A) If the user wants to check for DM updates
            def main():
                # Collect  ALL parts
                search = "ANSAPART"
                all_parts = base.CollectEntities(0, None, search, False)
                print("All parts = ", len(all_parts))

                # Collect Master Instances of multi instanciated parts
                tmp_parts = []
                for part in all_parts:
                    tmp_parts.append(base.GetMasterInstance(part))
                mparts = set(tmp_parts)
                master_parts = list(mparts)
                print("Master Instances= ", len(master_parts))

                # Get DM updates of Master Instances
                check_dm_updates_data = {
                    "newer_file": True,
                    "newer_version": [
                        True,  # for "Previous if no newer is found"
                        True,  # for "Report commmon repr for newer version"
                        True,  # for "Report any repr for newer version"
                    ],
                    "newer_st_version": True,
                }
                output_array = base.CheckDMUpdates(master_parts, check_dm_updates_data)
                print("Output = ", len(output_array["output"]))

                # Print results
                for item in output_array["output"]:
                    if item != 0:
                        print("DM item Id : ", item[0]._id)
                        ret = base.GetEntityCardValues(0, item[0], ["DM Updates", "Representation"])
                        print("DM Update status :", ret["DM Updates"])


            # B) If the user wants to search DM according to specific filters for the given parts:
            def main():
                search = ("ANSAPART",)
                all_parts = base.CollectEntities(0, None, search)
                dm_filters = [
                    ["Version", "equals", "AB"],
                    ["Representation", "equals", "FrontImpact"],
                ]
                output_array = base.CheckDMUpdates(all_parts, dm_filters)

                for item in output_array["output"]:
                    if item != 0:
                        for ent in item:
                            ret = base.GetEntityCardValues(0, ent, ["Representation", "Version"])
                            print("Reperesentation :", ret["Representation"])
                            print("Version :", ret["Version"])


    """


def CheckFree(visibility: str, nodes_with_mass_free: bool) -> object:
    """
    .. deprecated:: 18.1.0
            Use :py:func:`FreeNodes` instead.


    Checks for free nodes.

    Parameters
    ----------
    visibility : str
            Set to "visible", in case CHECK FREE applies to VISIBLE nodes only, or "all",
            in case CHECK FREE applies to WHOLE DB, just like the sub-pulldown menu of the
            original CHECK FREE function.

    nodes_with_mass_free : bool, optional
            True (default): considers nodes with masses as free dependent.

    Returns
    -------
    object
            Returns a list containing references to the FREE nodes on success, or 0 if invalid arguments were specified or if no FREE nodes were found.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                free_nodes = base.CheckFree("visible")


            # ...or...


            def main():
                base.CheckFree("all")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 18.1.0. Use :py:func: FreeNodes instead.",
        DeprecationWarning,
    )


def CheckInteriorIntersections(fast_run: bool, entities: object) -> object:
    """

    Checks for intersections including the interior of solids (not only skin).

    Parameters
    ----------
    fast_run : bool
            If fast_run = True the check will run for visible entites.
            If fast_run = False the check will search for all intersections.

    entities : object, optional
            A list with the entities to be checked.
            If not defined the check will run for visible entites.

    Returns
    -------
    object
            Returns a dictionary with keys 'intersected' containing the intersected elements and 'intersections' containing the number of intersected elements.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                InputEntsMatrix = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                ret = base.CheckInteriorIntersections(entities=InputEntsMatrix, fast_run=False)
                print(ret["intersected"])
                print(ret["intersections"])


    """


def CheckIntersections(
    check_visible: bool, fast_run: bool, return_regions: bool
) -> object:
    """

    Checks the existence of intersections between elements.

    Parameters
    ----------
    check_visible : bool
            If True the function will work on visible entities only.
            If False the function will work on the whole database.

    fast_run : bool
            If True the function will exit on first intersection it finds.
            If False the function will search for all intersections.

    return_regions : bool, optional
            If True the intersected elements will be grouped to region
            areas (defined by edge neighbourhoud).
            The returning list will contain sublists with the entities of each such area.
            If False, the returning list contains all the intersected elements.

    Returns
    -------
    object
            Returns None if no intersections are found.
            Returns 1 if any intersections are found and fast_run = True
            Returns a list containing all intersected elements if fast_run = False and return_regions = False.
            Returns a list containing one list per intersected region if fast_run = False and return_regions = True.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ret_val = base.CheckIntersections(True, False, False)
                if ret_val == None:
                    print("No intersections were found.")
                else:
                    print("Intersections were found at the following elements:")
                    for entry in ret_val:
                        print("Element with id: ", entry._id)


    """


def CheckListAddFixFunc(header: object, fix_func: str):
    """
    .. deprecated:: 17.0.0
            Use :py:class:`CheckReport` instead.


    Add a user defined function for Header header item with name 'FixFunction'.
    FixFunction should be a user function of the form FixFunction(entities,
    user_defined_data) entities is a copy of the list used as a second argument
    of the CheckListAddItem function, while user_defined_data should be of the same
    type as the last argument of CheckListAddItem function.

    Parameters
    ----------
    header : object
            A reference to a list header.

    fix_func : str
            The name of the function to be called when the user calls fix.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = base.CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    ind = prop._name.find(" ")
                    m = (prop,)
                    if ind >= 0:
                        item = base.CheckListAddItem(header, m, "", prop._name)
                        base.CheckListAddFixFunc(header, "FixFunction")


            def FixFunction(entities, name):
                # entities is the matrix 'm' given in CheckListAddItem
                # name is the string 'name' given in CheckListAddItem
                new_name = name.replace(" ", "_")
                base.SetEntityCardValues(constants.NASTRAN, entities[0], {"Name": new_name})
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                error_groups = base.CheckListGetErrorGroups()
                error_group = error_groups[0]

                item = base.CheckListGetFirstError(error_group)
                while item:
                    prop_ent = base.CheckListGetErrorValue(item, "ENTITIES")
                    prop_found = prop_ent[0]
                    if entities[0] == prop_found:
                        base.CheckListChangeErrorClass(item, "OK")
                        break
                    item = base.CheckListGetNextError(item)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: CheckReport instead.",
        DeprecationWarning,
    )


def CheckListAddItem(
    header: object, entities: object, message: str, user_data: object
) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`CheckReport` instead.


    Adds an item in the Checks List under HeaderItem, containing references to
    Ansa Entities with string Description. The last argument is user data.
    The user can pass any data, and they will be copied and passed as
    an argument to the user loaded Fix Function. User data will be
    destroyed when the list item is deleted or the List is closed.

    Parameters
    ----------
    header : object
            A reference to header item to add items to.

    entities : object
            A list of entities to associate with the added item.

    message : str
            A string description.

    user_data : object
            The user can pass any data which will be copied and passed as
            an argument to the user loaded Fix Function.

    Returns
    -------
    object
            Returns a reference to the item created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = base.CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    base.GetEntityCardValues(constants.NASTRAN, prop, ("Name",))
                    ind = name.find(" ")
                    m = (prop,)
                    if ind >= 0:
                        item = base.CheckListAddItem(header, m, "", None)
                        base.CheckListChangeErrorClass(item, "WARNING")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: CheckReport instead.",
        DeprecationWarning,
    )


def CheckListChangeErrorClass(item: object, status: str) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`CheckReport` instead.


    CheckListChangeErrorClass will change the error status of an ErrorItem.

    Parameters
    ----------
    item : object
            A reference to a list item.

    status : str
            An error class that can be either "ERROR", "WARNING" or "OK".

    Returns
    -------
    int
            The returned value is always 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = base.CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    ind = prop._name.find(" ")
                    if ind >= 0:
                        item = base.CheckListAddItem(header, (prop,), "", None)
                        base.CheckListChangeErrorClass(item, "WARNING")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: CheckReport instead.",
        DeprecationWarning,
    )


def CheckListGetErrorGroups() -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`CheckReport` instead.


    CheckListGetErrorGroups will give access to the Error Groups of an Open Checks List window.

    Returns
    -------
    object
            It returns a matrix containing the different Error Group Headers that can be used with
            CheckListGetFirstError and CheckListGetErrorValue functions.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = base.CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    ind = prop._name.find(" ")
                    m = (prop,)
                    if ind >= 0:
                        item = base.CheckListAddItem(header, m, "", prop._name)
                        base.CheckListAddFixFunc(header, "FixFunction")


            def FixFunction(entities, name):
                # entities is the matrix 'm' given in CheckListAddItem
                # name is the string 'name' given in CheckListAddItem
                new_name = name.replace(" ", "_")
                base.SetEntityCardValues(constants.NASTRAN, entities[0], {"Name": new_name})
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                error_groups = base.CheckListGetErrorGroups()
                error_group = error_groups[0]

                item = base.CheckListGetFirstError(error_group)
                while item:
                    prop_ent = base.CheckListGetErrorValue(item, "ENTITIES")
                    prop_found = prop_ent[0]
                    if entities[0] == prop_found:
                        base.CheckListChangeErrorClass(item, "OK")
                        break
                    item = base.CheckListGetNextError(item)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: CheckReport instead.",
        DeprecationWarning,
    )


def CheckListGetErrorValue(header: object, field: str) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`CheckReport` instead.


    CheckListGetErrorValue will give access to the data associated with each error.

    Parameters
    ----------
    header : object
            The header object.

    field : str
            Field label can be either "DESCRIPTION" or "ENTITIES".

    Returns
    -------
    object
            If label is "DESCRIPTION" the string with the error description is returned.
            If label is "ENTITIES", a list with the ansa entities associated with the error is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = base.CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    base.GetEntityCardValues(constants.NASTRAN, prop, ("Name",))
                    ind = name.find(" ")
                    m = (prop,)
                    if ind >= 0:
                        item = base.CheckListAddItem(header, m, "", name)
                        base.CheckListAddFixFunc(header, "FixFunction")


            def FixFunction(entities, name):
                # entities is the matrix 'm' given in CheckListAddItem
                # name is the string 'name' given in CheckListAddItem
                new_name = name.replace(" ", "_")
                base.SetEntityCardValues(constants.NASTRAN, entities[0], {"Name": new_name})
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                error_groups = base.CheckListGetErrorGroups()
                error_group = error_groups[0]

                item = base.CheckListGetFirstError(error_group)
                while item:
                    prop_ent = base.CheckListGetErrorValue(item, "ENTITIES")
                    prop_found = prop_ent[0]
                    if entities[0] == prop_found:
                        base.CheckListChangeErrorClass(item, "OK")
                        break
                    item = base.CheckListGetNextError(item)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: CheckReport instead.",
        DeprecationWarning,
    )


def CheckListGetFirstError(header: object) -> object:
    """

    CheckListGetFirstError will give access to the First Error belonging to an Error Group.
    ErrorGroup can be obtained by the CheckListGetErrorGroups function.

    Parameters
    ----------
    header : object
            A reference to a list header.

    Returns
    -------
    object
            It returns an Error Item that can be used with CheckListGetNextError and CheckListGetErrorValue
            functions.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    ind = prop._name.find(" ")
                    m = (prop,)
                    if ind >= 0:
                        item = base.CheckListAddItem(header, m, "", name)
                        base.CheckListAddFixFunc(header, "FixFunction")


            def FixFunction(entities, name):
                # entities is the matrix 'm' given in CheckListAddItem
                # name is the string 'name' given in CheckListAddItem
                new_name = name.replace(" ", "_")
                base.SetEntityCardValues(constants.NASTRAN, entities[0], {"Name": new_name})
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                error_groups = base.CheckListGetErrorGroups()
                error_group = error_groups[0]

                item = base.CheckListGetFirstError(error_group)
                while item:
                    prop_ent = base.CheckListGetErrorValue(item, "ENTITIES")
                    prop_found = prop_ent[0]
                    if entities[0] == prop_found:
                        base.CheckListChangeErrorClass(item, "OK")
                        break
                    item = base.CheckListGetNextError(item)


    """


def CheckListGetNextError(previous_error: object) -> object:
    """

    CheckListGetNextError will give access to the Next Error item of PreviousError. CheckListGetNextError and CheckListGetFirstError are used to loop through all Error of an Error Group.

    Parameters
    ----------
    previous_error : object
            'previous_error' is obtained by a call to either CheckListGetFirstError or CheckListGetNextError
            functions.

    Returns
    -------
    object
            It returns an Error Item that can be used with CheckListGetNextError and CheckListGetErrorValue functions.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = base.CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    base.GetEntityCardValues(constants.NASTRAN, prop, ("Name",))
                    ind = prop._name.find(" ")
                    m = (prop,)
                    if ind >= 0:
                        item = base.CheckListAddItem(header, m, "", prop._name)
                        base.CheckListAddFixFunc(header, "FixFunction")


            def FixFunction(entities, name):
                # entities is the matrix 'm' given in CheckListAddItem
                # name is the string 'name' given in CheckListAddItem
                new_name = name.replace(" ", "_")
                base.SetEntityCardValues(constants.NASTRAN, entities[0], {"Name": new_name})
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                error_groups = base.CheckListGetErrorGroups()
                error_group = error_groups[0]

                item = base.CheckListGetFirstError(error_group)
                while item:
                    prop_ent = base.CheckListGetErrorValue(item, "ENTITIES")
                    prop_found = prop_ent[0]
                    if entities[0] == prop_found:
                        base.CheckListChangeErrorClass(item, "OK")
                        break
                    item = base.CheckListGetNextError(item)


    """


def CheckListNewHeader(name: str) -> object:
    """

    Opens the Checks List and adds a HeaderItem with label HeaderTitle that can be used by the
    user for custom Checks.

    Parameters
    ----------
    name : str
            The title of the header.

    Returns
    -------
    object
            A reference to the item is returned, to be used by the CheckListAddItem function.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                header = base.CheckListNewHeader("PSHELL names with blank spaces")
                for prop in props:
                    base.GetEntityCardValues(constants.NASTRAN, prop, ("Name",))
                    ind = name.find(" ")
                    m[0] = prop
                    if ind:
                        item = base.CheckListAddItem(header, m, "", 0)


    """


def CheckPenetration2Sets(
    entities1: object, entities2: object, mode: int, factor: float, fast_run: int
) -> object:
    """

    The function detects intersections and/or penetrations between 2 containers only.

    Parameters
    ----------
    entities1 : object
            The first container

    entities2 : object
            The second container

    mode : int
            1: intersections , 2: property thickness , 3: user thickness

    factor : float
            Factor for property thickness, value for user thickness, ignored in intersections

    fast_run : int
            0: ignored , 1: test will stop at the first intersection detected , 2: test will
            stop at the first penetration or intersection detected.

    Returns
    -------
    object
            On success the function returns a dict with: key | value
            "intersected" > the intersected entities
            "penetrated" > the penetrated entities
            "penetrations" > the total number of penetrations

            On failure the function returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ret = base.CheckPenetration2Sets(p_matix1, p_matix2, 2, 1.2, 1)
                # will search for property thickness penetrations with factor 1.2 between p_matix1, p_matix2. Check will stop if any intersections are found.

                base.CheckPenetration2Sets(p_matix1, p_matix2, 1, 0, 0)
                # will search for intersections between p_matix1, p_matix2. Check will not stop.


    """


def CheckSharpEdges(
    input_entities: object, input_angle: float, exclude_macro_perimeter_edges: bool
) -> object:
    """

    This function accepts a list of entities, parts, properties, materials, sets or macros.
    If the INPUT is 0, the visible macros and shells are checked.
    All shells are collected from the INPUT and are checked for sharp edges, with an
    angle value larger than the input ANGLE.
    The shells who have a sharp edge between them, are returned in the three matrices,
    according to their type.

    Parameters
    ----------
    input_entities : object
            A list of entities, parts, properties, materials, sets or macros, to
            check for sharp edges.
            If 0 is given, all the visible macros and shells are checked.

    input_angle : float
            Any angle larger thatn the 'input_angle' will be considered as a
            sharp edge.

    exclude_macro_perimeter_edges : bool, optional
            If set to True, excludes the macro perimeter edges.

    Returns
    -------
    object
            The function returns a dictionary.
            The keys are the error names and their respective data are lists containing the entities belonging to each group.

            The dictionary keys can be:
            'concave_errors'
            'convex_errors'
            'mixed_errors'

            If no errors are found, None is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ret = base.CheckSharpEdges(0, 160.0)
                concave = ret["concave_errors"]
                convex = ret["convex_errors"]
                mixed = ret["mixed_errors"]


    """


def CleanGeometry():
    """

    This function automatically fixes most of the common topological problems.
    It eliminates:

    -Collapsed CONS.
    -Gaps (small openings between Faces).
    -Cracks (unpasted cons).
    -Triple or more CONS (needle Faces).
    -In addition it performs topology on all visible entities.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ansa.base.CleanGeometry()


    """


def ClearCurves(curves: object) -> int:
    """

    This function can be used to delete identical curves from a model in order to be left
    with unique ones.

    Parameters
    ----------
    curves : object

    Returns
    -------
    int
            Returns 0 upon success or 1 in case of failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))
                curves = base.CollectEntities(constants.NASTRAN, parts, "CURVE", recursive=True)
                base.ClearCurves(curves)


    """


def ClearDeck(fields: object, deck: int) -> int:
    """

    The function clears the database from unused DECK entities.

    Parameters
    ----------
    fields : object
            A dictionary of (entity name, value) pairs.
            Value is 1 or 0, indicating if the entity is going to be cleared or not, respectively.

    deck : int, optional
            The deck to be cleared.

    Returns
    -------
    int
            Returns 0 if the deck was cleared, or 1 if there was an error in input.

    See Also
    --------
    Compress

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.ClearDeck({"Nodes": 1, "Properties": 1, "Empty Sets": 1})

                base.ClearDeck({"Nastran Materials": 1}, ansa.constants.NASTRAN)


    """


def ClearIdsRange(
    ENT_TYPE: str, START_RANGE_ID: str, END_RANGE_ID: str, FROZEN_IDS_FORCE: str
) -> int:
    """

    This function clears a range from entities that occupy ids inside the range.

    Parameters
    ----------
    ENT_TYPE : str
            The type of entities, e.g. "GRID", or a matrix containing several types of entities,
            or "ALL" for all existing types of entities.

    START_RANGE_ID : str
            The first id of the range.

    END_RANGE_ID : str
            The last id of the range

    FROZEN_IDS_FORCE : str
            Determine how to proceed in case of FROZEN id:
            -"IGNORE_FROZEN"
            -"RESPECT_FROZEN"
            -"ABORT_IF_FROZEN"
            -"" (the blank string will abort).

    Returns
    -------
    int
            Returns 1 on success, or 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ClearIdsRange("ELEMENT", 1, 100000, "")


            # ...or...


            def main():
                base.ClearIdsRange("ALL", 100000, 200000, "RESPECT_FROZEN")


            # ...or...


            def main():
                types = ("ELEMENT", "GRID", "PROPERTY")
                base.ClearIdsRange(types, 1000000, 4000000, "IGNORE_FROZEN")


    """


def ClearIncludeConfiguration(CLEAR_OPTION: int) -> int:
    """

    Empties all active includes or clears database.

    Parameters
    ----------
    CLEAR_OPTION : int
            1: empty includes.
            2: clear database. This option renders all pointers to entities invalid,
            including those to configurations and includes.

    Returns
    -------
    int
            Returns 0 if an invalid argument was specified, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ClearIncludeConfiguration(1)


    """


def ClearMaterialDatabase(DECK: int) -> int:
    """

    This function deletes all the materials and their auxiliary entities from the Material Database of the specified deck.

    Parameters
    ----------
    DECK : int
            The deck in which the clearing will take place.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.ClearMaterialDatabase(constants.LSDYNA)


    """


def Cog(ENTITY: object) -> tuple | None:
    """

    Return the x,y,z coordinates of the center of gravity (geometric center - centroid) of the ENTITY.

    Parameters
    ----------
    ENTITY : object
            An entity for which to calculate the Cog.

    Returns
    -------
    tuple | None
            Returns a tuple of the x, y, z coordinates uppon success (the entity has geometric representation).
            None otherwise.

    See Also
    --------
    DeckMassInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shell = base.GetEntity(constants.NASTRAN, "SHELL", 412481)
                (x, y, z) = base.Cog(shell)
                print("(x, y, z) = (%f, %f, %f) " % (x, y, z))


    """


def CollectBoundaryNodes(container: object, include_second_order_nodes: bool) -> object:
    """

    This function collects boundary nodes that belong to red or blue edges of the given entities.

    Parameters
    ----------
    container : object
            Can contain parts, properties, macros or shells.
            Each node-chain represents nodes of a perimeter.
            These node-chains are sorted by descending perimeter length.

    include_second_order_nodes : bool, optional
            Defines whether the node-chains in PERIMETERS will include
            2nd order nodes.
            False: the 2nd order nodes are ommitted.
            True: the 2nd order nodes are included in node-chains,
            inserted between their 1storder neighbours.

    Returns
    -------
    object
            Returns an object with attributes "perimeters" and "diameters", or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = (base.GetPartFromModuleId("13"), base.GetPartFromModuleId("14"))
                prt_node_chains = base.CollectBoundaryNodes(parts)

                i = 0
                for chain in prt_node_chains.perimeters:
                    name = "Perimeter with diameter " + str(prt_node_chains.diameters[i])
                    set_ref = base.CreateEntity(constants.NASTRAN, "SET", {"Name": name})
                    base.AddToSet(set_ref, chain)
                    i += 1


    """


def CollectEntities(
    deck: int,
    containers: Entity | Iterable | None,
    search_types: str | Iterable,
    recursive: bool = False,
    filter_visible: bool = False,
    prop_from_entities: bool = False,
    mat_from_entities: bool = False,
    model_browser_filter: dict = {},
    no_expand_types: Iterable = None,
    hidden_entities: bool = True,
) -> List[Entity]:
    """

    Creates a list with the entities of specific types, contained in the containers.

    Parameters
    ----------
    deck : int
            The deck for which the collection will take place.

    containers : Entity | Iterable | None
            A reference to a container  entity or list with references to  containers.
            Some of the containers can be of type ANSAGROUP, ANSAPART, SET,
            property, material, face,  volume, elements, task manager items etc
            If the container is None, CollectEntities will search the entire
            ANSA database.

    search_types : str | Iterable
            A string or list of strings with "ansa keywords" of the types to be
            collected. Such types can be SHELL, SOLID, GRID etc.
            Additionally, the following keywords can be used:
            "__PROPERTIES__": returns all properties in the "containers".
            "__MATERIALS__": returns all materials in the "containers".
            "__ELEMENTS__": returns all standard elements in the "containers".
            "__ALL_ENTITIES__": returns all entities in the "containers".
            "__CONNECTIONS__": returns all connections in the "containers".
            "__MBCONTAINERS__": returns the model browser containers of the model if
            used with containers=None or the model browser containers of the containers.
            "__COORD_SYSTEMS__": returns all the coordinate systems in the "containers".
            "__CONNECTION_TEMPLATES__": returns all the connection templates in the "containers".
            "__OUT_OF_MBCONTAINERS__": returns the entities of the OutOfMBContainer. Can be used along with argument model_browser_filter.
            "BATCH_MESH_SESSION_GROUP": returns the meshing scenarios of Batch Mesh
            "BATCH_MESH_VOLUME_SCENARIO": returns the volume scenarios of Batch Mesh
            "BATCH_MESH_WRAP_SCENARIO": returns the wrap scenarios of Batch Mesh
            "BATCH_MESH_LAYERS_SCENARIO": returns the layer scenarios of Batch Mesh

    recursive : bool, optional
            Recursively search any containers contained in a higher level container
            for any of the search_types. (Default: False).

    filter_visible : bool, optional
            Return only the entities that satisfy all the collection criteria,
            have visibility status, and the status is active.
            In all other cases the parameter is ignored.
            (Default: False).

    prop_from_entities : bool, optional
            In case search_type is a property, this argument controls if the property
            must be acquired from the entities referenced by the entities in the
            container or not. For example, if search_type is "PSHELL", container is
            "PART", and prop_from_entities is True, if the part contains shells, the
            corresponding PSHELL will be returned.
            Otherwise, if prop_from_entities is False, None will be returned.
            (Default: False).

    mat_from_entities : bool, optional
            In case search_type is a material, this argument controls if the material
            must be acquired from the entities referenced by the entities in the
            container or not. For example, if search_type is "MAT1", container is
            "PART", and mat_from_entities is "yes", if the part  contains elements
            with MAT1 material, the corresponding material will be returned.
            Otherwise, if mat_from_entities is False, None will be returned.
            (Default: False).

    model_browser_filter : dict, optional
            In case search_types is None, this argument controls which entities to
            collect from a Part, a Group, a Subsystem, a Simulation Model or a
            Simulation Run. 'model_browser_filter' is a dictionary with three keys:
            'container', 'collect_mode' and 'collect_depth'.Acceptable values for these keys
            vary according to the entity they are applied on.

            -When collecting entities from a Part or a Group:
            { 'container' : 'all', 'collect_mode' : 'contents' | 'part_contents_and_references' | 'part_contents_and_related'} ,  'collect_depth' key is not applicable here.

            'container' values:
            -'all' returns entities of any type

            'collect_mode' values:
            -'contents' returns entities that strictly belong to the Part or the Group.
            -'part_contents_and_references' returns the 'contents' plus their properties and
            materials.
            -'part_contents_and_related'  returns the 'contents_related' plus all entities that
            are geometrically related to it (use same nodes or are otherwise connected).
            -'contents_related' .This value is deprecated, replaced by 'part_contents_and_references'.
            -'contents_affected'. This value is deprecated, replaced by 'part_contents_and_related'.

            -When collecting entities from a Subsystem, a Simulation Model or a
            Simulation Run:
            { 'container': 'all' | 'geometry' | 'connections' | 'model_setup_entities' | 'interfaces',
            'collect_mode': 'contents' | 'missing' | 'misplaced',
            'collect_depth': 'own_level' | 'all_levels' }

            'container' values:
            -'all' returns entities of any type.
            -'geometry' returns geometry entities.
            -'connections' returns Connections & Connectors.
            -'model_setup_entities' returns Model Setup Entities
            (like RBE3s directly connected to geometry)
            -'interfaces' returns Interfaces (like A_POINTs).

            'collect_mode' values:
            -'contents' returns entities that directly belong to the 'container'.
            -'missing' returns entities that don't belong to the 'container' but should do.
            -'misplaced' returns entities that belong to the 'container' but shouldn't do.

            'collect_depth' values:
            -'own_level' returns entities that are directly under the 'container', not under its inner containers.
            -'all_levels' returns entities found at any inner level under 'container'.
            Example:
            In case we want to collect the Connections of a SimModel, only the ones that are directly under it, we use 'own_level'.On the contrary, in case we wish to collect all connections, both from the SimModel as well as the connections under its subsystems/rlis, we use 'all_levels'.

            Note that use of model_browser_filter argument demands setting 'containers' argument with a value other than 'None'.
            Note that 'missing' and 'misplaced' are not defined for the
            GEOMETRY_OUT_OF_SUBSYSTEMS Subsystem(obsolete since 22.0.0).

    no_expand_types : Iterable, optional
            A list with ANSA types which won't be expanded while collecting their
            entities. Currently it works only for SETs with recursive = False,
            no_expand_types = ('SET',) in order to get the first level SET contents.

    hidden_entities : bool, optional
            If hidden_entities = False the hidden (inactive) entities will not be collected. These are the entities that are listed in the "Inactive" category of the Database Browser (e.g entities of parts with representation="Don't Use"). Default is True.

    Returns
    -------
    List[Entity]
            Returns a list with all the collected entities.

    See Also
    --------
    base.CollectEntitiesI

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                set1 = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "new set 1"})

                m = []
                containers = []

                for i in range(1, 100):
                    m.append(base.GetEntity(constants.NASTRAN, "GRID", i))
                base.AddToSet(set1, m)

                prop = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                containers.append(set1)
                containers.append(prop)

                ents = base.CollectEntities(constants.NASTRAN, containers, "GRID", recursive=True)
                for ent in ents:
                    base.SetEntityCardValues(
                        constants.NASTRAN, ent, {"Name": "node of set 1 or prop 1"}
                    )


            def main():
                part = base.GetPartFromModuleId("10")

                pshells = base.CollectEntities(
                    constants.NASTRAN, part, "PSHELL", prop_from_entities=True
                )
                for pshell in pshells:
                    print("PID: ", pshell._id)
                materials = base.CollectEntities(
                    constants.NASTRAN, part, "__MATERIALS__", mat_from_entities=True
                )
                for material in materials:
                    print("MID:", material._id)


            def main():
                subsystem = base.Entity(constants.ABAQUS, 1, "ANSA_SUBSYSTEM")

                mbf = {"container": "interfaces", "collect_mode": "contents"}
                interfaces = base.CollectEntities(
                    constants.ABAQUS, subsystem, None, model_browser_filter=mbf
                )

                mbf = {"container": "connections", "collect_mode": "contents"}
                connections = base.CollectEntities(
                    constants.ABAQUS, subsystem, None, model_browser_filter=mbf
                )

                mbf = {"container": "all", "collect_mode": "contents"}
                entities = base.CollectEntities(
                    deck=0,
                    containers=None,
                    search_types="__OUT_OF_MBCONTAINERS__",
                    model_browser_filter=mbf,
                )


    """


def CompareFromFile(
    filename_in: str,
    parts: object,
    model1: object,
    model2: object,
    model1filenames: object,
    model1filetypes: object,
    model2filenames: object,
    model2filetypes: object,
    matching_distance: float,
    matching_similarity: float,
    average_thickness_factor: float,
    connection_distance: float,
    connection_match_distance: float,
    connection_match_similarity: float,
    file_type: str,
    connections_same_type,
    connections_equiv_connectivity: bool,
    input_deck: int,
    report_export_dir: str,
    meta_post_command: str,
    meta_post_script: str,
    ansa_post_script: str,
    use_image_background: bool,
    separate_pictures_for_parts: bool,
    run_meta_in_batch_mode: bool,
    part_pictures_width: int,
    part_pictures_height: int,
    transparent_part_pictures_width: int,
    transparent_part_pictures_height: int,
    con_pictures_width: int,
    con_pictures_height: int,
    export_geometry_info: bool,
    export_connections_info: bool,
    export_visible_list: bool,
    export_unmatched_connections: bool,
    export_matched_connections_no_diffs: bool,
    c_state_export_dir: str,
    compare_action: str,
    keep_current_visibility_settings: bool,
    meta_post_arguments: str,
    ansa_script_function_name: str,
    apply_filter_configuration,
    compare_with_thickness: bool,
    export_unmatched_parts: bool,
    export_metadb: bool,
    matched_parts_map: object,
    match_parts_mode: str,
    report_filename: str,
    dock_area: str,
) -> int:
    """
    .. deprecated:: 17.1.1
            Use :py:class:`CompareTool` instead.


    This function can be used for the comparison of two models based on a number of compare options and tolerances.
    It can also be used for the creation of a report with the results of the comparison.
    It offers 3 ways to compare:

    - compare a list of parts from the current database, to a specified database (incoming).
     This can be an ansa database, or an input file, or a connection file.
    - compare 2 models, ansa database or input file, by merging/input the respective databases.
    - compare a set of databases with another set of databases.

    There are several options regarding the actions to be taken once the comparison is completed:

    - export a report in .pptx format with the aid of META PostProcessor.
    - export a custom report using an ansa user script.
    - save the Compare Report list along with the models involved in the comparison process.
    - keep the incoming database, while erasing the conflicting entities of the current database.
    - leave the Compare Report window open for further manual handling.
    - leave the Compare Report window open along with the Advanced View Settings window
     for further manual handling.
    - cancel the whole procedure erasing the incoming database.

    Parameters
    ----------
    filename_in : str
            The path of the database of the incoming model.
            Use an empty string if you will not work with the
            1st way of comparison.

    parts : object
            Only needed when working with the 1st way of comparison.
            List with the parts from the current database that will be
            compared.

    model1 : object
            Only needed when working with the 2nd way of comparison.
            The pointer of the 1st model to be compared.
            It is given by the function base.CreateNewAnsaModel()

    model2 : object
            Only needed when working with the 2nd way of comparison.
            The pointer of the 2nd model to be compared.
            It is given by the function base.CreateNewAnsaModell()

    model1filenames : object
            Only needed when working with the 3d way of comparison.
            List with the paths of the 1st set of databases.

    model1filetypes : object
            Only needed when working with the 3d way of comparison.
            List with the types of files in the list "model1filenames".
            The entries of this list must correspond to the list
            "model1filenames".
            The accepted values are:
            'INPUT_FILE', declares an input file.
            'ANSA_DB', declares an ansa database.
            'CONN_VIP', 'CONN_VIP2', 'CONN_XML', declares a connection
            file of the respective type.

    model2filenames : object
            Only needed when working with the 3d way of comparison.
            List with the paths of the 2nd set of databases.

    model2filetypes : object
            Only needed when working with the 3d way of comparison.
            List with the types of files in the list"model2filenames".
            The entries of this list must correspond to the list
            "model2filenames".
            The accepted values are given above for the model1filetypes
            list.

    matching_distance : float, optional
            Distance to be used for the geometrical comparison of two
            matched parts.
            (Default: 0.5)

    matching_similarity : float, optional
            Percentage to be used for the geometrical comparison of two
            matched parts.
            (Default: 90)

    average_thickness_factor : float, optional
            Threshold to be used for the matching of connection points.
            Calculated as a factor of the average thickness of the
            components connected by the spot.
            (Default: 0.5)

    connection_distance : float, optional
            Threshold to be used for the matching of connection points.
            Calculated as an absolute value of distance between the spots.
            (Default: 10)
            For a specific comparison only one of the 2 options above is
            used. If both are set, only the average_thickness_factor will
            be used. If none of the above is set, the default
            AverageThicknessFactor will be considered.

    connection_match_distance : float, optional
            Tolerance to be used for the matching of connection lines and
            connection faces.
            Calculated as an absolute value of distance.
            (Default: 0.5)

    connection_match_similarity : float, optional
            Percentage to be used for the matching of connection lines
            and connection faces.
            (Default: 90)

    file_type : str, optional
            Only needed when working with the 1st way of comparison.
            Defines the type of file used for comparison.
            The accepted values are:
            -'AnsaDB', to compare to an ansa database
            -'DeckFile', to compare to an input file
            -'VIP','VIP2','XML', to compare to a connection file of the
            respective type.
            (Default: "AnsaDB")

    connections_same_type :

    connections_equiv_connectivity : bool, optional
            Argument for the activation of the respective option.
            If set equal to TRUE connections that match based on the
            previous criteria but have differences in connectivity, will
            not be considered matched after all.
            (Default: False)

            ____Settings affecting the export of the comparison results
            used for the generation of report____

    input_deck : int, optional
            Only needed when working with the 1st way of comparison
            and file_type = 'DeckFile'.
            Defines the type of the input deck file. It will be used for
            the comparison.
            By default, the current deck is assigned.

    report_export_dir : str
            The path to the directory where all data for the generation of
            the report will be output.

    meta_post_command : str
            The path to the META PostProcessor executable.
            META PostProcessor will be used for the generation
            of the report in pptx format.

    meta_post_script : str
            The path to the script file which will handle the export data
            and produce the pptx presentation file.

    ansa_post_script : str
            The path to a user defined script which will be used
            instead of the meta_post_script in order to generate
            a different type of report.
            The user defined script function must be of the following type:
            SciptFunction(string export_dir, string meta_exe,
            string meta_script)
            The arguments export_dir, meta_exe, meta_script
            will be the report_export_dir, meta_post_command,
            and meta_post_script respectively as defined through the
            above described variables.

    use_image_background : bool, optional
            Argument to set the background color.
            If set equal to TRUE the exported images will have the
            current background.
            If set equal to FALSE the exported images will have
            transparent background.
            (Default: False)

    separate_pictures_for_parts : bool, optional
            Argument for the activation of the respective option.
            If set equal to TRUE two pictures will be taken,
            one for each part of the matched pair.
            If set equal to FALSE a single picture will be taken,
            showing both parts in unexploded view.
            The parts will most likely be overlaping.
            (Default: True)

    run_meta_in_batch_mode : bool, optional
            Argument for the activation of the respective option.
            If set equal to TRUE, META PostProcessor will run
            in no-gui mode.
            If set equal to FALSE, META PostProcessor will be
            launched with the procuced report open in the
            Report Composer Tool.
            (Default: True)

    part_pictures_width : int
            Argument to define the width of the parts' picture.
            Used when use_image_background=TRUE.

    part_pictures_height : int
            Argument to define the height of the parts' picture.
            Used when use_image_background=TRUE.

    transparent_part_pictures_width : int
            Argument to define the width of the parts' picture.
            Used when: use_image_background=FALSE.

    transparent_part_pictures_height : int
            Argument to define the height of the parts' picture.
            Used when: use_image_background=FALSE.

    con_pictures_width : int
            Argument to define the width of the connections' picture.

    con_pictures_height : int
            Argument to define the height of the connections' picture.

    export_geometry_info : bool, optional
            Argument to activate the respective option.
            If set to True information about the differences
            of parts will be exported.
            (Default: True)

    export_connections_info : bool, optional
            Argument to activate the respective option.
            If set to True information about the differences of
            connections will be exported.
            (Default: True)

    export_visible_list : bool, optional
            Argument to activate the respective option.
            If set equal to True the produced report will include only the
            items that are currently visible in the Compare Report window.
            (Default: False)

    export_unmatched_connections : bool, optional
            Argument to activate the respective option.
            If set equal to True information about unmatched connections
            will be exported.
            (Default: False)

    export_matched_connections_no_diffs : bool, optional
            Argument to activate the respective option.
            If set equal to True information about connections with
            no differences will be exported.
            (Default: False)

    c_state_export_dir : str
            Define this path to a directory in order to save a file of
            type '*.ansa_compare' containing the compare report list
            along with the models involved in the comparison process.

    compare_action : str, optional
            Argument to define the action taken once the comparison is
            completed.
            The accepted values are:
            -'OK', to import theincoming database.
            -'SHOW_CARD', to end the procedure with the Compare
            Report window open.
            -'SHOW_COMPARE_OPTIONS_AND_CARD', to end the
            procedure with Advanced View Options window and the
            Compare Report window open.
            -'CANCEL', to take no action.
            (Default: 'CANCEL')

    keep_current_visibility_settings : bool, optional
            Argument for the activation of the respective option.
            If set equal to TRUE the pictures will be taken using
            the current visibility settings.
            If set equal to FALSE the predefined by the Compare
            Tool settings will be used, e.g. Shadow ON, Wire OFF,
            Perims OFF etc.
            (Default: False)

    meta_post_arguments : str
            Argument containing any additional options the user would
            like to add.

    ansa_script_function_name : str
            The function name that will be called from the user defined
            script.

    apply_filter_configuration :

    compare_with_thickness : bool, optional
            Accepted values: True, False.
            If True, differences in thickness will be detected as geometric
            differences when comparing 2 middle surface parts
            (meshed geometry or FE).
            (Default: False)

    export_unmatched_parts : bool, optional
            Argument to activate the respective option.
            If set to True information about unmatched parts will be
            exported.
            (Default: True)

    export_metadb : bool, optional
            Argument to activate the export of differences on 3D models.
            If set to True, differences will be exported also on the 3D
            models.
            (Default: True)

    matched_parts_map : object, optional
            A Dictionary where the ids of the matched parts are stored.
            The ids from model 1 are stored as key and the ids of model
            2 as data. As a result the len of the dict is the number of the
            matched parts. Please note that the returned Ids refer to the
            separate Models 1 and 2. If the Models get merged, the Ids
            get invalidated.

    match_parts_mode : str, optional
            This option specifies how the parts will be mapped.

            Values: MATCH_MODULE_ID, MATCH_GEOMETRY,
            MATCH_MODULE_ID_AND_GEOMETRY.

            Default value: the respective value obtained from Ansa
            defaults or MATCH_MODULE_ID_AND_GEOMETRY.

            MATCH_MODULE_ID: matching of parts is based only on
            the Module Id and/or name.
            MATCH_GEOMETRY: parts with similar geometry and position
            are mapped regardless of their name and/or Module Id.
            MATCH_MODULE_ID_AND_GEOMETRY: both Module
            Id/name and geometry are considered.

    report_filename : str, optional
            This option specifies the filename of the report that will be
            generated.

    dock_area : str, optional
            Defines the location where the "Compare Report" window will
            be docked. The accepted values are "LeftDockArea".

    Returns
    -------
    int
            Returns 0 if the compare procedure has been executed successfully and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import utils


            def Comparison1st_a():
                part1 = base.GetPartFromModuleId("100")  # Select parts to be compared
                part2 = base.GetPartFromModuleId("200")  # Select parts to be compared
                parts = [part1, part2]  # Matrix of parts to be compared
                ret = base.CompareFromFile(
                    "/path/to/ansa/database/to/compare/with/to_compare_with.ansa",  # Incoming database to be compared with the defined matrix of parts
                    parts,  # Matrix of parts to be compared
                    matching_distance=0.5,  # Percentage to be used for the geometrical comparison of matched parts
                    matching_similarity=80,  # Percentage to be used for the geometrical comparison of two matched parts
                    average_thickness_factor=0.6,  # Threshold to be used for the matching of connection points
                    report_export_dir="/path/to/export/directory/",  # The path to the directory where all data for the generation of the report will be output
                    meta_post_command="/path/to/mETA_Post/executable/meta_post64.sh",  # The path to the mETA PostProcessor executable
                    meta_post_script="/path/to/script/ComparisonReport.bsx",  # The path to the script which will handle the export data
                    use_image_background=False,  # Set transparent background for the images
                    separate_pictures_for_parts=True,  # Two pictures will be taken, one for each part of the matched pair
                    run_meta_in_batch_mode=True,  # mETA PostProcessor will run in no-gui mode
                    compare_action="CANCEL",
                )  # Once the comparison is finished and the report is exported no further action will be taken
                print(ret)  # If the comparison has been performed successfully, 0 will be printed


            def Comparison1st_b():
                parts = base.CollectEntities(
                    NASTRAN, None, "ANSAPART"
                )  # Matrix of all parts of the database
                base.CompareFromFile(
                    "/path/to/connection/file/to/compare/with/NewConnections.xml",  # Incoming connection file to be compared with the defined matrix of parts
                    parts,  # Matrix of parts to be compared
                    file_type="XML",  # The incoming file is of type *.xml
                    report_export_dir="/path/to/export/directory/",
                )  # Directory where the export data will be saved
                # All other arguments are omited. Their default values will be used.


            def Comparison2nd():
                model_1 = base.CreateNewAnsaModel()  # Create a new model instance
                base.SetCurrentAnsaModel(model_1)  # Set the new model as current
                utils.Merge(
                    "/path/to/ansa/database/for/model1.ansa"
                )  # In the new model merge a ansa database

                model_2 = base.CreateNewAnsaModel()  # Create a new model instance
                base.SetCurrentAnsaModel(model_2)  # Set model2 as current
                base.InputNastran(
                    "/path/to/nastran/file/for/model2.nas"
                )  # In this new model input a nastran file

                base.CompareFromFile(
                    model1=model_1,  # The first ansa model to be compared
                    model2=model_2,  # The second ansa model to be compared
                    filename_in="",  # No incoming file to be compared is required
                    compare_action="SHOW_CARD",
                )  # Once the comparison is finished the Compare Report winodw will remain visible for further manual handing


            def Comparison3d():
                dbs_for_model1 = [
                    "/path/to/ansa/database/for/model1/database.ansa",
                    "/path/to/connection/file/for/model1/compare_connections.xml",
                ]
                types_for_model1 = ["ANSA_DB", "CONN_XML"]
                dbs_for_model2 = [
                    "/path/to/nastran/file/for/model2.nas",
                    "/path/to/connection/file/for/model2/new_connections.xml",
                ]
                types_for_model2 = ["INPUT_FILE", "CONN_XML"]
                base.CompareFromFile(
                    model1filenames=dbs_for_model1,  # List with the paths of the 1st set of databases
                    model1filetypes=types_for_model1,  # List with the types of the 1st set of databases
                    model2filenames=dbs_for_model2,  # List with the paths of the 2nd set of databases
                    model2filetypes=types_for_model2,  # List with the types of the 2nd set of databases
                    filename_in="",  # No incoming file to be compared is required
                    compare_action="SHOW_COMPARE_OPTIONS_AND_CARD",
                )  # End the procedure with Advanced View Options window and the Compare Report window open


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.1.1. Use :py:class: CompareTool instead.",
        DeprecationWarning,
    )


def CompareMatWithMdb(material: object, compare_mode: str) -> object:
    """

    Compare the material MATERIAL with the respective one from the Material Database,
    according to the MODE parameter. A value is given to the return argument 'status',
    which indicates the result of the comparison.

    Parameters
    ----------
    material : object
            The material entity to be compared.

    compare_mode : str
            The compare mode string: "by id", "by name" or "most similar".

    Returns
    -------
    object
            Returns a dictionary with 'message' and 'status' keys. The 'status' can take the
            following values depending on the comparison result:

            0: The material found a match in the Material DB. However there are differences in certain fields.
            1: The material did not find a match in the Material DB.
            2: The material found an identical match in the Material DB.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                material = base.GetEntity(
                    constants.LSDYNA, "MAT24 MAT_PIECEWISE_LINEAR_PLASTICITY", 1001
                )
                rmsg = base.CompareMatWithMdb(material, "by id")
                print("Status: ", rmsg["status"])
                print("Message: ", rmsg["message"])


    """


def Compress(fields: object, deck: int) -> int:
    """

    This function removes the deleted geometrical entities (Points, Curves, Faces, etc.)
    and unused model entities (unused Parts, PIDs, SETs, etc). It supports variable
    number of arguments.

    Parameters
    ----------
    fields : object
            A dictionary with keys the entity types to be compressed (as they appear in the window of the corresponding GUI function) and values 1 or 0, indicating if the entity will be compressed or not.
            For materials compression, the key value "__MATERIALS__" can be used, in order to work for all decks (provided that neither the 'deck' argument nor the 'DurrentDeck':1 option in fileds are given).

    deck : int, optional
            The deck that the compression will take place on. Several keywords work for
            specific decks only. If neither this nor the 'CurrentDeck': 1 option in fields is given,
            the compression will be implemented on all decks.

    Returns
    -------
    int
            The function returns 0 uppon success, 1 if there is an error in input.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Compress everything in all decks
                base.Compress("")


            # ...or...


            def main():
                # Compress everything in NASTRAN deck except grids
                base.Compress({"CurrentDeck": 1, "Geometry": 1, "F.E.": 1, "Grids": 0})


            # ...or...


            def main():
                # Compress all Abaqus Materials in ABAQUS deck
                base.Compress({"Abaqus Materials": 1}, ansa.constants.ABAQUS)


            # ...or...


            def main():
                # Compress Materials of all decks
                base.Compress({"__MATERIALS__": 1})


    """


def CompressMaterials(
    DECK: int,
    MATERIAL_MATRIX: object,
    COMPARE_BY_NAMES: int,
    COMPARE_BY_VALUES: int,
    DELETE_DUPLICATED: int,
) -> int:
    """

    Compress materials contained in matrix MATERIAL_MATRIX of deck DECK, by comparing
    each other according to their names (COMPARE_BY_NAMES active) or/and their
    values (COMPARE_BY_VALUES active), releases them from their usage, and
    optionaly deletes them (DELETE_DUPLICATED active).

    Parameters
    ----------
    DECK : int
            The deck constants.

    MATERIAL_MATRIX : object
            A list that contains all the materials for the compression.
            (if zero, all materials of deck DECK will be compressed)

    COMPARE_BY_NAMES : int
            [ 0 | 1 ] to allow or not comparison by names.

    COMPARE_BY_VALUES : int
            [ 0 | 1 ] to allow or not comparison by values.

    DELETE_DUPLICATED : int
            [ 0 | 1 ] to allow or not deletion of duplicates.

    Returns
    -------
    int
            Returns always 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.CompressMaterials(constants.LSDYNA, None, 1, 0, 1)


    """


def ConsToCurves(cons: object) -> object:
    """

    The function takes a list of CONS and creates curves. The curves are saved under the mat_curves variable.

    Parameters
    ----------
    cons : object
            A list of CONS entities.

    Returns
    -------
    object
            Returns None on failure or a list with the new curves on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = ("CONS",)
                mat = base.PickEntities(constants.NASTRAN, ents)  # Pick entities (cons)from screen
                res = base.ConsToCurves(mat)


    """


def ContactFlanges(
    deck: int,
    apply_on: object,
    factor: float,
    angle: float,
    solid_thickness: float,
    update_clearance: bool,
    contact_type: str,
    reference_contact: object,
    reference_pretension: object,
    merge_contacts: bool,
    merge_distance: int,
    create_symetrical: bool,
    use_connection_elements: bool,
    use_finer_mesh_as_main: bool,
    exclude_elements_on_connections: bool,
    update_cinterf: bool,
    create_gebs: bool,
    constraining_elements_type: str,
    constraining_elements_property: object,
    exclude_elements_on_same_property: bool,
    sets_definition: str,
    detection_mode: str,
) -> object:
    """

    Calculates Flanges that are created by the elements of the apply_on list. If None is given as apply_on
    the procedure runs on all visible elements.

    Parameters
    ----------
    deck : int
            The deck constant.

    apply_on : object, optional
            A list of elements to apply the function.
            If None is given it will apply to all visible elements.

    factor : float, optional
            The factor that the shell thickness will be multiplied with,
            in order to calculate the search distance. If a negative
            value is given, this will be the search distance.

    angle : float, optional
            The angle tolerance the function will use in order to
            isolate model faces.

    solid_thickness : float, optional
            The solid thickness that will be used by the function.

    update_clearance : bool, optional
            For ABAQUS only. Activating this option will activate the
            Small Sliding option and will update the contacts clearance.
            Default value is True.

    contact_type : str, optional
            Choose the type of contact the function will create.
            Valid types are:
            -"contact_pair"
            -"contact_tie"
            -"permas_pretension"
            -"permas_contact_isurface"
            (Default: "contact_pair")

    reference_contact : object, optional
            The contact entity that the function will use as prototype for the
            created contacts.

    reference_pretension : object, optional
            The pretension item that the function will use as prototype for the
            created pretensions.

    merge_contacts : bool, optional
            Choose if the function will merge contacts that are close with
            each other.

    merge_distance : int, optional
            The maximum distance (counted on elements) two contacts must have
            between them in order to be merged.

    create_symetrical : bool, optional
            Select whether the creation of the symetrical, of the detected
            contacts, is also desired.

    use_connection_elements : bool, optional
            Select if the elements that belong to connections
            (FE representations) will be included.

    use_finer_mesh_as_main : bool, optional
            Select if the set with the finer meshing will be used as Main.
            If not the set with the largest area will be used as Main.
            (Default: False)

    exclude_elements_on_connections : bool, optional
            Select if Shell elements that are connected upon Connections
            or Rigid bodies will be excluded from the flanges detection.
            (Default: False)

    update_cinterf : bool, optional
            Create a new Bconect Property [BCONPRG] for each new Contact.
            This property will have an updated CINTERF value.
            (Default: True)

    create_gebs : bool, optional
            Create one GEB_SB for each contact surface. The GEB acquires a
            subsystem (if exists otherwise module id of part) as connectivity and
            "UserDefinedArea" as search pattern. (Default: False)

    constraining_elements_type : str, optional
            Choose the element type for contact stabilizing elements between contact
            pairs. Valid values are "xstiff" and "zero_force". This option is used only
            in Permas.

    constraining_elements_property : object, optional
            The property of the created contact stabilizing elements between contact
            pairs. This option is used only in Permas.

    exclude_elements_on_same_property : bool, optional
            Controls whether flanges between the same property is allowed or not

    sets_definition : str, optional
            Choose whether the contact sets are defined by elements or by properties.
            Valid options are:
            -"Elements"
            -"Properties"
            (Default: "Elements")

    detection_mode : str, optional
            Select the detection mode.
            -"Standard": The detection is based on flanges recognition
            -"Edge to edge": The tool will search for edge to edge contacts
            -"Node to surface": The tool will detect the projection of single edges on surfaces
            (Default: "Standard")

    Returns
    -------
    object
            Returns a list containing the newly created contact flanges upon success.
            On failure it returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                contacts = base.ContactFlanges(
                    0,
                    contact_type="abaqus_contact",
                    solid_thickness=5.0,
                    update_clearance=True,
                    create_symetrical=False,
                    use_connection_elements=True,
                )
                if contacts:
                    print("Number of Contacts = ", len(contacts))


    """


def ConvertCShellToShell(
    entities: object,
    property: object,
    delete_cshells: bool,
    create_properties: bool,
    apply_thickness: bool,
    ret_ents: bool,
) -> object:
    """

    Converts all c.shells, given in CShell_matrix, to Shells. As input, one can also
    insert properties (CONTINUUM_SHELL_SECTION). The function, will then handle
    as input all the C.Shells that refer to the afforementioned properties.

    Parameters
    ----------
    entities : object
            A list of the entities (Cshells) that we desire to convert to Shells.

    property : object, optional
            The entity of the desired cshell property, to be used for the newly
            created cshells. If None is given a default property will be created.

    delete_cshells : bool, optional
            If True, the cshells used for the convertion to Shells will be
            deleted in the end of the procedure. Default value is False.

    create_properties : bool, optional
            If True, the function will create different Shell properties for each different
            Cshell property of the given elements.
            (Default: False)

    apply_thickness : bool, optional
            If True, the newly created shells will receive a nodal thickness according
            to the geometry characteristics of the C.Shells.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 1 on success and 0 on failure.
            If ret_ents=True it will return a list with the created entities or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entities = base.CollectEntities(
                    constants.ABAQUS, None, "CONTINUUM SHELL", False, filter_visible=True
                )
                total = len(entities)

                if not base.ConvertCShellToShell(
                    entities, delete_cshells=True, property=2, apply_thickness=True
                ):
                    print("Convertion Failed!")
                print("Total:", total)
                print("Convertion Done")


            # ...or...


            def main2():
                entities = []
                entities.append(base.GetEntity(constants.ABAQUS, "CONTINUUM_SHELL_SECTION", 1))
                entities.append(base.GetEntity(constants.ABAQUS, "CONTINUUM_SHELL_SECTION", 2))
                total = len(entities)
                if not base.ConvertCShellToShell(
                    entities, delete_cshells=True, property=2, apply_thickness=True
                ):
                    print("Convertion Failed!")
                print("Total:", total)
                print("Convertion Done")


    """


def ConvertIncludesToAnsaDBStorage(includes: object, conversion_option: int) -> int:
    """

    Converts include to AnsaDB storage type and thus makes it independent of external file reference.

    Parameters
    ----------
    includes : object
            A list containing the includes to be converted.

    conversion_option : int
            1: Works only if include already has a valid external file reference
            (FullPathName) and copies this file contents to internal AnsaDB.
            2: Output include database contents to internal AnsaDB storage.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                include = base.CreateEntity(constants.NASTRAN, "INCLUDE")
                node = base.CreateEntity(constants.NASTRAN, "GRID")
                base.AddToInclude(include, node)
                base.ConvertIncludesToAnsaDBStorage((include,), 2)


    """


def ConvertIncludesToDiskStorage(
    includes: object, conversion_option: int, output_directory: str
) -> int:
    """

    Converts selected includes to Disk storage type, external reference to file (FullPathName).

    Parameters
    ----------
    includes : object
            A list with the includes to be converted.

    conversion_option : int
            1: Copies contents of AnsaDB storage to external file and updates
                FullPathName accordingly (only if include had AnsaDB storage).
            2: Discards AnsaDB reference (if existed) and uses previous FullPathName
                as reference.
            3: Outputs include database contents to new external file and updates.

    output_directory : str, optional
            Used in option 1 and 3, output filename is output_directory + include name.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.CreateEntity(constants.NASTRAN, "INCLUDE")
                node = base.CreateEntity(constants.NASTRAN, "GRID")
                base.AddToInclude(include, node)
                base.ConvertIncludesToAnsaDBStorage((include,), 2)
                base.ConvertIncludesToDiskStorage((include,), 1, "directory_name")


    """


def ConvertPcompToLaminate(
    deck: int,
    entities: object,
    mode: str,
    t_tol: float,
    theta_tol: float,
    merge_unconnected_areas: bool,
    create_mapped_data: bool,
    delete_original_properties: bool,
    max_nlayers: int,
) -> object:
    """

    This function creates a new Laminate by merging multiple composite zones (PCOMPs or LAMINATEs).

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    entities : object
            A list of elements, properties, sets or parts containing elements.

    mode : str, optional
            "by_tolerances": merge layers with T and THETA within the t_tol and
            theta_tol tolerances.
            "by_gplyid": merge layers with the same GPLYID (default mode).
            "by_layer_name": merge layers with the same LAYER NAME.

    t_tol : float, optional
            Thickness tolerance for "by_tolerances" mode.

    theta_tol : float, optional
            Theta tolerance for "by_tolerances" mode.

    merge_unconnected_areas : bool, optional
            Merge unconnected areas for "by_tolerances" mode.

    create_mapped_data : bool, optional
            Create mapped data for "by_tolerances" mode.

    delete_original_properties : bool, optional
            If True all original properties will be deleted.

    max_nlayers : int, optional
            Set the maximum number of layers that the created Laminate can have.
            Otherwise ConvertPcompToLaminate fails and returns None.

    Returns
    -------
    object
            Returns the created LAMINATE Property or None if the function fails.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = list()
                props.append(base.GetEntity(constants.NASTRAN, "PCOMP", 2))
                props.append(base.GetEntity(constants.NASTRAN, "PCOMP", 3))
                ent = base.ConvertPcompToLaminate(
                    constants.NASTRAN, props, mode="by_tolerances", t_tol=0.01, theta_tol=5
                )
                # ent = ConvertPcompToLaminate(constants.NASTRAN, props, mode="by_gplyid")
                # ent = ConvertPcompToLaminate(constants.NASTRAN, props, mode="by_layer_name")
                if ent == None:
                    print("ConvertPcompToLaminate failed!!!")
                    return
                ret = base.GetEntityCardValues(constants.NASTRAN, ent, ("nlayers",))
                print("nlayers = ", ret["nlayers"])


    """


def ConvertShellToCShell(
    entities: object,
    property: object,
    delete_shells: bool,
    create_properties: bool,
    junctions: str,
    type: str,
    ret_ents: bool,
) -> object:
    """

    Convert all shells, given in Shell_matrix, to Continuum Shells.
    As input, one can also insert properties (SHELL_SECTION).
    The function will then handle as input all the Shells that refer to the aforementioned properties.

    Parameters
    ----------
    entities : object
            A list of the entities (Shells) that we desire to convert to Cshells.

    property : object, optional
            The reference to the desired shell property, to be used for the newly
            created shells. If None is given, a default property will be created.

    delete_shells : bool, optional
            If True, the shells used for the convertion to C.Shells will be
            deleted in the end of the procedure.

    create_properties : bool, optional
            If True, the function will create different Cshell properties for each different
            Shell property of the given elements.
            (Default: False)

    junctions : str, optional
            PASTE: If Paste, the Tshells will be created exactly upon the Shells' edge
            TIED_CONTACT and there may be penetrattion between the Tshells. If Paste, we can
            avoid this penetration by creating the Tshells slightly offset from
            the Shells' edges and connecting them with a TIED_CONTACT.

    type : str, optional
            "GASKET" for Gasket elements, "COHESIVE" for Cohesive elements.

    ret_ents : bool, optional
            If set to True a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 1 on success and 0 on failure.
            If ret_ents=True it will return a list with the created entities or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entities = base.CollectEntities(
                    constants.ABAQUS, None, "SHELL", False, filter_visible=True
                )
                total = len(entities)

                if not base.ConvertShellToCShell(entities, True, True):
                    print("Convertion Failed!")
                print("Total:", total)
                print("Convertion Done")


            # ...or...


            def main():
                entities = []
                entities.append(base.GetEntity(constants.ABAQUS, "SHELL_SECTION", 1))
                entities.append(base.GetEntity(constants.ABAQUS, "SHELL_SECTION", 2))
                total = len(entities)

                if not base.ConvertShellToCShell(entities, True, True):
                    print("Convertion Failed")
                print("Total:", total)
                print("Convertion Done")


    """


def ConvertTubesToCurves(
    input_faces: object,
    curves_with_diam: bool,
    matched_faces: bool,
    unmatched_faces: bool,
) -> object:
    """

    Converts tubes to curves.

    Parameters
    ----------
    input_faces : object
            A list of faces or a string with accepted values "All" or "Visible".

    curves_with_diam : bool, optional
            If True a dictionary will be returned with created curves and corresponding
            diameter.

    matched_faces : bool, optional
            If True a list with references to the faces of tubes that were converted to
            curves will be returned.

    unmatched_faces : bool, optional
            If True a list with references to the unmatched faces aents will be returned.

    Returns
    -------
    object
            On success it will return a dictionary with:
            key: curves_with_diam   value: a dictionary with key 'aent curve' and value 'diameter'.
            key: matched_faces      value: a list with the matched faces aents.
            key: unmatched_faces    value: a list with the unmatched faces aents.

            Returns None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE")
                ret = base.ConvertTubesToCurves(
                    input_faces=faces,
                    curves_with_diam=True,
                    matched_faces=True,
                    unmatched_faces=True,
                )
                print("Num of created curves: ", len(ret["curves_with_diam"]))


    """


def CopyEntity(target: object, source: object) -> object:
    """

    Creates a copy of an entity or copies the values of an entity's card to the ones of another.

    Parameters
    ----------
    target : object
            The reference to the target entity.

    source : object
            The reference to the source entity.

    Returns
    -------
    object
            Returns the target entity on success, None on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                prop_old = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                prop_new = base.CopyEntity(None, prop_old)


            # OR to copy the values from one entity to another


            def main():
                prop_1 = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                prop_2 = base.GetEntity(constants.NASTRAN, "PSHELL", 2)
                base.CopyEntity(prop_2, prop_1)


    """


def CopyMatFromMdb(DECK: int, NAME: str) -> object:
    """

    Creates a copy of a material named NAME, which is located in the Material Database, to the Material List.

    Parameters
    ----------
    DECK : int
            The deck.

    NAME : str
            The name of the material.

    Returns
    -------
    object
            Returns a copy of the material, if this exists in the Material Database, or None otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                mat_new = base.CopyMatFromMdb(constants.NASTRAN, "my_material_in_mdb")


    """


def CopyMatToMdb(MATERIAL: object) -> int:
    """

    Creates a copy of the material MATERIAL which is located in the Material List, to the material database.

    Parameters
    ----------
    MATERIAL : object
            A reference to the material to be copied.

    Returns
    -------
    int
            Returns 0 in case of success and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                mat = base.GetEntity(
                    constants.LSDYNA, "MAT24 MAT_PIECEWISE_LINEAR_PLASTICITY", 1001
                )
                ret_val = base.CopyMatToMdb(mat)
                if ret_val:
                    print("Copy material to material database, failed !!")
                else:
                    print("Copy material to material database, successful.")


    """


def CopyMatsFromMdbToMlist(
    deck: int,
    mode: str,
    overwrite_names: bool,
    overwrite_comments: bool,
    overwrite_colors: bool,
    copy_unmatched: bool,
    ret_ents: bool,
    case_sensitive: bool,
    verbose: int,
    overwrite_ids: bool,
) -> object:
    """

    This function copies/updates materials using the Material Database.

    Parameters
    ----------
    deck : int
            The current deck.

    mode : str
            Accepted values: "update_by_ids", "update_by_names", "copy".

    overwrite_names : bool
            Flag to overwrite names.

    overwrite_comments : bool
            Flag to overwrite comments.

    overwrite_colors : bool
            Flag to overwrite colors.

    copy_unmatched : bool
            Flag to copy unmatched materials.

    ret_ents : bool, optional
            If set to True a list with the created entities will be returned.

    case_sensitive : bool, optional
            Flag for name comparison to be case sensitive.

    verbose : int, optional
            If verbose is set to ansa.constants.REPORT_ALL the function returns a tuple that has two items:
            First the return value of the function if the verbose argument was not given.
            Second a list with possible error messages if the function fails.

    overwrite_ids : bool, optional
            Flag to overwrite ids when "update_by_names" is selected.

    Returns
    -------
    object
            Returns the number of materials successfuly copied.
            If ret_ents=True, it will return a list with the copied materials, or None if no materials were copied.
            if verbose = ansa.constants.REPORT_ALL, it will return a tuple where the first item is one of the return values mentioned above and second is a list with possible error messages during the execution.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.CopyMatsFromMdbToMlist(
                    constants.LSDYNA, "update_by_ids", False, True, True, False
                )


    """


def CreateCircle3Points(
    first_3d_point: object, second_3d_point: object, third_3d_point: object
) -> object:
    """

    Function CreateCircle3Points(), given three arbitrary non-collinear points (i.e. 3 element arrays of scalars) (e.g. A, B and C), constructs the registered circle of the triangle with vertices defined by points A, B and C.

    Parameters
    ----------
    first_3d_point : object
            First (A) point entity.

    second_3d_point : object
            Second (B) point entity.

    third_3d_point : object
            Third (C) point Entity.

    Returns
    -------
    object
            A list containing the IDs of the 2 curve-segments consisting the created circle.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                A = (0.0, 0.0, 0.0)
                B = (10.0, 0.0, 0.0)
                C = (0.0, 10.0, 0.0)
                # D will contain the 2 IDs of the created circle's curve segments
                # create registered circle of triangle with vertices A, B and C
                D = base.CreateCircle3Points(A, B, C)
                print("Output: ", D)


    """


def CreateCircleCenter2PointsRadius(
    center: object,
    first_3d_point: object,
    second_3d_point: object,
    radius: float,
    vectors: bool,
    cross_curve: bool,
) -> object:
    """

    Function that defines a circle on a plane.

    Parameters
    ----------
    center : object
            The center of the desired circle to be created.

    first_3d_point : object
            The first point that defines the plane.
            If 'vectors' is True, first_3d_point is a vector, defining the X axis
            of the temporary plane.

    second_3d_point : object
            The second point that defines the plane.
            If 'vectors' is True, second_3d_point is a vector, defining the Y axis
            of the temporary plane.

    radius : float
            Denotes its radius.

    vectors : bool, optional
            If True first_3d_point and second_3d_point are defined as vectors and
            not as coordinates of 3d points.

    cross_curve : bool, optional
            If True and a CROSS_SECTION exists in database, then a cross curve is
            created instead of a simple curve.

    Returns
    -------
    object
            A list containing the IDs of the 2 curve-segments consisting the created circle.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # define2 points
                A = (0.0, 0.0, 0.0)
                B = (10.0, 0.0, 0.0)
                # define center of circle
                C = (0.0, 10.0, 0.0)
                # define radius of circle
                r = 10.0
                # D will contain the created circle's curve segments
                # create circle with center C and radius r that lies on the plane defined by points A, B and C
                D = base.CreateCircleCenter2PointsRadius(C, A, B, r)

                print("Output:", D)


    """


def CreateEntity(
    deck: int,
    element_type: str,
    fields: object,
    mbcontainer: object,
    include: object,
    debug: int,
) -> object:
    """

    Creates a new ANSA entity.

    Parameters
    ----------
    deck : int
            The current deck.

    element_type : str
            A string that describes the entity type. It can be retrieved from the title
            of the entity's edit card, where it is displayed within brackets.

    fields : object, optional
            A Dictionary containing labels of the entity's Edit Card and
            the assigned values.

    mbcontainer : object, optional
            A reference to an ANSAPART, ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN.

    include : object, optional
            A reference to an include entity.
            It can be used along with "mbcontainer" argument,
            only if "mbcontainer" is ANSAPART.

    debug : int, optional
            If debug is set to ansa.constants.REPORT_ALL returns a tuple that has two items:
                    a reference to the entity created on success (None on error)
            and     a dictionary that holds any errors / warnings found. This dictionary has as keys the fields that were used upon calling the function and lead to errors / warnings. The data for each field is a dictionary with two keys:
                            'type' that holds the words 'error' or 'warning' as data.
                            'message' that holds the error message generated by this field.

            If debug is ansa.constants.REPORT_SILENCE returns a tuple that has two items:
                    a reference to the entity created on success (None on error) and an empty dictionary

            If not given a reference to the entity created on success (None on error).

    Returns
    -------
    object
            If debug argument is not given returns a reference to the entity created, or None if invalid arguments were specified, or an error occurred.

            If debug argument is given returns a tuple with a reference to the entity created as before and a dictionary with errors

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                vals = {"Name": "new set"}
                set = base.CreateEntity(constants.NASTRAN, "SET", vals)

                nodes_list = []
                for i in range(100):
                    vals = {"X1": i * 10, "X2": i * 10, "X3": i * 10}
                    n = base.CreateEntity(constants.NASTRAN, "GRID", vals)

                base.AddToSet(set, nodes_list)

                # for creation of second order tetras:
                vals_property = {"PID": 111, "Name": "new property"}
                property = base.CreateEntity(constants.NASTRAN, "PSOLID", vals_property)

                vals_element = {
                    "PID": 111,
                    "type": "CTETRA",
                    "__order__": "2",
                    "G1": 1,
                    "G2": 2,
                    "G3": 3,
                    "G4": 4,
                    "G5": 5,
                    "G6": 6,
                    "G7": 7,
                    "G8": 8,
                    "G9": 9,
                    "G10": 10,
                }
                tetra = base.CreateEntity(constants.NASTRAN, "SOLID", vals_element)

                # for creation of features (see also the help text of FeatureHandler for details)
                faces = []
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 111))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 222))
                fillet = base.CreateEntity(constants.NASTRAN, "FILLET", {"contents": faces})
                perims = []
                perims.append(base.GetEntity(constants.NASTRAN, "CONS", 6))
                special = base.CreateEntity(
                    constants.NASTRAN, "SPECIAL PERIMETER", {"contents": perims, "Type": "Sharp"}
                )

                # examples using "mbcontainer" and "include" arguments
                subsystem = base.GetEntity(constants.ABAQUS, "ANSA_SUBSYSTEM", 46)
                cload = base.CreateEntity(
                    constants.ABAQUS,
                    "CLOAD",
                    {"STEP": 1, "NODE": 1, "magn": 1.0, "Name": "cload1"},
                    mbcontainer=subsystem,
                )

                include_1 = base.GetEntity(ansa.constants.ABAQUS, "INCLUDE", 4)
                cload = base.CreateEntity(
                    constants.ABAQUS,
                    "CLOAD",
                    {"STEP": 1, "NODE": 1, "magn": 1.0, "Name": "cload2"},
                    include=include_1,
                )


            import pprint


            def main():
                debug_mode = constants.REPORT_ALL

                variables_list = {"G1": 15861, "G2": 18709, "G3": 9999999}
                ent, debug_report = base.CreateEntity(
                    constants.ABAQUS, "SHELL", variables_list, debug=debug_mode
                )

                if ent:
                    pprint.pprint("No errors or warnings found!")
                else:
                    pprint.pprint(debug_report)


    """


def CreateInactiveInclude(name: str, full_path_name: str, deck: int) -> object:
    """

    Creates an inactive unloaded include.
    Include is only visible in Includes Configurator and can be later loaded with "LoadInclude".

    Parameters
    ----------
    name : str
            The name of the include.

    full_path_name : str
            The FullPathName of the include.

    deck : int
            The current deck.

    Returns
    -------
    object
            Returns a reference to the created include.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.CreateInactiveInclude(
                    "test_inactive", "/home/user/include.nas", constants.NASTRAN
                )
                base.LoadInclude(include)


    """


def CreateLoadCurve(
    curve_type: str, fields: object, items: object, permas_mat_label: str
) -> object:
    """

    Creatse a new load curve and set the specified parameters.

    Parameters
    ----------
    curve_type : str
            Can be one of the following:
            For LS-DYNA:
            -DEFINE_CURVE_SMOOTH
            -DEFINE_CURVE
            -DEFINE_TABLE
            -DEFINE_CURVE Encrypted

            For NASTRAN:
            -TABLED1
            -TABLED2
            -TABLED3
            -TABLED4
            -TABLEM1
            -TABLEM2
            -TABLEM3
            -TABLEM4
            -TABLES1
            -TABDMP1
            -TABRND

            For RADIOSS or PAMCRASH:
            -FUNCT

            For ANSYS:
            -DIM
            -TBs : Use regural functions CreateEntity/SetEntityCardValues instead.

            For ABAQUS:
            -AMPLITUDE
            -DEPENDENCY_DATA_TABLE
            -ABAQUS TABLE

            For PERMAS:
            -FUNCTION TABLE
            -PERMAS_MATERIAL_DATA_LINES

            For MARC:
            -TABLE

            For OPTISTRUCT:
            -FATMCRV
            -TABLEXN

    fields : object
            A dictionary that sets the desired field values of the table cards.
            Dictionary items with the following keys can also be used as a pair:
            __table_curves: Curves willing to insert into a table.
            __table_values: The Rate values that will be used for the above curves.

    items : object, optional
            A pair of lists, one that contains curves and another that contains x values.
            Only for use with TABLE entities
            (e.g. [ [curve1, curve2, ...], [x1, x2, ...] ])

    permas_mat_label : str, optional
            A string that defines what kind PERMAS_MATERIAL_DATA_LINES curve will be.
            (e.g. "G :TEMP", "pL :DEFX :TEMP")

    Returns
    -------
    object
            Returns a reference to the created curve entity on success, or None otherwise.

    See Also
    --------
    SetLoadCurveData

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves_of_table = []

                # Create individual curves
                curve1 = base.CreateLoadCurve("DEPENDENCY_DATA_TABLE", {"Name": "test1"})
                mat = ((0.0, 2.0), (1.0, 4.0), (2.0, 8.0), (3.0, 16.0))
                base.SetLoadCurveData(curve1, mat)

                curves_of_table.append(curve1)

                curve2 = base.CreateLoadCurve("DEPENDENCY_DATA_TABLE", {"Name": "test2"})
                mat = ((0.0, 3.0), (1.0, 5.0), (2.0, 9.0), (3.0, 17.0))
                base.SetLoadCurveData(curve2, mat)
                curves_of_table.append(curve2)

                values = []
                values.append(5.0)
                values.append(6.0)

                # Create a table with the above created curves
                fields = {
                    "Name": "fixed_table",
                    "__table_curves": curves_of_table,
                    "__table_values": values,
                }
                table = base.CreateLoadCurve("ABAQUS TABLE", fields)

                # "__table_curves", "__table_values" of a table can be updated using SetEntityCardValues
                curve3 = base.CreateLoadCurve(
                    "DEPENDENCY_DATA_TABLE", {"Name": "test3"}, show_errors=True
                )
                mat = ((0.0, 4.0), (1.0, 6.0), (2.0, 10.0), (3.0, 18.0))
                base.SetLoadCurveData(curve3, mat)
                curves_of_table.append(curve3)
                values.append(7.0)
                ret = base.SetEntityCardValues(
                    constants.ABAQUS,
                    table,
                    {"__table_curves": curves_of_table, "__table_values": values},
                )

                # Create a PERMAS_MATERIAL_DATA_LINES table
                curve4 = base.CreateLoadCurve(
                    "PERMAS_MATERIAL_DATA_LINES", {"Name": "test4"}, permas_mat_label="G :TEMP"
                )


    """


def CreateMeasurement(entities: list, type: str, coord: Entity | None = None) -> object:
    """

    This function creates a measurement entity.

    After the creation of the new measurement you can use:
    base.GetEntityCardValues to get the measurement results or
    base.SetEntityCardValues to change the current measurement type.

    All supported values for the parameter "TYPE" are the same strings displayed within
    the measurements's edit card:

    ANGLE                           angle between shells, solid facets, edges, linear elements, etc.
    ANGLE_1                         angle at node 1, if three nodes are selected
    ANGLE_2                         angle at node 2, if three nodes are selected
    ANGLE_3                         angle at node 3, if three nodes are selected
    ANGLE_XY                        angle between two nodes and the default working plane XY
    ANGLE_YZ                        angle between two nodes and the default working plane YZ
    ANGLE_ZX                        angle between two nodes and the default working plane ZX
    AREA                            area of one or more shells, solid facets, faces
                                    or skin area of one or more solids
    CIRCUMSCRIBED_CIRCLE            if three nodes are selected
    CIRCUMSCRIBED_SPHERE            if four nodes are selected
    COG                             center of gravity if many nodes are selected
    CURVATURE                       the curvature (min radius) of one Cons/Curve, only
                                    if one Cons/Curve is selected
    DISTANCE                        distance between two nodes, a node and a plane, a
                                    node and a curve, two curves,two coord.systems, etc.
    DISTANCE_ELEMENTS               distance between a node and a macro's elements (shells),
                                    or distance between macros (shells)
    DISTANCE_GEOMETRY               distance between a node and a face's geometry, or
                                    distance between faces (geometry)
    DISTANCE_PERPENDICULAR          perpendicular distance between a node and an edge
    DISTANCE_SURFACE                distance between a node and a face's surface
    DISTANCE_TO_PLANE_1             distance between the node 1 and the plane 234, if four nodes selected
    DISTANCE_TO_PLANE_2             distance between the node 2 and the plane 134, if four nodes selected
    DISTANCE_TO_PLANE_3             distance between the node 3 and the plane 124, if four nodes selected
    DISTANCE_TO_PLANE_4             distance between the node 4 and the plane 123, if four nodes selected
    DISTANCE_TO_VECTOR_1            distance between the node 1 and the vector 23, if three nodes selected
    DISTANCE_TO_VECTOR_2            distance between the node 2 and the vector 13, if three nodes selected
    DISTANCE_TO_VECTOR_3            distance between the node 3 and the vector 12, if three nodes selected
    EQUIVALENT_CIRCLE               the circle (radius and center's coordinates) only if a closed path of
                                    Cons or edges is selected
    EULER_ANGLES_XYZ                the three euler angles between two coord.systems (1.rotation at axis
                                    X, 2.rotation at axis Y and 3.rotation at axis Z)
    EULER_ANGLES_ZXZ                the three euler angles between two coord.systems (1.rotation at axis
                                    Z, 2.rotation at axis X and 3.rotation at axis Z)
    EULER_AXIS                      the euler axis (dx,dy,dz) and euler angle for two selected
                                    coord.systems
    INSCRIBED_CIRCLE                if three nodes are selected
    INSCRIBED_SPHERE                if four nodes are selected
    LENGTH                          length of one or more Cons, curves, edges and other linear elements
    MASS                            mass of one or more elements
    MIDDLEPOINT                     coordinates of a shell's or solid facet's middlepoint
    MIDDLEPOINT_DISTANCE_GEOMETRY   distance between the middlepoint of a geometry shell from its geometry
    NEIGHBOURING_DISTANCE           maximum distance between two pasted Cons, only if a yellow Cons
                                    is selected
    NEIGHBOURING_ANGLE              maximum angle between tho pasted Cons, only if a yellow Cons
                                    is selected
    NODE_DISTANCE_GEOMETRY          distance between a node from its geometry, only for nodes that
                                    belong to a macro
    NODE_DISTANCE_ORIGIN            distance between a node from its original position, only for
                                    nodes that belong to a macro
    NODE_DISTANCE_PERIMETER         distance between a node from its macro's perimeter, only for
                                    nodes that belong to a perimeter
    NODE_POSITION                   coordinates (x,y,z) of a node
    POLYLINE_LENGTH                 polyline length if many nodes are selected (nodes are connected
                                    according to the given order)
    VOLUME                          volume of one or more solid elements

    Parameters
    ----------
    entities : list
            A list of entities (nodes, shells, solid facets, faces, curves, planes, etc.)
            to be measured.

    type : str, optional
            Type of measurement. See list above.

    coord : Entity|None, optional
            A coordinate system entity to get measurements relative to.

    Returns
    -------
    object
            Returns the newly created measurement entity on success, or 0 if the input could not result to a measurement.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # 1.Example for getting the angle between two shells:
            def main():
                ents = ("SHELL",)
                shells = base.PickEntities(constants.NASTRAN, ents)
                if len(shells) == 2:
                    msr = base.CreateMeasurement(shells, "ANGLE")
                    # msr = base.CreateMeasurement(shells)  without specification ---> this would also give the angle result
                    if msr:
                        ret_ents = base.GetEntityCardValues(
                            constants.NASTRAN, msr, ("ID", "RESULT", "RES1", "RES2", "RES3")
                        )
                        print("A new measurement is created with id: " + ret_ents["ID"])
                        print(
                            "The resulted angle is: ",
                            ret_ents["RESULT"],
                            ", XY-Plane: ",
                            ret_ents["RES1"],
                            ", YZ-Plane: ",
                            ret_ents["RES2"],
                            ", ZX-Plane: ",
                            ret_ents["RES3"],
                        )


            # 2.Example for getting the distance between a node and a curve:
            def main():
                ents = ("FACE",)
                nodes = base.PickNodes(constants.NASTRAN, ents)
                ents = ("CONS", "CURVE")
                curves = base.PickEntities(constants.NASTRAN, ents)

                input = []
                input.append(nodes[0])  # get only the 1. selected node
                input.append(curves[0])  # get only the 1. selected curve

                msr = base.CreateMeasurement(input, "DISTANCE")

                if msr:
                    ret_res = base.GetEntityCardValues(
                        constants.NASTRAN, msr, ("ID", "RESULT", "RES1", "RES2", "RES3")
                    )
                    print("A new measurement is created with id: ", ret_res["ID"])
                    print(
                        "The result is d: ",
                        ret_res["RESULT"],
                        ", dx: ",
                        ret_res["RES1"],
                        ", dy: ",
                        ret_res["RES2"],
                        ", dz: ",
                        ret_res["RES3"],
                    )


            # 3.Example for creating five new measurements from three selected nodes,
            # the three angles, the circumscribed and the inscrided circle:
            def main():
                ents = []
                ents.append("FACE")
                nodes = base.PickNodes(constants.NASTRAN, ents)
                if len(nodes) == 3:
                    msr = base.CreateMeasurement(nodes, "ANGLE_1")  # the angle at node 1
                    msr = base.CreateMeasurement(nodes, "ANGLE_2")  # the angle at node 2
                    msr = base.CreateMeasurement(nodes, "ANGLE_3")  # the angle at node 3
                    msr = base.CreateMeasurement(nodes, "CIRCUMSCRIBED_CIRCLE")
                    msr = base.CreateMeasurement(nodes, "INSCRIBED_CIRCLE")


            # 4.Example: applying local coordinate systems:
            def main():
                ent = ("POINT",)
                points = base.PickNodes(constants.NASTRAN, ent)
                if len(points) == 2:
                    msr = base.CreateMeasurement(points)
                    ret_mes = base.GetEntityCardValues(
                        constants.NASTRAN, msr, ("RESULT", "RES1", "RES2", "RES3")
                    )
                    print(
                        "1.Distance (global coordinate system): ",
                        ret_mes["RESULT"],
                        ", ",
                        ret_mes["RES1"],
                        ", ",
                        ret_mes["RES2"],
                        ", ",
                        ret_mes["RES3"],
                    )
                    coord = base.GetFirstEntity(constants.NASTRAN, "CORD_NODES_R")
                    msr = base.CreateMeasurement(points, coord=coord)
                    ret_mes = base.GetEntityCardValues(
                        constants.NASTRAN, msr, ("RESULT", "RES1", "RES2", "RES3")
                    )
                    print(
                        "2.Distance (local coordinate system): ",
                        ret_mes["RESULT"],
                        ", ",
                        ret_mes["RES1"],
                        ", ",
                        ret_mes["RES2"],
                        ", ",
                        ret_mes["RES2"],
                    )
                    coord_id = 2
                    msr = base.CreateMeasurement(points, coord=coord_id)
                    ret_mes = base.GetEntityCardValues(
                        constants.NASTRAN, msr, ("RESULT", "RES1", "RES2", "RES3")
                    )
                    print(
                        "3.Distance (local coordinate system): ",
                        ret_mes["RESULT"],
                        ", ",
                        ret_mes["RES1"],
                        ", ",
                        ret_mes["RES2"],
                        ", ",
                        ret_mes["RES3"],
                    )


    """


def CreateNewAnsaModel() -> Entity:
    """

    This function creates a new instance of an ansa model. Different databases can be opened and handled
    in Ansa in separate model instances, but only one instance can be current at any single moment. All ansa
    functionality will run on the current model. The function should only be used in combination with the following
    functions: SetCurrentAnsaModel(), GetCurrentAnsaModel(), DestroyAnsaModel()

    Returns
    -------
    Entity
            Returns the newly created ansa model instance, which must then be set as current, in order
            to continue working with Ansa on this model, or None in case of error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                old_model = (
                    base.GetCurrentAnsaModel()
                )  # Request for the current model instance. It will set current again at the end of all actions
                new_model = base.CreateNewAnsaModel()  # Create a new model instance
                base.SetCurrentAnsaModel(new_model)  # Set the new model as current
                utils.Merge(
                    "C:/temp/users/folder/new_data1.ansa"
                )  # In the new model merge a ansa database
                utils.Merge("C:/temp/users/folder/new_data1.ansa")  # Merge a second database
                base.SaveAs(
                    "C:/temp/users/folder/merge_dbs.ansa"
                )  # Save current model in a new database
                base.SetCurrentAnsaModel(old_model)  # Set the original current model as current
                base.DestroyAnsaModel(new_model)  # Destroy the previously created ansa model


    """


def CreateNumberingRule(
    deck: int,
    rule_source: str,
    reference_entity: object,
    element_type: str,
    apply_mode: str,
    from_value: int,
    to_value: int,
    rule_name: str,
    renumber_nodes: bool,
    renumber_properties: bool,
    renumber_materials: bool,
    renumber_elements: bool,
    force_ids: bool,
    preserve_ids: bool,
    connection_id_2body_element: bool,
    link_part_rule_to_moduleid: bool,
    internal_includes: bool,
    special_rules: bool,
    lock: bool,
    source_with_expression: str,
) -> object:
    """

    This function creates a numbering rule.

    Parameters
    ----------
    deck : int
            The current deck.

    rule_source : str
            Accepted values: "TOOL", "INCLUDE","PART", "PROPERTY", "CONNECTION",
            "GENERIC_ENTITIES_BUILDER", "CONNECTOR", "CONNECTION TEMPLATE",
            "ANSA_SIMULATION_MODEL", "ANSA_LOADCASE", "ANSA_SIMULATION_RUN",
            "ANSA_SUBSYSTEM", "ANSA_LIBRARY_ITEM".

    reference_entity : object
            - For special rules reference to an INCLUDE, PART, PROPERTY, CONNECTOR,
            GENERIC_ENTITIES_BUILDER, CONNECTION TEMPLATE, ANSA_SIMULATION_MODEL,
            ANSA_LOADCASE, ANSA_SIMULATION_RUN, ANSA_SUBSYSTEM or ANSA_LIBRARY_ITEM.

            - For general rule the list of entities to be renumbered.

            - A list of properties or ids of properties when used in conjunction
              with SOURCE=PROPERTY. The elements of the user defined group
              of properties will be renumbered.

            - "WSPOT", "SPOTLINE", "ADH.LINE", "ADH.FACE", "SEAMLINE",
              "GUM DROP", "HEMMING", "BOLT". For reference to the Connection type.

    element_type : str
            Type-name of entity or a list of entities to be renumbered.
            With an empty string the rule will be applied to all entities
            in the referenced_entity.

    apply_mode : str
            "PER_GROUP" or "1" | "PER_TYPE" or "0".

    from_value : int
            Renumbering range's starting id.

    to_value : int
            Renumbering range's end id.

    rule_name : str
            Rule name.

    renumber_nodes : bool, optional
            Control renumber referenced nodes flag.

    renumber_properties : bool, optional
            Control renumber referenced properties flag.

    renumber_materials : bool, optional
            Control renumber referenced materials flag.

    renumber_elements : bool, optional
            Control renumber referenced elements flag.

    force_ids : bool, optional
            Control the force option.

    preserve_ids : bool, optional
            Control the preserve option.

    connection_id_2body_element : bool, optional
            In case of a CONNECTIONS rule add this parameter in order to
            assign connector's id to first created body element.

    link_part_rule_to_moduleid : bool, optional
            In case of a PART rule, add this parameter in order to link the
            special rule to the ANSA PART through the module ID.

    internal_includes : bool, optional
            In case of an INCLUDE rule, add this parameter in order to apply
            numbering rule to all internal rules that do not have numbering rules.

    special_rules : bool, optional
            In case of general rules, control the special rules.

    lock : bool, optional
            in case of general children rules, control the lock option.

    source_with_expression : str, optional
            a regular expression that leads to the creation of a dynamic special numbering rule. The supported wildcard characters are the asterisk ("*"), questionmark ("?") and brackets ("[]"). When a dynamic numbering rule is created a py_list is exported. The py_list contains the dynamic rule and the created special rules.

    Returns
    -------
    object
            Returns a reference to the rule created, py_list when "source with expression" is given as argument, or None if invalid arguments are given. When "source with expression" is a valid regular expression containing the asterisk ("*"), questionmark ("?") or brackets ("[]"), a dynamic special numbering rule is created. The py_list contains first the dynamic rule followed by all the created special rules.

    See Also
    --------
    CreateNumberingRuleWithIncrement, SetStatusOfNumberingRules, Renumber

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                rule1 = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "TOOL",
                    None,
                    "ELEMENT",
                    "PER_GROUP",
                    1,
                    1000000,
                    "element_rule",
                    preserve_ids=True,
                    special_rules=True,
                )
                rule2 = base.CreateNumberingRuleWithIncrement(
                    constants.NASTRAN,
                    "TOOL",
                    None,
                    "GRID",
                    "PER_GROUP",
                    1,
                    1000000,
                    50,
                    "grid_rule",
                )
                rule3 = base.CreateNumberingRuleWithIncrement(
                    constants.NASTRAN,
                    "INCLUDE",
                    "default_include",
                    "SHELL",
                    "PER_TYPE",
                    1200,
                    10000,
                    1000,
                    "new_rule",
                    force_ids=True,
                    internal_includes=True,
                )
                rule4 = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "PART",
                    "my_part",
                    "0",
                    "1",
                    2222,
                    3330000,
                    "new_rule_part",
                    renumber_nodes=True,
                    renumber_materials=True,
                )
                dynamic_and_created_rules = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "INCLUDE",
                    "test1",
                    "",
                    "PER_GROUP",
                    20000,
                    10000,
                    "dynamic_related_rule",
                    force_ids=True,
                    source_with_expression="test*",
                )
                base.SetStatusOfNumberingRules(True, True)
                base.Renumber()


    """


def CreateNumberingRuleForGeneratedPropsInOutput(
    DECK: int, REF_ENT: object, FROM_ID: int, TO_ID: int, INCREMENT: int, RULE_NAME: str
) -> object:
    """

    This function creates a numbering rule for the properties that will be generated during output. Currently, it can only be applied fot the PCOMPs that will be generated from LAMINATE output. If a not LAMINATE property is passed in function, no rule will be defined. The defined renumber will not be applied if 'Renumber' script function is called. That renumber is mentioned to be usedduring output ONLY.

    Parameters
    ----------
    DECK : int
            The deck constant. One of: NASTRAN | LSDYNA | PAMCRASH | ABAQUS | RADIOSS | ANSYS | PERMAS | CFD_*

    REF_ENT : object
            A reference to the LAMINATE property.

    FROM_ID : int
            Renumbering range's starting id.

    TO_ID : int
            Renumbering range's ending id.

    INCREMENT : int
            Renumbering increment value.

    RULE_NAME : str
            Name of numbering rule.

    Returns
    -------
    object
            Returns a reference to the rule created, or 0 if invalid arguments are given.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_laminate = base.GetEntity(constants.NASTRAN, "LAMINATE", 1)
                rule1 = base.CreateNumberingRuleForGeneratedPropsInOutput(
                    constants.NASTRAN, p_laminate, 2000, 4000, 2, "laminate_output_rule"
                )
                base.SetStatusOfNumberingRules(True, True)
                base.Renumber()


    """


def CreateNumberingRuleWithIncrement(
    deck: int,
    rule_source: str,
    reference_entity: object,
    element_type: str,
    apply_mode: str,
    from_value: int,
    to_value: int,
    increment_value: int,
    rule_name: str,
    renumber_nodes: bool,
    renumber_properties: bool,
    renumber_materials: bool,
    renumber_elements: bool,
    force_ids: bool,
    preserve_ids: bool,
    connection_id_2body_element: bool,
    link_part_rule_to_moduleid: bool,
    internal_includes: bool,
    special_rules: bool,
    lock: bool,
    source_with_expression: str,
) -> object:
    """

    This function creates a numbering rule.

    Parameters
    ----------
    deck : int
            The current deck.

    rule_source : str
            Accepted values: "TOOL", "INCLUDE", "PART", "PROPERTY",
            "CONNECTION", "GENERIC_ENTITIES_BUILDER", "ANSA_SIMULATION_MODEL", "ANSA_LOADCASE", "ANSA_SIMULATION_RUN", "ANSA_SUBSYSTEM", "ANSA_LIBRARY_ITEM"

    reference_entity : object
            - Reference to an INCLUDE, PART, PROPERTY, CONNECTOR,
              GENERIC_ENTITIES_BUILDER, CONNECTION TEMPLATE, ANSA_SIMULATION_MODEL,
            ANSA_LOADCASE, ANSA_SIMULATION_RUN, ANSA_SUBSYSTEM or ANSA_LIBRARY_ITEM

            - A list of entities to be renumbered.

            - A list of properties or ids of properties when used in conjunction
              with SOURCE=PROPERTY. The elements of the user defined group
              of properties will be renumbered.

            - "WSPOT", "SPOTLINE", "ADH.LINE", "ADH.FACE", "SEAMLINE",
              "GUM DROP", "HEMMING", "BOLT". For reference to the Connection type.

    element_type : str
            Type-name of entities or of group of entities to be renumbered,
            or None for all groups of entities.

    apply_mode : str
            "PER_GROUP" or "1" | "PER_TYPE" or "0".
            (Renumber whole group of entities or entities of same type)

    from_value : int
            Renumbering range's starting id.

    to_value : int
            Renumbering range's ending id.

    increment_value : int
            Renumbering range's increment value.

    rule_name : str
            Name of numbering rule.

    renumber_nodes : bool, optional
            Control renumber referenced nodes flag.

    renumber_properties : bool, optional
            Control renumber referenced properties flag.

    renumber_materials : bool, optional
            Control renumber referenced materials flag.

    renumber_elements : bool, optional
            Control renumber referenced elements flag.

    force_ids : bool, optional
            Control the force option.

    preserve_ids : bool, optional
            Control the preserve option.

    connection_id_2body_element : bool, optional
            In case of a CONNECTIONS rule add this parameter in order to
            assign connector's id to first created body element.

    link_part_rule_to_moduleid : bool, optional
            In case of a PART rule, add this parameter in order to link the
            special rule to the ANSA PART through the module ID.

    internal_includes : bool, optional
            In case of INCLUDE rule, add this parameter in order to apply
            numbering rule to all internal rules that do not have numbering rules.

    special_rules : bool, optional
            In case of general rules, control the special rules.

    lock : bool, optional
            in case of general children rules, control the lock option.

    source_with_expression : str, optional
            a regular expression that leads to the creation of a dynamic special numbering rule. The supported wildcard characters are the asterisk ("*"), questionmark ("?") and brackets ("[]"). When a dynamic numbering rule is created a py_list is exported. The py_list contains the dynamic rule and the created special rules.

    Returns
    -------
    object
            Returns a reference to the rule created, py_list when "source with expression" is given as argument, or None if invalid arguments are given. When "source with expression" is a valid regular expression containing the asterisk ("*"), questionmark ("?") or brackets ("[]"), a dynamic special numbering rule is created. The py_list contains first the dynamic rule followed by all the created special rules.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.CreateNumberingRuleWithIncrement(
                    constants.NASTRAN,
                    "TOOL",
                    None,
                    "ELEMENT",
                    "PER_GROUP",
                    True,
                    1000000,
                    10,
                    "new_rule",
                    True,
                    special_rules=True,
                )
                base.CreateNumberingRuleWithIncrement(
                    constants.NASTRAN,
                    "INCLUDE",
                    "default_include",
                    "SHELL",
                    "PER_TYPE",
                    1,
                    10000,
                    1000,
                    "new_rule",
                    True,
                )
                base.CreateNumberingRuleWithIncrement(
                    constants.NASTRAN,
                    "INCLUDE",
                    "test1",
                    "SHELL",
                    "PER_TYPE",
                    1,
                    10000,
                    1000,
                    "new_rule",
                    True,
                    source_with_expression="test*",
                )

                base.SetStatusOfNumberingRules(True, True)
                base.Renumber()


    """


def CreateSectionForce(
    x0: float,
    y0: float,
    z0: float,
    dx: float,
    dy: float,
    dz: float,
    name: str,
    entities: object,
    local: str,
    mkrefnode: int,
    ref_step: int,
) -> object:
    """

    Creates a Section Force Assistant Utility.

    Parameters
    ----------
    x0 : float
            The x coordinate of the point.

    y0 : float
            The y coordinate of the point.

    z0 : float
            The z coordinate of the point.

    dx : float
            The x coordinate of the normal vector.

    dy : float
            The y coordinate of the normal vector.

    dz : float
            The z coordinate of the normal vector.

    name : str
            The name of the Section Force to be created.

    entities : object
            Selected entities to cut by the cross section.

    local : str, optional
            Results output frame. 'G' (for global), 'LX','LY','LZ' (for local respectively axis).

    mkrefnode : int, optional
            Refererence node (if given) (ABQ).

    ref_step : int, optional
            Reference step (if it is to be created) (ABQ).

    Returns
    -------
    object
            Returns the section created on success, or 0 on failure.

    """


def CreateShellsFromSolidFacets(
    option: str, pid: int, ret_ents: bool, solids: object, part: int
) -> object:
    """

    This function creates shell elements from free or interior facets of solid elements.
    Hence new FE-Model shell elements can be created from selected facets.
    The function runs on an array of solids given as input. If no solids array is given then the function runs on visible.

    Parameters
    ----------
    option : str
            Accepted values: "skin", "skin exclude internal bounds" or "interior".

    pid : int, optional
            The id of the property that will be used for the shells. If it does not correspond to an existing PID a new one will be created for it. If none provided the new shells will be assigned to an auto created PID for each solid property.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    solids : object, optional
            An array of solids from the facets of which the shells will be created.

    part : int, optional
            The id of the part that will be used for the shells. If it does not correspond to an existing part a new one will be created for it. If none provided the new shells will be assigned to an auto created Part for each solid property.

    Returns
    -------
    object
            Returns 0 on success or 1 on failure.
            If ret_ents=True, it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.CreateShellsFromSolidFacets("skin", 1)


    """


def CreateTransformRotate(
    COMPONENT: object,
    ANGLE: float,
    X0: float,
    Y0: float,
    Z0: float,
    UX: float,
    UY: float,
    UZ: float,
) -> object:
    """

    Creates a rotation transformation of an entity.

    Parameters
    ----------
    COMPONENT : object
            The entity to be rotated.

    ANGLE : float
            Thre angle of rotation.

    X0 : float
            The x coordinate of the rotation point.

    Y0 : float
            The y coordinate of the rotation point.

    Z0 : float
            The z coordinate of the rotation point.

    UX : float
            The x component of the rotation vector.

    UY : float
            The y component of the rotation vector.

    UZ : float
            The z component of the rotation vector.

    Returns
    -------
    object
            Returns a reference to the transformation on success, or None on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.CreateTransformRotate(dummy, 30.0, 100.0, 20.0, -30.0, 0.0, 0.5, 0.1)


    """


def CreateTransformScale(
    COMPONENT: object, X0: float, Y0: float, Z0: float, SX: float, SY: float, SZ: float
) -> object:
    """

    Performs a scale transformation of an entity.

    Parameters
    ----------
    COMPONENT : object
            The entity to be scaled.

    X0 : float
            The x coordinate of the normal point.

    Y0 : float
            The y coordinate of the normal point.

    Z0 : float
            The z coordinate of the normal point.

    SX : float
            The x component of the scale factor.

    SY : float
            The y component of the scale factor.

    SZ : float
            The z component of the scale factor.

    Returns
    -------
    object
            Returns a reference to the transformation on success, or None on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ansa.base.CreateTransformScale(barrier, 100.0, 0.0, 0.0, 1.5, 1.5, 1.5)


    """


def CreateTransformTranslate(
    COMPONENT: object, DIST: float, UX: float, UY: float, UZ: float
) -> object:
    """

    Creates a translation of structure COMPONENT (set or include), of a distance DIST according to
    the vector UX, UY, UZ. In case of a zero distance, as DIST is taken vector's length.

    Parameters
    ----------
    COMPONENT : object
            The entity to be translated.

    DIST : float
            The translation distance.

    UX : float
            The x component of the translation vector.

    UY : float
            The y component of the translation vector.

    UZ : float
            The z component of the translation vector.

    Returns
    -------
    object
            Returns a reference to the transformation on success, or None on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.CreateTransformTranslate(front_panel_incl, 120.0, 1.0, 0.0, 0.0)


    """


def CreateUserDefinedAttribute(
    element_type: str,
    name: str,
    type: str,
    default_value: str,
    group_name: str,
    read_only: bool,
    accepted_values: str,
    deck: int,
    entity_subtype: str,
    save_in_defaults: bool,
    save_in_dm: bool,
    save_in_db: bool,
) -> object:
    """

    This function creates a user attribute that will accompany all entities of the specified ANSA keyword.
    Every newly created attribute will be added in the entity's list fields and it will be exist in the entity's card.
    Note that GetEntityCardValues/SetEntityCardValues can be used to get/set attribute values to an entity.

    Parameters
    ----------
    element_type : str
            The ANSA keyword.

    name : str
            The user attribute name.

    type : str, optional
            The user attribute type (TEXT, BOOL, INTEGER, DOUBLE).

    default_value : str, optional
            The user attribute default value.

    group_name : str, optional
            The user attribute group name.

    read_only : bool, optional
            The user attribute read-only state (True/False).

    accepted_values : str, optional
            The user attribute accepted values (comma separated).

    deck : int, optional
            The deck type.

    entity_subtype : str, optional
            The entity subtype that may exists in addition to the ANSA keyword.

    save_in_defaults : bool, optional
            Sets if the user attribute should be saved in ANSA defaults (default value: False)

    save_in_dm : bool, optional
            Sets if the user attribute should be saved in DM (default value: False)

    save_in_db : bool, optional
            Sets if the user attribute should be saved in the ANSA database (default value: True)

    Returns
    -------
    object
            Returns a reference to the newly created user attribute entity, or None if this user attribute could not be created.
            Note that if a user attribute already exists with this name, then this already existing attribute will be returned.

    See Also
    --------
    GetUserDefinedAttribute, GetUserDefinedAttributes, CompressUserDefinedAttributes

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create a user attribute with a specific name for the keyword: ANSAPART
                attr = base.CreateUserDefinedAttribute(
                    deck=constants.NASTRAN,
                    element_type="ANSAPART",
                    name="MyTestAttribute",
                    default_value="A",
                )

                if attr == None:
                    print("This user attribute could NOT be created!")
                else:
                    print("This user attribute could be created! ")

                    # Example: ask for user attribute characteristics:
                    ret_vals = base.GetEntityCardValues(constants.NASTRAN, attr, ("Default Value",))
                    print("Currently the default value is: ", ret_vals["Default Value"])

                    # Example: change the user attribute characteristics:
                    base.SetEntityCardValues(
                        constants.NASTRAN, attr, {"Default Value": "my_default_value"}
                    )
                    ret_vals = base.GetEntityCardValues(constants.NASTRAN, attr, ("Default Value",))
                    print("The new default value is: ", ret_vals["Default Value"])

                    # Example: set values to an entity's user attribute:
                    parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                    for part in parts:
                        base.SetEntityCardValues(
                            constants.NASTRAN, part, {"MyTestAttribute": "my_test_value"}
                        )
                    # Example: get values of an entity's user attribute:
                    for part in parts:
                        ret_vals = base.GetEntityCardValues(
                            constants.NASTRAN, part, ("Name", "MyTestAttribute")
                        )
                        print(
                            "Part with name: ",
                            ret_vals["Name"],
                            ", has the user attribute value: ",
                            ret_vals["MyTestAttribute"],
                        )


    """


def CreateWplane3Points(
    x1: float,
    y1: float,
    z1: float,
    x2: float,
    y2: float,
    z2: float,
    x3: float,
    y3: float,
    z3: float,
) -> object:
    """

    This function takes x, y, z coordinates from three points and creates a working plane.

    Parameters
    ----------
    x1 : float
            The x coordinate of the first point.

    y1 : float
            The y coordinate of the first point.

    z1 : float
            The z coordinate of the first point.

    x2 : float
            The x coordinate of the second point.

    y2 : float
            The y coordinate of the second point.

    z2 : float
            The z coordinate of the second point.

    x3 : float
            The x coordinate of the third point.

    y3 : float
            The y coordinate of the third point.

    z3 : float
            The z coordinate of the third point.

    Returns
    -------
    object
            Returns a reference to the new working plane on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ansa.base.CreateWplane3Points(10.0, 10.0, 10.0, 0.0, 5.0, 10.0, 5.0, 10.0, 20.0)


    """


def CreateWplaneNormal(
    x: float, y: float, z: float, dx: float, dy: float, dz: float
) -> object:
    """

    This function creates a working plane by giving its origin point and a vector which
    is normal to the created working plane.

    Parameters
    ----------
    x : float
            The x coordinate of the point.

    y : float
            The y coordinate of the point.

    z : float
            The z coordinate of the point.

    dx : float
            The x component of the normal vector.

    dy : float
            The y component of the normal vector.

    dz : float
            The z component of the normal vector.

    Returns
    -------
    object
            Returns a reference to the new working plane on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.CreateWplaneNormal(10.0, 10.0, 10.0, 0.0, 0.0, 1.0)


    """


def CreateWplaneWith2Axis(
    x: float,
    y: float,
    z: float,
    dx1: float,
    dy1: float,
    dz1: float,
    dx2: float,
    dy2: float,
    dz2: float,
) -> object:
    """

    This function takes a point which is the origin one and two vectors and creates a working plane.

    Parameters
    ----------
    x : float
            The x coordinate of the origin point.

    y : float
            The y coordinate of the origin point.

    z : float
            The z coordinate of the origin point.

    dx1 : float
            The x component of the first vector.

    dy1 : float
            The y component of the first vector.

    dz1 : float
            The z component of the first vector.

    dx2 : float
            The x component of the second vector.

    dy2 : float
            The y component of the second vector.

    dz2 : float
            The z component of the second vector.

    Returns
    -------
    object
            Returns a reference to the new working plane on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.CreateWplaneWith2Axis(10.0, 10.0, 10.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0)


    """


def CurrentDeck() -> int:
    """

    The CurrentDeck function will return the current ANSA deck.

    Returns
    -------
    int
            Returns the current ANSA deck as an integer.

    See Also
    --------
    session.DeckName, constants

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = base.CurrentDeck()

                if deck != constants.NASTRAN:
                    print("Please switch to the NASTRAN DECK.")


    """


def CurrentMenu() -> str:
    """

    Informs the user about the name of the current menu. All standard menus are supported (e.g. TOPO, TANK, NASTRAN) plus the exclussive custom menus.

    Returns
    -------
    str
            Returns the name of the current menu.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                print(base.CurrentMenu())


    """


def CurvesConnectMulti(
    curves: object, total: int, tolerance: float, angle: float, ret_ents: bool
) -> object:
    """

    This script function can merge multiple Curves in a single one in one step.
    It can connect multiple 3D-Curves provided that the Corner Angle and Nodes Matching distance are below the user specified limits.

    Parameters
    ----------
    curves : object, optional
            A curve, a connection curve, a cross curve, a list of these entities,
            a string with value 'visible' or a string with value 'all'. If it is called with
            'visible', it works with all the above visible entities. If it is called with 'all',
            it works with all the above entities.
            If nothing is passed, visible entities are taken into account.

    total : int, optional
            (Deprecated named argument. The result is not affected no matter what value is passed.
            Please do not use.)

    tolerance : float, optional
            Tolerance value for connectivity.
            If nothing is passed, HOT POINTS matching distance from settings is taken into account.

    angle : float, optional
            The angle tolerance between neighboring curves.
            (Default: 45)

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 0 on failure and 1 on success.
            If ret_ents=True, it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                mat_curves = base.CollectEntities(constants.NASTRAN, None, "CURVE")

                base.CurvesConnectMulti(curves=mat_curves, tolerance=0.05, angle=45.0)
                base.CurvesConnectMulti(curves="visible", tolerance=0.05, angle=45.0, ret_ents=True)
                base.CurvesConnectMulti(curves="all", tolerance=0.05, angle=45.0, ret_ents=True)


    """


def CurvesOffset(
    wplane: object, curve: object, x: float, y: float, z: float, offset_distance: float
) -> object:
    """

    This function takes a working plane, a curve, the coordinates of a point
    and the distance value to create a new curve in new position. The coordinates of the point are
    needed to define the direction of the offset.

    Parameters
    ----------
    wplane : object
            A reference to the working plane.

    curve : object
            A reference to the existing curve.

    x : float
            The x coordinate of the point.

    y : float
            The y coordinate of the point.

    z : float
            The z coordinate of the point.

    offset_distance : float
            The offset distance value.

    Returns
    -------
    object
            Returns a reference to the newly created curve on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curve = base.GetEntity(constants.NASTRAN, "CURVE", 1)
                wplane = base.GetEntity(constants.NASTRAN, "WPLANE", 1)
                points = base.CollectEntities(constants.NASTRAN, None, "POINT")
                dist_offset = -10

                for point in points:
                    ret = base.GetEntityCardValues(constants.NASTRAN, point, ("X", "Y", "Z"))
                    new_curve = base.CurvesOffset(
                        wplane_in, curve_in, ret["X"], ret["Y"], ret["Z"], dist_offset
                    )


    """


def CurvesProjectOnPlane(
    coordinate_system: object,
    axial_elements: object,
    produce_curves: bool,
    split_orig: bool,
    perform_topo: bool,
    new_part: bool,
    cross_section: bool,
) -> object:
    """

    A function to project curves on a plane and create the respective faces.

    Parameters
    ----------
    coordinate_system : object
            A list ([xo, yo, zo, dx1, dy1, dz1, dx2, dy2, dz2]) of doubles, representing
            the coordinate System (origin & i,j vectors) of the projection plane
            (dx3, dy3, dz3 calculated implicitly).

    axial_elements : object, optional
            A list of the entities to project (if nothing is passed,
            all visible curves are projected).

    produce_curves : bool, optional
            If set to True, curves are produced instead of faces.
            (Default: False)

    split_orig : bool, optional
            In some cases the selected entities intersect with each other on the
            Working Plane (2D space), but due to their position, they do not intersect in
            the 3D space. At the resulting face, the intersection points will always be
            created, no matter if the option is active or not, due to topological reasons.
            In order to continue and create faces between the new and the original face,
            this option also creates the intersection hot points on the first selected
            entities.
            If "produce_curves" is False, default value is True.

    perform_topo : bool, optional
            Perform topology between the created faces. The argument
            "split_orig" is also set to True, whether the user enables it or not.

    new_part : bool, optional
            If set ti True, the function will assign the entities in a Part named
            "Projection on Wrk. Plane".

    cross_section : bool, optional
            If set to True and a cross_section exists, the produced curves will
            appear as "cross_curves".

    Returns
    -------
    object
            Returns a list with the id`s of the created faces or curves on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # ----------------------------------------------
            # Example 1 -  Project all visible curves -----
            # ---------------------------------------------
            def main():
                A = (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0)  # define a projection plane
                # The argument 'axial_elements' is empty, so all visible curves will be projected on A.
                N = base.CurvesProjectOnPlane(A)


            # -------------------------------------------
            # Example 2 -  Project specific curves -----
            # ------------------------------------------
            def main():
                A = (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0)
                B = list()
                B.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 171))
                B.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 172))
                B.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 173))
                B.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 174))
                B.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 175))
                C = base.CurvesProjectOnPlane(A, B)


            def main():
                arg1 = (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0)
                arg2 = []
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 13))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 22))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 171))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 172))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "MORPHEDGE", 13))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "CBAR", 1188))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "CBEAM", 595))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "CBEAM", 593))
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "PLOTEL", 594))
                ansa.base.CurvesProjectOnPlane(arg1, arg2, produce_curves=True)


    """


def CutModelByPlanes(
    deck: int,
    cutting_planes: object,
    apply_on: str,
    create_on_bounds: str,
    delete_unconnected: str,
    step_id: int,
    create_node_set: int,
    dofs: int,
    reconstruct_bounds: bool,
    put_in_set: bool,
    ret_ents: bool,
) -> object:
    """

    Script function to cut a model by using cutting planes. Optionally, the user can create
    entities on the boundary of the cut.

    Parameters
    ----------
    deck : int
            The deck.

    cutting_planes : object
            A list containing the CUTTING PLANEs to be used for the cut.

    apply_on : str, optional
            Accepted values: 'visible' or 'database'. Decide whether the cut
            will be applied on the entire database or only on visible elements.

    create_on_bounds : str, optional
            Define entities to be created on the boundary of the cut.
            'spc', 'rbe2', 'rbe3', 'rbe2_and_mass', 'rbe3_and_mass'
            (valid only for NASTRAN and LSDYNA)

    delete_unconnected : str, optional
            Accepted values: 'yes' or 'no' or 'yes_exclude_box'. Decide
            whether elements that remain unconnected after the cut will be
            deleted or not, or only the exterior ones of the cutting box.

    step_id : int, optional

    create_node_set : int, optional

    dofs : int, optional

    reconstruct_bounds : bool, optional

    put_in_set : bool, optional

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 0 on success or 1 otherwise.
            If ret_ents=True it will return a list with the created entities or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cutting_plane = (base.GetEntity(constants.NASTRAN, "CUTTING PLANE", 1),)
                base.CutModelByPlanes(
                    constants.NASTRAN,
                    apply_on="visible",
                    create_on_bounds="rbe2",
                    delete_unconnected="yes",
                    cutting_planes=cutting_plane,
                )


    """


def Dach(rad1: float, rad2: float, len1: float, len2: float, tanfromnear: int) -> int:
    """

    Replaces a series of fillets with the corresponding tangent surfaces.

    Parameters
    ----------
    rad1 : float
            :ower bound for radius.

    rad2 : float
            Upper bound for radius.

    len1 : float
            Lower bound for length.

    len2 : float
            Upper bound for length.

    tanfromnear : int
            0: use tangents from fillets.
            1: use tangents from neighbors.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Dach(5, 10, 10, 20, 1)


    """


def DataBaseName() -> str:
    """

    This function returns the full path to the current Ansa DataBase.

    Returns
    -------
    str
            Always returns a valid string. If its length is 0 then the filename is not set.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                print(base.DataBaseName())


    """


def DefineRBE3WithFacets(
    master_faces: object,
    slave_faces: object,
    search_distance: float,
    diameter: float,
    ret_ents: bool,
) -> object:
    """

    DefineRBE3WithFacets creates RBE3s using the nodes of the master entities MASTER and the slave entities SLAVE,
    using the search distance search_dist and the diameter diam. The created RBE3s will be assigned to the current part.

    Parameters
    ----------
    master_faces : object
            A list with master entities. They can be shells, solid facets, or nodes.

    slave_faces : object
            A list with slave entities. They can be shells or solid facets.

    search_distance : float
            The search distance.

    diameter : float
            The search radius.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Always returns 1.
            If ret_ents=True, it will return a list with the created entities or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                master_prop = base.GetEntity(ansa.constants.NASTRAN, "PSHELL", 2)
                slave_prop = base.GetEntity(ansa.constants.NASTRAN, "PSHELL", 6)
                master = base.CollectEntities(
                    ansa.constants.NASTRAN, master_prop, "SHELL", recursive=True
                )
                slave = base.CollectEntities(
                    ansa.constants.NASTRAN, slave_prop, "SHELL", recursive=True
                )
                base.DefineRBE3WithFacets(master, slave, 8.1, 1.0)


    """


def DefineVolumeFrom(pid: int, part_name: str) -> int:
    """

    This function is used for the definition of closed volumes. The volumes may be bounded
    by Macro Areas of FE-Model shell elements.

    Parameters
    ----------
    pid : int
            The pid value.

    part_name : str
            The name of the newly created ANSAPart.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.DefineVolumeFrom(1, "new_part")


    """


def DeleteCurves(entities: object, delete_connections: bool) -> int:
    """

    Deletes the curves in the database, depending on the optional arguments.

    Parameters
    ----------
    entities : object, optional
            A curve, a connection curve, a cross curve, a list of these entities,
            a string with value 'visible' or a string with value 'all' . If it is called
            with 'visible', it works with all the above visible entities. If it is called
            with 'all', it works with all the above entities.
            If nothind is defined, the function will delete all the curves.

    delete_connections : bool, optional
            If True, deletes the connection curves.
            (Default: False)

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # 1. Delete all the curves in a database, regardless of their visibility:
            def _DeleteCurves():
                base.DeleteCurves()


            # 2. Delete an array of curves, while deleting flag for connections is True:
            def _DeleteCurves():
                curves = []
                curves.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 421))
                curves.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 420))
                curves.append(base.GetEntity(ansa.constants.NASTRAN, "CONNECTION_CURVE", 354))
                curves.append(base.GetEntity(ansa.constants.NASTRAN, "CONNECTION_CURVE", 352))
                ansa.base.DeleteCurves(curves, True)


            # 3. Delete all the curves:
            def _DeleteCurves():
                ansa.base.DeleteCurves("all", True)


            # 4. Delete all the visible curves:
            def _DeleteCurves():
                ansa.base.DeleteCurves("visible", False)


    """


def DeleteEntity(
    entities: Entity | Iterable, force: bool = False, compress: bool = True
) -> int:
    """

    Delete an entity or a list of entities.

    Parameters
    ----------
    entities : Entity | Iterable
            An entity or a list of entities to be deleted.

    force : bool, optional
            If set to True, the function will delete the entities, along
            with any reference to these entities.

    compress : bool, optional
            If set to False, unused Nodes and Properties from the deleted
            entities will not be deleted.
            (Default: True)

    Returns
    -------
    int
            Returns 0 if all elements were deleted, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                to_del = []
                ents = base.CollectEntities(constants.NASTRAN, None, "PSHELL")
                for ent in ents:
                    to_del.append(ent)
                base.DeleteEntity(to_del, True)


    """


def DeleteFaces(entities: object, filter_visible: bool, convert_links: bool) -> int:
    """

    This function deletes the faces in a base.

    Parameters
    ----------
    entities : object, optional
            A list of faces to be deleted. This list can contain faces, parts,
            PIDs ot sets. If a faces list isn't provided or it is None, then the
            faces are collected from the entire database.

    filter_visible : bool, optional
            If True, the provided faces are filtered and only the visible ones are deleted.
            (Default: False)

    convert_links : bool, optional
            If True , parent faces will be deleted, while linked faces will be converted
            to geometry, else all provided faces will be deleted.
            (Default: False)

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # 1. Delete all the faces in a database, regardless of their visibility:
            def main():
                base.DeleteFaces()


            # 2. Delete all the visible faces in a database:
            def main():
                base.DeleteFaces(None, True)


            # 3. Delete an array of faces with id between 1 - 100, regardless of their visibility:
            def main():
                m = list()
                for i in range(1, 101):
                    m.append(base.GetEntity(constants.NASTRAN, "FACE", i))
                base.DeleteFaces(m)


            # 4. Delete all visible faces in a part:
            def main():
                part = base.GetPartFromModuleId("1")
                base.DeleteFaces(part, True)


            # 5. Delete an array of faces with linked children faces, converting them to geometry.
            def main():
                face_list = []
                face_list.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 1))
                face_list.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 10))
                base.DeleteFaces(face_list, convert_links=True)


    """


def DeleteMetricFile(control: object, filename: str) -> int:
    """

    Deletes a Metric File from a control.

    Parameters
    ----------
    control : object
            A reference to the selected control.

    filename : str
            The path to the file to be deleted.

    Returns
    -------
    int
            Returns 0 if the file is successfully deleted, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pcontrol = base.GetEntity(constants.PAMCRASH, "CTRL", 1)
                if pcontrol:
                    delete = base.DeleteMetricFile(pcontrol, "/tmp/bagin_metricfile")
                    if not delete:
                        print("File has been deleted!")


    """


def DeleteNumberingRules(rules: object) -> int:
    """

    This function deletes numbering rules. All existing rules if no argument is defined, selected rules otherwise.

    Parameters
    ----------
    rules : object, optional
            A list of references to numbering rules to be deleted.

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.DeleteNumberingRules()


    """


def DeletePart(
    parts: object,
    entities: bool,
    hierarchy: bool,
    follow_links: bool,
    connections: str,
    connectors: str,
    titems: str,
    bconditions: str,
    orequests: str,
    setbuilders: str,
    generalbuilders: str,
    dpatches: str,
    resmap: str,
) -> int:
    """

    This function deletes one or more parts contained in a list, according to a series of arguments.

    Parameters
    ----------
    parts : object
            A list of part entities.

    entities : bool, optional
            Determines whether the parts' entities should be deleted or not.
            (Default: False)

    hierarchy : bool, optional
            Determines whether the full hierarchy upwards should be deleted or not.
            (Default: False)

    follow_links : bool, optional
            Determines whether linked parts will be deleted or not.
            (Default: False)

    connections : str, optional
            Determines whether internal and external connections should be deleted or
            not. Supported values are "INTERNAL", to include internal connections,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exlude all connections. By default the "EXCLUDE" option is assumed.

    connectors : str, optional
            Determines whether internal and external connectors should be deleted or
            not. Supported values are "INTERNAL", to include internal connectors,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exlude all connectors.
            (Default: "EXCLUDE")

    titems : str, optional
            Determines whether internal and external trim items should be deleted or
            not. Supported values are "INTERNAL", to include internal trim items,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exclude all trim items.
            (Default: "EXCLUDE")

    bconditions : str, optional
            Determines whether internal and external Boundary Conditions should
            be deleted or not. Supported values are "INTERNAL", to include internal
            Boundary Conditions, "ALL AFFECTED", to include internal and external ones,
            and "EXCLUDE" to exlude all Boundary Conditions.
            (Default: "EXCLUDE")

    orequests : str, optional
            Determines whether internal and external Output Requests should be
            deleted or not. Supported values are "INTERNAL", to include internal
            Output Requests, "ALL AFFECTED", to include internal and external ones,
            and "EXCLUDE" to exlude all Output Requests.
            (Default: "EXCLUDE")

    setbuilders : str, optional
            Determines whether internal and external setbuilders should be deleted or
            not. Supported values are "INTERNAL", to include internal setbuilders,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exclude all setbuilders.
            (Default: "EXCLUDE")

    generalbuilders : str, optional
            Determines whether internal and external generalbuilders should be deleted or
            not. Supported values are "INTERNAL", to include internal generalbuilders,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exclude all generalbuilders.
            (Default: "EXCLUDE")

    dpatches : str, optional
            Determines whether included Damping Patches should be
            deleted or not. Supported values are "INTERNAL", to include and
            "EXCLUDE" to exlude Damping Patches.
            (Default: "EXCLUDE")

    resmap : str, optional
            Determines whether included resmap should be
            deleted or not. Supported values are "INTERNAL", to include and
             EXCLUDE" to exclude resmap.
            (Default: "EXCLUDE")

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))

                base.DeletePart(
                    parts,  # Array with parts to be deleted
                    entities=True,  # Delete the parts' entities
                    hierarchy=True,  # Delete also each part's parents, if empty
                    follow_links=False,  # Do NOT delete linked parts of selected parts
                    connections="INCLUDE",  # Delete internal Connections
                    connectors="ALL AFFECTED",  # Delete all affected connectors
                    bconditions="ALL AFFECTED",  # Delete also internal Boundary Conditions
                    orequests="EXCLUDE",  # Do not delete any Output Requests
                    dpatches="INTERNAL",
                )  # Delete included Damping Patches as well


    """


def DeleteVisibleHotPoints() -> int:
    """

    This function deletes all visible hot points from the screen in a similar way to when they are selected with box selection and deleted.

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.DeleteVisibleHotPoints()


    """


def DestroyAnsaModel(model: Entity) -> int:
    """

    This function destroys an ansa model.

    Parameters
    ----------
    model : Entity
            The ansa model object to be deleted.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                old_model = (
                    base.GetCurrentAnsaModel()
                )  # Request for the current model instance. It will set current again at the end of all actions
                new_model = base.CreateNewAnsaModel()  # Create a new model instance
                base.SetCurrentAnsaModel(new_model)  # Set the new model as current
                utils.Merge(
                    "C:/temp/users/folder/new_data1.ansa"
                )  # In the new model merge a ansa database
                utils.Merge("C:/temp/users/folder/new_data1.ansa")  # Merge a second database
                base.SaveAs(
                    "C:/temp/users/folder/merge_dbs.ansa"
                )  # Save current model in a new database
                base.DestroyAnsaModel(old_model)  # Destroy "the old_model"


    """


def DetectSolidDescription(
    faces: object,
    thickness: float,
    return_percentage: bool,
    estimate_thickness: bool,
    separate_connectivity: bool,
    separate_connectivity_stop_at_pid_bound: bool,
    fix_unchecked_faces: bool,
    estimate_thickness_num_decimals: int,
) -> object:
    """

    Checks if the input entities are a middle surface or a 3D body.

    Parameters
    ----------
    faces : object
            A list of faces, parts, properties or sets.
            If 0 is specified, then the function works on
            all visible faces.

    thickness : float, optional
            The approximate thickness for thin walled solid
            description detection.
            (Default: 0)

    return_percentage : bool, optional
            If True, then a list with 3 percentage values
            (0 <= percentage val <= 1) is returned:
            position 0: shell description.
            position 1: thin solid description. Filled only
            when thickness is provided, else it is set to 0.
            position 2: solid description. If thickness is
            provided, this percentage represents the area of
            the part where distance > thickness.
            (Default: False)

    estimate_thickness : bool, optional
            If True, the function provides a thickness estimation.
            If thickness is provided, but percentages are not
            requested, then areas with distance > thickness
            are not considered as solid description.
            (Default: False)

    separate_connectivity : bool, optional
            If True, input ents are separated in connectivity groups
            and each connectivity group is examined separately.
            (Default: False)

    separate_connectivity_stop_at_pid_bound : bool, optional
            This option is considered only if
            separate_connectivity == True. If set to True, then
            connectivity groups are separated per PID.
            (Default: False)

    fix_unchecked_faces : bool, optional
            Results are more accurate if unchecked faces are fixed.
            If this has been done before or the user just wishes to
            skip it then set to False.
            (Default: True)

    estimate_thickness_num_decimals : int, optional
            The option controls the number of decimal digits to be kept in the thickness estimation results. It is considered only if estimate_thickness = True. (Default: 1)

    Returns
    -------
    object
            If return_percentage=True:
            Returns a list with 3 percentage values.

            If estimate_thickness=True:
            Returns a list with dicts. Each dict corresponds to one connectivity group. If separation in connectivities is disabled, then the list contains always 1 dict. Each dict has the estimated thickness value as key and its corresponding percentage as data.

            If return_percentage=False, estimate_thickness=False:
            Returns an integer. It is equal to 1 if the input is Solid Description and to 0 otherwise.

            The estimated thickness value is a non negative float for Solid Description input or
            -1 if the thickness fails to be estimated (eg. the input is not Solid Description).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # Example 1:
            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE", False)
                is_solid_description = base.DetectSolidDescription(faces)

                print("is_solid_description::", is_solid_description)


            # Example 2:
            def main():
                part1 = base.GetPartFromModuleId("1")
                percentages = base.DetectSolidDescription(
                    part1, thickness=1.2, return_percentage=True
                )

                print("shell::", percentages[0], "%")
                print("thin solid (dist <= 1.2)::", percentages[1], "%")
                print("solid (dist > 1.2)::", percentages[2], "%")


            # Example 3:
            def main():
                part1 = base.GetPartFromModuleId("1")
                thickness = base.DetectSolidDescription(
                    part1,
                    estimate_thickness=True,
                    separate_connectivity=True,
                    separate_connectivity_stop_at_pid_bound=True,
                )
                print("number of connectivity groups::", len(thickess_range_list))

                for i in range(0, len(thickess_range_list)):
                    print("current connectivity group:: ", i + 1)
                    connectivity_group_thickness_vals = thickess_range_list[i]
                    for thickness_val in connectivity_group_thickness_vals:
                        print(
                            " thickness val:: ",
                            thickness_val,
                            " percentage ",
                            connectivity_group_thickness_vals[thickness_val],
                        )


    """


def DisplayModelShells(
    entities: object,
    connectivity_area_limit: float,
    target_length: float,
    defeaturing_length: float,
    feature_line_angle: float,
    fill_hole_diameter: float,
    exclude_holes_with_hard_points: bool,
    freeze_hard_points: bool,
    hard_points_are_grids_with_name: bool,
    hard_points_are_grids_with_field10: bool,
    respect_pid_bounds: bool,
    add_existing_plotels_to_set: bool,
    create_plotels_in_all_1d_elements: bool,
    hard_points_are_alc_points: bool,
    hard_points_are_grids_from_sets: bool,
    hard_points_sets: object,
    convert_shells_to_plotels: bool,
    output_element_type: str,
    create_display_element: bool,
    alc_points: object,
    coarsen_mesh_based_on: str,
    target_nodes_num: int,
    max_nodes_num: int,
    min_length: float,
    max_length: float,
) -> object:
    """

    This function can be used to create a compact display model consisting of shells/plotels/segments from the shell and facet elements of a larger model.

    Parameters
    ----------
    entities : object, optional
            Accepted values are a list of properties, parts, macros, volumes, fe shells, fe solids or a Subsystem, Include, Set, or 'visible'. If the selected entity is a Subsystem, an Include or Set, then the Display Model is created only on the entities of the selected entity.

    connectivity_area_limit : float, optional
            Ignores parts with area smaller than value.

    target_length : float, optional
            Target element length of the output mesh.

    defeaturing_length : float, optional
            Minimum distance between feature lines.
            Deprecated argument.
            Setting in will no affect the result.

    feature_line_angle : float, optional
            Angle degrees required for the feature line definition.
            Deprecated argument.
            Setting in will no affect the result.

    fill_hole_diameter : float, optional
            Maximum diameter that will be filled.

    exclude_holes_with_hard_points : bool, optional
            Holes with hard points are excluded from fill.

    freeze_hard_points : bool, optional
            Hard points are kept to output mesh (hard points are defined by other parameters in this function).

    hard_points_are_grids_with_name : bool, optional
            Named grids are considered hard points.

    hard_points_are_grids_with_field10 : bool, optional
            Grids with field 10 are considered hard points.

    respect_pid_bounds : bool, optional
            Each property creates its own output mesh.

    add_existing_plotels_to_set : bool, optional
            Adds existing visible plotel elements to set
            (that DISP.MOD. produces).

    create_plotels_in_all_1d_elements : bool, optional
            Creates plotel elements to visible 1-d elements.

    hard_points_are_alc_points : bool, optional
            A/LC points are considered hard points.

    hard_points_are_grids_from_sets : bool, optional
            Points from sets are considered hard points.

    hard_points_sets : object, optional
            List with set entities.

    convert_shells_to_plotels : bool, optional
            Convert display model output to plotels. In case both
            convert_shells_to_plotels and output_element_type
            are used, convert_shells_to_plotels is ignored.

    output_element_type : str, optional
            Sets the element type of the display model output
            (accepted values: 'shell', 'plotel', 'segment').
            In case both convert_shells_to_plotels and output_element_type
            are used, convert_shells_to_plotels is ignored.

    create_display_element : bool, optional
            Create (and return) a Display Model entity instead of a SET.

    alc_points : object, optional
            Can be a list of A/LC points. Accepted values are a list of A/LC points or 'all'. In case a display model is requested for a subsystem value is ignored and the A/LC points used are the ones that belong to the subsystem.

    coarsen_mesh_based_on : str, optional
            Set criterion with which display model shells will be created.
            It can be one of the following:
            - 'element_size'
            - 'nodes_number_uniform_length'
            - 'nodes_number_proportional_length'
            Default value: 'element_size'

    target_nodes_num : int, optional
            Set the desired number of nodes.
            It should be specified only if coarsen_mesh_based_on is equal
            to 'nodes_number_uniform_length' or 'nodes_number_proportional_length'.

    max_nodes_num : int, optional
            Set upper limit for number of nodes. It can be specified only
            if coarsen_mesh_based_on is equal to 'element_size'.

    min_length : float, optional
            Set lower limit for length. It can be specified only if
            coarsen_mesh_based_on is equal to
            'nodes_number_uniform_length' or 'nodes_number_proportional_length'.

    max_length : float, optional
            Set upper limit for length. It can be specified only if
            coarsen_mesh_based_on is equal to
            'nodes_number_uniform_length' or 'nodes_number_proportional_length'.

    Returns
    -------
    object
            Returns either the set with output mesh or the Display Model entity (if option create_display_element=True) on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = (
                    base.GetEntity(constants.NASTRAN, "PSOLID", 1),
                    base.GetPartFromModuleId("102"),
                )
                sets_for_display_model = []
                p_set = base.DisplayModelShells(
                    props,
                    40,
                    8,
                    3,
                    40,
                    5,
                    True,
                    False,
                    False,
                    False,
                    False,
                    True,
                    True,
                    False,
                    False,
                    sets_for_display_model,
                    "plotel",
                    False,
                    "all",
                )


            def main():
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                display_entity = base.DisplayModelShells(shells, create_display_element=True)


            def main():
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                display_entity = base.DisplayModelShells(
                    shells,
                    coarsen_mesh_based_on="element_size",
                    target_length=20,
                    max_nodes_num=5000,
                    create_display_element=True,
                )


            def main():
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                display_entity = base.DisplayModelShells(
                    shells,
                    coarsen_mesh_based_on="nodes_number_proportional_length",
                    target_nodes_num=10000,
                    min_length=5,
                    max_length=20,
                    create_display_element=True,
                )


    """


def Divide(rad1: float, rad2: float, len1: float, len2: float) -> int:
    """

    Splits a series of fillets in the middle.

    Parameters
    ----------
    rad1 : float
            Lower bound for radius.

    rad2 : float
            Upper bound for radius.

    len1 : float
            Lower bound for length.

    len2 : float
            Upper bound for length.

    Returns
    -------
    int
            It returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Divide(5, 10, 8, 15)


    """


def DoesRepresentationBelongInDM(
    entity: object, representation: str, deck: int
) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`DoesRepresentationExist` instead.


    The functions checks if the given representation exists in DM for one or more parts or includes.

    Parameters
    ----------
    entity : object
            May either be one ANSA Part or Include, or a list containing
            multiple Parts/Includes.

    representation : str
            A string describing a potential representation name.

    deck : int, optional
            A reference to a deck, in case that entity is Include.

    Returns
    -------
    object
            When the input to the function is one entity:
                    The function returns 1 if a representation file by the name of repr_name exists.
                    In case that PART is not a valid part or a file by the name repr_name does not exist, 0 is returned.
            When a list with entities is given as input:
                    The function returns a dictionary with the entity as the key and the return value as the value.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # in case of Part
                parts = [base.GetPartFromModuleId("607001"), base.GetPartFromModuleId("607002")]
                ret = base.DoesRepresentationBelongInDM(parts[0], "FrontImpact")
                print(ret)


            # ...or...


            def main():
                # in case of Include
                includes = base.CollectEntities(constants.NASTRAN, None, "INCLUDE")
                ret = base.DoesRepresentationBelongInDM(
                    includes[0], "FrontImpact", constants.NASTRAN
                )
                print(ret)


            # ...or...


            def main():
                # in case of multiple parts
                parts = [base.GetPartFromModuleId("607001"), base.GetPartFromModuleId("607002")]
                ret = base.DoesRepresentationBelongInDM(parts, "FrontImpact")
                print(ret)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: DoesRepresentationExist instead.",
        DeprecationWarning,
    )


def DownloadPartsFromDM(
    part: object,
    property_conflicts: str,
    material_conflicts: str,
    set_conflicts: str,
    coord_conflicts: str,
    node_conflicts: str,
) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`DownloadEntities` instead.


    This function may only be used along with CheckDMUpdates function.

    Parameters
    ----------
    part : object
            A part that contains DM Items which were output from the CheckDMUpdates()
            function, in the same way they were given in the output array. Otherwise,
            they may be collected from the database and given in a matrix.

    property_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    material_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    set_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    coord_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    node_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    Returns
    -------
    int
            Returns the total number of parts that were actually downloaded from DM.

    See Also
    --------
    CheckDMUpdates

    Examples
    --------
    ::

            import ansa
            from ansa import base


            # A) If the user first wants to collect the updates from DM:
            def main():
                search = ("ANSAPART",)
                all_parts = base.CollectEntities(0, None, search)
                print(len(all_parts))
                check_dm_updates_data = {"newer_file": True}

                ret = base.CheckDMUpdates(all_parts, check_dm_updates_data)
                print(len(ret["output"]))

                print(base.DownloadPartsFromDM(ret["output"]))


            # B) If the user wants to collect the found updates from the database:
            def main():
                search = ("A_DM_ITEM",)
                all_items = base.CollectEntities(0, None, search, True)

                base.DownloadPartsFromDM(all_items)


            # C) In the case of optional arguments:
            def main():
                search = ("A_DM_ITEM",)
                all_items = base.CollectEntities(0, None, search, True)
                base.DownloadPartsFromDM(
                    all_items,
                    property_conflicts="KeepOld",
                    material_conflicts="KeepNew",
                    set_conflicts="Offset",
                )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: DownloadEntities instead.",
        DeprecationWarning,
    )


def DrawCurves(vsb_flag: int) -> int:
    """

    This function enables/disables the curves visibility flag.

    Parameters
    ----------
    vsb_flag : int
            1: Enable the curves visibility flag.
            0: Disable the curves visibility flag.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = base.DrawCurves(1)  # will turn curves visibility flag on


    """


def EditEntity(deck: int, entity: object, location: str, read_only: bool) -> int:
    """

    Edit an entity using the edit card's graphics interface. By executing this function,
    the edit card of the specified entity for the current deck pops up.
    If the entity is not visible in the current deck, then no card appears.

    Parameters
    ----------
    deck : int
            The deck constant.

    entity : object
            A reference to the entity.

    location : str, optional
            The location of a "Material Database".

    read_only : bool, optional
            Opens the Edit Card in read only mode.

    Returns
    -------
    int
            Returns 0 if OK is pressed and 1 if CANCEL is pressed.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "PSHELL", 15)
                base.EditEntity(constants.NASTRAN, ent)


    """


def EditPLMXMLTree(xml_fname: str, dl_list_fname: str) -> int:
    """

    Parameters
    ----------
    xml_fname : str
            The path to the xml file or to the CATProduct.

    dl_list_fname : str
            The file path to output the D/L List.

    Returns
    -------
    int
            Returns:
            0, if the xml file is invalid.
            1, if the user exited the editor by pressing the 'OK' button.
            2, if the user exited the editor by pressing the 'Cancel' button.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.EditPLMXMLTree("/home/demo/Hierarchy.xml", "DownloadList.txt")


    """


def EditProductTree(tree: object, dl_list_fname: str) -> int:
    """

    Launches the product tree interface.

    Parameters
    ----------
    tree : object
            The tree is the object returned from a previous call to 'NewProductTree' function.

    dl_list_fname : str
            The filepath to output the D/L List.

    Returns
    -------
    int
            Returns:
            -1, if the interface failed to open.
            1, if the user exited the interface by pressing the 'OK' button.
            2, if the user exited the interface by pressing the 'Cancel' or the 'ESC' button.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create the product tree
                tree = base.NewProductTree()

                # Create a group
                pos_matrix_group = ((1, 0, 0), (0, 1, 0), (0, 0, 1), (0, 0, 1))
                parent_identifier = 0  # no parent for the top level group
                child_identifier = 1
                base.NewPTPart(tree, "group", "MID A", "Version A", "Top Level Group", 0)
                base.NewPTInstance(
                    tree, child_identifier, "group", parent_identifier, pos_matrix_group
                )

                # Create a part
                pos_matrix_part = ((1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
                parent_identifier = child_identifier  # the part belongs to the previous group
                child_identifier += 1
                part_attr = (("Mesh Type", "Fine"), ("Target Mass", "1.5"))
                part_file_attr = (
                    ("PID", 1000),
                    ("Property Name", "Front Part"),
                    ("Material", "ES200"),
                )
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "Part MI", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part
                )
                base.NewPTModel(tree, "part1", "/home/demo/FrontPart.CATPart", part_file_attr, 0)

                # Create an instance to the previously created part
                pos_matrix_instance = ((1, 0, 0, 0), (0, -1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
                child_identifier += 1
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_instance
                )
                # Add a PID offset of 100 to the new instance
                base.SetPTInstancePidOffset(tree, child_identifier, 100)

                # Create a new tailorblanked part
                pos_matrix_part = ((1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
                child_identifier += 1
                part_attr = (("Mesh Type", "Fine"), ("Target Mass", "3.4"))
                part_file_attr = (
                    ("PID", 2000),
                    ("Property Name", "Front TB Part"),
                    ("Material", "ES220"),
                )
                base.NewPTPart(tree, "part2", "MID 2", "Version AB", "Part TB", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part2", parent_identifier, pos_matrix_part
                )
                # Add the first CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/FrontTBPart.CATPart", part_file_attr, 0)

                part_file_attr = (
                    ("PID", 2001),
                    ("Property Name", "Rear TB Part"),
                    ("Material", "ES200"),
                )
                # Add the second CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/RearTBPart.CATPart", part_file_attr, 0)

                # Launch the editor. Selecting items in the "Part List" tab, pressing "Include" and
                # then "Export D/L list" will save a download list at /home/irene/dl_list.txt
                res = base.EditProductTree(tree, "/home/irene/dl_list.txt")

                # res = 1: OK was pressed in the Product Tree Editor
                # res = 2: Cancel was pressed in the Product Tree Editor


    """


def EditVpmTree(vpm_fname: str, dl_list_fname: str) -> int:
    """

    Parameters
    ----------
    vpm_fname : str
            The path to the vpm file or to the CATProduct.

    dl_list_fname : str
            The file path to output the D/L List.

    Returns
    -------
    int
            Returns:
            0, if the vpm file is invalid.
            1, if the user exited the editor by pressing the 'OK' button.
            2. if the user exited the editor by pressing the 'Cancel' button.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vpm_fname = "/home/demo/hierarchy.xml"
                dl_list_fname = "DownloadList.txt"
                base.EditVpmTree(vpm_fname, dl_list_fname)


    """


def ElementQuality(entity: object, quality_criteria: object) -> object:
    """

    Requests and gets the quality criteria of an element, with the options specified in
    the "Presentation Parameters" window.

    Parameters
    ----------
    entity : object
            Can be either Shell, Solid, Bar or Rod.

    quality_criteria : object
            A name (string) or a list which contains the names of the Quality criteria as these
            are reported in the ANSA TEXT window when applying ELEMENTS>INFO on an entity.

    Returns
    -------
    object
            Returns a list containing the entity's quality criteria that were requested in the
            respective quality_criteria_names list position.
            If the specified entity doesn't exist, 0 is returned.
            If a specified quality criterion is not defined for the entity, "error" is
            returned in the respective position.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                qual_n = ("SKEW", "CRASH")

                ent = base.GetEntity(constants.NASTRAN, "SHELL", 1)
                qual = base.ElementQuality(ent, qual_n)

                length = len(qual)
                for i in range(length):
                    print(qual_n[i] + " ", qual[i])
                warp = base.ElementQuality(ent, "WARP")
                print("WARP" + " ", warp)


    """


def ElementsOffset(
    shells: object,
    option: str,
    offset: float,
    pid_offset: int,
    part: object,
    pid_specific: int,
    sharp_edges_limit_angle: float,
    distance_mode: str,
    set: object,
    expand_existing_set: bool,
) -> int:
    """

    This function offsets (copies/moves) shell elements or facets by means of their normal vector.

    Parameters
    ----------
    shells : object
            List with shells or facets to be offset.

    option : str
            Can either be "Copy" or "Move" and determines whether
            the shells are to be copied or moved to their new position.

    offset : float
            Defines the offset distance.

    pid_offset : int, optional
            The property id which will be assigned to the new shells will be offset
            by this value. By default, they keep the original property.
            "pid_offset" and "pid_specific" are mutually exclusive.

    part : object, optional
            The new shells will be placed in the given part. If no
            part is specified, they will go to the current part.

    pid_specific : int, optional
            The property id which will be assigned to the new shells.
            "pid_offset" and "pid_specific" are mutually exclusive.

    sharp_edges_limit_angle : float, optional
            The angle that limits the movement of nodes on sharp edges.

    distance_mode : str, optional
            Can either be "Absolute" or "Thickness" and determines the mode
            by which the "distance_offset" will be applied.

    set : object, optional
            The set that the offset result shells will be added to.

    expand_existing_set : bool, optional
            Expands existing set to the new shells.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                search = ("SHELL",)
                all_shells = base.CollectEntities(0, None, search)
                search = ("ANSAPART",)
                all_parts = base.CollectEntities(0, None, search)

                ret_val = base.ElementsOffset(
                    all_shells,
                    "Copy",
                    20.0,
                    pid_offset=10,
                    part=all_parts[0],
                    expand_existing_set=True,
                )
                print("ElementsOffset returned: ", str(ret_val))


            def main():
                set = base.GetEntity(ansa.constants.NASTRAN, "SET", 1)
                facets = base.CollectEntities(constants.NASTRAN, set, "SOLIDFACET", recursive=True)

                ret_val = base.ElementsOffset(facets, "Copy", 3.0, pid_offset=10)
                print("ElementsOffset returned: ", str(ret_val))


    """


def EmptyInclude(include: object) -> int:
    """

    Deletes all entities contained in include. If an entity cannot be deleted (is used) then it is set as undefined and moved out of includes. If an entity is used and does not support undefined flag then it cannot be moved or deleted and EmptyInclude is considered unsuccessful

    Parameters
    ----------
    include : object
            The include entity to be emptied.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)
                if base.EmptyInclude(entity):
                    print("Operation Unsuccessful, some entities can not be deleted!!")


    """


def CurvesFromEntities(entities: list | str, connect_curves: list) -> list:
    """

    This script function defines 3D-curves from input FACEs, CONS, shell/solid edges, Connection Lines, Linear Elements etc.

    Parameters
    ----------
    entities : list | str, optional
            This is a list with FACEs, CONS, Connection lines, line elements, SHELLs, SOLIDs etc.
            Also accepts a string with value 'visible' or a string with value 'all' .
            If it is called with 'visible', it works with all the visible entities concerning the
            above types . If it is called with 'all', it works with all the entities.
            If nothing is passed it works with the visible.

    connect_curves : list, optional
            A list with two float variables defining nodes matching distance in the first place
            and angle in the second respectively. If list is given. then script function will
            merge the created curves, according to the input values, else curves per
            segment will be created.

    Returns
    -------
    list
            Returns a list with the created curves on success, otherwise an empty list on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ents = []
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 338))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 371))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 367))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "MORPHEDGE", 11))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 2))
                connect_curves = []
                connect_curves.append(0.05)
                connect_curves.append(45)
                ret = ansa.base.CurvesFromEntities(ents, connect_curves)
                # ret = ansa.base.CurvesFromEntities()


    """


def EraseConnectorsFeRep(entities: object) -> int:
    """

    This function erases the FE Representation of the corresponding Connector entity or
    all the Connector entities contained in a list.

    Parameters
    ----------
    entities : object
            The connector entities contained in a list.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, or 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # In case of single connector
                connector = base.GetEntity(constants.NASTRAN, "CONNECTOR_ENTITY", 1)
                ret_val = base.EraseConnectorsFeRep(connector)
                print(ret_val)

                # In case of a list of connector entities
                all_connectors = base.CollectEntities(constants.NASTRAN, None, "CONNECTOR_ENTITY")
                ret_val = base.EraseConnectorsFeRep(all_connectors)
                print(ret_val)


    """


def EraseGenericEntitiesFeRep(entities: object) -> int:
    """

    This function erases the FE Representation of the corresponding generic entity or all the generic entities
    contained in a list.

    Parameters
    ----------
    entities : object
            An object or a list of Generic Entity objects.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, or 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                connector = base.GetEntity(constants.NASTRAN, "GEB_BC", 1)
                ret_val = base.EraseGenericEntitiesFeRep(connector)
                print(ret_val)


            # or for a list...


            def main():
                geb_types = ("GEB_BC", "GEB_GN", "GEB_MT", "GEB_OR", "GEB_SB")
                all_gebs = base.CollectEntities(constants.NASTRAN, None, geb_types)
                ret_val = base.EraseGenericEntitiesFeRep(all_gebs)
                print(ret_val)


    """


def EvaluateCurvePoint(CURVE: object, U: float) -> object:
    """

    The function returns the coordinates in a specific distance on a 3D curve.

    Parameters
    ----------
    CURVE : object
            A reference to the curve entity.

    U : float
            The distance of the requested coordinates, from the curve's start point.
            Valid values are between 0 and 1.

    Returns
    -------
    object
            The function returns a list containing the XYZ coordinates requested in
            the global coordinate system. In case an error occurs, 0 will be returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_curve = base.GetEntity(constants.NASTRAN, "CURVE", 10)
                xyz_coords = base.EvaluateCurvePoint(p_curve, 0.6)
                if xyz_coords:
                    print("Requested coordinates:")
                    print("X = ", str(xyz_coords[0]))
                    print("Y = ", str(xyz_coords[1]))
                    print("Z = ", str(xyz_coords[2]))


    """


def F11GraphParamsOptionsSet(
    criterion_name: str,
    criterion_status: Any,
    criterion_min_value: Any,
    criterion_max_value: Any,
    number_of_colors: int,
) -> int:
    """

    This function enables/disables/changes the corresponding visibility flag/pulldown menus
    and values, in the "Graph Parameters" tab of the F11 window.

    Parameters
    ----------
    criterion_name : str
            The criterion name of the F11 window to enable, disable or change. Available values:
            'Use Shell's nodes', 'Use Shell's middle point', 'Show draw mode label', 'Show extra colors', 'Invert colors', 'Color bar limits', 'Color bar range', 'Number of colors', 'Quality graph by', 'No value color', 'Edit colors'

    criterion_status : Any
            This argument holds the value that the selected criterion will acquire.
            If the criterion_name is 'Use Shell's nodes', 'Use Shell's middle point', 'Show draw mode label', 'Show extra colors' or 'Invert colors' the accepted value is a boolean.
            If the criterion_name is 'Color bar limits', 'Color bar range' or 'Quality graph by' the accepted value is a string.
            If the criterion_name is 'Number of colors' the accepted value is an integer or a string.
            If the criterion_name is 'No value color' the accepted value is a list of three integers.
            If the criterion_name is 'Edit colors' the accepted value is a dictionary of color index to color value (list of three integers)

    criterion_min_value : Any, optional
            This argument is available if criterion_name="Color bar limits" and
            criterion_status="User min-max" or "Ranges defined min-max".
            It holds the minimun value, which can be a float or a string respectively.

    criterion_max_value : Any, optional
            This argument is available if criterion_name="Color bar limits" and
            criterion_status="User min-max" or "Ranges defined min-max".
            It holds the maximum value, which can be a float or a string respectively.

    number_of_colors : int, optional
            The total number of colors.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Set 'Color bar limits' pulldown to "User min-max", minimum value to 1.2 and maximum value 4.5.
                m = base.F11GraphParamsOptionsSet("Color bar limits", "User min-max", 1.2, 4.5)

                # Set 'Quality graph by' pulldown to "skewness".
                m = base.F11GraphParamsOptionsSet("Quality graph by", "skewness")

                # Set 'Number of Colors' to 6.
                m = base.F11GraphParamsOptionsSet("Number of Colors", 6)

                # Set unique 'Number of Colors'.
                m = base.F11GraphParamsOptionsSet("Number of Colors", "Unique color")

                # Set 'No value color'.
                m = base.F11GraphParamsOptionsSet("No value color", [250, 250, 250])

                # Set 'Number of Colors' to 'Palette' with 4 colors
                m = base.F11GraphParamsOptionsSet(
                    criterion_name="Number of colors",
                    criterion_status="Palette",
                    number_of_colors=4,
                )

                # Set the color of the 3rd and 4th index
                base.F11GraphParamsOptionsSet(
                    "Edit colors", {3: [250, 250, 250], 4: [100, 50, 100]}
                )


    """


def F11PresParamsOptionsGet(parameter_name: object) -> object:
    """

    This function gets the corresponding visibility flag/pulldown menu and their values (if they exist).

    Parameters
    ----------
    parameter_name : object
            "Shrink shells %", "Shrink Rbe2s", "Draw 2nd order faster",
            "Draw 2nd order perim in detail", "Draw shell as solid",
            "Element orientation", "Material orientation", "Bar/Beam CrossSection",
            "CrossSection M,S,1-2 sys", "Transformations", "Transformations method", "Explode view",
            "Connections draw mode:", "Shell Normal Vectors", "Shell Normal Vectors Size".

            Draw Sizes buttongroup: "Coords", "Loads", "SPCs", "Line width"
            Graphics buttongroup: "Elements %", "Light", "Shadow unmeshed", "Feature lines angle".

            Labels buttongroup: "Elements", "Nodes", "labels Loads", "labels Masses",
            "labels SPCs", "Names".

            Magnitude buttongroup: "magnitude Masses", "magnitude Loads",
            "magnitude DVGrid", "magnitude DVGrid", "Detail on Demand effect".

            Visualization buttongroup: "Draw per PID", "Draw CONS in PID,MID,... mode,like in ENT mode",
            "Transparency".

    Returns
    -------
    object
            Returns a dictionary with keys "status" and "value", on success.
            On failure, returns an empty dictionary.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = base.F11PresParamsOptionsGet("Draw Shell as Solid")
                print("F11PresParamsOptionsGet returned status: ", str(m["status"]))

                m = base.F11PresParamsOptionsGet("Transparency")
                print("F11PresParamsOptionsGet returned value: ", str(m["value"]))

                m = base.F11PresParamsOptionsGet("shrink shells %")
                print(
                    "F11PresParamsOptionsGet returned status: "
                    + str(m["status"])
                    + " value: "
                    + str(m["value"])
                )

                m = base.F11PresParamsOptionsGet("SPCs")
                print("SPCs: " + str(m["status"]) + " value: " + str(m["value"]))

                m = base.F11PresParamsOptionsGet("Labels SPCs")
                print("Labels SPCs: ", str(m["status"]))


    """


def F11PresParamsOptionsSet(
    parameter_name: str, parameter_status: Any, parameter_value: float
) -> int:
    """

    This function enables/disables/changes the corresponding visibility flag/pulldown menu
    and values.

    Parameters
    ----------
    parameter_name : str
            The criterion name to enable or disable.

    parameter_status : Any
            (double/boolean) A boolean to enable/disable a value,
            or a double when numerical input is required.

    parameter_value : float, optional
            An optional argument to set a float value, according to the criterion.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = base.F11PresParamsOptionsSet("Draw Shell as Solid", True)
                # will turn "Draw Shell as Solid" visibility flag on.
                m = base.F11PresParamsOptionsSet("Coords", "Absolute", 7.5)
                # will set Coordinates systems size to "Absolute" and value to 7.5.
                m = base.F11PresParamsOptionsSet("SPCs", "Relative to screen (%)", 5)
                # will set SPCs size to "Relative to screen (%)"and value to 5
                m = base.F11PresParamsOptionsSet("Labels SPCs", True)
                # will set Labels SPCs to True

                base.F11PresParamsOptionsSet("magnitude loads", True)
                base.F11PresParamsOptionsSet("magnitude masses", True)
                base.F11PresParamsOptionsSet("magnitude dvgrid", True)
                base.F11PresParamsOptionsSet("Material orientation", True)
                base.F11PresParamsOptionsSet("Draw material orientation as vectors", True)
                base.F11PresParamsOptionsSet("Material orientation X axis", True)
                base.F11PresParamsOptionsSet("Material orientation Y axis", True)
                base.F11PresParamsOptionsSet("Material orientation Z axis", True)

                m = base.F11PresParamsOptionsGet("magnitude dvgrid")
                print("magnitude dvgrid: ", str(m["status"]))
                m = base.F11PresParamsOptionsGet("Draw Shell as Solid")
                print("idraw shell as solid: ", str(m["status"]))
                m = base.F11PresParamsOptionsGet("Coords")
                print("Coords: " + str(m["status"]) + " value: " + str(m["value"]))
                m = base.F11PresParamsOptionsGet("SPCs")
                print("SPCs: " + str(m["status"]) + " value: " + str(m["value"]))
                m = base.F11PresParamsOptionsGet("Labels SPCs")
                print("Labels SPCs: ", str(m["status"]))

                base.F11PresParamsOptionsSet("Bar/Beam CrossSection", True)
                base.F11PresParamsOptionsSet("PBxSECT elements draw mode", "as_solids")
                base.F11PresParamsOptionsSet("Feature lines angle", 35.0)


    """


def F11ShellsOptionsGet(criterion_name: str) -> object:
    """

    This function returns the corresponding visibility flag/pulldown menu
    and values for shells quality criteria. The visibility flag is returned in the argument "status".
    If the criterion has a calculation method, then it's name is returned in the argument "calc".
    If the criterion does not have a calculation method, then the "calc" argument is 0.
    The criterion failed value is returned in the last argument.

    Parameters
    ----------
    criterion_name : str
            The name of the desired criterion, to retrieve its value.

    Returns
    -------
    object
            Returns a dictionary on success or None on error.
            The dictionary's key are: "status", "calculation" and "value".

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = base.F11ShellsOptionsGet("aspect ratio")
                print(
                    "F11ShellsOptionsGet returned: status: ",
                    m["status"],
                    " calculation: ",
                    m["calculation"],
                    " value: ",
                    m["value"],
                )
                m = base.F11ShellsOptionsGet("min length")
                print(
                    "F11ShellsOptionsGet returned: status: ",
                    m["status"],
                    " calculation: ",
                    m["calculation"],
                    " value: ",
                    m["value"],
                )


    """


def F11ShellsOptionsSet(
    criterion_name: str,
    criterion_status: bool,
    criterion_calculation: str,
    criterion_value: float,
) -> int:
    """

    This function enables/disables/changes the corresponding visibility flag/pulldown menu
    and values. When status equals True the visibility flag is turned on, while off if value if False.
    The pulldown menu options can be accessed using the exact name of the Calculation used (e.g. NASTRAN)

    Parameters
    ----------
    criterion_name : str
            The criterion name of the F11 window to enable, disable or change.

    criterion_status : bool
            True or False, to set the criterion active or inactive.

    criterion_calculation : str
            A string to set the respective criterion's calculation field.
            An empty string should be given if you don't care for this argument.
            Using a string that doesn't match any calculation name will return an error.

    criterion_value : float
            A float to set the respective criterion's value field.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.F11ShellsOptionsSet("aspect ratio", True, "PAM-CRASH", 0.4)
                # will turn Shell's "aspect ratio" visibility flag on, calculation type to "PAM-CRASH" and criterion value to 0.4.
                m = base.F11ShellsOptionsGet("aspect ratio")
                print(
                    "F11ShellsOptionsGet returned: status: "
                    + str(m["status"])
                    + " calculation: "
                    + str(m["calculation"])
                    + " value: "
                    + str(m["value"])
                )
                m = base.F11ShellsOptionsSet("min length", True, "", 4.5)
                # will turn Shell's "min length" visibility flag on, minimum length value to 4.5.
                m = base.F11ShellsOptionsGet("min length")
                print(
                    "F11ShellsOptionsGet returned: status: "
                    + str(m["status"])
                    + " calculation: "
                    + str(m["calculation"])
                    + " value: "
                    + str(m["value"])
                )


    """


def F11SolidsOptionsGet(criterion_name: str) -> object:
    """

    This function returns the corresponding visibility flag/pulldown menu
    and values for solids quality criteria. The visibility flag is returned in the argument "status".
    If the criterion has a calculation method, then it's name is returned in the argument "calc".
    If the criterion does not have a calculation method, then the "calc" argument is 0.
    The criterion failed value is returned in the last argument.

    Parameters
    ----------
    criterion_name : str
            The criterion name, to retrieve its value.

    Returns
    -------
    object
            Returns a dictionary on succes or None on failure.
            The dictionary's keys are: "status", "calculation" and "value".

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = ansa.base.F11SolidsOptionsGet("aspect ratio")
                print(
                    "F11SolidsOptionsGet returned: status: "
                    + str(m["status"])
                    + " calculation: "
                    + str(m["calculation"])
                    + " value: "
                    + str(m["value"])
                )


    """


def FacesConvert(entities: object) -> int:
    """

    Converts link faces to geom faces.

    Parameters
    ----------
    entities : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    Returns
    -------
    int
            Returns the length of the converted faces, as an integer.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(ansa.constants.NASTRAN, None, "FACE")
                n = base.FacesConvert(faces)
                print(n)


    """


def FacesNewFitted(
    faces_array: object,
    join_perimeters: bool,
    respect_user_selection: bool,
    ret_ents: bool,
) -> object:
    """

    This script function creates a surface that fits the elements (CONS, CURVES) of list, in order to host the new face.
    It takes a list of cons curves, puts in line the elements of table (automatically) and then creates a face.

    Parameters
    ----------
    faces_array : object
            Is a list with entities (CONS, CURVES, ELEMENTS, CONNECTION CURVES etc.).
            The new face will be created based on these entities.

    join_perimeters : bool, optional
            Is a boolean value to join the perimeters of the created face or not.

    respect_user_selection : bool, optional
            If True then the order of entries in faces_array will be respected and thus
            Cons will be created in that order.
            (Default: False)

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.
            (Default: False)

    Returns
    -------
    object
            Returns the number of created faces, otherwise 0.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves_arr = base.CollectEntities(constants.NASTRAN, None, "CURVE")
                base.FacesNewFitted(curves_arr, respect_user_selection=True)


    """


def FacesNewPlanar(
    faces_array: object,
    join_perimeters: bool,
    respect_user_selection: bool,
    ret_ents: bool,
) -> object:
    """

    This script function creates a new planar face. The underlying planar Surface is automatically created.
    It takes a matrix of cons curves, puts in line the elements of table (automatically) and then create a face.

    Parameters
    ----------
    faces_array : object
            A list with entities (CONS, CURVES, ELEMENTS, CONNECTION CURVES etc.).
            The new face is created based on these entities.

    join_perimeters : bool, optional
            A boolean value to join the perimeters of the created face or not.
            (Default: False)

    respect_user_selection : bool, optional
            if True then the order of entries in faces_array will be respected and thus
            Cons will be created in that order.
            (Default: False)

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.
            (Default: False)

    Returns
    -------
    object
            Returns the number of the created faces on success, otherwise 0.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves_arr = base.CollectEntities(constants.NASTRAN, None, "CURVE")
                base.FacesNewPlanar(faces_array=curves_arr, respect_user_selection=True)


    """


def FacesProject(
    faces1: object,
    faces2: object,
    range: float,
    project_type: object,
    min_length: float,
    split_original: bool,
    connect_with_faces: bool,
    paste: bool,
    produce_curves: bool,
    part: object,
    property: object,
) -> int:
    """

    This script function projects all the CONS of a group of faces (faces1) to a second group of faces (faces2), also applying the topology, if desired.

    Parameters
    ----------
    faces1 : object
            A face, a list of faces, a string with value 'visible' or a string with
            value 'all'. If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    faces2 : object
            A face, a list of faces, a string with value 'visible' or a string with
            value 'all'. If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    range : float, optional
            If given, projections are being created only in areas that the projection
            distance is not bigger than the specified value, else there is no limitation.

    project_type : object, optional
            A dictionary containing tuples of string values 'normal' or 'user' - a triple
            of floats defining the direction, in case that string value is 'user'.
            Triple of floats may not be given, in case that the string value equals
            to 'normal'.

    min_length : float, optional
            If given, avoids projections in areas that would create CONs very close
            to existing ones, provided that the defined value is not bigger than the
            critical length.

    split_original : bool, optional
            If True, the source CONS of the faces1 will be split according to their
            projections' Hot Points.

    connect_with_faces : bool, optional
            If True, results in the creation of Faces between the original CONS of the
            faces1 and their projections.

    paste : bool, optional
            If True, CONS of faces1 and target projections (faces2) are pasted, where/ if
            their distance is smaller than the "CONS matching distance" parameter in
            Windows>Settings>Settings>Tolerance.

    produce_curves : bool, optional
            If True, 3D Curves are produced instead of CONS as projections of the faces1.

    part : object, optional
            The part of the created face(s) in case that connect_with_faces flag is True.

    property : object, optional
            The property of the created face(s) in case that connect_with_faces flag is True.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    ConsProject, ConsProjectNormal, ConsProjectUser, CurvesProjectOnPlane

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = []
                arg1.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 4))
                arg2 = []
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 7))
                arg4 = {}
                arg4["Normal"] = (0, 0, 0)
                faces_project = ansa.base.FacesProject(
                    faces1=arg1,
                    faces2=arg2,
                    range=150,
                    project_type=arg4,
                    split_original=True,
                    paste=True,
                )
                print(faces_project)


            # ...or...


            def main():
                arg1 = []
                arg1.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 3))
                arg2 = []
                arg2.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 2))
                arg3 = {}
                arg3["User"] = (0.911611, 0.134586, 0.388396)
                faces_project = ansa.base.FacesProject(
                    faces1=arg1, faces2=arg2, project_type=arg3, min_length=20, split_original=True
                )
                print(faces_project)


    """


def Field10ToGrids(pattern: str) -> object:
    """

    The Field10ToGrids() function returns all Grids with non-empty field 10.
    If the 'pattern' argument is defined, then the function returns all Grids whose field 10 matches the defined pattern.

    Parameters
    ----------
    pattern : str, optional
            A string with the search pattern.

    Returns
    -------
    object
            Returns None, when no field 10 matches are found, or a list containing references to entities with successful field 10 matches.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Get all Grids whose field 10 starts with "Default"
                m = base.Field10ToGrids("^Default.*")
                for ent in m:
                    ret = base.GetEntityCardValues(constants.NASTRAN, ent, ("field 10",))
                    print(ret["field 10"])
                # Get all Grids with non-empty field 10
                m = base.Field10ToGrids()
                for ent in m:
                    ret = base.GetEntityCardValues(constants.NASTRAN, ent, ("field 10",))
                    print(ret["field 10"])


    """


def FillCorner(faces: object) -> int:
    """

    Transforms free round shaped edges (red CONS) into sharp-edged corners.

    Parameters
    ----------
    faces : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                faces = (
                    base.GetEntity(ansa.constants.NASTRAN, "FACE", 175),
                    base.GetEntity(ansa.constants.NASTRAN, "FACE", 48),
                )
                fill = base.FillCorner(faces)
                print(fill)


    """


def FindMatchesInDM(parts: object, tolerance: float) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`FindMatches` instead.


    Given a parts list, this function searches the DM for matching parts, under the tolerance.

    Parameters
    ----------
    parts : object
            List that contains the ANSA parts for which a match will be searched in DM.

    tolerance : float
            The match tolerance value.

    Returns
    -------
    object
            The function returns the list of matches that were found in DM. Otherwise it returns None

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = base.GetPartFromModuleId("810")
                ret_val = base.FindMatchesInDM(parts, 10.0)
                print(ret_val)
                base.DownloadPartsFromDM(ret_val)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: FindMatches instead.",
        DeprecationWarning,
    )


def FlangeTopo(FACES1: object, FACES2: object) -> int:
    """

    This script function takes two list of faces, locates the common area between them and deletes it from the second group.
    Finally topology applied between two groups of faces.

    Parameters
    ----------
    FACES1 : object
            A list of faces.

    FACES2 : object
            A list of faces.

    Returns
    -------
    int
            Returns 1 on success, or 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ret = base.FlangeTopo(matrix1, matrix2)


    """


def FourBarsAutoPositionSeat(Y_Point, S_Point) -> int:
    """

    All arguments correspond to the respective fields of the 4 Bar Mechanism dialog
    FourBarsDefineMembers and FourBarsDefineSlider should be called before FourBarsAutoPositionSeat.

    Parameters
    ----------
    Y_Point :

    S_Point :

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """


def FourBarsDefineBackrest(backrest, T1, T2) -> int:
    """

    FourBarsDefineMembers should be called before FourBarsAutoPositionSeat.

    Parameters
    ----------
    backrest :

    T1 :

    T2 :

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """


def FourBarsDefineMembers(coupler, driver, follower, OA, OB, A, B, x, y, z) -> int:
    """

    All arguments correspond to the respective fields of the 4bars dialog.

    Parameters
    ----------
    coupler :

    driver :

    follower :

    OA :

    OB :

    A :

    B :

    x :

    y :

    z :

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """


def FourBarsDefineSlider(slider, T1, T2) -> int:
    """

    All arguments correspond to the respective fields of the 4 Bar Mechanism dialogFourBarsDefineSlider should be called before FourBarsAutoPositionSeat.

    Parameters
    ----------
    slider :

    T1 :

    T2 :

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """


def FourBarsLockBackrest(status) -> int:
    """

    FourBarsLockBackrest should be called after FourBarsDefineBackrest and FourBarsDefineMembers.

    Parameters
    ----------
    status :
            ON or OFF. (1 for ON 0 for OFF)

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """


def FourBarsLockSlider(status) -> int:
    """

    FourBarsLockSlider should be called after FourBarsDefineSlider and FourBarsDefineMembers.

    Parameters
    ----------
    status :
            LockSlider status ON or OFF. (1 for ON 0 for OFF)

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """


def FourBarsRotateMechanism(angle) -> int:
    """

    All arguments correspond to the respective fields of the 4 Bar Mechanism dialog.

    Parameters
    ----------
    angle :

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """


def FreezeVisibleFaces() -> int:
    """

    Freezes the visible faces.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.FreezeVisibleFaces()


    """


def GatherElements(
    deck: int,
    type: str,
    search_mode: str,
    gather_from: str,
    gather_from_containers: object,
    x: float,
    y: float,
    z: float,
    search_radius: float,
    source: object,
    angle: float,
) -> object:
    """

    A function that gathers desired elements from all elements of the model or from every visible item or from containers.
    This function works as a script alternative for selecting. The user can gather any element he needs in a similar way as he would select elements from the screen.

    The function works in three modes:

    Mode A: Proximity
     The function will gather all elements that are approximated to a user defined selection point,
     according to a given range.
    Mode B: Connectivity
     The function will gather all elements that are connected to a starting (user given) element. Two elements are
     considered connected if they have at least one common node.
    Mode C: Feature angle
     The function will gather elenents in a way that mimics the feature angle selection tool of ANSA. A starting point
     must also be given.
    Mode D: Macro area
     The function will gather elenents in a way that mimics the macro area selection tool of ANSA. A starting point
     must also be given.

    Parameters
    ----------
    deck : int
            The desired deck. Default current deck.

    type : str, optional
            Accepted values: "Same" or "All". Choose if the elements that will be
            returned are going to have the same type with the given starting point.
            With option "All", every elements will be returned regardless of their type,
            or by giving a type (or a list of types) the user can select which types
            are going to be returned.

    search_mode : str, optional
            Accepted values: "Proximity", "Connectivity", "Feature_angle" or "Macro_area".
            (Default: "Proximity")

    gather_from : str, optional
            Accepted values: "Visible" or "All". Choose the pool from where the function
            will gather the elements.

    gather_from_containers : object, optional
            As containers the user can give an entity or a list of entities that can hold
            elements. Examples of containers are Sets, Parts, Properties etc.

    x : float, optional
            The x coordinate of the selection point (Mode A only).

    y : float, optional
            The y coordinate of the selection point (Mode A only).

    z : float, optional
            The z coordinate of the selection point (Mode A only).

    search_radius : float, optional
            The range around selection point that the function will search to
            gather elements (Mode A only).

    source : object, optional
            Starting element (or list of starting elements) (Mode B, Mode C and Mode D only).

    angle : float, optional
            The desired feature angle in order to execute Mode C.

    Returns
    -------
    object
            Returns a dictionary with gathered elements on success or 0 on failure.

            When in Mode B, Mode C or Mode D the keys of the dictionary correspond to the starting elements.
            The value of each key is a list containing the gathered elements.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                starting_element_item1 = base.GetEntity(constants.ABAQUS, "SHELL", 77)
                starting_element_item2 = base.GetEntity(constants.ABAQUS, "SHELL", 38)
                starting_elements = [starting_element_item1, starting_element_item2]

                elements = base.GatherElements(
                    search_mode="Connectivity",
                    deck=constants.ABAQUS,
                    type="All",
                    source=starting_elements,
                    angle=65,
                    gather_from="Visible",
                )

                container = base.CreateEntity(constants.ABAQUS, "HIGHLIGHT_CONTAINER")
                for key, value in elements.items():
                    list_of_elems = value
                    base.AddToHighlight(container, list_of_elems, "RED")
                base.RedrawAll()


    """


def GeoMirrorAxis(
    input_function_type: str,
    pid_offset: int,
    group_offset: str,
    input_sets_type: str,
    x: float,
    y: str,
    z: float,
    fx: float,
    fy: float,
    fz: float,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
    existing_part: object,
) -> int:
    """

    The function mirrors entities by means of an axis.

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied,
            moved or linked. The avaialble options are: "COPY",
            "MOVE" and "LINK" respectively.

    pid_offset : int
            Determines if the pids of the entities will be
            offset or not. Use 0 to denote that offset will
            not take place and any other integer to denote
            the exact offset value.
            Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset
            the original PID or "CURRENT_PROPERTY" to assign
            the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the ways sets will be treated. It is used
            only in COPY and LINK mode. The avaialble options
            are: "COPY", "EXPAND" and "NONE"

    x : float
            The coordinates of the first of the two points that
            specify an axis.

    y : str
            The coordinates of the first of the two points that
            specify an axis.

    z : float
            The coordinates of the first of the two points that
            specify an axis.

    fx : float
            The coordinates of the second of the two points that
            specify an axis.

    fy : float
            The coordinates of the second of the two points that
            specify an axis.

    fz : float
            The coordinates of the second of the two points that
            specify an axis.

    entities : object
            A list containing references to the entities to
            be copied/moved. The list can contain different
            types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            If True it will refresh the screen after completion of the function.
            (Default: False)

    keep_connectivity : bool, optional
            True or False.
            (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                args = []
                args.append(base.GetPartFromModuleId("9"))
                args.append(base.GetEntity(constants.NASTRAN, "MAT1", 5))
                base.GeoMirrorAxis("COPY", 0, "NEW PART", "NONE", 0, 0, 0, 0, 1, 0, args, True)


    """


def GeoMirrorPlane(
    input_function_type: str,
    pid_offset: Any,
    group_offset: str,
    input_sets_type: str,
    fx: float,
    fy: float,
    fz: float,
    fx2: float,
    fy2: float,
    fz2: float,
    fx3: float,
    fy3: float,
    fz3: float,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
    existing_part: object,
) -> int:
    """

    The function mirrors entities by means of a plane.

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied,
            moved or linked. The avaialble options are: "COPY",
            "MOVE" and "LINK" respectively.

    pid_offset : Any
            Determines if the pids of the entities will be offset or not.
            Use 0 to denote that offset will not take place and any
            other integer to denote the exact offset value.
            Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset
            the original PID or "CURRENT_PROPERTY" to assign
            the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the ways sets will be treated. It is used
            only in COPY and LINK mode. The avaialble options
            are: "COPY", "EXPAND" and "NONE"

    fx : float
            The coordinates of the first of three points that
            specify the mirror plane.

    fy : float
            The coordinates of the first of three points that
            specify the mirror plane.

    fz : float
            The coordinates of the first of three points that
            specify the mirror plane.

    fx2 : float
            The coordinates of the second of three points that
            specify the mirror plane.

    fy2 : float
            The coordinates of the second of three points that
            specify the mirror plane.

    fz2 : float
            The coordinates of the second of three points that
            specify the mirror plane.

    fx3 : float
            The coordinates of the third of three points that
            specify the mirror plane.

    fy3 : float
            The coordinates of the third of three points that
            specify the mirror plane.

    fz3 : float
            The coordinates of the third of three points that
            specify the mirror plane.

    entities : object
            A list containing references to the entities to
            be copied/moved. The list can contain different
            types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            If True it will refresh the screen after completion of the function.
            (Default: False)

    keep_connectivity : bool, optional
            True or False.
            (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                args = (base.GetPartFromModuleId("9"), base.GetEntity(constants.NASTRAN, "MAT1", 5))
                base.GeoMirrorPlane(
                    "COPY",
                    0,
                    "NEW INSTANCE",
                    "EXPAND",
                    125.3,
                    210.6,
                    642.94,
                    435.72,
                    482.75,
                    308.21,
                    642.94,
                    435.72,
                    482.75,
                    args,
                    keep_connectivity=True,
                )


    """


def GeoMirrorPoint(
    input_function_type: str,
    pid_offset: int,
    group_offset: str,
    input_sets_type: str,
    fx: float,
    fy: float,
    fz: float,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
    existing_part: object,
) -> int:
    """

    The function mirrors entities by means of a point.

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied,
            moved or linked. The avaialble options are: "COPY",
            "MOVE" and "LINK" respectively.

    pid_offset : int
            Determines if the pids of the entities will be
            offset or not. Use 0 to denote that offset will
            not take place and any other integer to denote
            the exact offset value.
            Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset
            the original PID or "CURRENT_PROPERTY" to assign
            the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the ways sets will be treated. It is used
            only in COPY and LINK mode. The avaialble options
            are: "COPY", "EXPAND" and "NONE"

    fx : float
            The coordinates of the point that specifies the
            mirror plane.

    fy : float
            The coordinates of the point that specifies the
            mirror plane.

    fz : float
            The coordinates of the point that specifies the
            mirror plane.

    entities : object
            A list containing references to the entities to
            be copied/moved. The list can contain different
            types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            If True it will refresh the screen after completion of the function.
            (Default: False)

    keep_connectivity : bool, optional
            True or False.
            (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                args[0] = base.GetPartFromModuleId("9")
                args[1] = base.GetEntity(constants.NASTRAN, "MAT1", 5)
                base.GeoMirrorPoint(
                    "MOVE", 0, "SAME PART", "EXPAND", 125, 40, 56, args, keep_connectivity=True
                )


    """


def GeoRotate(
    input_function_type: str,
    pid_offset: int,
    group_offset: str,
    input_sets_type: str,
    fx: float,
    fy: float,
    fz: float,
    fx2: float,
    fy2: float,
    fz2: float,
    angle: float,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
    existing_part: object,
    duplicate_affected_coords: bool,
    move_with_coord: bool,
    create_nodal_coords: bool,
) -> int:
    """

    The function rotates entities around a rotation axis.

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied,
            moved or linked. The available options are: "COPY",
            "MOVE" and "LINK" respectively.

    pid_offset : int
            Determines if the pids of the entities will be
            offset or not. Use 0 to denote that offset will
            not take place and any other integer to denote
            the exact offset value.
            Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset
            the original PID or "CURRENT_PROPERTY" to assign
            the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the ways sets will be treated. It is used
            only in COPY and LINK mode. The avaialble options
            are: "COPY", "EXPAND" and "NONE".

    fx : float
            The coordinates of the first of two points that
            specify the rotation axis.

    fy : float
            The coordinates of the first of two points that
            specify the rotation axis.

    fz : float
            The coordinates of the first of two points that
            specify the rotation axis.

    fx2 : float
            The coordinates of the second of two points that
            specify the rotation axis.

    fy2 : float
            The coordinates of the second of two points that
            specify the rotation axis.

    fz2 : float
            The coordinates of the second of two points that
            specify the rotation axis.

    angle : float
            The desired rotation angle in degrees.

    entities : object
            A list containing references to the entities to
            be copied/moved. The list can contain different
            types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            If True it will refresh the screen after completion
            of the function. (Default: False)

    keep_connectivity : bool, optional
            If True it will keep the connectivity. (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    duplicate_affected_coords : bool, optional
            If True, a new local coordinate system is created and assigned to
            the transformed entities. If False, the local coordinate system of
            the original entities is used. (Default: True)

    move_with_coord : bool, optional
            Determines whether entities are transformed together with
            their local coordinate system during MOVE operation
            of the latter. (Default: True)

    create_nodal_coords : bool, optional
            If True, a new local coordinate system is created and assigned to
            nodes without coordinate system. (Default: False)

    Returns
    -------
    int
            Returns 0 upon successful execution, or 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                args = (
                    base.GetPartFromModuleId("9"),
                    base.GetEntity(constants.NASTRAN, "SHELL", 20),
                )
                base.GeoRotate(
                    "MOVE",
                    1,
                    "SAME PART",
                    "NONE",
                    125,
                    10,
                    20,
                    0,
                    -1,
                    0,
                    90,
                    args,
                    keep_connectivity=True,
                )


    """


def GeoRotateMoveSet(
    set: object,
    x1: float,
    y1: float,
    z1: float,
    x2: float,
    y2: float,
    z2: float,
    angle: float,
) -> int:
    """

    This function rotates all geometric entities of a set.

    Parameters
    ----------
    set : object
            The set.

    x1 : float
            The x coordinate of the first point.

    y1 : float
            The y coordinate of the first point.

    z1 : float
            The z coordinate of the first point.

    x2 : float
            The x coordinate of the second point.

    y2 : float
            The y coordinate of the second point.

    z2 : float
            The z coordinate of the second point.

    angle : float
            The rotation angle.

    Returns
    -------
    int
            Returns 0 on success, 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                set = base.GetEntity(ansa.constants.NASTRAN, "SET", 1)
                base.GeoRotateMoveSet(set, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 90.0)


    """


def GeoScale(
    input_function_type: str,
    pid_offset: int,
    group_offset: str,
    input_sets_type: str,
    dx: float,
    dy: float,
    dz: float,
    scale_value: float,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
    existing_part: object,
) -> int:
    """

    This function scales entities.

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied, moved or linked.
            The avaialble options are: "COPY", "MOVE" and "LINK" respectively.

    pid_offset : int
            Determines if the pids of the entities will be offset or not. Use 0 to denote
            that offset will not take place and any other integer to denote the exact
            offset value. Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset the original PID
            or "CURRENT_PROPERTY" to assign the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the ways sets will be treated. It is used
            only in COPY and LINK mode. The avaialble options
            are: "COPY", "EXPAND" and "NONE".

    dx : float
            The coordinates of the reference point.

    dy : float
            The coordinates of the reference point.

    dz : float
            The coordinates of the reference point.

    scale_value : float
            The scale factor.

    entities : object
            A list containing references to the entities to
            be copied/moved. The list can contain different
            types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            If True it will refresh the screen after completion of the function.
            (Default: True)

    keep_connectivity : bool, optional
            True or False. (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                args = (base.GetPartFromModuleId("9"), base.GetEntity(constants.NASTRAN, "MAT1", 5))
                base.GeoScale(
                    "MOVE", 0, "SAME PART", "EXPAND", 125, 40, 56, 2, args, keep_connectivity=True
                )


    """


def GeoSymmetry(
    input_function_type: str,
    pid_offset: int,
    group_offset: str,
    input_sets_type: str,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
    existing_part: object,
) -> int:
    """

    This function creates symmetric entities.

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied,
            moved or linked. The avaialble options are: "COPY",
            "MOVE" and "LINK" respectively.

    pid_offset : int
            Determines if the pids of the entities will be
            offset or not. Use 0 to denote that offset will
            not take place and any other integer to denote
            the exact offset value.
            Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset
            the original PID or "CURRENT_PROPERTY" to assign
            the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the ways sets will be treated. It is used
            only in COPY and LINK mode. The avaialble options
            are: "COPY", "EXPAND" and "NONE"

    entities : object
            A list containing references to the entities to
            be copied/moved. The list can contain different
            types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            If True it will refresh the screen after completion
            of the function. (Default: False)

    keep_connectivity : bool, optional
            True or False. (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                args = (base.GetPartFromModuleId("9"), base.GetEntity(constants.NASTRAN, "MAT1", 5))
                base.GeoSymmetry("COPY", 0, "NEW INSTANCE", "EXPAND", args, keep_connectivity=True)


    """


def GeoTransform(
    input_function_type: str,
    pid_offset: object,
    group_offset: str,
    input_sets_type: str,
    x0: float,
    y0: float,
    z0: float,
    dx1: float,
    dy1: float,
    dz1: float,
    dx2: float,
    dy2: float,
    dz2: float,
    x1: float,
    y1: float,
    z1: float,
    dx3: float,
    dy3: float,
    dz3: float,
    dx4: float,
    dy4: float,
    dz4: float,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
    convert_ranges_to_entities: bool,
    existing_part: object,
    duplicate_affected_coords: bool,
    move_with_coord: bool,
    create_nodal_coords: bool,
) -> int:
    """

    This function transforms entities in a way that immitates the GUI function Utilities>Transform>Copy/Move/Link>Transform. The transformation takes place between two coordinate systems (defined implicitly via the x0/1, y0/1, z0/1 and dx1/2, dy1/2, dz1/2 arguments of the function)/ It is a simultaneous translation and rotation procedure.

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied,
            moved or linked. The available options are: "COPY",
            "MOVE" and "LINK" respectively.

    pid_offset : object
            Determines if the pids of the entities will be
            offset or not. Use 0 to denote that offset will
            not take place and any other integer to denote
            the exact offset value.
            Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset
            the original PID or "CURRENT_PROPERTY" to assign
            the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the ways sets will be treated. It is used
            only in COPY and LINK mode. The available options
            are: "COPY", "EXPAND" and "NONE"

    x0 : float
            The x coordinate of the origin point.

    y0 : float
            The y coordinate of the origin point.

    z0 : float
            The z coordinate of the origin point.

    dx1 : float
            The x coordinate of the 1st origin vector (i.e of the unit vector that defines the x direction of the origin coordinate system).

    dy1 : float
            The y coordinate of the 1st origin vector.

    dz1 : float
            The z coordinate of the 1st origin vector.

    dx2 : float
            The x coordinate of the 2nd origin vector (i.e of the unit vector that, together with the 1st origin vector, defines the xy plane of the origin coordinate system).

    dy2 : float
            The y coordinate of the 2nd origin vector.

    dz2 : float
            The z coordinate of the 2nd origin vector.

    x1 : float
            The x coordinate of the destination point.

    y1 : float
            The y coordinate of the destination point.

    z1 : float
            The z coordinate of the destination point.

    dx3 : float
            The x coordinate of the 1st destination vector (i.e of the unit vector that defines the x direction of the destination coordinate system).

    dy3 : float
            The y coordinate of the 1st destination vector.

    dz3 : float
            The z coordinate of the 1st destination vector.

    dx4 : float
            The x coordinate of the 2nd destination vector (i.e of the unit vector that, together with the 1st destination vector, defines the xy plane of the destination coordinate system).

    dy4 : float
            The y coordinate of the 2nd destination vector.

    dz4 : float
            The z coordinate of the 2nd destination vector.

    entities : object
            A list containing references to the entities to
            be copied/moved. The list can contain different
            types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            If True it will refresh the screen after completion
            of the function. (Default: False)

    keep_connectivity : bool, optional
            If True it will keep the connectivity. (Default: False)

    convert_ranges_to_entities : bool, optional
            Affects the copies of Sets that involve Ranges of entity ids.
            When set to True, the copied sets acquire directly the
            corresponding entities instead of Ranges (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    duplicate_affected_coords : bool, optional
            If True, a new local coordinate system is created and assigned to
            the transformed entities. If False, the local coordinate system of
            the original entities is used. (Default: True)

    move_with_coord : bool, optional
            Determines whether entities are transformed together with
            their local coordinate system during MOVE operation
            of the latter. (Default: True)

    create_nodal_coords : bool, optional
            If True, a new local coordinate system is created and assigned to
            nodes without coordinate system. (Default: False)

    Returns
    -------
    int
            Returns 0 on success, or 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                args = (
                    base.GetPartFromModuleId("9"),
                    base.GetEntity(constants.NASTRAN, "SHELL", 20),
                )

                base.GeoTransform(
                    "MOVE",  # Entities will be moved
                    1,  # Offset will take place
                    "SAME PART",  # No Group Options
                    "NONE",  # Option for Sets is set to NONE
                    10,
                    20,
                    30,  # Origin point
                    1.0,
                    0.0,
                    0.0,  # 1st origin vector
                    0.0,
                    1.0,
                    0.0,  # 2nd origin vector
                    40,
                    50,
                    60,  # Destination point
                    0.0,
                    -1.0,
                    0.0,  # 1st destination vector
                    0.0,
                    0.0,
                    1.0,  # 2nd destination vector
                    args,  # Entities to be moved
                    draw_results=False,
                    keep_connectivity=True,
                )  # Node Connectivity will be kept


    """


def GeoTranslate(
    input_function_type: str,
    pid_offset: int | str,
    group_offset: str,
    input_sets_type: str,
    dx: float,
    dy: float,
    dz: float,
    entities: list,
    draw_results: bool = False,
    keep_connectivity: bool = False,
    existing_part: Entity | None = None,
) -> int:
    """

    This function translates entities according to the input given by the arguments. The arguments are explained below:

    Parameters
    ----------
    input_function_type : str
            Determines whether the entities will be copied, moved or linked.
            The available options are: "COPY", "MOVE" and "LINK" respectively.

    pid_offset : int|str
            Determines if the pids of the entities will be offset or not.
            Use 0 to denote that offset will not take place and any other integer to denote
            the exact offset value. Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset the original PID
            or "CURRENT_PROPERTY" to assign the current PID to all the new entities.

    group_offset : str
            It is used only in COPY and LINK mode. The avaialble
            options are: "SAME PART", "CURRENT PART",
            "EXISTING PART", "NEW PART" and "NEW INSTANCE".
            The "existing_part" argument should be specified if
            "EXISTING PART" is used.

    input_sets_type : str
            Controls the way sets will be treated. It is used only in COPY and LINK mode.
            The available options are: "COPY", "EXPAND" and "NONE".

    dx : float
            Specify the translation distance in the x axis.

    dy : float
            Specify the translation distance in the y axis.

    dz : float
            Specify the translation distance in the z axis.

    entities : list
            A list containing references to the entities to be copied/moved.
            The list can contain different types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            Defines whether the results should be redrawn at the end of the transformation.
            Values can be True or False. Default value is False.

    keep_connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved entities
            should be released or not in a MOVE transformation. Value can be True or False.
            Default value is False.

    existing_part : Entity|None, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                args = (
                    base.GetPartFromModuleId("9"),
                    base.GetEntity(constants.NASTRAN, "SHELL", 20),
                )
                x1 = 10
                y1 = 0
                z1 = 10
                x2 = 0
                y2 = 0
                z2 = 0
                dx = x1 - x2
                dy = y1 - y2
                dz = z1 - z2

                base.GeoTranslate(
                    "MOVE",
                    1,
                    "SAME PART",
                    "NONE",
                    dx,
                    dy,
                    dz,
                    args,
                    keep_connectivity=True,
                    draw_results=False,
                )


    """


def GeoTranslateMoveSet(set: object, dx: float, dy: float, dz: float) -> int:
    """

    This function translates geometrical entities hosted in a SET according to
    the translation vector given by the arguments.

    Parameters
    ----------
    set : object
            The set.

    dx : float
            The x component of the vector.

    dy : float
            The y component of the vector.

    dz : float
            The z component of the vector.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                set = base.GetEntity(ansa.constants.NASTRAN, "SET", 1)
                base.GeoTranslateMoveSet(set, 1200, 50, 200)


    """


def GetANSAdefaultsValues(fields: object, mbcontainer_type: str) -> object:
    """
    .. deprecated:: 22.0.0
            Use :py:func:`BCSettingsGetValues` instead.


    Function is obsolete. Use BCSettingsGetValues() instead.

    Parameters
    ----------
    fields : object
            A list of ANSA defaults keywords whose values will be retrieved.

    mbcontainer_type : str, optional
            If this argument is provided, for fields
            that can be customized per Model Browser
            Container, the value of the specified
            container type is collected.

            Accepted values are:
            "ANSA_SUBSYSTEM",
            "ANSA_SIMULATION_MODEL",
            "ANSA_LOADCASE",
            "ANSA_SIMULATION_RUN"

    Returns
    -------
    object
            On success it returns a dictionary where the keys are the ANSA defaults keywords
            provided as arguments and the values are their retrieved values stored in ANSA.
            On failure it returns None.
            In case the optional script argument "mbcontainer_type" is specified, the return
            value will contain the ANSA default values of the that type.

    Examples
    --------
    ::

            import ansa
            from ansa import base

            ret = base.GetANSAdefaultsValues(("element_type", "SpotweldPoint_Type"))
            print("The default element type is: ", ret["element_type"])

            ret = base.GetANSAdefaultsValues(["outpcomments"], mbcontainer_type="ANSA_SUBSYSTEM")
            print(
                "The default setting of Subsystems for outputting comments is: ",
                ret["outpcomments"],
            )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 22.0.0. Use :py:func: BCSettingsGetValues instead.",
        DeprecationWarning,
    )


def GetConfigurationIncludes(INCLUDE_CONFIG: Entity) -> list:
    """

    This function gets all the includes that belong to an include configuration.

    Parameters
    ----------
    INCLUDE_CONFIG : Entity
            A reference to an include configuration.

    Returns
    -------
    list
            Returns a list that contains all the includes that belong to the INCLUDE_CONFIG.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                includes_mat = []
                includes_mat.append(
                    base.CreateEntity(constants.NASTRAN, "INCLUDE", {"Name": "include_1"})
                )
                includes_mat.append(
                    base.CreateEntity(constants.NASTRAN, "INCLUDE", {"Name": "include_2"})
                )
                configuration = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE_CONF", {"Name": "INCLUDE_CONFIGURATION1"}
                )
                base.SetConfigurationIncludes(configuration, includes_mat, 1)

                includes_mat = base.GetConfigurationIncludes(configuration)

                length = len(includes_mat)
                print("Configuration Includes")
                for i in range(length):
                    print("Id: " + str(includes_mat[i]._id) + ", Name: " + includes_mat[i]._name)


    """


def GetCrossSectionsSettings(fields: object) -> object:
    """

    Gets values of global parameters for ANSA Cross Sections.

    Parameters
    ----------
    fields : object
            A list with the request labels. Recognizable parameter names and
            extracted values are:
            "Transparent Plane": 0, 1
            "Transparency"
            "Cross curves resolution"
            "Automatically Update After Every Run": 0, 1
            "Calculate offsets and orientation of beams": 0, 1
            "Boundary elements accumulation factor"

            "<result> visibility": 0, 1 (<result>: any Cross Section result)
            "<result> format": "Default", "Float", "Scientific" (<result>: any Cross Section result)
            "<result> decimal digits" (<result>: any Cross Section result)

            "Extracted type": "PBAR", "PBEAM"
            "Assign values based on": "X-Y", "1-2"
            "Segments' distortion angle limit"
            "Restrictions": "Version < 2013.1", "Version >= 2013.1"
            "POINT start id"
            "SET3 start id"

            "Enable similarity": 0, 1
            "Similarity mode": "Geometry", "Results"
            "factor(%)"
            "tol geom"
            "tol thick"
            "tol E"
            "tol n"
            "<result> tolerance" (<result>: any Cross Section result)

            "Assume nonhomogeneous if E differs more than"
            "Definition of reference E, v": "user_selection", "specify"
            "Eref"
            "vref"

    Returns
    -------
    object
            Returns a dictionary on success, or None on failure.
            The return keys of the dictionary correspond to the list of the requested labels.
            The dictionary's values are the function's returns.

    See Also
    --------
    SetCrossSectionsSettings

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = (
                    "Segments' distortion angle limit",
                    "Calculate offsets and orientation of beams",
                    "Cw(s) visibility",
                )
                ret = base.GetCrossSectionsSettings(vals)

                print(
                    "Segments' distortion angle limit = ", ret["Segments' distortion angle limit"]
                )


            if __name__ == "__main__":
                main()


    """


def GetCurrentAnsaModel() -> Entity:
    """

    This function returns the ansa model instance, which is currently set as current. Different databases can be opened
    and handled in Ansa in separate model instances, but only one instance can be current at any single moment. All ansa
    functionality will run on the current model. The function should only be used in combination with the following
    functions: SetCurrentAnsaModel(), GetCurrentAnsaModel(), DestroyAnsaModel().

    Returns
    -------
    Entity
            Returns the current ansa model.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import utils


            def main():
                old_model = (
                    base.GetCurrentAnsaModel()
                )  # Request for the current model instance. It will set current again at the end of all actions
                new_model = base.CreateNewAnsaModel()  # Create a new model instance
                base.SetCurrentAnsaModel(new_model)  # Set the new model as current
                utils.Merge(
                    "C:/temp/users/folder/new_data1.ansa"
                )  # In the new model merge a ansa database
                utils.Merge("C:/temp/users/folder/new_data1.ansa")  # Merge a second database
                base.SaveAs(
                    "C:/temp/users/folder/merge_dbs.ansa"
                )  # Save current model in a new database
                base.SetCurrentAnsaModel(old_model)  # Set the original current model as current
                base.DestroyAnsaModel(old_model)  # Destroy ansa old_model


    """


def GetCurrentDeckDatabaseTypesInInclude(include: object, recursive: bool) -> object:
    """
    .. deprecated:: 18.0.0
            Use :py:func:`GetDatabaseTypesInInclude` instead.


    Returns all different ansa types contained in an include as seen in current deck database. Helpfull to answer questions like "does include has this type entities?".

    Parameters
    ----------
    include : object
            A reference to an INCLUDE ANSA entity.

    recursive : bool
            Recursively search any containers contained in a higher level INCLUDE.
            Availiable options: True or False

    Returns
    -------
    object
            Returns a list with the types of entities contained in the selected INCLUDE.
            In case that the selected INCLUDE is empty, it returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)

                types_matrix = base.GetCurrentDeckDatabaseTypesInInclude(include, 1)

                if types_matrix != 0 and "SpotweldPoint_Type" in types_matrix:
                    print("Spotwelds are contained in Include :", include._id)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 18.0.0. Use :py:func: GetDatabaseTypesInInclude instead.",
        DeprecationWarning,
    )


def GetCurrentIncludeConfiguration() -> object:
    """

    Returns the current include configuration.

    Returns
    -------
    object
            Returns the current include configuration or None if no current include configuration exists.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                configuration1 = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE_CONF", {"Name": "INCLUDE_CONF1"}
                )
                configuration2 = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE_CONF", {"Name": "INCLUDE_CONF2"}
                )
                include_1[0] = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE", {"Name": "include_1"}
                )
                include_2[0] = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE", {"Name": "include_2"}
                )
                base.SetConfigurationIncludes(configuration1, include_1, 1)
                base.SetConfigurationIncludes(configuration2, include_2, 1)

                base.LoadIncludeConfiguration(configuration2, 2)

                current_config = base.GetCurrentIncludeConfiguration()

                ret.GetEntityCardValues(constants.NASTRAN, current_config, {"Name": name})
                print("Current Configuration: ", name)


    """


def GetCurveLength(element_curve) -> int:
    """

    This function calculates the length of a curve. CURVE is the required curve entity.

    Parameters
    ----------
    element_curve :
            The curve entity, to calculate its length.

    Returns
    -------
    int
            Returns the length of the curve, or -1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                CURVE = base.GetEntity(constants.NASTRAN, "CURVE", 166)
                length = base.GetCurveLength(CURVE)


    """


def GetCurveTolerance() -> float:
    """

    This funtion gives the current CONS matching distance. This value coresponds to the field "CONS matching distance"
    placed in Options>Settings>Tolerances.

    Returns
    -------
    float
            Returns the current cons matching distance.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.GetCurveTolerance()


    """


def GetEntity(deck: int, type: str, element_id: int, location: str = None) -> Entity:
    """

    Returns a reference to an entity using its ID and TYPE.

    Parameters
    ----------
    deck : int
            The deck.

    type : str
            A string that describes the type of the entity.
            It can be retrieved from the title of the element's edit card,
            where it is displayed within brackets.
            To get a reference to a property, material, model browser container
            or coordinate system, the types "__PROPERTIES__", "__MATERIALS__",
            "__MBCONTAINERS__"and "__COORD_SYSTEMS__" can be used instead
            of the exact entity type.

    element_id : int
            The id of the entity seeking its reference.

    location : str, optional
            For entities in the material database location = 'Material Database'

    Returns
    -------
    Entity
            Returns a reference to the entity on success, or None if the entity is not found.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pshell = base.GetEntity(ansa.constants.NASTRAN, "PSHELL", 1)

                if pshell == None:
                    print("PSHELL property with ID 1 does not exist!")
                else:
                    print("PSHELL property with ID 1, is named: ", pshell._name)


    """


def GetEntityAttributeFromSet(set: object, entity: object, attribute_name: str) -> str:
    """

    Returns the value that an entity's attribute has in a set.

    Parameters
    ----------
    set : object
            A reference to a set.

    entity : object
            A reference to an entity.

    attribute_name : str
            Availabe attribute names:
            -"Oriented": value can be "SPOS", "SNEG" or " ".
            -"Output as": value can be "PART_IO" or "PART" for properties and
              "BOX_SHELL", "BOX_SOLID", "BOX_SLDIO" or "BOX" for boxes.
            -"Output Face as": value can be "Solidfacets" or "Shells".

            When ENTITY is not included in the SET, the attribute value
            is "not found", and if the ENTITY does not support the
            specified attribute its value is "invalid attribute".

    Returns
    -------
    str
            Returns a string with the attribute's value.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                set = (base.GetEntity(constants.ABAQUS, "SET", 1),)
                shells = base.CollectEntities(constants.ABAQUS, set[0], "SHELL")

                for ent in shells:
                    ret = base.GetEntityCardValues(constants.ABAQUS, ent, ("__id__",))
                    if ret:
                        attr_value = base.GetEntityAttributeFromSet(set[0], ent, "Oriented")
                        print("Shell " + ret[__id__] + " with oriented attribute " + attr_value)


    """


def GetEntityInclude(entity: object) -> object:
    """

    Returns the include file of the given entity.

    Parameters
    ----------
    entity : object
            A reference to the entity.

    Returns
    -------
    object
            Returns the include file on success, None otherwise.

    See Also
    --------
    RemoveFromInclude

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # In the following example the Include file where node with id 1 is defined is returned
            def main():
                m = base.GetEntity(constants.NASTRAN, "GRID", 1)
                vals = {"Name": "new_include_file.nas", "Comment": "This is a test case"}
                include = base.CreateEntity(constants.NASTRAN, "INCLUDE", vals)
                base.AddToInclude(include, m)
                include = base.GetEntityInclude(m)


    """


def GetEntityPart(entity: object) -> object:
    """

    Gets a reference to the PART of an entity.

    Parameters
    ----------
    entity : object
            A reference to an entity, to find the part it belongs to.

    Returns
    -------
    object
            Returns a reference to the part where the entity belongs, or None if the element does not belong to a PART.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "SHELL", 53)
                part = base.GetEntityPart(ent)
                vals = ("Name", "Module Id")
                ret = base.GetEntityCardValues(constants.NASTRAN, part, vals)


    """


def GetEntityType(DECK: int, entity) -> str:
    """

    Returns a string containing the TYPE of an entity.

    Parameters
    ----------
    DECK : int
            The desired Deck

    entity :
            A reference to the entity, to find its type.

    Returns
    -------
    str
            Returns a string containing the TYPE of the Entity, on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                if ent:
                    print(base.GetEntityType(constants.NASTRAN, ent))  # "PSHELL"


    """


def GetEntityVisibFlag(deck: int, entity_name: str) -> int:
    """

    This function gets the corresponding visibility flag status of entity.

    Parameters
    ----------
    deck : int
            The deck constant.

    entity_name : str
            The name of the entity to get visibility status.

    Returns
    -------
    int
            Returns 1 if the visibility flag is turned on, 0 if it is turned off and -1 at error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                m = base.GetEntityVisibFlag(constants.NASTRAN, "BEAM")
                # will store  Nastran's "BEAM" visibility flag to variable m. Variable m will
                # have value 1/0 if the visibility flag of beams is turned on/off.
                m = base.GetEntityVisibFlag(1, "WRONG_KEYWORD")
                # will store -1 as value in variable m.


    """


def GetFaceArea(FACE: object) -> float:
    """

    This function calculates the area of a face.

    Parameters
    ----------
    FACE : object
            The required face entity.

    Returns
    -------
    float
            Returns the area of a face or -1.0, if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                face = base.GetEntity(constants.NASTRAN, "FACE", 166)
                area = base.GetFaceArea(face)


    """


def GetFaceMacro(face: object) -> object:
    """

    This function returns the macro that the given face belongs to.

    Parameters
    ----------
    face : object
            The face entity.

    Returns
    -------
    object
            Returns the macro that the given face belongs to, or None in case of error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                id = 10
                face = base.GetEntity(constants.NASTRAN, "FACE", id)
                macro = base.GetFaceMacro(face)
                ret = base.GetEntityCardValues(constants.NASTRAN, macro, ("ID",))
                print(
                    "The face with id "
                    + str(id)
                    + " belongs to the macro with id "
                    + str(ret["ID"])
                )


    """


def GetFaceOrientation(face: object) -> object:
    """

    The function calculates a faces orientation vector.

    Parameters
    ----------
    face : object
            The face entity whose orientation vector will be calculated.

    Returns
    -------
    object
            Returns a list containing the vector's coordinates.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                face = base.GetEntity(constants.NASTRAN, "FACE", 1)
                vector = base.GetFaceOrientation(face)
                print("dx = ", vector[0])
                print("dy = ", vector[1])
                print("dz = ", vector[2])


    """


def GetFacesOfCons(cons: object) -> object:
    """

    Returns the faces that the input CONS belong to.

    Parameters
    ----------
    cons : object
            A CONS entity, CONS ID, a list of CONS entities, a list of CONS IDs, or a list of CONS entities and IDs.

    Returns
    -------
    object
            Returns a list with the faces that the input CONS belong to.

    See Also
    --------
    GetMacrosOfCons, GetFacesOfHotPoints, GetMacrosOfHotPoints, GetConsOfHotPoints

    Examples
    --------
    ::

            import ansa


            def GetFacesOfConsFromListOfConsEntitiesDemo():
                # collect all CONS of data-base
                cons_list = ansa.base.CollectEntities(
                    deck=ansa.constants.NASTRAN, search_types="CONS"
                )
                # collect adjacent faces of CONS contained in list cons_list
                faces_list = ansa.base.GetFacesOfCons(cons=cons_list)
                # Pick faces contained in list faces_list
                ansa.base.PickEntities(
                    deck=ansa.constants.NASTRAN, types="FACE", initial_entities=faces_list
                )


            def GetFacesOfConsFromSingleConsEntityDemo():
                # collect CONS with ID 2210 from data-base (## Change here to desired ID ##)
                cons_entity = ansa.base.GetEntity(
                    deck=ansa.constants.NASTRAN, type="CONS", element_id=2210
                )
                # collect adjacent faces of cons_entity
                faces_list = ansa.base.GetFacesOfCons(cons=cons_entity)
                # Pick faces contained in list faces_list
                ansa.base.PickEntities(
                    deck=ansa.constants.NASTRAN, types="FACE", initial_entities=faces_list
                )


            def GetFacesOfConsFromListOfConsEntitiesIDsDemo():
                # Define a list of CONS IDs (## Change here to desired IDs ##)
                cons_ids_list = [2210, 2161, 1719]
                # collect adjacent faces of CONS list with IDs
                faces_list = ansa.base.GetFacesOfCons(cons=cons_ids_list)
                # Pick faces contained in list faces_list
                ansa.base.PickEntities(
                    deck=ansa.constants.NASTRAN, types="FACE", initial_entities=faces_list
                )


            def GetFacesOfConsFromSingleConsIDDemo():
                # collect adjacent faces of CONS with ID 2210 (## Change here to desired ID ##)
                faces_list = ansa.base.GetFacesOfCons(cons=2210)
                # Pick faces contained in list faces_list
                ansa.base.PickEntities(
                    deck=ansa.constants.NASTRAN, types="FACE", initial_entities=faces_list
                )


            def GetFacesOfConsFromListOfConsEntitiesAndIDsDemo():
                # Define a list of CONS entities/IDs (## Change here to desired IDs ##)
                cons_list = [
                    2210,
                    ansa.base.GetEntity(deck=ansa.constants.NASTRAN, type="CONS", element_id=2161),
                    1719,
                ]
                # collect adjacent facess of CONS list cons_list
                faces_list = ansa.base.GetFacesOfCons(cons=cons_list)
                # pick faces contained in list faces_list
                ansa.base.PickEntities(
                    deck=ansa.constants.NASTRAN, types="FACE", initial_entities=faces_list
                )


    """


def GetFirstEntity(deck: int, type: str, location: str) -> object:
    """

    Gets a reference to the first entity of the database using its TYPE.

    Parameters
    ----------
    deck : int
            The deck.

    type : str
            A string that describes the entity. It can be retrieved from the title of
            the entity's edit card, where it is displayed within brackets.

    location : str, optional
            For entities in the material database location = 'Material Database'.

    Returns
    -------
    object
            Returns a reference to the entity, or None if no entity is found.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetFirstEntity(constants.NASTRAN, "PSHELL")
                while ent:
                    ret_vals = base.GetEntityCardValues(constants.NASTRAN, ent, ("Name", "T"))
                    print(ret_vals["Name"] + " : %d" + str(ret_vals["T"]))
                    ent = base.GetNextEntity(constants.NASTRAN, ent)


    """


def GetFirstPartEntity(PART: Entity) -> Entity:
    """

    Gets a reference to the first entity of a PART.

    Parameters
    ----------
    PART : Entity
            A reference to an ANSA part. It can be obtained from a previous
            call to GetFirstEntity, GetNextEntity.

    Returns
    -------
    Entity
            Returns a reference to the entity, or None if no entity is found.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                part = base.GetPartFromModuleId("100")
                ent = base.GetFirstPartEntity(part)
                while ent:
                    if base.GetEntityType(constants.NASTRAN, ent) == "FACE":
                        print("FACE found in part")
                    ent = base.GetNextPartEntity(part)


    """


def GetFringeBarMinMaxValues() -> object:
    """

    This function calculates the minimum and maximum limits of the visible fringe bars.
    The lists min_values and max_values will contain the minimum and maximum limits of the visible fringe bars respectively.If one fringe bar is visible, then only the first position of each list will have a value. The second position will be zero.If no fringe bars are visible, then both list will contain zeros.
    If two fringe bars are visible, then each list will have two values.
    The latter occurs when the "Color Bar Limits" is "Ranges defined min-max" or when the "Color Bar Colors" is "Use unique color for each range" and there are both shells and solids visible and the view mode is QGRAPH.

    Returns
    -------
    object
            Returns a Dictionary object with two keys: min_values and max_values.
            min_values and max_values are lists with two positions.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = base.GetFringeBarMinMaxValues()
                print("min = " + str(vals["min_values"][0]) + "    " + str(vals["min_values"][1]))
                print("min = " + str(vals["max_values"][0]) + "    " + str(vals["max_values"][1]))


    """


def GetGeneralComment() -> str:
    """

    Gets the Deck's General Comment.

    Returns
    -------
    str
            Returns the string entered as a General Comment.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                comment = base.GetGeneralComment()
                print(comment)


    """


def GetGlobalControl(deck: int) -> object:
    """

    Function that returns the active global control of the base. Works for Decks that have one control per model,
    (DECK_DYN, DECK_PAM, DECK_RDS, CFD_OPENFOAM, DECK_ANSYS). For other decks such as for example ABAQUS one
    can use the GetEntity() function.

    Parameters
    ----------
    deck : int, optional
            The deck. Default value is the current deck.

    Returns
    -------
    object
            Returns a reference to the Control object on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                control = base.GetGlobalControl(constants.LSDYNA)

                control.set_entity_values(
                    constants.LSDYNA, {"TERMINATION": "ON", "TERMINATION_ENDTIM": 1.23}
                )

                ret = control.get_entity_values(
                    constants.LSDYNA, ["TERMINATION", "TERMINATION_ENDTIM"]
                )
                print(ret)


    """


def GetHighlightColor(container: object, ent: object) -> str:
    """

    Gets the color with which an entity is set into a Highlight Container.

    Parameters
    ----------
    container : object
            A reference to a highlight container.

    ent : object
            A reference to an entity that will placed in the highlight container.

    Returns
    -------
    str
            Returns the color keyword on success or the keyword "Invalid" upon failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = (base.GetEntity(constants.ABAQUS, "SHELL", 1),)
                containers = base.CollectEntities(
                    constants.ABAQUS, None, "HIGHLIGHT_CONTAINER", False
                )

                for container in containers:
                    color = base.GetHighlightColor(container, ents[0])
                    print("The color is ", color)


    """


def GetHighlightContainerContents(container: object) -> object:
    """

    All the objects that are contained into the highlight container will be returned as a list.

    Parameters
    ----------
    container : object
            A reference to a highlight container.

    Returns
    -------
    object
            Returns a list containing ansa entities.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                containers = base.CollectEntities(constants.ABAQUS, None, "HIGHLIGHT_CONTAINER")
                for container in containers:
                    entities = base.GetHighlightContainerContents(container)
                    for ent in entities:
                        base.EditEntity(ent)


    """


def GetIncludeActiveState(include: object) -> int:
    """

    Returns the include active state.

    Parameters
    ----------
    include : object
            A reference to the include object.

    Returns
    -------
    int
            Returns the active state:
            0: Include is inactive, has been unloaded from includes manager or "UnloadInclude" script function,
               it is empty and visible only on includes manager and NVH console.
            1: Include is active and visible.
            2: Include is in a middle (zombie) state, tried to unload but contained entities with external references
               and thus could not fully be unloaded. it seems active but is mostly unused to the model.
               Usually LoadIncludeConfiguration (with "reload" option) or ReplaceInclude will solve this situation.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.GetEntity(constants.NASTRAN, "INCLUDE", 5)
                active_state = base.GetIncludeActiveState(include)
                if active_state == 2:
                    base.ReplaceInclude(include, "/home/user/filename")


    """


def GetIncludeExclusiveState(include: object) -> int:
    """

    Returns the include "configuration exclusive" state.
    The exclusive state is mainly used in the Includes Configurator and usualy refers to group includes.
    An exclusive group include can have only one of its children includes active (loaded).

    Parameters
    ----------
    include : object
            A reference to an include object.

    Returns
    -------
    int
            Returns the exclusive state:
            -0: include is not exclusive.
            -1: include is exclusive (if LoadInclude is applied in one of its children, all other children will be unloaded).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.GetEntity(constants.NASTRAN, "INCLUDE", 5)
                exclusive_state = base.GetIncludeExclusiveState(include)
                print("exclusive state: ", exclusive_state)


    """


def GetInternalAndExternalFacets(deck: int, entities: object) -> object:
    """

    The GetInternalAndExternalFacets returns the internal and the external facets of the ANSA model.
    If the 'entities' argument is defined, then the function will only return the facets from these entities.

    Parameters
    ----------
    deck : int
            The deck constant.

    entities : object, optional
            An object or a list of objects to get the facets from.

    Returns
    -------
    object
            Returns a dictionary with two items:
            -key: "internal_facets"         value: a list with the internal facets
            -key: "external_facets"         value: a list with the external facets

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                solids = base.CollectEntities(constants.NASTRAN, None, "SOLID")
                ret = base.GetInternalAndExternalFacets(constants.NASTRAN, solids)
                for key, data in ret.items():
                    print(key, len(data))


    """


def GetLoadCurveData(entity: object):
    """

    Returns the values of a curve data table.

    Parameters
    ----------
    entity : object
            A reference to the curve data table.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curve = base.GetEntity(constants.LSDYNA, "DEFINE_CURVE", 10)
                vals = base.GetLoadCurveData(curve)
                print(vals)


            # ...or...


            def main():
                table = base.GetEntity(constants.LSDYNA, "DEFINE_TABLE", 16084)
                ret = base.GetEntityCardValues(constants.LSDYNA, table, ("ITEMS", "x"))
                for curve in ret["ITEMS"]:
                    vals = base.GetLoadCurveData(curve)
                    print(len(vals))
                    print(curve._name)


    """


def GetMasterInstance(PART: object) -> object:
    """

    Gets a reference to the master instance of a PART or GROUP.

    Parameters
    ----------
    PART : object
            A reference to a part object.

    Returns
    -------
    object
            Returns a reference to the master instance.
            If an element is the master part then it returns itself.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromModuleId("10")
                transf_matrix = ((1, 0, 0, 0), (0, -1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
                inst = base.MakeNewInstance(part, transf_matrix)
                master_inst = base.GetMasterInstance(inst)


    """


def GetNextEntity(deck: int, entity: object, location: str) -> object:
    """

    Gets a reference to the next entity of the database by specifying the current.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, PAMCRASH, ABAQUS, RADIOSS, ANSYS,
            FLUENT, FLUENT2D, STAR, UH3D, CFDPP, OPENFOAM, PERMAS.

    entity : object
            A reference to an entity.

    location : str, optional
            For entities in the material database, location = 'Material Database'.

    Returns
    -------
    object
            Returns a reference to an entity, or None when no entity is found.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetFirstEntity(constants.NASTRAN, "PSHELL")
                while ent:
                    ret_vals = base.GetEntityCardValues(constants.NASTRAN, ent, ("Name", "T"))
                    print(ret_vals["Name"] + " : %d" + str(ret_vals["T"]))
                    ent = base.GetNextEntity(constants.NASTRAN, ent)


    """


def GetNextPartEntity(PART, ENTITY) -> object:
    """

    Gets a reference to the next entity of a PART by specifying the current.

    Parameters
    ----------
    PART :
            A reference to an ANSA part. It can be obtained from a previous call to
            GetFirstEntity or GetNextEntity.

    ENTITY :
            A reference to an element. It can be retrieved from a previous call to
            GetFirstEntity or GetNextEntity.

    Returns
    -------
    object
            Returns a reference to the entity, or None when no entity is found.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = GetFirstPartEntity(part)
                while ent:
                    if base.GetEntityType(constants.NASTRAN, ent) == "FACE":
                        print("FACE found in part")
                    ent = base.GetNextPartEntity(part, ent)


    """


def GetNodeTolerance() -> float:
    """

    The function gives the current "HOT POINTS matching distance" value from Options>Settings>Tolerances.

    Returns
    -------
    float
            Returns the current hot points matching distance.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.GetNodeTolerance()


    """


def GetNormalVectorOfShell(shell: object) -> object:
    """

    This function gets the normal vector of a shell or a facet.

    Parameters
    ----------
    shell : object
            A reference to a shell or facet entity.

    Returns
    -------
    object
            Returns the unit normal vector (list) of the given shell or facet, or 0 if the vector is not defined.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                id = 10
                shell = base.GetEntity(constants.NASTRAN, "SHELL", id)
                vec = base.GetNormalVectorOfShell(shell)
                print(
                    "The shell with id "
                    + str(id)
                    + " has the normal vector dx: "
                    + str(vec[0])
                    + " dy: "
                    + str(vec[1])
                    + " dz: "
                    + str(vec[2])
                )


    """


def GetOldAndNewEntitiesMap() -> object:
    """

    The function is used to get a dictionary with the selected and created entities, after a copy
    transformation has been performed. It is used in combination with the function
    Prepare2GetOldAndNewEntitiesMap, which is called prior to the transformation.

    Returns
    -------
    object
            Returns a dictionary of the selected and newly created entities.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = (
                    base.GetPartFromModuleId("9"),
                    base.GetEntity(constants.NASTRAN, "SHELL", 20),
                )
                base.Prepare2GetOldAndNewEntitiesMap()
                base.GeoTranslate("COPY", 1, "SAME PART", "NONE", 125, 200, 56, ents)
                map = base.GetOldAndNewEntitiesMap()


    """


def GetOutOfPlaneShearComponents(mat: object) -> object:
    """

    This function calculates the two out-of-plane shear components
    of the material's elastic stifness matrix.

    Parameters
    ----------
    mat : object
            A reference to a material entity.

    Returns
    -------
    object
            Returns a list of size 2 containing the two out-of-plane shear components
            of the material's elastic stifness list. (i.e. the G12 and G13 components)

            In case of failure, a message is displayed ("No tranverse shear components
            defined for material") and the returned list has its two values set to
            zero.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                mat = base.GetEntity(
                    constants.ABAQUS, "MATERIAL", 1
                )  # Assuming that a material with Id 1 exists.
                m = base.GetOutOfPlaneShearComponents(mat)


    """


def GetPartCogAndPrincipalInertiaVectors(part: object) -> object:
    """

    The GetPartCogAndPrincipalInertiaVectors function calculates the part's center of gravity, based on
    the part's faces, shells, solids and volumes.
    It also calculates the principal inertia vectors and the Ixx, Iyy, Izz moments of inertia.

    Parameters
    ----------
    part : object
            An ANSAPART Entity.

    Returns
    -------
    object
            In case of successful calculation of the cog and intertia vectors,the function returns a list with 15 elements.
            The first three elements of the list, are the coordinates of the center of gravity.
            The following nine, are the three vectors for the principal inertia vectors.
            The last three elements are the Ixx, Iyy and Izz moments of inertia.
            In case of failure, it returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                search_parts = ("ANSAPART",)
                all_parts = base.CollectEntities(0, None, search_parts)
                if len(all_parts):
                    for part in all_parts:
                        table = base.GetPartCogAndPrincipalInertiaVectors(part)
                        if not table:
                            continue
                        base.Newpoint(table[0], table[1], table[2])


    """


def GetPartDepth(part: Entity) -> dict:
    """

    The GetPartDepth function returns the part's depth and it's parent part.(if any)

    Parameters
    ----------
    part : Entity
            The part to search for it's depth and it's parent part.

    Returns
    -------
    dict
            Returns a dictionary in case of success and None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                part = base.GetPartFromModuleId("789F")
                ret = base.GetPartDepth(part)

                # Get the parent's part values
                base.GetEntityCardValues(constants.NASTRAN, ret["parent_part"], ("Name",))
                # Print the depth
                print("Depth is: " + str(ret["depth"]))


    """


def GetPartFromModuleId(ID: str, type: str) -> Entity:
    """

    This function finds the reference to the ANSAPART or ANSAGROUP, according to the Module Id given as argument.

    This function can also find a reference to a Configuration or a Subsystem, if the second optional argument "type" is used.

    For Configurations the type is "ANSA_CONFIGURATION".
    For Subsystems the type is "ANSA_SUBSYSTEM".

    Parameters
    ----------
    ID : str
            The module id.

    type : str, optional
            The type of the entity.

            For Configurations use type: "ANSA_CONFIGURATION".
            For Subsystems use type: "ANSA_SUBSYSTEM".

    Returns
    -------
    Entity
            Returns the reference to the ANSAPART or ANSAGROUP with this Module Id.
            If such a part does not exist None is returned.

            If the additional argument "type" has been used, the returned type can
            also be an "ANSA_CONFIGURATION" or an "ANSA_SUBSYSTEM".

    See Also
    --------
    base.GetPartInstances

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromModuleId("100")
                subsystem = base.GetPartFromModuleId("100", type="ANSA_SUBSYSTEM")


    """


def GetPartInstancesFromModuleId(ID: str) -> object:
    """

    This functions finds the references to all ANSAPART's or ANSAGROUP's
    instances, according to the Module Id given as argument.

    Parameters
    ----------
    ID : str
            The module id.

    Returns
    -------
    object
            Returns a list with the references to all instances of the ANSAPART or
            ANSAGROUP with the given Module Id. If such a part does not exist 0 is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part_instances = base.GetPartInstancesFromModuleId("100")
                print(len(part_instances))


    """


def GetPlanarGMatrixAndThickness(deck: int, prop: object, layer: int) -> object:
    """

    This function computes the Planar G Matrix for a PSHELL or PCOMP property.
    If prop is a PCOMP, the layer must also be defined, otherwise only prop is sufficient.

    Parameters
    ----------
    deck : int
            The deck constant.

    prop : object
            A reference to a property object.

    layer : int, optional
            The number of the layer.

    Returns
    -------
    object
            Returns a list of size 10, containing the 9 components of the G Matrix (G11, G12, G13, G21, G22, G23 ... )
            and the thickness of the PSHELL (or the layer of the PCOMP).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pshell = base.GetEntity(constants.ABAQUS, "SHELL_SECTION", 1)
                pcomp = base.GetEntity(constants.ABAQUS, "COMPOSITE", 2)

                m = base.GetPlanarGMatrixAndThickness(constants.ABAQUS, prop=pshell)

                m = base.GetPlanarGMatrixAndThickness(constants.ABAQUS, prop=pcomp, layer=2)


    """


def GetShellEffectiveEngineeringProperties(deck: int, entity: object) -> object:
    """

    This function calculates the effective egineering properties of a laminate shell: E11, E22, N12, N21, G and ABD matrix.

    Parameters
    ----------
    deck : int
            The deck constant.

    entity : object
            A reference to a laminate shell object.

    Returns
    -------
    object
            Returns a dictionary on success:

            Key   | Value
            "E11" | double, E11
            "E22" | double, E22
            "N12" | double N12
            "N21" | double N21
            "G"   | double G
            "ABD" | list of 6 lists with 6 doubles: double ABD[6][6]

            Returns None on failure.

    """


def GetShellsFromBeamSection(beams: object, deck: int, element_length: float) -> object:
    """

    This function creates shell elements in the form of specific beam cross sections.

    Parameters
    ----------
    beams : object
            An object or a list of beam objects, "all", "visible", 0.
            If set to 0 or "all", runs for all compatible elements of the database.
            If set to "visible," runs for all compatible elements which are visible.

    deck : int, optional
            Deck in which function is run.

    element_length : float, optional
            Element length. In case this length is greater than maximum element length, that is estimated from the function, maximum element length is used.

    Returns
    -------
    object
            Returns a list that contains all created shells or 0 if no shell could be created.
            Returns NULL in case of invalid "element_length" (<= 0).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = (
                    base.GetEntity(constants.NASTRAN, "CBAR", 1),
                    base.GetEntity(constants.NASTRAN, "CBAR", 2),
                )
                shells = base.GetShellsFromBeamSection(entity)
                if shells:
                    for i in range(len(shells)):
                        print(shells[i])
                ents = ansa.base.CollectEntities(constants.NASTRAN, None, "CBEAM3")
                new_ents = ansa.base.GetShellsFromBeamSection(ents, constants.PERMAS, 1)


    """


def GetSpecialNumberingRules(element: object) -> object:
    """

    The GetSpecialNumberingRules returns all special rules defined for the PROPERTY,
    PART, SET, INCLUDE, CONNECTOR, GENERIC ENTITY BUILDER, ANSA_SIMULATION_MODEL,
    ANSA_LOADCASE, ANSA_SIMULATION_RUN, ANSA_SUBSYSTEM or ANSA_LIBRARY_ITEM defined.

    Parameters
    ----------
    element : object
            A reference to a property, part, set, include, connector, generic entity builder, subsystem, simulation model, loadcase, simulation run, or library item.

    Returns
    -------
    object
            Returns a list containing all the numbering rules of the entity.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.ABAQUS, "SHELL", 1)
                if not ent:
                    print("Entity not found")
                part = base.GetEntityPart(ent)
                if not part:
                    print("Part not found.")
                rule_list = base.GetSpecialNumberingRules(part)

                if not rule_list:
                    print("Special Rules not found")
                rule_matrix_len = len(rule_list)
                print(rule_matrix_len)
                for i in range(rule_matrix_len):
                    base.DeleteNumberingRules(rule_list[i])


    """


def GetTypesToCompareSettingsValues(key: str, fields: object) -> object:
    """

    Gets the values of parameters concerning 'Compare Settings' window in Compare process (not 'Advanced' options).

    Parameters
    ----------
    key : str
            A string describing the parameters' full name in tree view.
            e.g., "GEOMETRY (PARTS)::PROPERTY::PSHELL".

    fields : object, optional
            A list  with the command we need its value.
            e.g. "compare".

    Returns
    -------
    object
            Returns a dictionary with keys the needed command and values whether it's On/Off.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                results_dict = base.GetTypesToCompareSettingsValues(
                    "GEOMETRY (PARTS)::ANSAPART::Attributes", ["compare"]
                )
                print(results_dict["compare"])


    """


def GetUserDefinedAttribute(
    element_type: str, name: str, deck: int, entity_subtype: str
) -> object:
    """

    This function returns a reference to a user attribute entity with specific name that was created for a specific ANSA keyword. Note that GetEntityCardValues/SetEntityCardValues can be used to get/set the characteristics of user attributes like their Name, Type, Default Value, etc.

    Parameters
    ----------
    element_type : str
            The ANSA keyword.

    name : str
            The user attribute name.

    deck : int, optional
            The deck type.

    entity_subtype : str, optional
            The entity subtype that may exists in addition to the ANSA keyword.

    Returns
    -------
    object
            Returns a reference to a user attribute entity or None if this user attribute was not found.

    See Also
    --------
    CreateUserDefinedAttribute, GetUserDefinedAttributes

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Check if a specific user attribute is defined for the keyword: ANSAPART
                attr = base.GetUserDefinedAttribute(
                    deck=constants.NASTRAN, element_type="ANSAPART", name="MyTestAttribute"
                )
                if attr == None:
                    print("This user attribute does NOT exist for this keyword!")
                else:
                    print("This user attribute does exist for this keyword!")

                    # Example: ask for user attribute characteristics:
                    ret_vals = base.GetEntityCardValues(
                        constants.NASTRAN,
                        attr,
                        ("Entity Type", "Full Name", "Type", "Default Value", "Accepted Values"),
                    )
                    print("Entity Type: ", ret_vals["Entity Type"])
                    print("Full Name: ", ret_vals["Full Name"])
                    print("Type: ", ret_vals["Type"])
                    print("Default Value: ", ret_vals["Default Value"])
                    print("Accepted Values: ", ret_vals["Accepted Values"])


    """


def GetUserDefinedAttributes(
    element_type: str, deck: int, entity_subtype: str
) -> object:
    """

    This function collects all user attribute entities of a specific ANSA keyword. Note that GetEntityCardValues/SetEntityCardValues can be used to get/set the characteristics of user attributes like their Name, Type, Default Value, etc.

    Parameters
    ----------
    element_type : str
            The ANSA keyword.

    deck : int, optional
            The deck type.

    entity_subtype : str, optional
            The entity subtype that may exists in addition to the ANSA keyword.

    Returns
    -------
    object
            Returns a list with all the existing user attribute entities or 0 if no user attribute was found for the given ANSA keyword.

    See Also
    --------
    CreateUserDefinedAttribute, GetUserDefinedAttribute

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Check if a specific user attribute is defined for the keyword: ANSAPART
                user_attributes = base.GetUserDefinedAttributes(
                    deck=constants.NASTRAN, element_type="ANSAPART"
                )
                if not user_attributes:
                    print("No user attributes exist for this keyword!")
                else:
                    print("Total user attributes for this keyword: ", len(user_attributes))

                    # Example: ask for user attribute characteristics:
                    for attr in user_attributes:
                        ret_vals = base.GetEntityCardValues(constants.NASTRAN, attr, ("Full Name",))
                        print("A user attribute exists with name: ", ret_vals["Full Name"])


    """


def GetViewAngles() -> object:
    """

    GetViewAngles() returns the screen view in the form of the angle rotation around X, Y, Z axis.

    Returns
    -------
    object
            Returns a list with three memeber holding the angles.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def angles_test():
                angles = base.GetViewAngles()
                print(
                    "x_angle =  "
                    + str(angles[0])
                    + " y_angle = "
                    + str(angles[1])
                    + " z_angle = "
                    + str(angles[2])
                )


    """


def GetViewButton(fields: object) -> object:
    """

    This function gets the corresponding visibility flag status.
    The flag status is stored in the variable following the name of the button.

    Parameters
    ----------
    fields : object
            A list with button names to obtain their status.

    Returns
    -------
    object
            Returns a dictionary with keys the names of the visibility buttons and
            values 1 or 0, whether they are enabled or not, respectively.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = base.GetViewButton(("SHADOW", "GRIDs"))
                # will get the status of buttons SHADOW and GRIDs and store it in variables "ishadow" and "igrids".
                if not m["SHADOW"]:
                    base.SetViewButton({"SHADOW": "on"})  # If the shadow mode is off, turn it on.


    """


def GetViewMode() -> str:
    """

    This function returns the current view mode to the provided variable.

    Returns
    -------
    str
            Returns the label of the current view mode.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                the_mode = (
                    base.GetViewMode()
                )  # will return the current view mode option to variable the_mode.
                print(the_mode)


    """


def GetZoom() -> object:
    """

    This function returns a list of 9 values with the current Graphic window minimum and
    maximum limits and the rotation center point in the following form:
    [xmin, ymin, zmin, xmax, ymax, zmax, rtcn_x, rtcn_y, rtcn_z].

    Returns
    -------
    object
            Returns a list with 9 values [xmin, ymin, zmin, xmax, ymax, zmax, rtcn_x, rtcn_y, rtcn_z]

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                zoom = base.GetZoom()
                print(zoom)


    """


def InputAdamsView(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function imports a .cmd (Adams/View) format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputAdamsView("/home/users/base.cmd", "keep-old", "keep-old", "offset")


    """


def InputBetaTank(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function imports a .tank format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputBetaTank("C:/temp/users/folder/data.tank", elements_id="offset")


    """


def InputCFX(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    This function imports a CFX format file in ANSA similar to the FILE>INPUT>CFX functionality.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
             If it is set to "on", ANSA CFD Light data will be input.
             (Default: "off")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputCFX(filename="C:/temp/users/folder/data.cfx", cfd_light_mode="on")


    """


def InputFibersim(
    filename: str,
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    input_properties: str = "off",
    merge_files_to_one_laminate: str = "off",
    properties_file_name: str = "",
    merge_to: str = "Nothing",
    thickness_tolerance: float = 0.0,
    theta_tolerance: float = 0.0,
    model_action: str = "merge_model",
) -> int:
    """

    Import a Fibersim file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    input_properties : str, optional
            Flag to Input Nastran Properties.
            Accepted values: "on", "off"
            (Default: "off")

    merge_files_to_one_laminate : str, optional
            Flag to merge multiple input files to one laminate property.
            Accepted values: "on", "off"
            (Default: "off")

    properties_file_name : str, optional
            Nastran file name with properties.

    merge_to : str, optional
            Merge method
            Accepted values: "Laminate", "Laminate by PCOMPG", "Nothing"
            (Default: "Nothing")

    thickness_tolerance : float, optional
            Thickness tolerance for merge_to = "Laminate"
            (Default: "0.0")

    theta_tolerance : float, optional
            Angle tolerance for merge_to = "Laminate"
            (Default: "0.0")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import os
            import ansa


            def main():
                ansa.base.InputFibersim(
                    filename="FS_cylinder.fsim2ansa",
                    input_properties="on",
                    properties_file_name="FS_cylinder.bdf",
                    merge_to="Laminate by PCOMPG",
                )


    """


def InputFreeForm(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function inputs a free format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputFreeForm("C:/temp/users/folder/data.free", elements_id="offset")


    """


def InputInventor(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function imports an .iv format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputInventor("C:/temp/users/folder/data.iv", elements_id="keep-old")


    """


def InputMedina(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    create_ansa_parts: str = None,
    put_layers: str = None,
    model_action: str = "merge_model",
) -> int:
    """

    This function imports a MEDINA format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset","nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset")

    create_ansa_parts : str, optional
            Accepted values: "from_parts", "from_layers", "from_properties"
            (Default: what set at the last execution)

    put_layers : str, optional
            Accepted_values: "in_sets", "in_lockviews", "in_sets_and_lockviews"
            (Default: None)

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputMedina("C:/temp/users/folder/data.bif", elements_id="offset")


    """


def ImportFATXMLTree(fatxml_filename: str, merge_parts: bool) -> int:
    """

    Imports a FATXML file into ANSA without launching the PLMXML tree editor.

    Parameters
    ----------
    fatxml_filename : str
            The file path of the FATXML Tree to read.

    merge_parts : bool, optional
            In order to merge or not the parts.
            (Default: True)

    Returns
    -------
    int
            Returns 1 on success and 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ImportFATXMLTree("C:/temp/users/data.fatxml", merge_parts="False")


    """


def ImportPLMXMLTree(plm_fname: str, dl_list_fname: str, linked_groups: bool) -> int:
    """

    Imports a PLMXML file, or a CATProduct into ANSA without launching the PLMXML tree editor.
    All the products of the tree will be automatically imported into ANSA
    while a download list will be written with all tree information. Upon request,
    a group containing links of all newly created parts, can also be created.

    Parameters
    ----------
    plm_fname : str
            The path to the xml file or to the CATProduct.

    dl_list_fname : str
            The file path to output the D/L List.

    linked_groups : bool, optional
            Option to create a group of links to newly created parts.
            (Obsolete)

    Returns
    -------
    int
            Returns 1 on success and 0 on error.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ImportPLMXMLTree(
                    "/home/demo/tmp/hierarchy.xml",  # the file path of the tree
                    "DownloadList.txt",  # the filename to output the D/L list
                    linked_groups=True,
                )  # Create a group containing links of all newly created part


    """


def ImportProductTree(tree: object, dl_list_fname: str, linked_groups: bool) -> int:
    """

    Imports a product tree into ANSA without launching the product tree editor.
    All the products of the tree will be automatically imported into ANSA
    while a download list will be written with all tree information. Upon request,
    a group containing links of all newly created parts, can also be created.
    The tree is the element returned from a previous call to 'NewProductTree'
    function.

    Parameters
    ----------
    tree : object
            The object of the tree created from the 'NewProductTree' function.

    dl_list_fname : str
            The file path to output the D/L List.

    linked_groups : bool, optional
            Option to create a group of links to newly created parts.
            (Obsolete)

    Returns
    -------
    int
            Returns 1 on success and 0 on error.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create the product tree
                tree = base.NewProductTree()

                # Create a group
                pos_matrix_group = ((1, 0, 0), (0, 1, 0), (0, 0, 1), (0, 0, 1))
                parent_identifier = 0  # no parent for the top level group
                child_identifier = 1
                base.NewPTPart(tree, "group", "MID A", "Version A", "Top Level Group", 0)
                base.NewPTInstance(
                    tree, child_identifier, "group", parent_identifier, pos_matrix_group
                )

                # Create a part
                pos_matrix_part = ((1, 0, 0), (0, 1, 0), (0, 0, 1), (0, 0, 1))
                parent_identifier = child_identifier  # the part belongs to the previous group
                child_identifier += 1
                part_attr = (("Mesh Type", "Fine"), ("Target Mass", "1.5"))
                part_file_attr = (
                    ("PID", 1000),
                    ("Property Name", "Front Part"),
                    ("Material", "ES200"),
                )
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "Part MI", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part
                )
                base.NewPTModel(tree, "part1", "/home/demo/FrontPart.CATPart", part_file_attr, 0)

                # Create an instance to the previously created part
                pos_matrix_instance = ((1, 0, 0, 0), (0, -1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
                child_identifier += 1
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_instance
                )
                # Add a PID offset of 100 to the new instance
                base.SetPTInstancePidOffset(tree, child_identifier, 100)

                # Create a new tailorblanked part
                pos_matrix_part = ((1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
                child_identifier += 1
                part_attr = (("Mesh Type", "Fine"), ("Target Mass", "3.4"))
                part_file_attr = (
                    ("PID", 2000),
                    ("Property Name", "Front TB Part"),
                    ("Material", "ES220"),
                )
                base.NewPTPart(tree, "part2", "MID 2", "Version AB", "Part TB", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part2", parent_identifier, pos_matrix_part
                )
                # Add the first CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/FrontTBPart.CATPart", part_file_attr, 0)

                part_file_attr = (
                    ("PID", 2001),
                    ("Property Name", "Rear TB Part"),
                    ("Material", "ES200"),
                )
                # Add the second CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/RearTBPart.CATPart", part_file_attr, 0)

                # Launch the editor.
                my_settings = base.InputProductTreeSettings()
                my_settings.should_open_window = True
                base.InputModelDefinition(product_tree=tree, settings=my_settings)


    """


def ImportVpmTree(vpm_fname: str, dl_list_fname: str, linked_groups: bool) -> int:
    """

    Imports a VPM file or a CATProduct into ANSA without launching the VPM tree editor.
    All the products of the tree will be automatically imported into ANSA
    while a download list will be written with all tree information. Upon request,
    a group containing links of all newly created parts, can also be created.

    Parameters
    ----------
    vpm_fname : str
            The path to the vpm file or to the CATProduct.

    dl_list_fname : str
            The file path to output the D/L List.

    linked_groups : bool, optional
            Option to create a group of links to newly created parts.
            (Obsolete)

    Returns
    -------
    int
            Returns 1 on success and 0 on error.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ImportVpmTree(
                    "/home/demo/tmp/hierarchy.xml",  # the VPM tree's file path
                    "DownloadList.txt",  # the filename to output the D/L list
                    linked_groups=True,
                )  # Create a group containing links of all newly created part


    """


def InputAbaqus(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    merge_steps_by_name: str = "off",
    new_include: str = "off",
    merge_parts: str = "on",
    read_only: str = "wp",
    read_hmcomments: str = "off",
    create_parameters: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_safety: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    create_assembly_and_instances: str = "off",
    advanced_options: str = "",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    header: str = "merge",
    source_unit_system: utils.UnitSystem = None,
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    The InputAbaqus function imports an Abaqus model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    merge_steps_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    read_hmcomments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    create_parameters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_safety : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    create_assembly_and_instances : str, optional
            Create ASSEMBLY and INSTANCEs. Enable Modules must be turned on in Settings > Decks.

            Accepted values: "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            Defines the entity types to be read:
            dr, Header, Nodes, Elements, Properties, Materials, Sets, Contacts.
            When this argument is defined, only the provided types will be read.
            When dr exists in the beginning of the string the provided types
            will not be read.
            By default, everything will be read.

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            "on" or "off". If left blank, the current ANSA defaults value is assumed.

    header : str, optional
            Accepted values: "overwrite", "skip", "merge", "new"
            (Default: "merge")

    source_unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from the
            argument's unit system to the ANSA unit system after input.
            If no unit system is defined in ANSA, no conversion will take
            place.

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is enabled, it returns a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                # Read Abaqus file with the default options.
                files = utils.SelectOpenFile(0)
                if len(files) > 0:
                    base.InputAbaqus(
                        filename="C:/temp/users/folder/data.inp", merge_steps_by_name=1
                    )


    """


def InputAnsaThickness(filename: str) -> int:
    """

    Imports an Ansa Thickness format file in ANSA, similar to the FILE>INPUT>Ansa Thickness functionality.

    Parameters
    ----------
    filename : str
            The file system path.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputAnsaThickness("C:/temp/users/folder/data.ansat")


    """


def InputAnsys(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    merge_parts: str = "on",
    header: str = "overwrite",
    ignore_enddata: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    coords_id: str = "offset",
    perform_material_synchronization: str = "",
    source_unit_system: utils.UnitSystem = None,
    read_hmcomments: str = "off",
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    store_unsupported_keywords_to_include: str = "off",
) -> int:
    """

    The InputAnsys function imports an Ansys model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old" or
            "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge" or "skip".
            (Default: "overwrite")

    ignore_enddata : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    coords_id : str, optional
            Accepted values: "offset","nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            (Default: current ANSA defaults value)

    source_unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from the
            argument's unit system to the ANSA unit system after input.
            If no unit system is defined in ANSA, no conversion will take
            place.

    read_hmcomments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 in success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                # Read Ansys file with the default options.
                files = utils.SelectOpenFile(0)
                if len(files) > 0:
                    base.InputAnsys(
                        filename="C:/temp/users/folder/data.cdb",
                        ignore_enddata=1,
                        merge_sets_by_name=1,
                    )


    """


def InputCFDPP(
    dirname: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    mcfd_inp: str = "mcfd.inp",
    nodesin: str = "nodesin.bin",
    cellsin: str = "cellsin.bin",
    exbcsin: str = "exbcsin.bin",
    inbcsin: str = "inbcsin.bin",
    cgrpsin: str = "cgrpsin.bin",
    bcnames: str = "mcfd.bc",
    grpnames: str = "mcfd.grp",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    InputCFDPP is a wrapper of INPUT_CFDPP. It supports variable number of arguments.

    Parameters
    ----------
    dirname : str
            The path to the directory to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "offset-freeid" or "keep-new".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values:"offset", "nooffset", "keep-old", "keep-new" or  "offset-freeid".
            (Default: "offset-freeid")

    mcfd_inp : str, optional
            The filename for the mcfd file.
            (Default: "mcfd.inp")

    nodesin : str, optional
            The filename for the nodes data file.
            (Default: "nodesin.bin")

    cellsin : str, optional
            The filename for the cells data file.
            (Default: "cellsin.bin")

    exbcsin : str, optional
            The filename for the external boundary condition file.
            (Default: "exbcsin.bin")

    inbcsin : str, optional
            The filename for the internal boundary condition file.
            (Default: "inbcsin.bin")

    cgrpsin : str, optional
            The filename for the groups data file.
            (Default: "cgrpsin.bin")

    bcnames : str, optional
            The filename for the BC family names file.
            (Default: "mcfd.bc")

    grpnames : str, optional
            The filename for the group names file.
            (Default: "mcfd.grp")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            The filename for the external boundary condition file.
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            By default, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA CFD Light data will be input.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                dir = utils.SelectOpenDir("/home/user/")
                base.InputCFDPP(dirname=dir, nodes_id="keep-old")


    """


def InputCGNS(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    The InputCGNS function imports a CGNS model file in ANSA.

    Parameters
    ----------
    filename : str
            the path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA will use the light volume representation,
            which is more suitable for CFD meshes.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputCGNS("C:/temp/users/folder/data.cgns", elements_id="offset")


    """


def InputFluent(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    skip_inner_faces: str = "on",
    skip_cells: str = "off",
    read_solver_info: str = "off",
    read_comments: str = "off",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    InputFluent imports a fluent file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    skip_inner_faces : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    skip_cells : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_solver_info : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA CFD Light data will be input.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputFluent(
                    filename="C:/temp/users/folder/data.msh",
                    skip_inner_faces="on",
                    skip_cells="off",
                )


    """


def InputLSDyna(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    header: str = "overwrite",
    ignore_enddata: str = "off",
    read_only: str = "wp",
    read_hmcomments: str = "off",
    create_parameters: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_safety: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    create_independent_sections: str = "off",
    model_action: str = "merge_model",
    version: str = "",
    comment_input_annotations: str = "on",
    advanced_options: str = "",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    ignore_primer_keywords: str = "off",
    source_unit_system: utils.UnitSystem = None,
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    propsections_id: str = "offset",
    eos_id: str = "offset",
    hourglass_id: str = "offset",
    functions_id: str = "offset",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    The InputLSDyna function imports a LsDyna model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old"
            or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge", "skip" or "new".
            (Default: "overwrite")

    ignore_enddata : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    read_hmcomments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    create_parameters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_safety : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    create_independent_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    version : str, optional
            Accepted values: "960", "970", "971", "971r5/6",
            "971r71", "971r8", "971r9", "971r10", "r11",
            "r11.1", "r11.2", "r12" or "r13" .
            If left blank, the current version is used.

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    advanced_options : str, optional
            Defines the entity types to be read:
            dr, Header, Nodes, Elements, Properties, Materials, Sets,
            Contacts. When this argument is defined only the provided
            types will be read. When dr exists in the beginning of the
            string the provided types will not be read
            If left blank everything will be read.

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            If left blank, the current ANSA defaults value is assumed.

    ignore_primer_keywords : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    source_unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from the
            argument's unit system to the ANSA unit system after input.
            If no unit system is defined in ANSA, no conversion will take
            place.

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    propsections_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    eos_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new"
            (Default: "offset")

    hourglass_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new"
            (Default: "offset")

    functions_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new"
            (Default: "offset")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is defined,
            it returns a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                # Read LsDyna  file with the default options.
                files = utils.SelectOpenFile(0)
                if len(files) > 0:
                    base.InputLSDyna(filename="C:/temp/users/folder/data.key", header="merge")


    """


def InputMoldex3D(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    The InputMoldex3D function imports a Moldex3D model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 1 in success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputMoldex3D(filename="C:/temp/users/folder/data.mfe")


    """


def InputNastran(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    header: str = "overwrite",
    ignore_enddata: str = "off",
    read_only: str = "wp",
    sets_type_definition: str = "",
    read_hmcomments: str = "off",
    bc_sets_offset: str = "offset",
    create_parameters: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    read_replication_lines: str = "off",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    advanced_options: str = "",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    source_unit_system: utils.UnitSystem = None,
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    The InputNastran function imports a Nastran model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old"
            or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge", "skip" or "new".
            (Default: "overwrite")

    ignore_enddata : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    sets_type_definition : str, optional
            Pairs of ids and type of imported sets. Ranges of sets can be
            specified by a pair of lower and upper ids separated by ":".
            The whole range of imported sets can be represented by "ALL".
            Set type can be assigned the option "NODE", "ELEMENT",
            "DESVAR", "RANDOM", "FATIGUE", "UNDEFINED" or "TRIM".

    read_hmcomments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    bc_sets_offset : str, optional
            Accepted values: "offset" or "keep-old".
            (Default: "offset")

    create_parameters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    read_replication_lines : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    advanced_options : str, optional
            Defines the entity types to be read:
            dr, Header, Nodes, Elements, Properties, Materials, Sets,
            Contacts. When this argument is defined only the provided
            types will be read. When dr exists in the beginning of the
            string the provided types will not be read
            If left blank everything will be read.

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            If left blank, the current ANSA defaults value is assumed.

    source_unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from the
            argument's unit system to the ANSA unit system after input.
            If no unit system is defined in ANSA, no conversion will take
            place.

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off". (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off". (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is enabled, it returns
            a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputNastran("C:/temp/users/folder/data.nas", elements_id="offset")


    """


def InputOpenFoam(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    ctrl_action: str = "overwrite",
    version: str = "v8.0",
    polymesh: str = None,
    binary_io_single_precision: str = "off",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
    binary_io_64bit_integers: str = "off",
) -> int:
    """

    This function imports an OpenFOAM format directory in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid", or the last option used)

    elements_id : str, optional
            Accepted values: "offset","nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid", or the last option used)

    properties_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid", or the last option used)

    ctrl_action : str, optional
            Controls whether to overwrite or not the solver info.
            Accepted values: "overwrite" or "skip".
            (Default: "overwrite", or the last option used)

    version : str, optional
            Accepted values: from "v1.4" to "v8.0".
            (Default: "v8.0")

    polymesh : str, optional
            The subdirectory inside openfoam case where the polymesh folder lies.
            Accepted values: "constant" or "1", "2", "3.0", etc.
            By default, the directory which has the largest arithmetic value
            and contains polymesh folder is assumed.

    binary_io_single_precision : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            By default, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA will use the light volume representation,
            which is more suitable for CFD meshes.
            (Default: "off")

    binary_io_64bit_integers : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            It returns 1 in success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dir = SelectOpenDir("/home/user/")
                base.InputOpenFoam(dir, ctrl_action="skip", version="v1.4", polymesh="constant")


    """


def InputPamCrash(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    header: str = "overwrite",
    ignore_enddata: str = "off",
    read_only: str = "wp",
    version: str = "",
    read_hmcomments: str = "off",
    create_parameters: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_safety: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    advanced_options: str = "",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    source_unit_system: utils.UnitSystem = None,
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    functions_id: str = "offset",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    The InputPamCrash function imports a InputPamCrash model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old"
            or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge" or "skip".
            (Default: "overwrite")

    ignore_enddata : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    version : str, optional
            Accepted values: "2002" or "2003", etc.

    read_hmcomments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    create_parameters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_safety : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    advanced_options : str, optional
            Defines the entity types to be read:
            dr, Header, Nodes, Elements, Properties, Materials, Sets,
            Contacts. When this argument is defined only the provided
            types will be read. When dr exists in the beginning of the
            string the provided types will not be read
            If left blank everything will be read.

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            If left blank, the current ANSA defaults value is assumed.

    source_unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from the
            argument's unit system to the ANSA unit system after input.
            If no unit system is defined in ANSA, no conversion will take
            place.

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    functions_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new"
            (Default: "offset")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is enabled, it returns
            a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputPamCrash(filename="C:/temp/users/folder/data.pc", merge_parts="off")


    """


def InputPatran(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputPatran("C:/temp/users/folder/data.pat", elements_id="offset")


    """


def InputPermas(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    header: str = "overwrite",
    read_only: str = "wp",
    merge_variants_by_name: str = "off",
    medina_to_ansa_parts: str = None,
    put_medina_layers: str = None,
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    advanced_options: str = "",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    store_unsupported_keywords_to_include: str = "off",
) -> int:
    """

    This function imports a Permas model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old"
            or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge" or "skip".
            (Default: "overwrite")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    merge_variants_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    medina_to_ansa_parts : str, optional
            Accepted values: "from_parts", "from_layers" or "from_properties".
            (Default: what set at the last execution)

    put_medina_layers : str, optional
            Accepted values: "in_sets", "in_lockviews" or "in_sets_and_lockviews".
            (Default: None)

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    advanced_options : str, optional
            Defines the entity types to be read:
            dr, Header, Nodes, Elements, Properties, Materials, Sets,
            Contacts. When this argument is defined only the provided
            types will be read. When dr exists in the beginning of the
            string the provided types will not be read
            If left blank everything will be read.

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputPermas(filename="C:/temp/users/folder/data.dat")


    """


def InputRadTherm(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    params_action: str = None,
    model_action: str = "merge_model",
) -> int:
    """
    .. deprecated:: 22.0.0
            Use :py:func:`InputTAITHERM` instead.


    This function imports a RADTHERM format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    params_action : str, optional
            Accepted values: "overwrite" or "skip".
            (Default: what set at the last execution)

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    See Also
    --------
    base.InputTAITHERM

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputRadTherm(filename="/home/test.tdf", elements_id="offset")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 22.0.0. Use :py:func: InputTAITHERM instead.",
        DeprecationWarning,
    )


def InputRadioss(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    version: str = "",
    new_include: str = "off",
    merge_parts: str = "on",
    header: str = "overwrite",
    ignore_enddata: str = "off",
    read_only: str = "wp",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_safety: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    create_parameters: str = "off",
    create_independent_sections: str = "off",
    read_engine_file: str = "off",
    model_action: str = "merge_model",
    comment_input_annotations: str = "off",
    merge_properties_for_time_step: str = "on",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    source_unit_system: utils.UnitSystem = None,
    advanced_options: str = "",
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    ignore_hypercrash_keywords: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    propsections_id: str = "offset-freeid",
    functions_id: str = "offset",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    The InputRadioss function imports a Radioss model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old"
            or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    version : str, optional
            Accepted values: "4.1" or "4.2" or "4.4" or "5.1" or "9.0"
            or "10.0" or "11.0" or "12.0" or "13.0" or "14.0" or "2017" or "2018" or "2019".
            (Default: what set at the last execution)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge" or "skip".
            (Default: "overwrite")

    ignore_enddata : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_safety : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    create_parameters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    create_independent_sections : str, optional
            Enables/ disables 'Create Independent RADIOSS PROPS' selection. Accepted values: "on" or "off".
            (Default: "off")

    read_engine_file : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_properties_for_time_step : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            If left blank, the current ANSA defaults value is assumed.

    source_unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from the
            argument's unit system to the ANSA unit system after input.
            If no unit system is defined in ANSA, no conversion will take
            place.

    advanced_options : str, optional
            Defines the entity types to be read:
            dr, Header, Nodes, Elements, Properties, Materials, Sets,
            Contacts. When this argument is defined only the provided
            types will be read. When dr exists in the beginning of the
            string the provided types will not be read
            If left blank everything will be read.

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    ignore_hypercrash_keywords : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    propsections_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    functions_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new"
            (Default: "offset")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is enabled,
            it returns a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputRadioss(filename="C:/temp/users/folder/dataD00", version="5.1")


    """


def InputSCTetra(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    skip_boundary_file: bool = False,
) -> int:
    """

    This function imports a SCTETRA format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    skip_boundary_file : bool, optional
            Skip the reading of the boundary file.
            By default, ANSA will automatically read the boundary files that are next to the input file ("filename" argument), if they have the same name and a ".s" extension.
            (Default: False)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # this will look for a boundary file in "C:/users/data.s", and read it
                base.InputSCTetra(filename="C:/users/data.pre", elements_id="offset")


    """


def InputSHL(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function imports an SHL format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputSHL("C:/temp/users/folder/data.shl", properties_id="offset")


    """


def InputStarCCM(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    state_name: str = None,
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    The InputStarCCM function imports a StarCCM model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    state_name : str, optional
            The name of the state to be read. By default, if only one state exists, it is read.
            If many states exist, the state named 'state_name' is read (if it exists). If there
            are many states and the 'state_name' is not defined, the first valid state is read.

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            By default, no scaling occurs.

    cfd_light_mode : str, optional
            If set to "on", ANSA CFD Light data will be input.
            (Default: "off")

    Returns
    -------
    int
            Return 1 on success, 0 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputStarCCM(filename="C:/temp/data.ccm", properties_id="nooffset")


    """


def InputStarCD(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    version: str = "v3",
    read_comments: str = "False",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
) -> int:
    """

    The InputStarCD function imports a StarCD model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    version : str, optional
            The version of the solver.
            Accepted values: "v3", "v4".
            (Default: "v3")

    read_comments : str, optional
            'True' or 'False'.
            (Default: 'False')

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputStarCD("C:/temp/users/folder/data.inp", version="v4", read_comments="on")


    """


def InputStereoLithography(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
) -> int:
    """

    Inputs an STL file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    Returns
    -------
    int
            Rreturns 0 on success and 1 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputStereoLithography(
                    "C:/temp/users/folder/data.stl", elements_id="offset-freeid"
                )


    """


def InputTosca(filename: str, model_action: str = "merge_model") -> int:
    """

    Inputs a TOSCA File.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    """


def InputUh3d(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
) -> int:
    """

    Inputs a UH3D file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset","nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    Returns
    -------
    int
            Returns 0 on success and 1 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputUh3d("C:/temp/users/folder/data.uh3d", model_action="overwrite_model")


    """


def InputVrml(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    length: str = "m",
    paste_coincident_nodes: str = "off",
) -> int:
    """

    This function imports a VRML format file in ANSA similar to the FILE>INPUT>VRML functionality.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset","nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    length : str, optional
            Accepted values: "m" or "as-is". "m" option states that the input file
            is in meters and converts it to the current ANSA units. "as-is" option
            states that no conversion will occur.
            (Default: "m")

    paste_coincident_nodes : str, optional
            Accepted values: "on" or "off". When enabled coincident nodes will be
            pasted during input.
            (Default: "off")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputVrml("C:/temp/users/folder/data.msh", elements_id="offset")


    """


def InputWaveFront(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
) -> int:
    """

    InputWaveFront imports a Wave Front file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset","nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset","nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputWaveFront(filename="C:/temp/users/folder/data.wave")


    """


def InsertMetricFile(control: object, filename: str) -> int:
    """

    Inserts a metric file to a control.

    Parameters
    ----------
    control : object
            The selected control object.

    filename : str
            The name of the file to be inserted.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pcontrol = base.GetEntity(constants.PAMCRASH, "CTRL", 1)
                if pcontrol:
                    insert_ok = base.InsertMetricFile(pcontrol, "/tmp/bagin_metricfile")
                    if insert_ok:
                        print("File can not be inserted")


    """


def Intersection(
    topological_paste: bool,
    first_area: object,
    second_area: object,
    reconstruct: bool,
    delete: int,
    keep: object,
) -> object:
    """

    Load 2 different Matrices containing the 2 different areas of SHELLs and/or FACEs.Only FACEs and SHELLs are allowed.

    Parameters
    ----------
    topological_paste : bool
            Set to True if topological paste should follow, else set to False.

    first_area : object
            A list of entities of the first area.

    second_area : object
            A list of entities of the second area.

    reconstruct : bool, optional
            True or False, if reconstruct should follow.

    delete : int, optional
            Set to 0 for NO delete or
            1 for Boolean Union,
            2 for Boolean Intersect,
            3 for Boolean Subtract (first_area - second_area).

    keep : object, optional
            A list of coordinate triplets, that lie on the area to be
            kept ( [[x1,y1,z1], [x2,y2,z2], ..., [xn,yn,zn]] ).

    Returns
    -------
    object
            Returns None on failure (i.e. Frozen Face, Unchecked Face, Multiple input etc.).
            Returns a list with 3 inner lists on success:
            Index 0: a list with the first_area intersected entities.
            Index 1: a list with the second_area intersected entities.
            Index 2: a list with the new cons created at the intersection position
                     (filled only if first_area and second_area contain faces).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pnt1 = base.GetPartFromModuleId("11")
                faces1 = base.CollectEntities(constants.NASTRAN, pnt1, "FACE", False)
                pnt2 = base.GetPartFromModuleId("13")
                faces2 = base.CollectEntities(constants.NASTRAN, pnt2, "FACE", False)
                status = base.Intersection(True, faces1, faces2, True, 1)
                base.RedrawAll()
                print(status)


    """


def Invert() -> int:
    """

    This function inverts the current visibility status in ANSA.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Invert()


    """


def IsEntityDeleted(entity: object) -> bool:
    """

    Examines whether a deleted Entity can be retrieved by the Undelete functionality.

    Parameters
    ----------
    entity : object
            A reference to the entity object.

    Returns
    -------
    bool
            Returns True if the entity is deleted and can be retrieved
            by the UNDELETE function, False otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "FACE", 1)
                if ent and base.IsEntityDeleted(ent):
                    print("Face with id '1' is deleted and can be retrieved by UNDELETE")


    """


def IsEntityVisible(entity: object) -> bool:
    """

    Examines whether an entity is visible or not.
    It is applicable only for elements that have visibility control within ANSA,
    as well as for Parts, Properties, Materials, Sets.

    Parameters
    ----------
    entity : object
            A reference to the entity object.

    Returns
    -------
    bool
            Returns True if the entity is visible, False otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "SHELL", 1)
                if ent and base.IsEntityVisible(ent):
                    print("Shell with id '1' is visible")


    """


def IsolateConnectivityGroups(
    entities: object,
    separate_at_blue_bounds: int,
    separate_at_pid_bounds: int,
    feature_angle: float,
    feature_type: str,
    include_fe_rep_elems: int,
) -> object:
    """

    Isolate entities which form connectivity groups.

    Parameters
    ----------
    entities : object
            A list that can contain faces, volumes, shells and solids.
            If 0 is specified, then the function works on visible.

    separate_at_blue_bounds : int
            If 1 is specified, then regions connected via triple bounds are placed
            into separate connectivity groups. If 0 is specified, then all connected
            entities are placed into the same group.

    separate_at_pid_bounds : int
            If 1 is specified, then all entities contained in a connectivity group will
            have the same PID. If 0 is specified, then each connectivity group
            can contain connected entities with different PIDs.

    feature_angle : float, optional
            Values: 0 - 180, default: 0 (disabled).The feature angle limit in degrees.
            If this value is exceeded, the groups get separated at this feature line.

    feature_type : str, optional
            Values: "convex", "concave", "convex_and_concave".
            Default: convex_and_concave. This option  is considered only when
            separation by feature angle is enabled. Groups get separated at the
            examined bound only if feature_angle is exceeded and the feature type
            is of the specified type.

    include_fe_rep_elems : int, optional
            If 1 is specified, then entities belong to FE representation will be
            included in connectivity groups. If 0 is specified, then entities
            belong to FE representation won't be included in connectivity groups.
            Default value is 0.

    Returns
    -------
    object
            Returns a dictionary.
            The keys are the group names and their respective data are lists containing the entities belonging to each group.
            If no connectivity groups are found, it returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # Example 1:
            # In the following example all entities contained in a single part are collected and
            # then separated into connectivity groups. A new PID is set on each group.
            def main():
                part = base.GetPartFromModuleId("1")

                groups = base.IsolateConnectivityGroups(
                    part, 0, 0, feature_angle=40.0, feature_type="convex", include_fe_rep_elems=0
                )

                for group_name, group_items in groups.items():
                    vals = {"Name": group_name}
                    pid = base.CreateEntity(constants.NASTRAN, "PSHELL", vals)
                    vals = ("PID", "T")
                    ret = base.GetEntityCardValues(constants.NASTRAN, pid, vals)

                    for ent in group_items:
                        vals = {"PID": ret["PID"]}
                        base.SetEntityCardValues(constants.NASTRAN, ent, vals)


            # Example 2:
            # Separate visible entities into connectivity groups and set part to each one:
            def main():
                groups = base.IsolateConnectivityGroups(0, 0, 0)

                for group_name, group_items in groups.items():
                    part = base.NewPart(group_name, group_name)
                    base.SetEntityPart(group_items, part)


    """


def IsolateFringeBarValues(min_val: float, max_val: float) -> int:
    """

    This function isolates all elements whose values are between the given minimum and maximum limits.
    Their values depend on the current view mode(i.e. QGRAPH).

    Parameters
    ----------
    min_val : float
            The minimum value.

    max_val : float
            The maximum value.

    Returns
    -------
    int
            Returns:
            -1, if elements are left visible.
            -0, if arguments are incorrect or no elements match the specified range.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetViewButton({"VIEWMODE": "QGRAPH"})
                base.F11GraphParamsOptionsSet("Quality graph by", "aspect ratio", 0, 0, 0)
                base.IsolateFringeBarValues(1.5, 4.0)


    """


def IsolateSolidFlanges(
    user_items: object,
    recognize_using_all_any_methods: bool,
    recognize_by_shape: bool,
    recognize_by_shape_and_proximity: bool,
    proximity_distance: float,
    proximity_angle: float,
    recognition_by_sets: bool,
    sets: object,
    auto_calculate_orientation: bool,
) -> object:
    """

    The function searches for flanges on a solid base.
    Search flanges by shape and proximity: if it is active, function will search for
    flanges with respect to shape and proximity. Faces that will be returned, match
    both searching methods and not only one.

    Parameters
    ----------
    user_items : object, optional
            A list of properties, parts or faces.
            None:  the function works on visible faces.

    recognize_using_all_any_methods : bool, optional
            False: tries to match all recognition methods.
            True:  tries to match any recognition method.
            (DEPRECATED ARGUMENT)

    recognize_by_shape : bool, optional
            Activates recognition by shape.
            (DEPRECATED ARGUMENT)

    recognize_by_shape_and_proximity : bool, optional
            Activates search for flanges with respect to shape and proximity.

    proximity_distance : float, optional
            Proximity distance of the opposite faces.

    proximity_angle : float, optional
            Angle between the normal vectors of the opposite faces.

    recognition_by_sets : bool, optional
            Activates recognition by sets.
            (DEPRECATED ARGUMENT)

    sets : object, optional
            A list with the ids of sets.
            Faces that belong to these sets will be recognised as solid flanges.
            (DEPRECATED ARGUMENT)

    auto_calculate_orientation : bool, optional
            Activates automatic calculation of orientation.
            Otherwise the existing orientation will be used.

    Returns
    -------
    object
            Returns a list that contains all the faces recognized as flanges, or 0 if an error exists.

    Examples
    --------
    ::

            # Example with shape and proximity.
            # The flanges_matrix variable will contain faces recognized both by shape and proximity.

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "PSHELL", False)
                flanges_matrix = base.IsolateSolidFlanges(
                    props,
                    recognize_by_shape_and_proximity=True,
                    proximity_distance=0.5,
                    proximity_angle=5.0,
                    auto_calculate_orientation=True,
                )
                set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "Solid Flanges"})
                base.AddToSet(set, flanges_matrix)


    """


def IsolateTubes(
    diameter: float, generate_lines: bool, feature_line_angle_limit: float
):
    """

    The function corresponds to the GUI function ISOLATE>HOLES3D of the bottom menu. It leaves
    visible only the tubes with diameter smaller than the given in the diameter argument.

    Parameters
    ----------
    diameter : float
            Tubes with smaller diameter will be isolated.

    generate_lines : bool
            True will create a center line.

    feature_line_angle_limit : float, optional
            The feature line angle limit.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.IsolateTubes(50.0, False)


    """


def KinematicsAddConfigToConfig(PARENT: object, CHILD: object) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`AddConfigToConfig` instead.


    This function adds a kinematic configuration as child to another
    kinematic configuration. In order for the operation to succeed, CHILD
    must not be already contained to PARENT. CHILD is considered to be
    contained in PARENT, if ANY of the Kinematic Joints and Kinematic
    Configurations that CHILD contains, are already contained in PARENT
    or in any Kinematic Configuration that contains PARENT.

    Parameters
    ----------
    PARENT : object
            A kinematic configuration object.

    CHILD : object
            The kinematic configuration that will be added to the PARENT.

    Returns
    -------
    int
            Returns 0 if CHILD was added to PARENT. If PARENT does not exist, the function returns 1.
            If PARENT exists, but CHILD doesn't, the function returns 2.
            Finally, if CHILD cannot be added to PARENT, the return value is 3.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: AddConfigToConfig instead.",
        DeprecationWarning,
    )


def KinematicsAddForceToConfig(CONFIG: object, FORCE: object) -> int:
    """
    .. deprecated:: 17.1.0
            Use :py:func:`AddForceToConfig` instead.


    This function adds a kinematic force to a kinematic configuration. In
    order for the operation to succeed, FORCE must not be already
    contained in CONFIG. FORCE is considered to be contained in CONFIG if
    it is one of its kinematic forces or it is contained in any kinematic
    hierarchy that also contains CONFIG.

    Parameters
    ----------
    CONFIG : object
            A kinematic configuration element that a kinematic force will be added to.

    FORCE : object
            The kinematic force that will be added to the CONFIG.

    Returns
    -------
    int
            Returns 0 if FORCE was added to CONFIG. If CONFIG does not exist, the function returns 1.
            If CONFIG exists, but FORCE doesn't, the function returns 2.
            Finally, if FORCE cannot be added to CONFIG, the return value is 3.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.1.0. Use :py:func: AddForceToConfig instead.",
        DeprecationWarning,
    )


def KinematicsAddJointToConfig(CONFIG: object, JOINT: object) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`AddJointToConfig` instead.


    This function adds a kinematic joint to a kinematic configuration. In
    order for the operation to succeed, JOINT must not be already
    contained in CONFIG. JOINT is considered to be contained in CONFIG if
    it is one of its kinematic joints or it is contained in any kinematic
    hierarchy that also contains CONFIG.

    Parameters
    ----------
    CONFIG : object
            A kinematic configuration entity that a kinematic joint will be added to.

    JOINT : object
            The kinematic joint element that will be added to the CONFIG.

    Returns
    -------
    int
            Returns 0 if JOINT was added to CONFIG. If CONFIG does not exist, the function returns 1.
            If CONFIG exists, but JOINT doesn't, the function returns 2.
            Finally, if JOINT cannot be added to CONFIG, the return value is 3.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: AddJointToConfig instead.",
        DeprecationWarning,
    )


def KinematicsAddToKinematicJoint(JOINT: object, ELEMENT: object) -> int:
    """

    This function adds an element as part of a kinematic joint.

    Parameters
    ----------
    JOINT : object
            The kinematic joint element.

    ELEMENT : object
            The element to add as part of the given kinematic joint.

    Returns
    -------
    int
            Returns 0 if ELEMENT was added to JOINT.
            Otherwise, if JOINT is invalid, the function returns 1.
            If ELEMENT is invalid, the return value is 2.

    """


def KinematicsAddToRigidBody(BODY: object, ELEMENTS) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`AddToRigidBody` instead.


    This function adds an element OR list of elements as part of rigid body.

    Parameters
    ----------
    BODY : object
            The rigid body that the given element is added to.

    ELEMENTS :
            A list of elements to be added in the rigid body.

    Returns
    -------
    int
            Returns 0 if ELEMENT / list of elements was added to BODY.
            Otherwise, if BODY is invalid, the function returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def add_1elem():
                bd = base.GetEntity(base.CurrentDeck(), "KIN_RBODY", 2)
                sh = base.GetEntity(base.CurrentDeck(), "SHELL", 32)
                return base.KinematicsAddToRigidBody(bd, sh)


            def add_list():
                bd = base.GetEntity(base.CurrentDeck(), "KIN_RBODY", 3)
                sh1 = base.GetEntity(base.CurrentDeck(), "SHELL", 33)
                sh2 = base.GetEntity(base.CurrentDeck(), "SHELL", 34)
                return base.KinematicsAddToRigidBody(bd, [sh1, sh2])


            def main():
                ret_1elem = add_1elem()
                ret_list = add_list()
                print(ret_1elem, ret_list)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: AddToRigidBody instead.",
        DeprecationWarning,
    )


def KinematicsConvertToNMap(CONFIG: object, POSITION: object) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`ConvertToTransformation` instead.


    This function relates the current position of a given Kinematic
    Configuration to another Kinematic Position.

    Parameters
    ----------
    CONFIG : object
            A Kinematic Configuration whose current position is to be related to POSITION.

    POSITION : object
            The name of the Kinematic Position that CONFIG's current
            position is to be related. If "Reference Position" is given as the
            second argument, the CONFIG's current position is related to the
            reference position.

    Returns
    -------
    int
            The function returns 0 if the transformation was calculated successfully.
            In all other cases, it may return the following error codes:
            -1, CONFIG is not a Kinematic Configuration entity.
            -2, CONFIG is invalid.
            -3, POSITION was not found among existing Kinematic Positions.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                config = base.GetEntity(constants.ABAQUS, "KIN_CONFIG", 1)

                # "+50 degrees inclination" is the name of a saved kinematic position
                retCode = base.KinematicsConvertToNMap(config, "+50 degrees inclination")

                # Calculate the transform relative to the reference position.
                retCode = base.KinematicsConvertToNMap(config, 0)
                base.KinematicsConvertToNMap(config, "REFERENCE POSITION")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: ConvertToTransformation instead.",
        DeprecationWarning,
    )


def KinematicsMoveConfig() -> object:
    """

    This function performs the actual motion of a kinematicconfiguration. The motion parameters
    must be set by calling thefunction KinematicsSetParameters, before calling this function.

    Returns
    -------
    object
            If move method is 'BY JOINT' or 'BY ACTUATOR JOINT' this function returns
            a 6-entries list with the amount of the performed movement for
            each dof (the first 3 entries correspond to the translational dofs and
            the last 3 to the rotational ones).
            If move method is 'BY TIME' or 'BY MATCHING POINTS',then this function returns 1 on success.
            The function returns zero in case of failure for all move methods.

    """


def KinematicsMoveToPosition(CONFIG: object, POSNAME: str) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`MoveToPosition` instead.


    This function moves a given kinematic configuration to a desired position.
    The position was created by function KinematicsSavePosition.

    Parameters
    ----------
    CONFIG : object
            The kinematic configuration entity to move.

    POSNAME : str
            The name of the desired position.

    Returns
    -------
    int
            The function returns 0 if no error was encountered. If an error was encountered the function
            returns a positive non-zero value. The possible error codes are the following:
            1, CONFIG is not the proper type of element.
            2, CONFIG is not valid.
            3, POSNAME is not valid (e.g empty).
            4, POSNAME is already used by another kinematic position.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                config = base.GetEntity(constants.ABAQUS, "KINCONFIG", 1)
                i = base.KinematicsSavePosition(config, "Saved position name")
                print(i)  # should be 0.


            # ...or...


            def main():
                i = base.KinematicsMoveToPosition(config, "Saved position name")
                print(i)  # should be 0.


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: MoveToPosition instead.",
        DeprecationWarning,
    )


def KinematicsRmvFrKinematicJoint(JOINT: object, ELEMENT: object) -> int:
    """

    This function removes an element which is part of a kinematic joint.

    Parameters
    ----------
    JOINT : object
            The kinematic joint that the given element will be removed from.

    ELEMENT : object
            The element to be removed from the kinematic joint.

    Returns
    -------
    int
            Returns 0 if ELEMENT was removed from JOINT.
            Otherwise, if JOINT is invalid, the function returns 1.
            If ELEMENT is invalid, the return value is 2.

    """


def KinematicsRmvFrRigidBody(BODY: object, ELEMENT: object) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`RemoveFromRigidBody` instead.


    This function removes an element which is part of a rigid body.

    Parameters
    ----------
    BODY : object
            The rigid body that the given element will be removed from.

    ELEMENT : object
            The element to remove the rigid body.

    Returns
    -------
    int
            Returns 0 if ELEMENT was removed from BODY.
            Otherwise, if BODY is invalid, the function returns 1.
            If ELEMENT is invalid, the return value is 2.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: RemoveFromRigidBody instead.",
        DeprecationWarning,
    )


def KinematicsSavePosition(CONFIG: object, NAME: str) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`SavePosition` instead.


    This function saves the current position of a kinematic configuration with a desired name given
    by the user. The saved position can later be recalled by calling the script function
    KinematicsMoveToPosition. Two positions cannot have the same name.

    Parameters
    ----------
    CONFIG : object
            The kinematic configuration whose current position will be saved.

    NAME : str
            The desired name of the configuration's current position.

    Returns
    -------
    int
            The function returns 0 if no error was encountered. If an error was encountered, the function
            returns a positive non-zero value. The possible error codes are:
            1. CONFIG was not a valid kinematic configuration entity.
            2. The function failed to save the position.
            3. NAME is invalid (e.g empty).
            4. NAME is already used by another kinematic position.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                config = base.GetEntity(constants.ABAQUS, "KINCONFIG", 1)
                i = base.KinematicsSavePosition(config, "Saved position name")
                print(i)  # i is 0 if no error was encountered.


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: SavePosition instead.",
        DeprecationWarning,
    )


def KinematicsSetJointStatus(JOINT: object, STATUS: str) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`SetJointStatus` instead.


    This function sets the current status of a kinematic joint entity to either "LOCKED",
    or "UNLOCKED". The status of a newly created joint is set to "UNLOCKED".

    Parameters
    ----------
    JOINT : object
            The reference to the kinematic joint whose status is to be set.

    STATUS : str
            It defines the desired status ("LOCKED" or "UNLOCKED").

    Returns
    -------
    int
            The function returns 0 if the joint's status was altered successfully.
            The return value is 1 if JOINT is invalid, 2 if JOINT is not actually
            a joint entity, 3 if the given STATUS is neither "LOCKED" nor "UNLOCKED",
            and 4 if the STATUS argument was not a string.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                joint = base.GetEntity(constants.LSDYNA, "KIN_JOINT", 1)
                base.KinematicsSetJointStatus(joint, "LOCKED")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: SetJointStatus instead.",
        DeprecationWarning,
    )


def KinematicsSetParameters(
    kin_config: int,
    move_method: str,
    kin_joint: int,
    displacement: float,
    angle: float,
    translate_x: float,
    translate_y: float,
    translate_z: float,
    rotate_x: float,
    rotate_y: float,
    rotate_z: float,
    sp: object,
    tp: object,
    motor_joint: int,
    end_time: float,
    start_at_equilibrium: bool,
    step_size_type: str,
    step_size: float,
    number_of_steps: int,
    results_file: str,
    max_step_size: float,
    translate_x_total: float,
    translate_y_total: float,
    translate_z_total: float,
    rotate_x_total: float,
    rotate_y_total: float,
    rotate_z_total: float,
    displacement_total: float,
    angle_total: float,
) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`ConfigSetParameters` instead.


    This function performs the setup of the kinematic parameters for kinematic configuration motion.

    Parameters
    ----------
    kin_config : int
            The id of the kinematic configuration element
            that motion is to be applied. ANSA SETs to apply mass on.

    move_method : str
            "BY JOINT", "BY MATCHING POINTS", "BY ACTUATOR JOINT", "BY TIME".
            Apply motion to a kinematic joint of a kinematic configuration or
            move a kinematic configuration by matching points or move a kinematic
            configuration by the actuator joint or move a kinematic configuration
            by time.

    kin_joint : int
            The id of the kinematic joint of the kinematic configuration that
            motion is to be applied.

    displacement : float
            Amount of translation to be applied to a kinematic joint. Valid
            only if "MOVE METHOD" = "BY JOINT" or "BY ACTUATOR JOINT"
            and the joint has a translational dof.

    angle : float
            Amount of rotation to be applied to a kinematic joint. Valid
            only if "MOVE METHOD" = "BY JOINT" or "BY ACTUATOR JOINT"
            and the joint has a rotational dof.

    translate_x : float
            Translation in 'X' axis (step).

    translate_y : float
            Translation in 'Y' axis (step).

    translate_z : float
            Translation in 'Z' axis (step).

    rotate_x : float
            Rotation about 'X' axis (step).

    rotate_y : float
            Rotation about 'Y' axis (step).

    rotate_z : float
            Rotation about 'Z' axis (step).

    sp : object
            Either the id of a node to be used as a source point
            or ANSA entity.
            Valid only if "MOVE METHOD" = "BY MATCHING POINTS".
            The node must belong to a rigid body.

    tp : object
            Either the id of a node to be used as a target point
            or ANSA entity.
            Valid only if "MOVE METHOD" = "BY MATCHING POINTS".

    motor_joint : int
            The id of the kinematic joint that will be set
            as the actuator joint of the kinematic configuration
            (optional). If another kinematic joint is already
            defined as the actuator joint of the kinematic
            configuration, this parameter will override the
            previous selection. Valid only if
            "MOVE METHOD" = "BY ACTUATOR JOINT".

    end_time : float
            Total simulation time. Valid only if
            "MOVE METHOD" = "BY TIME".

    start_at_equilibrium : bool
            valid only if "MOVE METHOD" = "BY TIME".

    step_size_type : str
            "NONE", "SIZE", "NUMBER". Valid only if
            "MOVE METHOD" = "BY TIME".

    step_size : float
            Valid only if "MOVE METHOD" = "BY TIME" and "STEP SIZE TYPE"= "SIZE".

    number_of_steps : int
            Valid only if "MOVE METHOD" = "BY TIME" and "STEP SIZE TYPE"= "NUMBER".

    results_file : str
            Desired file name (*.xml). Valid only if "MOVE METHOD" = "BY TIME".

    max_step_size : float
            Maximum step size of HHT-I3 Solver.

    translate_x_total : float
            Translation in 'X' axis (total).

    translate_y_total : float
            Translation in 'Y' axis (total).

    translate_z_total : float
            Translation in 'Z' axis (total).

    rotate_x_total : float
            Rotation about 'X' axis (total).

    rotate_y_total : float
            Rotation about 'Y' axis (total).

    rotate_z_total : float
            Rotation about 'Z' axis (total).

    displacement_total : float
            Total amount of translation to be applied to a kinematic joint.
            Valid only if "MOVE METHOD" = "BY JOINT" or "BY ACTUATOR JOINT"
            and the joint has a translational dof.

    angle_total : float
            Total amount of rotation to be applied to a kinematic joint.
            Valid only if "MOVE METHOD" = "BY JOINT" or "BY ACTUATOR JOINT"
            and the joint has a rotational dof.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # example 1: move the kinematic joint with id 7 of the kinematic
                # configuration with id 1. The joint must have a translational dof.

                base.KinematicsSetParameters(kin_config=1, move_method="BY JOINT")
                base.KinematicsSetParameters(kin_joint=7, translate_z=100.0)
                base.KinematicsMoveConfig()  # performs the motion.

                # example 2: move kinematic configuration with id 3, by matching points

                base.KinematicsSetParameters(kin_config=3, move_method="BY MATCHING POINTS")

                # source point id: 99, target point id: 100. Any number of source-target
                # pair can be used.

                base.KinematicsSetParameters(sp=99, tp=100)
                base.KinematicsMoveConfig()  # performs the actual motion.

                # example 3: move kinematic configuration with id 1, by actuator joint.

                base.KinematicsSetParameters(
                    kin_config=1, move_method="BY ACTUATOR JOINT", rotate_z=10.0
                )
                base.KinematicsMoveConfig()  # performs the motion.

                # example 4: set the kinematic joint with id 3 to be the actuator joint of the kinematic configuration
                # with id 1, and articulate by actuator joint.

                base.KinematicsSetParameters(
                    kin_config=1, move_method="BY ACTUATOR JOINT", motor_joint=3, rotate_z=10.0
                )
                base.KinematicsMoveConfig()  # performs the motion.

                # example 5: set the move method of the kinematic configuration with id 1, set the "END TIME" equal to 20,
                # set the full path filename of the results file, and articulate by time.

                base.KinematicsSetParameters(
                    kin_config=1,
                    move_method="BY TIME",
                    end_time=20,
                    results_file="/home/user/results.xml",
                )
                base.KinematicsMoveConfig()  # performs the motion.


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: ConfigSetParameters instead.",
        DeprecationWarning,
    )


def LaminateCreate(deck: int, fields: object, laminate_type: str) -> object:
    """

    The LaminateCreate function creates a Laminate property valid for all the supported decks.

    Parameters
    ----------
    deck : int
            One of NASTRAN, ABAQUS, LSDYNA, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    fields : object
            Given as pairs of arguments, in order to initialize the definition.

    laminate_type : str, optional
            Accepted values: 'shell', 'tshell' or 'solid'.
            (Default: 'shell')

    Returns
    -------
    object
            Returns a reference to the newly created laminate part on success.
            Otherwise, None is returned.

    See Also
    --------
    LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateSequenceNew(laminate, name="My new sequence")
                base.LaminateLayerNew(
                    constants.NASTRAN, laminate, sequence_pos=2, layer_pos=1, name="My new layer"
                )

                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN,
                    fields={"Name": "Laminate Part", "PID": 1000},
                    laminate_type="solid",
                )


    """


def LaminateInfo(deck: int, laminate: object, fields: object, ret_ents: bool) -> object:
    """

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate Property.

    fields : object
            A list of the edit card fields to retrieve info.

    ret_ents : bool, optional
            If set to True, the returning dictionary will have entities instead of their ids.

    Returns
    -------
    object
            Returns a dictionary with keys the requested fields and values their retrived values on success.
            Otherwise it returns None.
            If ret_ents is set to True, the returning dictionary will have entities instead of their ids.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                ret = base.LaminateInfo(
                    deck=constants.NASTRAN, laminate, ("Name", "PID", "number_sequences")
                )
                print("Laminate Name: ", ret["Name"])
                print("Laminate Id: ", str(ret["PID"]))


    """


def LaminateLayerCopy(laminate: object, sequence_pos: int, layer_pos: int) -> int:
    """

    Parameters
    ----------
    laminate : object
            The laminate object.

    sequence_pos : int
            The position of the sequence to copy.

    layer_pos : int
            The position of the layer to copy.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateLayerCopy(laminate, sequence_pos=1, layer_pos=1)


    """


def LaminateLayerDelete(laminate: object, sequence_pos: int, layer_pos: int) -> int:
    """

    Parameters
    ----------
    laminate : object
            The laminate object.

    sequence_pos : int
            The position of the sequence to delete.

    layer_pos : int
            The position of the layer to delete.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateLayerDelete(laminate, sequence_pos=1, layer_pos=4)


    """


def LaminateLayerInfo(
    deck: int, laminate: object, sequence_pos: int, layer_pos: int, fields: object
) -> object:
    """

    Get values from a Laminate Layer in the specified laminate or pcomp Property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate or pcomp Property.

    sequence_pos : int
            The position of the sequence to retrieve information (always 1 for a pcomp property).

    layer_pos : int
            The position of the layer to retrieve information.

    fields : object
            A list of the fields to retrieve info

            Available fields are:

            NAME (string): The name of the layer
            T (double): The thickness of the layer
            THETA (double): The orientation of the layer
            NIP (integer): The number of integration points through the layer's thickness.
            SOUT (string): "", "YES" or "NO" the NASTRAN output parameter
            type (string): "", "SHELL", "PLANE" or "CORE", the PERMAS ply type
            MID (element): Material of the layer for the given deck
            PLY (element): PLY of the layer for PAMCRASH
            elements (list): A list containing the elements of the layer
            mapped_data (string): "Thick", Orient", "Thickness", "Orientation" or ""
            mapped_thickness (list): A list of the mapped thicknesses of the elements in "elements" matrix
            mapped_orientation (list): A list of the mapped orientations of the elements in "elements" matrix
            FT (string): "", "HOFF", "TSAI", "STRN", "STRS" or "TS" (Solid Laminate, NX Nastran)
            ILFT (string): "" or "NB" (Solid Laminate, NX Nastran)
            color (list): A list with 3 integers (rgb)
            rosette (integer): ID of the rosette
            side (string): "POS", or "NEG"
            active (boolean): layer is active or not
            drape (string): "not_draped", "draped_with_failed_elements", "draped"
            template (integer): Template id
            A (double): Angle between first and second material direction (Radioss)
            visible (boolean): Visibility of the layer
            draw_orientation (boolean): Visibility of the layer orientation. Used in LAMINATE draw mode.
            TMID (element): Thermal material of the layer (LSDYNA).

    Returns
    -------
    object
            Returns a dictionary with keys the 'field' values on success.
            Otherwise, None is retuned.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    constants.NASTRAN, {"Name": "Laminate Part", "PID": 1000}
                )
                ret = base.LaminateLayerInfo(
                    constants.NASTRAN, laminate, 1, 1, {"NAME", "T", "MID"}
                )
                print("Layer Name: ", ret["NAME"])
                print("Layer thickness: ", ret["T"])
                print("Layer MID: ", ret["MID"])


    """


def LaminateLayerModify(
    deck: int,
    laminate: object,
    sequence_pos: int,
    layer_pos: int,
    name: str,
    t: float,
    theta: Any,
    sout: str,
    gplyid: int,
    type: str,
    mat: object,
    ply: object,
    nip: int,
    add_elements: object,
    remove_elements: object,
    mapped_data: str,
    modify_elements: object,
    mapped_thickness: object,
    mapped_orientation: object,
    layer_new_pos: int,
    ft: str,
    ilft: str,
    color: object,
    rosette: object,
    side: str,
    active: bool,
    sequence_new_pos: int,
    template: int,
    regenerate_mapped_data: bool,
    a: float,
    visible: bool,
    draw_orientation: bool,
    mat_thermal: object,
) -> int:
    """

    Modifies a Laminate Layer in the specified laminate Property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate Property.

    sequence_pos : int
            The position of the sequence to modify.

    layer_pos : int
            The position of the layer to modify.

    name : str, optional
            The name of the layer.

    t : float, optional
            The thickness of the layer.

    theta : Any, optional
            double or list,  the orientation/orientations of the layer.

    sout : str, optional
            "", "YES" or "NO" the nastran output parameter.

    gplyid : int, optional
            The GPLYID of the layer.

    type : str, optional
            "", "SHELL", "PLANE" or "CORE", the PERMAS ply type.

    mat : object, optional
            A reference to a material for the layer.

    ply : object, optional
            The element PLY of the layer for PAMCRASH.

    nip : int, optional
            The number of integration points through the layer's thickness.

    add_elements : object, optional
            A list containing the elements to be added to the layer.

    remove_elements : object, optional
            A list containing the elements to be removed from the layer.

    mapped_data : str, optional
            "Thick, Orient", "Thickness", "Orientation" or ""
            "mapped_data" must be set to "Orientation" or "Thick, Orient",
            when changing the "mapped_orientation" of the "modify_elements"
            and must be set to "Thickness" or "Thick, Orient", when changing
            the "mapped_thickness".

    modify_elements : object, optional
            A list of the elements that will be modified.

    mapped_thickness : object, optional
            A list of the mapped thicknesses of the elements in
            "modify_elements" or "add_elements" list.

    mapped_orientation : object, optional
            A list or a list with lists of the mapped orientations of the
            elements in "modify_elements" or "add_elements" list.

    layer_new_pos : int, optional
            The new position of the layer.

    ft : str, optional
            "", "HILL", "HOFF", "TSAI", "STRN", "STRS" or "TS" (Solid Laminate, NX Nastran)

    ilft : str, optional
            "", "SB" or "NB" (Solid Laminate, NX Nastran).

    color : object, optional
            A list with 3 integers (rgb).

    rosette : object, optional
            A rosette id, or None to clear rosette.

    side : str, optional
            "POS" or "NEG".

    active : bool, optional
            If the layer is active or not.

    sequence_new_pos : int, optional
            The new sequence position of the layer.

    template : int, optional
            The template id.

    regenerate_mapped_data : bool, optional
            If the mapped data of the layer will be regenerated when there are elements to be added to it. If it was already draped by ANSA, draping will be reapplied. Otherwise, any existing mapped data will be extrapolated to the newly added elements.

    a : float, optional
            The angle between first and second material direction (Radioss).

    visible : bool, optional
            Visibility of layer.

    draw_orientation : bool, optional
            Visibility of layer orientation. Used in LAMINATE draw mode.

    mat_thermal : object, optional
            The thermal material of the layer (LSDYNA).

    Returns
    -------
    int
            Returns 0 on success, otherwise 1 is retuned.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateLayerModify(
                    constants.NASTRAN, laminate, sequence_pos=1, layer_pos=1, name="Base layer"
                )
                base.LaminateLayerModify(
                    constants.NASTRAN, laminate, sequence_pos=2, layer_pos=2, theta=10.0
                )
                base.LaminateLayerModify(
                    constants.NASTRAN, laminate, sequence_pos=2, layer_pos=3, theta=(10.0, 20)
                )


    """


def LaminateLayerNew(
    deck: int,
    laminate: object,
    sequence_pos: int,
    layer_pos: int,
    gplyid: int,
    t: float,
    theta: object,
    nip: int,
    sout: str,
    type: str,
    mat: object,
    ply: object,
    name: str,
    add_elements: object,
    remove_elements: object,
    mapped_data: str,
    mapped_thickness: object,
    mapped_orientation: object,
    ft: str,
    ilft: str,
    color: object,
    rosette: object,
    side: str,
    active: bool,
    template: int,
    a: float,
    mat_thermal: object,
) -> int:
    """

    Creates a new Laminate Layer in the specified laminate Property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate Property.

    sequence_pos : int
            The position of the new sequence. Use 0 to position this last.

    layer_pos : int
            The position of the new layer. Use 0 to position this last.

    gplyid : int, optional
            The GPLYID of the layer.

    t : float, optional
            The thickness of the layer.

    theta : object, optional
            double or list, the orientation/orientations of the layer.

    nip : int, optional
            The number of integration points through the layer's thickness.

    sout : str, optional
            "", "YES" or "NO" the nastran output parameter.

    type : str, optional
            "SHELL", "PLANE" or "CORE", the PERMAS ply type.

    mat : object, optional
            The material of the layer.

    ply : object, optional
            The element PLY of the layer for PAMCRASH.

    name : str, optional
            The name of the layer.

    add_elements : object, optional
            A list containing the elements to be added to the layer.

    remove_elements : object, optional
            A list containing the elements to be removed from the layer.

    mapped_data : str, optional
            "Thick, Orient", "Thickness", "Orientation" or "".

    mapped_thickness : object, optional
            A list of the mapped thicknesses of the elements
            in "add_elements" matrix.

    mapped_orientation : object, optional
            A list or a list with lists of the mapped orientations of the elements
            in "add_elements" matrix.

    ft : str, optional
            "", "HILL", "HOFF", "TSAI", "STRN", "STRS" or "TS" (Solid Laminate, NX Nastran)

    ilft : str, optional
            "", "SB" or "NB" (Solid Laminate, NX Nastran).

    color : object, optional
            A list with 3 integers (rgb).

    rosette : object, optional
            A rosette id.

    side : str, optional
            "POS" or "NEG". (Default: "POS")

    active : bool, optional
            If the layer is active or not.

    template : int, optional
            The template id.

    a : float, optional
            The angle between first and second material direction (Radioss).

    mat_thermal : object, optional
            The thermal material of the layer (LSDYNA).

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateSequenceNew(laminate, name="My new sequence")
                base.LaminateLayerNew(
                    constants.NASTRAN, laminate, sequence_pos=2, layer_pos=1, name="My new layer"
                )
                base.LaminateLayerNew(
                    constants.NASTRAN, laminate, sequence_pos=2, layer_pos=2, theta=10.0
                )
                base.LaminateLayerNew(
                    constants.NASTRAN,
                    laminate,
                    sequence_pos=2,
                    layer_pos=3,
                    theta=(10.0, 20),
                    color=(100, 155, 255),
                )


    """


def LaminateModify(deck: int, laminate: object, fields: object) -> int:
    """

    Modifies the specified laminate Property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to the laminate Property.

    fields : object
            A dictionary with edit card fields as keys and the modified values as values.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateModify(constants.NASTRANS, laminate, {"Name": "My Laminate Part"})


    """


def LaminateSequenceCopy(laminate: object, sequence_pos: int, mirror: bool) -> int:
    """

    Copies a Laminate Sequence of the specified laminate Property.

    Parameters
    ----------
    laminate : object
            A reference to a laminate Property.

    sequence_pos : int
            The position of the sequence to copy.

    mirror : bool, optional
            True or False option to mirror copy the layers included in the sequence.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateSequenceCopy(laminate, sequence_pos=1)


    """


def LaminateSequenceDelete(laminate: object, sequence_pos: int) -> int:
    """

    Deletes a Laminate Layer from the specified laminate Property.

    Parameters
    ----------
    laminate : object
            A reference to a laminate Property.

    sequence_pos : int
            The position of the sequence to delete.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateSequenceDelete(laminate, sequence_pos=2)


    """


def LaminateSequenceInfo(laminate: object, sequence_pos: int) -> object:
    """

    Gets values from a Laminate Sequence in the specified laminate Property.

    Parameters
    ----------
    laminate : object
            A reference to a laminate Property.

    sequence_pos : int
            The position of the sequence to retrieve information.

    Returns
    -------
    object
            Returns a dict with keys:

            "name"                  string          The name of the sequence
            "number_of_layers"      integer         The number of layers of the sequence
            "active"                boolean         True if at least one layer of the sequence is active. False otherwise.

            In case of error, it returns None.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                ret = base.LaminateSequenceInfo(laminate, sequence_pos=1)
                print(ret["name"])
                print("Number of layers: ", ret["number_of_layers"])


    """


def LaminateSequenceModify(
    laminate: object, sequence_pos: int, name: str, sequence_new_pos: int, active: bool
) -> int:
    """

    Modifies a Laminate Sequence in the specified laminate Property.

    Parameters
    ----------
    laminate : object
            A reference to a laminate Property.

    sequence_pos : int, optional
            The position of the sequence to modify.
            If not given the first sequence will be modified.

    name : str, optional
            The name of the sequence.

    sequence_new_pos : int, optional
            The new position of the sequence.

    active : bool, optional
            Activates or deactivates all the layers of the sequence.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateSequenceModify(laminate, sequence_pos=1, name="Base sequence")


    """


def LaminateSequenceNew(laminate: object, sequence_pos: int, name: str) -> int:
    """

    Parameters
    ----------
    laminate : object
            A reference to a laminate Property.

    sequence_pos : int, optional
            The position of the new sequence.
            Use 0 to position the new sequence last.
            (Default: 0)

    name : str, optional
            The name of the sequence.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.LaminateCreate(
                    deck=constants.NASTRAN, fields={"Name": "Laminate Part", "PID": 1000}
                )
                base.LaminateSequenceNew(laminate, name="My new sequence")
                base.LaminateLayerNew(
                    constants.NASTRAN, laminate, sequence_pos=2, layer_pos=1, name="My new layer"
                )


    """


def LoadInclude(include: object, load_exclusively: bool) -> int:
    """

    Loads the include from its reference (full path name or AnsaDB text). Has the same effect
    as adding the include to the current configuration (or marking for next update if already in configuration)
    and updating the configuration.

    Parameters
    ----------
    include : object
            A reference to an include element.

    load_exclusively : bool, optional
            If True and include is part of a group include, parent will be exclusive,
            include will be the only one loaded among group children.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.NASTRAN, "INCLUDE", 5)
                base.LoadInclude(entity, True)


    """


def LoadIncludeConfiguration(
    include_config: object, load_option: int, incomplete_unload: bool
) -> object:
    """

    Update or reload the include configuration include_config.

    Parameters
    ----------
    include_config : object
            A reference to a configuration object.

    load_option : int
            1, for update include configuration.
            2, for reload include configuration.
            Note: This option renders all pointers to
            entities invalid, including those to configurations and includes.

    incomplete_unload : bool, optional
            True or False (See RETURN).

    Returns
    -------
    object
            Returns 0 if invalid arguments were specified. Returns 1 otherwise.
            If the argument "incomplete_unload" is set to True, the function returns an object with two variables:
            a) success (integer, 0 for failure, 1 for success)
            b) incomplete_entities (list containing the includes that failed to unload)

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                includes_mat = []
                configuration = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE_CONF", {"Name": "INCLUDE_CONFIGURATION1"}
                )
                includes_mat.append(
                    base.CreateEntity(constants.NASTRAN, "INCLUDE", {"Name": "include_1"})
                )
                includes_mat.append(
                    base.CreateEntity(constants.NASTRAN, "INCLUDE", {"Name": "include_2"})
                )
                base.SetConfigurationIncludes(configuration, includes_mat, 1)

                base.LoadIncludeConfiguration(configuration, 2)
                # Because LoadIncludeConfiguration has been called with load_option = 2 (reload), variables "includes_mat", and "configuration" will not be usable after this function.


    """


def LoadStoredLockView(lockview: object) -> int:
    """

    This function accepts as an argument a string with the name of an already
    stored locked view or a lock view object obtained by calling the
    base.StoreLockView function. It restores the saved model view.

    Parameters
    ----------
    lockview : object
            The name of the stored lockview or an object.

    Returns
    -------
    int
            Returns 1 on success or None on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetViewAngles(rot_x=90.0, rot_y=45.0, rot_z=-180.0)
                lockview1 = base.StoreLockView("X_+90_Y-45_Z-180", overwrite=True)
                # restore the lockview using a string name
                base.LoadStoredLockView("X_+90_Y-45_Z-180")
                # restore the same lockview using an object
                base.LoadStoredLockView(lockview1)


    """


def InvertGeomOrientation() -> int:
    """

    This function inverts the orientation of Macros like the FACEs>INVERT function.
    Works only on visible macros or negative volume solid elements.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InvertGeomOrientation()


    """


def PerformGeomOrientation() -> int:
    """

    This function sets a uniform orientation vector to all visible connected Macro Areas and shell
    elements, FE-Model as well.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.PerformGeomOrientation()


    """


def CreateCurvesFromFeatureLines(angle: float, ret_ents: bool) -> object:
    """

    This function creates 3D curves from visible feature lines of a Geometry or FE-Model shell mesh.

    Parameters
    ----------
    angle : float
            The angle to be used for the feature line recognition.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 0.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.CreateCurvesFromFeatureLines(30)


    """


def FillHoleFe(
    diameter: float,
    create_3D_point: str,
    convert_to_connection_point: str,
    create_3D_curve: str,
    number_of_shell_zones_affected: int,
) -> int:
    """

    This function is used to select and close holes according to some measurements given by the user.

    Parameters
    ----------
    diameter : float
            The diameter upon which the holes will be filled.

    create_3D_point : str
            Defines whether to create a 3d point at the center of the
            hole or not. Can be set either "on" or "off".

    convert_to_connection_point : str
            Defines whether to convert the 3d point to connection point
            or not. Can be set either "on" or "off".

    create_3D_curve : str
            Defines whether to create a 3d curve at the hole edges or
            not. Can be set either "on" or "off".

    number_of_shell_zones_affected : int
            The number of shell zones that will be affected.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.FillHoleFe(22, "on", "on", "on", 1)


    """


def MakeNewInstance(PART: object, TRANSFORMATION_MATRIX: object) -> object:
    """

    This function creates a new instance of an existing part/group.
    The position of the new created instance is controlled by a 4X4 transformation matrix.

    Parameters
    ----------
    PART : object
            The part object.

    TRANSFORMATION_MATRIX : object
            A 4x3 list that describes the transformation matrix.

    Returns
    -------
    object
            Returns a reference to the new instance or None in case of error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # the example below, creates a new symmetrical instance of a part
                transf_matrix = ((1, 0, 0, 0), (0, -1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
                master = base.GetPartFromModuleId("10")
                new_inst = base.MakeNewInstance(master, transf_matrix)


    """


def MassBalance(
    sets: object,
    calculate_mass_from: str,
    mass_definition_type: str,
    target_mass: float,
    cog_x: float,
    cog_y: float,
    cog_z: float,
    upper_limiting_factor: float,
) -> int:
    """

    This function adds masses on selected regions of the model in order to modify its total mass and relocate
    its center of gravity. These target regions, where the masses will be spread, are specified using ANSA SETs.

    Parameters
    ----------
    sets : object
            A list of integers (SET ids) or list of entities (SET objects) were the
            mass will be applied.

    calculate_mass_from : str, optional
            Calculates Mass from visible elements or the whole DB. "visible" or "whole_database".

    mass_definition_type : str, optional
            Specifies the definition type of "target_mass" parameter. valid options are
            "total_target_mass" or "mass_to_be_added".

    target_mass : float, optional
            The target mass.

    cog_x : float, optional
            Co-ordinate X of target center of gravity.

    cog_y : float, optional
            Co-ordinate Y of target center of gravity.

    cog_z : float, optional
            Co-ordinate Z of target center of gravity.

    upper_limiting_factor : float, optional
            Upper Bound limiting factor (> 1.).

    Returns
    -------
    int
            Returns 1 on error and 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                sets = (1, 2, 3)
                base.MassBalance(
                    calculate_mass_from="visible",
                    mass_definition_type="total_target_mass",
                    target_mass=3400.5,
                    cog_x=123.0,
                    cog_y=444.0,
                    cog_z=234.0,
                    upper_limiting_factor=2.5,
                    sets=sets,
                )


            # ...or...


            def main():
                sets = (
                    base.GetEntity(constants.NASTRAN, "SET", 1),
                    base.GetEntity(constants.NASTRAN, "SET", 2),
                    base.GetEntity(constants.NASTRAN, "SET", 3),
                )
                base.MassBalance(
                    calculate_mass_from="whole_database",
                    mass_definition_type="mass_to_be_added",
                    target_mass=5.0,
                    cog_x=123.0,
                    cog_y=444.0,
                    cog_z=234.0,
                    upper_limiting_factor=2.5,
                    sets=sets,
                )


    """


def MassesInertiaToHexas(pid_name: str, mode: str, ret_ents: bool) -> object:
    """

    The MassesInertiaToHexas function creates hexahedron elements from mass elements.

    Parameters
    ----------
    pid_name : str
            The name of the solid pid of the hexahedron elements.
            If is set to "", a new solid PID will be created. If the pid_name
             already exists, the created hexahedrons are assigned with that pid.

    mode : str, optional
            If equals "All", all the mass elements are processed. In any other case,
            the function waits for user interaction. User must select from the screen
            the mass elements and confirm the selection. If mode argument is ommited,
            the function enters the selection mode and waits for user interaction.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns None.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.MassesInertiaToHexas("Created_hexas")


    """


def MatchNodes(source_nodes: object, target_nodes: object, move_target: float) -> int:
    """

    Match pairs of nodes to each other. The source nodes will be matched to the
    target nodes. The source and target matrices may contain either
    references to nodes or node ids.
    The target_nodes and source_nodes matrices must have the same number
    of items, otherwise incorrect results may occur.

    Parameters
    ----------
    source_nodes : object
            A list of the nodes to match from.

    target_nodes : object
            A list of the nodes to match to.

    move_target : float, optional
            The valid values are between 0 and 1.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                n1 = base.CreateEntity(constants.NASTRAN, "GRID", {"X1": 0, "X2": 0, "X3": 0})
                n2 = base.CreateEntity(
                    constants.NASTRAN, "GRID", {"X1": 10, "X2": 10, "X3": 10, "Name": "source"}
                )
                n3 = base.CreateEntity(
                    constants.NASTRAN, "GRID", {"X1": 10, "X2": 10, "X3": 0, "Name": "Target"}
                )
                n4 = base.CreateEntity(constants.NASTRAN, "GRID", {"X1": 0, "X2": 10, "X3": 0})

                ret1 = base.GetEntityCardValues(constants.NASTRAN, n1, ("NID",))
                ret2 = base.GetEntityCardValues(constants.NASTRAN, n2, ("NID",))
                ret3 = base.GetEntityCardValues(constants.NASTRAN, n3, ("NID",))
                ret4 = base.GetEntityCardValues(constants.NASTRAN, n4, ("NID",))

                b1 = base.CreateEntity(
                    constants.PAMCRASH,
                    "BEAM",
                    {"N1": ret1["NID"], "N2": ret2["NID"], "IPART": 1, "x1": 1},
                )
                b2 = base.CreateEntity(
                    constants.PAMCRASH,
                    "BEAM",
                    {"N1": ret4["NID"], "N2": ret4["NID"], "IPART": 1, "y1": 1},
                )
                base.MatchNodes(n2, n3, 0.5)


    """


def MaterialOrientation(
    entities: object,
    orientation_elements_type: str,
    orientation_type: str,
    coordinate: object,
    vertical_limit: float,
    orientation_vector: object,
    orientation_element: str,
    orientation_curves: object,
    skip_non_orthotropic_shells: bool,
    orientation_vector_z: object,
    deck: int,
    shear_lock_angle: float,
    detail_level: str,
    orientation_surface: object,
    orientation_surface_flip: bool,
    orientation_surface_axis: str,
    orientation_curves_axis: str,
    orientation_vector_axis: str,
    calculate_thickening: bool,
    spacing: float,
    treat_offending_geometry: bool,
) -> object:
    """

    Just like its GUI counterpart (UTIL->MaterialOrientation) this function specifies the orientation of materials held by Shells, Thick Shells, Solids or Cohesives. The correct orientation is based upon prototypes given by the user.
    These prototypes can be an other element, one or more curves, a coordinate, a vector or a surface.

    Parameters
    ----------
    entities : object
            A list of element entities to apply material orientation.

    orientation_elements_type : str
            One of "shells", "thick_shells", "composite_solids", "solids", "cohesives".

    orientation_type : str
            One of "by_coordinate", "by_vector", "by_theta",
            "by_curves" which accepts both curves and edges, "by_draping",
            "by_surface_and_edge","by_surface_and_vector", "by_vector_and_edge"
            For shells: by_coordinate, by_vector, by_theta, by_curves, by_draping
            For thick_shells: by_coordinate, by_vector, by_theta, by_curves
            For composite_solids: by_coordinate (only in Ansys), by_vector,
            by_theta, by_curves
            For solids: by_surface_and_edge, by_surface_and_vector,
            by_vector_and_edge, by_vector, by_coordinate
            For cohesives: by_coordinate, by_vector, by_theta, by_curves.

    coordinate : object, optional
            A coordinate system.

    vertical_limit : float, optional
            Angle in degrees. Material orientation fails if the angle
            between the normal vector and the vector which
            gives the orientation is lesser than the vertical_limit.

    orientation_vector : object, optional
            A list with three double values. Needed for
            "by_vector", "by_theta", "by_draping",
            "by_surface_and_vector", "by_vector_and_edge"
            (optional):object A list with three double values. Used only for solids.
            xis (optiona): string One of "X", "Y", "Z"

    orientation_element : str, optional
            One of "shells", "thick_shells", "composite_solids", "solids", "cohesives"
            optional): object A shell, thick shell, composite solid or cohesive depending
            on the orientation_elements_type. Needed for "by_theta" or "by_draping".

    orientation_curves : object, optional
            A matrix of curves. Needed for
            "by_curves", "by_surface_and_edge", "by_vector_and_edge".

    skip_non_orthotropic_shells : bool, optional
            Choose whether it will skip non orthotropic shells.

    orientation_vector_z : object, optional
            with three double values. Used only for solids.

    deck : int, optional
            will be used by default.

    shear_lock_angle : float, optional
            Lock angle in degrees. Needed 'by_draping'.

    detail_level : str, optional
            Valid values are 'minimum', 'average', 'maximum'.
            Needed 'by_draping'.

    orientation_surface : object, optional
            A set containing shells or solid facets. Need for
            "by_surface_and_edge", "by_surface_and_vector"

    orientation_surface_flip : bool, optional
            If True, the surface axis is flipped.

    orientation_surface_axis : str, optional
            One of "X", "Y", "Z".

    orientation_curves_axis : str, optional
            One of "X", "Y", "Z".

    orientation_vector_axis : str, optional
            One of "X", "Y", "Z".

    calculate_thickening : bool, optional
            Calculate thickening. Optional only for "by_draping".
            (Default: False)

    spacing : float, optional
            Optional only for "by_draping".
            (Default: 5)

    treat_offending_geometry : bool, optional
            Treat offending geometry. Optional only for "by_draping".
            (Default: True)

    Returns
    -------
    object
            Returns None on success and a list of failed entities if any of the given entities fail to orient.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_material_orientation():
                shells = base.CollectEntities(
                    ansa.constants.ABAQUS,
                    containers=None,
                    search_types="SHELL",
                    filter_visible=True,
                )
                curves = base.CollectEntities(
                    ansa.constants.ABAQUS, containers=None, search_types="CURVE"
                )

                cord = base.GetEntity(ansa.constants.ABAQUS, "ORIENTATION_NODES_R", 1)
                or_elem = base.GetEntity(ansa.constants.ABAQUS, "SHELL", 16009587)

                failed_shells = base.MaterialOrientation(
                    shells, "shells", "by_curves", vertical_limit=5.0, orientation_curves=curves
                )
                failed_shells = base.MaterialOrientation(
                    shells,
                    "shells",
                    "by_theta",
                    vertical_limit=5.0,
                    orientation_element=or_elem,
                    orientation_vector=(1.0, 1.0, 0.0),
                )
                failed_shells = base.MaterialOrientation(
                    shells,
                    "shells",
                    "by_vector",
                    vertical_limit=5.0,
                    orientation_vector=(1.0, 1.0, 0.0),
                )
                failed_shells = base.MaterialOrientation(
                    shells, "shells", "by_coordinate", vertical_limit=5.0, coordinate=cord
                )

                solids = base.CollectEntities(constants.ABAQUS, None, "SOLID")
                surface_set = ansa.base.GetFirstEntity(ansa.constants.ABAQUS, "SET")

                failed = ansa.base.MaterialOrientation(
                    solids,
                    "solids",
                    "by_surface_and_edge",
                    orientation_surface=surface_set,
                    orientation_curves=curves,
                )

                cord = base.CreateEntity(
                    constants.ABAQUS, "ORIENTATION_NODES_DYN", {"N1": 185, "N2": 190, "N3": 210}
                )
                failed = base.MaterialOrientation(
                    solids, "solids", "by_coordinate", coordinate=cord
                )

                failed = base.MaterialOrientation(
                    solids,
                    "solids",
                    "by_vector",
                    orientation_vector=(1.0, 0.0, 0.0),
                    orientation_vector_z=(0.0, 0.0, -1.0),
                )


    """


def MidSurfAuto(
    thick: float,
    faces: object,
    handle_many_solids: bool,
    handle_as_single_solid: bool,
    length: float,
    join_distance: float,
    elem_type: int,
    exact_middle: bool,
    paste_triple_len: float,
    add_features_to_set: int,
    part: str,
    ret_ents: bool,
    property: str,
    join_distance_as_percentage: bool,
    paste_triple_len_as_percentage: bool,
    connect_weldings: bool,
    thickness_ratio: float,
    sharpen_fillets_min_radius: float,
    thickness_limit: float,
    thickness_limit_percentage: float,
    get_result_type: bool,
    steady_thickness_limit: float,
    thickness_sides_min_angle: float,
    thickness_sides_max_width: float,
    intersection_angle: float,
    get_solid_percentage: bool,
    inherit_mesh_from: str,
    reset_resolution_percentage: int,
    collapse_ribs_height: float,
    collapse_ribs_height_as_percentage: bool,
) -> object:
    """

    Creates mesh in the middle surface of solids defined by faces.
    It needs a list of (argument name, argument value) pairs.

    Parameters
    ----------
    thick : float
            The minimum thickness of the solid(s), must be > 0.

    faces : object, optional
            A list of faces and shells. (if 0 is typed then it runs for all faces and shells of the database)

    handle_many_solids : bool, optional
            Deprecated

    handle_as_single_solid : bool, optional
            If set to True, input is handled as a single solid

    length : float, optional
            The target element length must be greater than the minimum thickness.
            By default it equals to the minimum thickness.

    join_distance : float, optional
            The minimum distance where two perimeters are collapsed.

    elem_type : int, optional
            Accepted values:
            -1: QUAD
            -2: TRIA
            -3: MIXED
            -4" ORTHO_TRIA
            (Default:3)

    exact_middle : bool, optional
            If set to False, Y-Treatment is enabled.

    paste_triple_len : float, optional
            The minimum distance where two triple bounds are collapsed.

    add_features_to_set : int, optional
            Deprecated.

    part : str, optional
            Accepted values: "use_existing", "use_current", "auto_create" and "id=<integer>".

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    property : str, optional
            Accepted values: "use_existing", "use_current", "auto_create" and "id=<integer>".

    join_distance_as_percentage : bool, optional
            If set to True, "join_distance" value is used as a percentage with respect to target length.

    paste_triple_len_as_percentage : bool, optional
            If set to True, "paste_triple_len" value is used as percentage with respect to target length.

    connect_weldings : bool, optional
            Is set to True, weldings are automatically connected after casting,

    thickness_ratio : float, optional
            The minimum distance where two areas are connected, expressed as a ratio of the local nodal thickness.

    sharpen_fillets_min_radius : float, optional
            The minimum radius where a fillet is sharpened.

    thickness_limit : float, optional
            The thickness limit for an area to be identified as solid.

    thickness_limit_percentage : float, optional
            The percentage of the area above a thickness_limit where a part would be identified as solid.

    get_result_type : bool, optional
            If set to True it returns the result type of each input part.

    steady_thickness_limit : float, optional
            If get_result_type is enabled it sets the limit where two areas are considered to have different thickness.

    thickness_sides_min_angle : float, optional
            Minimum angle that defines whether a face is identified as thickness side.

    thickness_sides_max_width : float, optional
            Maximum width that defines whether a face is identified as thickness side.

    intersection_angle : float, optional
            Modifies the intersection angle limit. Valid values are between 5 and 45 degrees.

    get_solid_percentage : bool, optional
            Always return solid percentage in the return list (thickness_limit must be set)

    inherit_mesh_from : str, optional
            The full path of the database which is used as a reference for inherit middle mesh.

    reset_resolution_percentage : int, optional
            Reset solid description resolution using a percentage of target element length. If set to 0 resolution is not affected. Default value is 50.

    collapse_ribs_height : float, optional
            The minimum distance under which a rib is collapsed.

    collapse_ribs_height_as_percentage : bool, optional
            If set to True, "collapse_ribs_height" value is used as percentage with respect to target length.

    Returns
    -------
    object
            Returns 0 on success or 1 on failure.
            If ret_ents is True it returns a list with the created entities, or None if no entities are created.
            If get_result_type is True it returns an object 'ret' with the following members:
            ret.type: a list of result types in the following format ["input part id", "output part id", "type", "solid percentage"] or in the following format ["part id", "failed percentage", "type", "solid percentage"] if the part has been identified as solid. Return types are "Ribs", "Steady thickness", "Variable thickness" and "Solid".
            ret.ents: (if ret_ents is True) a list with the created entities, or None if no entities are created

    Examples
    --------
    ::

            from ansa import base


            def main():
                results_list = []

                search_face = ("FACE",)
                all_faces = base.CollectEntities(0, None, search_face, False)
                result = base.MidSurfAuto(
                    faces=all_faces,
                    thick=2.0,
                    length=5.0,
                    elem_type=3,
                    join_distance=50,
                    join_distance_as_percentage=True,
                    paste_triple_len=50,
                    paste_triple_len_as_percentage=True,
                    handle_as_single_solid=False,
                    thickness_limit=5,
                    thickness_limit_percentage=25,
                    get_result_type=True,
                    part="use_current",
                    property="id=5",
                )


    """


def MirrorPartAxis(
    parts: object,
    transformation_mode: str,
    x1: float,
    y1: float,
    z1: float,
    x2: float,
    y2: float,
    z2: float,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: bool,
    ext_connectors: str,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function mirrors parts based on the arguments provided.

    Parameters
    ----------
    parts : object
            A list that contains the part/s to be mirrored.

    transformation_mode : str
            Accepted values: "COPY", "MOVE" or "LINK".

    x1 : float
            First point used to define the mirror axis.

    y1 : float
            First point used to define the mirror axis.

    z1 : float
            First point used to define the mirror axis.

    x2 : float
            Second point used to define the mirror axis.

    y2 : float
            Second point used to define the mirror axis.

    z2 : float
            Second point used to define the mirror axis.

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not. Used only in COPY and
            LINK cases. Supported values are 0, to denote that offset will not take
            place and any other integer to denote the actual property offset value.
            Alternatively, you can set the value to "auto_offset", so that pids will be
            automatically offset by ANSA or "current_property" to assign the current
            PID to all the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source Module Id. It is
            taken into account only when used with the 'NEW PART' option. It is ignored in
            any other case.

    set_mode : str, optional
            Supported values are "COPY", "EXPAND" and "NONE".
            Used only in COPY and LINK cases.
            (Default: "NONE")

    connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved entities should
            be released or not in a MOVE transformation. Supported values are True or False.
            (Default: False)

    ext_connectors : str, optional
            Determines whether external connections and connectors will be included in a
            MOVE transformation. Supported values are "INCLUDE" and "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: "False")

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))

                base.MirrorPartAxis(
                    parts,  # Parts to be mirrored
                    transformation_mode="MOVE",  # Parts will be mirrored-moved
                    x1=10,
                    y1=10,
                    z1=10,  # First point has been defined
                    x2=10,
                    y2=10,
                    z2=11,  # Second point has been defined
                    connectivity=False,  # Connecting nodes will be released
                    ext_connectors="INCLUDE",
                )  # External connections and connectors will also be moved


    """


def MirrorPartPlane(
    parts: object,
    transformation_mode: str,
    x1: float,
    y1: float,
    z1: float,
    x2: float,
    y2: float,
    z2: float,
    x3: float,
    y3: float,
    z3: float,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: bool,
    ext_connectors: str,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function mirrors parts based on the arguments provided.
    The list PARTS contains the part/s to be mirrored.

    Parameters
    ----------
    parts : object
            A list that contains the part/s to be mirrored.

    transformation_mode : str
            Accepted values: "COPY", "MOVE" and "LINK"

    x1 : float
            First point used to define the mirror plane.

    y1 : float
            First point used to define the mirror plane.

    z1 : float
            First point used to define the mirror plane.

    x2 : float
            Second point used to define the mirror plane.

    y2 : float
            Second point used to define the mirror plane.

    z2 : float
            Second point used to define the mirror plane.

    x3 : float
            Third point used to define the mirror plane.

    y3 : float
            Third point used to define the mirror plane.

    z3 : float
            Third point used to define the mirror plane.

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not. Used only in COPY and
            LINK cases. Supported values are 0, to denote that offset will not take
            place and any other integer to denote the actual property offset value.
            Alternatively, you can set the value to "auto_offset", so that pids will be
            automatically offset by ANSA or "current_property" to assign the current
            PID to all the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source Module Id. It is
            taken into account only when used with the 'NEW PART' option. It is ignored in
            any other case.

    set_mode : str, optional
            Supported values are "COPY", "EXPAND" and "NONE".
            Used only in COPY and LINK cases.
            (Default: "NONE")

    connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved entities should
            be released or not in a MOVE transformation. Supported values are True or False.
            (Default: False)

    ext_connectors : str, optional
            Determines whether external connections and connectors will be included in a
            MOVE transformation. Supported values are "INCLUDE" and "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: "False")

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))

                base.MirrorPartPlane(
                    parts,  # Parts to be mirrored
                    transformation_mode="MOVE",  # Parts will be mirrored-moved
                    x1=10,
                    y1=10,
                    z1=10,  # First point has been defined
                    x2=10,
                    y2=10,
                    z2=11,  # Second point has been defined
                    x3=10,
                    y3=11,
                    z3=11,  # Third point has been defined
                    connectivity=False,  # Connecting nodes will be released
                    ext_connectors="INCLUDE",
                )  # External connections and connectors will also be moved


    """


def MirrorPartPoint(
    parts: object,
    transformation_mode: str,
    x: float,
    y: float,
    z: float,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: bool,
    ext_connectors: str,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function mirrors parts based on the arguments provided.

    Parameters
    ----------
    parts : object
            A list that contains the part/s to be mirrored.

    transformation_mode : str
            Accepted values: "COPY", "MOVE" or "LINK".

    x : float
            Point used to define the mirror plane.

    y : float
            Point used to define the mirror plane.

    z : float
            Point used to define the mirror plane.

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not. Used only in COPY and
            LINK cases. Supported values are 0, to denote that offset will not take
            place and any other integer to denote the actual property offset value.
            Alternatively, you can set the value to "auto_offset", so that pids will be
            automatically offset by ANSA or "current_property" to assign the current
            PID to all the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source Module Id. It is
            taken into account only when used with the 'NEW PART' option. It is ignored in
            any other case.

    set_mode : str, optional
            Supported values are "COPY", "EXPAND" and "NONE".
            Used only in COPY and LINK cases.
            (Default: "NONE")

    connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved entities should
            be released or not in a MOVE transformation. Supported values are True or False.
            (Default: False)

    ext_connectors : str, optional
            Determines whether external connections and connectors will be included in a
            MOVE transformation. Supported values are "INCLUDE" and "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: "False")

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))

                base.MirrorPartPoint(
                    parts,  # Parts to be mirror
                    transformation_mode="MOVE",  # Parts will be mirrored-moved
                    x=10,
                    y=10,
                    z=10,  # Point has been defined
                    connectivity=False,  # Connecting nodes will be released
                    ext_connectors="INCLUDE",
                )  # External connections and connectors will also be moved


    """


def ModelCutAddPlane(model_cut: object, cutting_plane: object) -> int:
    """

    Adds a CUTTING PLANE to a MODEL CUT.

    Parameters
    ----------
    model_cut : object
            A reference to a MODEL CUT object.

    cutting_plane : object
            A reference to a CUTTING PLANE object that is to be added to the model_cut.

    Returns
    -------
    int
            Returns 0 on succes, non-zero otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Create a Cutting Plane
                pl1 = base.CreateEntity(
                    ansa.constants.NASTRAN,
                    "CUTTING PLANE",
                    (
                        "Clip",
                        "NO",
                        "oX",
                        2000,
                        "oY",
                        -500,
                        "oZ",
                        500,
                        "xX",
                        1,
                        "xY",
                        0,
                        "xZ",
                        0,
                        "zX",
                        0,
                        "zY",
                        0,
                        "zZ",
                        1,
                    ),
                )

                # Create a Model Cut
                md_cut = base.CreateEntity(ansa.constants.NASTRAN, "MODEL CUT")

                # Put Cutting plane in Model Cut (ModelCutRemovePlane works the same way...)
                base.ModelCutAddPlane(md_cut, pl1)


    """


def ModelCutApply(model_cut: object) -> int:
    """

    Performs a model cut using the CUTTING PLANEs of the MODEL CUT object.

    Parameters
    ----------
    model_cut : object
            The MODEL CUT object that contains the CUTTING PLANEs and performs the cut.

    Returns
    -------
    int
            Returns 0 on succes, non-zero otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def cut_the_model():
                # Create a Cutting Plane
                pl1 = base.CreateEntity(
                    ansa.constants.NASTRAN,
                    "CUTTING PLANE",
                    (
                        "Clip",
                        "NO",
                        "oX",
                        2000,
                        "oY",
                        -500,
                        "oZ",
                        500,
                        "xX",
                        1,
                        "xY",
                        0,
                        "xZ",
                        0,
                        "zX",
                        0,
                        "zY",
                        0,
                        "zZ",
                        1,
                    ),
                )

                # Create a Model Cut
                md_cut = base.CreateEntity(ansa.constants.NASTRAN, "MODEL CUT")

                # Put Cutting plane in Model Cut
                base.ModelCutAddPlane(md_cut, pl1)

                # Perform cut. Model Cut will use the Cutting Plane added to it
                # in order to cut the model
                base.ModelCutApply(md_cut)


    """


def ModelCutRemovePlane(model_cut: object, cutting_plane: object) -> int:
    """

    Removes a CUTTING PLANE from a MODEL CUT.

    Parameters
    ----------
    model_cut : object
            A reference to a MODEL CUT object.

    cutting_plane : object
            A reference to a CUTTING PLANE object that is to be removed from the model_cut.

    Returns
    -------
    int
            Returns 0 on succes, non-zero otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Create a Cutting Plane
                pl1 = base.CreateEntity(
                    ansa.constants.NASTRAN,
                    "CUTTING PLANE",
                    (
                        "Clip",
                        "NO",
                        "oX",
                        2000,
                        "oY",
                        -500,
                        "oZ",
                        500,
                        "xX",
                        1,
                        "xY",
                        0,
                        "xZ",
                        0,
                        "zX",
                        0,
                        "zY",
                        0,
                        "zZ",
                        1,
                    ),
                )

                # Create a Model Cut
                md_cut = base.CreateEntity(ansa.constants.NASTRAN, "MODEL CUT")

                # Put Cutting plane in Model Cut
                base.ModelCutAddPlane(md_cut, pl1)

                # Remove Cutting plane from Model Cut
                base.ModelCutRemovePlane(md_cut, pl1)


    """


def ModifyIncludeSubcontainerRules(
    includes: object, rules: str, keep_existing_rules: bool, empty_before_apply: bool
) -> int:
    """

    This function changes subcontainer rules for the specified includes.

    Parameters
    ----------
    includes : object
            A list with includes.

    rules : str, optional
            Can be declared as a string or a matrix of strings of the following form:
            "Include/Exclude nodes/elements/all entities/steps/loads used (only) by included
            groups/faces/volumes/properties/connections/connector_entities/GEBs/
            thermal loadsets/step managers/steps".

    keep_existing_rules : bool, optional
            Controls if the new rules will be appended to the existing rules.

    empty_before_apply : bool, optional
            Controls if INCLUDE will contain only related to the rules
            entities after Apply All.

    Returns
    -------
    int
            Returns 0 if include is not a valid reference or 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include1 = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)
                include2 = base.GetEntity(constants.NASTRAN, "INCLUDE", 2)

                base.ModifyIncludeSubcontainerRules(
                    include1,
                    keep_existing_rules=True,
                    empty_before_apply=True,
                    rules=(
                        "Include all entities used by included groups",
                        "Exclude nodes used by included groups",
                    ),
                )

                base.ModifyIncludeSubcontainerRules(
                    include2, keep_existing_rules=False
                )  # clear include's subcontainer rules


    """


def HotPointsMatchingDistance(tolerance: float) -> int:
    """

    Sets the nodes tolerance - nodes matching distance.

    Parameters
    ----------
    tolerance : float
            The value used for the hotpoints automatic topology.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.HotPointsMatchingDistance(0.1)


    """


def NameToEnts(pattern: str, deck: int, match: int) -> object:
    """

    Get a list containing elements whose name matches a specific pattern based on the compare mode. If your input contains special characters, use re.escape to escape all the characters in pattern.

    Read the manual of the Python 're' module for help on regular expression syntax.

    Parameters
    ----------
    pattern : str
            It must be a Perl compatible regular expression.
            (internally interpreted by the PCRE library)

    deck : int, optional
            The desired DECK. If no deck is given, the function
            will search entities of all decks.

    match : int, optional
            Control the matching mode of the name lookup.
            Values are:
            -constants.ENM_REGEX: a regular expression match (default)
            -constants.ENM_EXACT: an exact match
            -constants.ENM_SUBSTRING: a sub-string match
            -constants.ENM_SUBSTRING_IGNORECASE: a sub-string case-insensitive match

    Returns
    -------
    object
            Returns None when no name matches are found or a list containing references
            to entities with successful name matches.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # get all entities whose name starts with "Default"
                default_entities = base.NameToEnts("^Default.*")
                if default_entities:
                    for ent in default_entities:
                        print(ent._name)
                # get all entities whose has "Default" as a substring
                default_entities = base.NameToEnts("Default", match=constants.ENM_SUBSTRING)
                if default_entities:
                    for ent in default_entities:
                        print(ent._name)
                # get all entities in Abaqus deck with name starting with "default",
                # regardless of case
                default_abaqus_entities = base.NameToEnts("(?i)^default.*", constants.ABAQUS)
                if default_abaqus_entities:
                    for ent in default_abaqus_entities:
                        print(ent)


    """


def Near(radius: float, dense_search: bool, custom_entities: object) -> int:
    """

    This function can be used in order to bring to visible all entities, which are located within
    a user defined distance from the already visible ones (or from user specified entities provided
    via the 'custom_entities' option) .

    Parameters
    ----------
    radius : float, optional
            The maximum distance from the target entities (visible or custom). Default is 10.

    dense_search : bool, optional
            Flag which controls if interpolation will be made for large entities, in order to
            obtain more points from which projections will be performed to non visible entities.
            This gives more accurate results, but can slow down the function. Default is False.

    custom_entities : object, optional
            A container (Property, Ansa Part, Set, Include or python list)
            for which the near entities will be searched.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                base.Near(radius=10.0)  # applies to the visible entities

                p_face = base.GetEntity(0, "FACE", 1)
                if p_face:
                    base.Near(
                        radius=10.0, dense_search=True, custom_entities=p_face
                    )  # applies to the given FACE
                    m = []
                    m.append(p_face)
                    base.Near(
                        radius=10.0, dense_search=True, custom_entities=m
                    )  # applies to the m list


    """


def NearElements(
    coordinates: object, tolerance: float, search_entities: object
) -> object:
    """

    This function finds elements near a 3D point that are within the specified tolerance.

    Parameters
    ----------
    coordinates : object
            A list with lists of the x, y, z coordinates for which the nearest
            elements need to be found.

    tolerance : float
            The tolerance between the node/point and the searched entities.

    search_entities : object, optional
            A list of objects where the search will take place.

    Returns
    -------
    object
            Returns a list, where every member of the list is a list with the entities found foreach
            xyz given in the xyz lists. The returned list can contain elements of various types.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = (
                    base.GetEntity(constants.NASTRAN, "SET", 4),
                    base.GetEntity(constants.NASTRAN, "PSHELL", 20),
                    base.GetEntity(constants.NASTRAN, "SET", 3),
                )
                coords = (2018, -806, 566)
                results = base.NearElements(search_entities=ents, coordinates=coords, tolerance=50)
                print(results)
                for ent in results:
                    print(base.GetEntityType(constants.NASTRAN, ent))


    """


def NearestNode(
    coordinates: object, tolerance: float, search_entities: object
) -> object:
    """

    This function finds the nearest node to a set of points. A list with lists of the x, y, z
    coordinates are given as input and for each point the nearest node is found.

    Parameters
    ----------
    coordinates : object
            A list with lists of the x, y, z coordinates for
            the nearest node to be found.

    tolerance : float
            The search tolerance.

    search_entities : object, optional
            A list of entities were the search will take place. These entities can be
            parts, properties, sets, materials and set ranges.

    Returns
    -------
    object
            Returns a list, where the elements of the list are references to the closest nodes
            to each point. The first element is a reference to the closest node to the first point
            as it is determined by the x, y, z coordinates of the first element in the coordinates list.
            If a nearest node does not exist None is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = (
                    base.GetPartFromModuleId("9"),
                    base.GetEntity(constants.NASTRAN, "PSHELL", 20),
                    base.GetEntity(constants.NASTRAN, "SET", 1),
                    base.GetEntity(constants.NASTRAN, "MAT1", 16),
                )
                coords = ((5000, -825, 485), (2018, -806, 566))
                results = base.NearestNode(coords, 10, ents)
                for ent in results:
                    print(ent._id)


    """


def NearestShell(
    coordinates: object, tolerance: float, search_entities: object
) -> object:
    """

    This function finds the nearest shell element to a set of 3D points. A list containing lists of the x, y, z
    coordinates is given as input and for each point the nearest node is found.

    Parameters
    ----------
    coordinates : object
            A list containing lists of x, y, z coordinates is given as
            input and for each point the nearest shell is found.

    tolerance : float
            The tolerance between the node/point and the searched entities.

    search_entities : object, optional
            A list of objects where the search will take place.

    Returns
    -------
    object
            Returns a list, where the first element of the list is a reference to the
            shell closest to the first point, the second is a reference to the shell found closest
            to the second point and so on. If a shell does not exist for a point, then None is
            inserted.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = (
                    base.GetPartFromModuleId("9"),
                    base.GetEntity(constants.NASTRAN, "PSHELL", 20),
                    base.GetEntity(constants.NASTRAN, "SET", 1),
                    base.GetEntity(constants.NASTRAN, "MAT1", 20),
                )

                coords = ((5000, -825, 485), (2018, -806, 566))
                results = base.NearestShell(coordinates=coords, tolerance=50, search_entities=ents)

                for ent in results:
                    print(ent)


    """


def Neighb(number_of_steps: str) -> int:
    """

    This function can be used in order to bring to visible neighboring items connected to the
    already visible ones. The string can be a number, which sets the number of steps taken
    each time by the NEIGHB function.

    Parameters
    ----------
    number_of_steps : str
            A number indicating how many steps will be brought
            to visible everytime the NEIGHB function is run. If
            an empty string is given, the number of steps is
            assumed to be "1". 2)"ALL", to bring all neighbours.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Neighb("2")


            # ...or...


            def main():
                base.Neighb("ALL")


    """


def NewGroup(name: str, module_id: str = "") -> Entity:
    """

    This function instructs the program to create a new group named 'name' with module id 'module_id'.
    Please refer to the appropriate ANSA documentation for a detailed documentation on groups and their management.

    Parameters
    ----------
    name : str
            The name of the new part.

    module_id : str, optional
            The module id of the new part.

    Returns
    -------
    Entity
            Returns a reference to the new group, if it is created successfully, and None otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                new_group = base.NewGroup(name="SOME_GROUP", module_id="GROUP58")


    """


def NewGroupFromVisible(name: str, module_id: str, create_links: str) -> object:
    """

    This function creates a new group and adds to it all currently visible parts.

    Parameters
    ----------
    name : str
            The name of the new group.

    module_id : str
            The module_id of the new group.

    create_links : str, optional
            "yes" or "no", to specify the creation of links or move to the new group.
            (Default: "yes")

    Returns
    -------
    object
            Returns a reference to the newly created group, or 0 if it fails.
            Reasons of failure are the existence of a part with the same name or module id.
            In this case different values for NAME and MODULE_ID should be applied.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                group = base.NewGroupFromVisible("My Name", "My Id")
                ret = base.GetEntityCardValues(constants.NASTRAN, group, ("Name", "Module Id"))
                print(
                    "Created group with Name: "
                    + ret["Name"]
                    + " and Module Id: "
                    + ret["Module Id"]
                )
                group = base.NewGroupFromVisible("My Name 2", "My Id 2", create_links="YES")
                ret = base.GetEntityCardValues(constants.NASTRAN, group, ("Name", "Module Id"))


    """


def NewPart(name: str, module_id: str = "") -> Entity:
    """

    This function creates a new part whose name and module id are specified through the name and module_id arguments. The new part appears in the part manager the next time it is launched.

    Parameters
    ----------
    name : str
            The name of the part.

    module_id : str, optional
            The module id of the part.

    Returns
    -------
    Entity
            Returns a reference to the newly created part if it is created successfully and None otherwise.
            Reasons of failure are the existence of a part with the same name or module id.
            In this case different values D should be applied.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.NewPart("Crankshaft", "100")


    """


def Newpoint(x: float, y: float, z: float) -> object:
    """

    Creates a 3D-point.

    Parameters
    ----------
    x : float
            The x coordinate of the point.

    y : float
            The y coordinate of the point.

    z : float
            The z coordinate of the point.

    Returns
    -------
    object
            Returns a reference to the newly created 3D-point.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Newpoint(0, 0, 1)


    """


def NodesOfVisibleElements() -> object:
    """

    Collect all the nodes of the visible elements. This function performs in the same way as
    the GRIDS flag in the ANSA main window except that it does not consider free nodes.

    Returns
    -------
    object
            Returns a dictionary with a reference to a node key, and the
            value '1' as data, for the nodes of the visible elements.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                map_n1 = base.NodesOfVisibleElements()
                base.Invert()
                map_n2 = base.NodesOfVisibleElements()
                base.Invert()

                common_nodes = []
                len = 0
                for key in map_n1.keys():
                    if key in map_n2:
                        common_nodes.append(node)
                set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": set_name})
                base.AddToSet(set, common_nodes)


    """


def NodesToElements(
    nodes: List[int] | List[Entity] | int | Entity, sources: list = ["entities"]
) -> dict:
    """

    Given some nodes, NodesToElements finds the elements that use these nodes.

    Parameters
    ----------
    nodes : List[int]|List[Entity]|int|Entity
            Can be one of the following:
            1) A list with node ids.
            2) A list containing node references.
            3) A specific node id.
            4) A specific reference to a node object.

    sources : list, optional
            A list with values 'entities' and 'bcs'. 'entities' (default) returns the
            elements that use the nodes and 'bcs' returns the boundary conditions
            that use the nodes.

    Returns
    -------
    dict
            Returns a dictionary, where the key of each entry of the dictionary is a reference to the corresponing node.
            The data of the dictionary is a list that contains references to the elements that use the corresponig node.

    See Also
    --------
    NodesToElementsI

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                nodes = []
                nodes.append(
                    base.GetEntity(constants.NASTRAN, "GRID", 5)
                )  # try it with a free node.
                nodes.append(
                    base.GetEntity(constants.NASTRAN, "GRID", 158)
                )  # try it with a used node.

                results = base.NodesToElements(nodes)
                results_num = len(results)
                print(results)

                for key, data in results.items():
                    elems_num = len(data)
                    if elems_num == 0:
                        print("Node with id: " + str(key._id) + " is free!!!!")
                    else:
                        print(
                            "Node with id: "
                            + str(key._id)
                            + " is used by "
                            + str(elems_num)
                            + " elements:"
                        )
                    for j in range(elems_num):
                        print(
                            data[j].ansa_type(constants.NASTRAN)
                            + " element with id: "
                            + str(data[j]._id)
                        )


    """


def Not(
    entities: Entity | Iterable = None,
    deck: int = None,
    keyword: str = None,
    id: int or Iterable = None,
    apply_on_contents: bool = True,
) -> int:
    """

    This function sets the entities matching the criteria defined by the arguments to be non-visible on the screen.

    Parameters
    ----------
    entities : Entity | Iterable, optional
            A list of entities to be removed from the screen.
            NOTE: This argument can be omitted, if the arguments 'keyword'
            and 'id' are defined.

    deck : int, optional
            The deck type of the entities which will be visible,
            (e.g. deck = constants.NASTRAN)

    keyword : str, optional
            The type of entity for the specified id (e.g. "PSHELL").

    id : int or Iterable, optional
            The ID of the specified entity, or a list with the IDs of the
            entities to be removed from the screen.

    apply_on_contents : bool, optional
            If set to True, the focus command will also apply
            on the contents of the given entity, else it will not.
            (Default: True)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "MAT1", 2)
                status = base.Not(ent)

                # ...or...

                status = base.Not(keyword="MAT1", id=2)


    """


def OffsetCons(offset_distance: float, faces: object) -> int:
    """

    Offset CONS lying on faces by a given distance.
    For each CONS, a curve is created at the position prescribed by the offset distance.

    Parameters
    ----------
    offset_distance : float
            The offset distance.

    faces : object, optional
            Can be either a face, a list of faces, a string with value 'visible'
            or a string with value 'all'. If it is called with 'visible', it works with
            all the visible faces . If it is called with 'all', it works with all the faces.
            If faces value is not defined it works with the visible entities.

    Returns
    -------
    int
            Returns 0 pon success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def OffsetCons():
                faces_list = []
                faces_list.append(base.GetEntity(constants.NASTRAN, "FACE", 1201))
                faces_list.append(base.GetEntity(constants.NASTRAN, "FACE", 1202))
                offsetCons = base.OffsetCons(2.5, faces_list)
                print("offsetCons = %d" % offsetCons)


            def OffsetCons2():
                offsetCons = base.OffsetCons(2.5)
                print("offsetCons = %d" % offsetCons)


    """


def OffsetFaces(
    offset_distance: float,
    old_faces: str,
    faces: object,
    part: object,
    property: object,
) -> int:
    """

    Offsets faces by a given distance.

    Parameters
    ----------
    offset_distance : float
            The offset distance.

    old_faces : str
            The old_faces can be "DELETE" or "KEEP".
            (deletes or keeps the original faces).

    faces : object, optional
            Can be either a face, a list of faces, a string with value 'visible'
            or a string with value 'all' . If it is called with 'visible', it works with
            all the visible faces . If it is called with 'all', it works with all the faces.
            If faces value is not defined it works with the visible entities.

    part : object, optional
            Is the part for the created face(s).

    property : object, optional
            Is the property for the created face(s).

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def OffsetFaces():
                faces_list = []
                faces_list.append(base.GetEntity(constants.NASTRAN, "FACE", 1201))
                faces_list.append(base.GetEntity(constants.NASTRAN, "FACE", 1202))
                face1 = base.GetEntity(constants.NASTRAN, "FACE", 1)
                part = base.GetEntityPart(face1)
                pid = base.GetEntity(constants.NASTRAN, "PSHELL", 2)

                offsetFaces = base.OffsetFaces(2.5, "KEEP", faces_list, part, pid)
                print("offsetFaces = %d" % offsetFaces)


            def OffsetFaces2():
                offsetFaces = base.OffsetFaces(2.5, "DELETE")
                print("offsetFaces = %d" % offsetFaces)


    """


def OffsetIds(
    ENT_TYPE: object, OFFSET_VALUE: float, FROZEN_IDS_OFFSET: str, OFFSET_SET_RANGE: int
) -> int:
    """

    This function applies an offset value to ids of predefined or of all the existing model groups
    in the current base.

    Parameters
    ----------
    ENT_TYPE : object
            A group of entities or a list of groups of entities to apply offset value.
            "ALL" for all existing groups of entities.

    OFFSET_VALUE : float
            The offset value.

    FROZEN_IDS_OFFSET : str
            Accepted values: "IGNORE_FROZEN", "RESPECT_FROZEN", "ABORT_IF_FROZEN" or "",
            to determine how to proceed in case of FROZEN id. ("", aborts)

    OFFSET_SET_RANGE : int
            1 or 0, to offset range values of existing set ranges or not.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OffsetIds("ELEMENT", 100000, "", 1)


            def main():
                base.OffsetIds("ALL", 100000, "RESPECT_FROZEN", 0)


            def main():
                types = ("ELEMENT", "GRID", "PROPERTY")
                base.OffsetIds(types, 1000000, "IGNORE_FROZEN", 1)


    """


def OffsetLink(offset_distance: str, faces: object) -> int:
    """

    Offset faces as new faces, linked to the original ones.

    Parameters
    ----------
    offset_distance : str
            A parameter (0-1) of the property thickness, or an absolute (~value).

    faces : object, optional
            Can be either a face, a list of faces, a string with value 'visible'
            or a string with value 'all' . If it is called with 'visible', it works with
            all the visible faces . If it is called with 'all', it works with all the faces.
            If faces value is not defined it works with the visible entities.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def OffsetLink():
                faces_list = []
                faces_list.append(base.GetEntity(constants.NASTRAN, "FACE", 1201))
                faces_list.append(base.GetEntity(constants.NASTRAN, "FACE", 1202))
                offsetlink = base.OffsetLink("~2.5", faces_list)
                print("offsetlink = %d" % offsetlink)


            def OffsetLink2():
                offsetlink = base.OffsetLink("0.5")
                print("offsetlink = %d" % offsetlink)


    """


def Open(filename: str) -> int:
    """

    This function instructs ANSA to open an existing file.

    Parameters
    ----------
    filename : str
            The path to the file that will be opened.

    Returns
    -------
    int
            Returns 0 in case of success or:
            0: OPEN_ANSA_FILE_SUCCESS
            1: OPEN_ANSA_FILE_PERMISSION_DENIED
            2: OPEN_ANSA_FILE_NOT_ANSA_DB
            3: OPEN_ANSA_FILE_NOT_VALID_CAD
            4: OPEN_ANSA_FILE_NOT_COMPATIBLE_DB
            5: OPEN_ANSA_FILE_READ_ERROR
            6: OPEN_ANSA_FILE_CAD_ERROR
            7: OPEN_ANSA_FILE_NOT_ALLOWED_IN_THIS_MODULE

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Open("C:/tmp/users/folder/data.ansa")


    """


def Or(
    entities: Entity | Iterable = None,
    deck: int = None,
    keyword: str = None,
    id: int or Iterable = None,
    apply_on_contents: bool = True,
) -> int:
    """

    This function sets only the entities matching the criteria defined by
    the arguments to be visible on the screen.

    Parameters
    ----------
    entities : Entity | Iterable, optional
            An entity or a list of entities to be isolated on the screen.
            NOTE: This argument can be omitted, if the arguments 'keyword'
            and 'id' are defined.

    deck : int, optional
            The deck type of the entities which will be visible.
            (e.g. deck = constants.NASTRAN)

    keyword : str, optional
            The type of entity for the specified id (e.g. "PSHELL").

    id : int or Iterable, optional
            The ID of the specified entity, or a list with the IDs of the
            entities to be removed from the screen.

    apply_on_contents : bool, optional
            If set to True, the focus command will also apply
            on the contents of the given entity, else it will not.
            (Default: True)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ent = base.GetEntity(0, "PSHELL", 600)
                status = base.Or(ent)

                # ...or...

                status = base.Or(keyword="PSHELL", id=600)


    """


def Orient(items_array: object) -> int:
    """

    Orients visible faces/shells/solids.

    Parameters
    ----------
    items_array : object, optional
            A list of faces/shells/solids to be oriented.

    Returns
    -------
    int
            Returns:
            1: If the orientation was made uniform.
            2: If the orientation was inverted.
            0: In any other case.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Orient()


    """


def OutputAbaqus(
    filename: str,
    mode: str,
    write_comments: str,
    preserve_ids_in_names: str,
    element_sets_as_surfaces: str,
    solver: str,
    split_pyramid: str,
    disregard_includes: str,
    output_element_thickness: str,
    thickness: float,
    apply_subcontainer_rules: str,
    version: str,
    substructure: int,
    lf_mode: str,
    output_numbering_rules: str,
    include_output_mode: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    cosimulation: int,
    update_include_fname: str,
    output_parameter_keywords: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    comment_output_lock_views: str,
    advanced_options: str,
    include: object,
    configuration: object,
    comment_output_annotations: str,
    comment_output_attributes: str,
    mbcontainer: object,
    target_unit_system: object,
    create_include_output_directory: str,
    substructures: Any,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    output_heading_keyword: str,
    output_heading_keyword_main_file: str,
    comment_output_fe_perimeters: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_features: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs an Abaqus format file like the FILE>OUTPUT>ABAQUS functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            mode="custom_mbcontainer" can be used only
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "as_v_11_2_4", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    preserve_ids_in_names : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    element_sets_as_surfaces : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    solver : str, optional
            "standard" or "explicit".
            (Default: "explicit" if there is at least one active explicit step, otherwise "standard")

    split_pyramid : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_element_thickness : str, optional
            "off", "at_element_card", "as distribution" or "at_property_card".
            (Default: what set at the last execution)

    thickness : float, optional
            The value of the element thickness.
            (Default: "0.0")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    version : str, optional
            The abaqus version.
            (Default: what set at the last execution)

    substructure : int, optional
            Deprecated. Use the "substructures" argument instead.

            The id of the Substructure to output.
            (Default: "0")

    lf_mode : str, optional
            "dos", "unix" or "system native".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    cosimulation : int, optional
            The cosimulator entity id.
            (Default: "0")

    update_include_fname : str, optional
            "on" or "off". Corresponds to the "Update Include
            ReferenceFile" option of the Output Parameters of
            the GUI function.
            (Default: "off")

    output_parameter_keywords : str, optional
            "on" or "off".
            (Default: "off")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of dw, wo, followed by Header, UHeader, Nodes, UNodes,
            Elements, UElement, Properties, UProperties,
            Materials, UMaterials, Sets, USets, Contacts, UContacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    include : object, optional
            The reference to an include entity.
            Should not be used along with "configuration" or
            "mbcontainer" argument.

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" or
            "mbcontainer" argument.
            Outputs either an inactive configuration when no other.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    mbcontainer : object, optional
            The reference to an ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN entity
            Should not be used along with "include" or
            "configuration" argument.
            If used, mode argument must be
            set to "custom_mbcontainer"

    target_unit_system : object, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from
            ANSA's unit system to the argument's unit system before
            output. If no unit system is defined in ANSA, no conversion
            will take place.

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    substructures : Any, optional
            It can be either a list with the Substructure entities we want to output or 'all' in order to output all available Substructures. This option must be used along with mode='model'.

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    output_heading_keyword : str, optional
            "on" or "off".
            (Default: "on")

    output_heading_keyword_main_file : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off".
            (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def get_include_by_name(name):
                ents = base.NameToEnts(name)
                for ent in ents:
                    if base._ansaType(constants.ABAQUS, ent) == "INCLUDE":
                        return ent
                return 0


            # ...or...


            def main():
                base.OutputAbaqus(filename="C:/temp/users/folder/data.inp", disregard_includes="on")
                include_entity = get_include_by_name("data.inp")
                if include_entity:
                    base.OutputAbaqus("include", include_entity)


            # ...or...


            def main():
                loadcase = base.GetFirstEntity(constants.ABAQUS, "ANSA_LOADCASE")
                base.OutputAbaqus(
                    filename="C:/users/folder/data.inp",
                    mbcontainer=loadcase,
                    mode="custom_mbcontainer",
                )


    """


def OutputAdamsView(filename: str, mode: str = "", adams_name: str = "") -> int:
    """

    This function outputs an AdamsView file.

    Parameters
    ----------
    filename : str
            The path to the directory to export.

    mode : str, optional
            "all" or "model" or "visible".
            The default option is defined in ANSA Defaults.

    adams_name : str, optional
            "on" or "off". Modifies the kinematic entities names
            according adams hierarchy rules.
            The default option is defined in ANSA Defaults.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    InputAdamsView

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                dir = utils.SelectSaveDir("/home/user/")
                base.OutputAdamsView(dir, "all", "on")


    """


def OutputAnsys(
    filename: str,
    mode: str,
    beam_node_orient: str,
    write_comments: str,
    lf_mode: str,
    output_numbering_rules: str,
    include: object,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_misc: str,
    comment_output_inline_include: str,
    comment_output_lock_views: str,
    version: str,
    configuration: object,
    comment_output_annotations: str,
    mbcontainer: object,
    target_unit_system: object,
    create_include_output_directory: str,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_fe_perimeters: str,
    comment_output_features: str,
    workbench_compatible: str,
    entities: object,
    advanced_options: str,
) -> int:
    """

    This function outputs an Ansys format file like the FILE>OUTPUT>ANSYS functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be used
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    beam_node_orient : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    write_comments : str, optional
            "none" or "at_eof".
            (Default: what set at the last execution)

    lf_mode : str, optional
            "dos", "unix" or "system native".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    include : object, optional
            A reference to an include entity.
            Should not be used along with "configuration" or
            "mbcontainer" argument.

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_misc : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    version : str, optional
            "11.0", "12.0", "12.1", "13.0", "14.0", "14.5", "15.0", "16.0", "17.0", "18.0", "19.0" or "All".
            (Default: what set at the last execution)

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" or
            "mbcontainer" argument.
            Outputs either an inactive configuration when no other.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    mbcontainer : object, optional
            The reference to an ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN entity
            Should not be used along with "include" or
            "configuration" argument.
            If used, mode argument must be
            set to "custom_mbcontainer"

    target_unit_system : object, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from
            ANSA's unit system to the argument's unit system before
            output. If no unit system is defined in ANSA, no conversion
            will take place.

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off".
            (Default: "off")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    workbench_compatible : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    advanced_options : str, optional
            One of dw, wo, followed by Header, UHeader,
            Nodes, UNodes, Elements, UElement, Properties,
            UProperties, Materials, UMaterials,
            Sets, USets, Contacts, UContacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputAnsys(
                    "C:/temp/users/folder/data.cdb", mode="visible", write_comments="at_eof"
                )


            # ...or...


            def main():
                loadcase = base.GetFirstEntity(0, "ANSA_LOADCASE")
                base.OutputAnsys(
                    filename="C:/users/folder/data.cdb",
                    mbcontainer=loadcase,
                    mode="custom_mbcontainer",
                )


    """


def OutputBetaTank(filename: str, mode: str = "") -> int:
    """

    Parameters
    ----------
    filename : str
            The name of the output file; must contain the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputBetaTank("c:/temp/users/folder/data.tank", "all")


    """


def OutputCFDPP(
    dirname: str,
    mode: str = "",
    nodesin: str = "nodesin.bin",
    cellsin: str = "cellsin.bin",
    exbcsin: str = "exbcsin.bin",
    inbcsin: str = "inbcsin.bin",
    cgrpsin: str = "cgrpsin.bin",
    bcnames: str = "mcfd.bc",
    grpnames: str = "mcfd.grp",
    model_check: str = "off",
    model_check_template: str = None,
    cancel_output_if_model_check_error: str = "on",
    unit_system: utils.UnitSystem = None,
    scale: float = 1.0,
) -> int:
    """

    OutputCFDPP is a wrapper of OUTPUT_CFDPP. It supports variable number of arguments.

    Parameters
    ----------
    dirname : str
            The path to the directory to import.

    mode : str, optional
            "all" or "model" or "visible".

    nodesin : str, optional
            The filename for nodes data file.
            (Default: "nodesin.bin")

    cellsin : str, optional
            The filename for cells data file.
            (Default: "cellsin.bin")

    exbcsin : str, optional
            The filename for external boundary condition file.
            (Default: "exbcsin.bin")

    inbcsin : str, optional
            The filename for internal boundary condition file.
            (Default: "inbcsin.bin")

    cgrpsin : str, optional
            The filename for groups data file.
            (Default: "cgrpsin.bin")

    bcnames : str, optional
            The filename for BC family names file.
            (Default: "mcfd.bc")

    grpnames : str, optional
            filename for group names file.
            (Default: "mcfd.grp")

    model_check : str, optional
            "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The name of template to run if model_check is "on".

    cancel_output_if_model_check_error : str, optional
            "on" or "off".
            (Default: "on")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: 1.0)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                dir = utils.SelectSaveDir("/home/user/")
                base.OutputCFDPP(dirname=dir, mode="all")


    """


def OutputCFX(
    filename: str,
    mode: str = "",
    format: str = "ascii",
    unit_system: utils.UnitSystem = None,
    scale: float = 1.0,
) -> int:
    """

    This function outputs a CFX format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "ascii" or "binary".
            (Default: "ascii")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: 1.0)

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputCFX("C:/temp/users/folder/data.cfx5", mode="all", format="binary")


    """


def OutputCGNS(
    filename: str,
    mode: str,
    deck: int,
    format: str = "unstructured",
    write_separated: str = "no",
    unit_system: utils.UnitSystem = None,
    scale: float = 1.0,
    filetype: str = "ADF",
    unstructured_options: str = "mixed",
    write_families: str = "no",
    version: str = "",
    bc_correspondence: str = "",
    ignore_shell_orientation: str = "",
    write_unmeshed_volumes: str = "",
) -> int:
    """

    OutputCGNS is a wrapper of OUTPUT_CGNS. It supports variable number of arguments.

    Parameters
    ----------
    filename : str
            The name of the output file; must include
            the full path to the file.

    mode : str
            "all" or "model" or "visible".
            (Default: "all")

    deck : int
            The current deck.

    format : str, optional
            "structured" or "unstructured".
            (Default: "unstructured")

    write_separated : str, optional
            "yes" or "no".
            It controls whether to output elements in
            different sections or not.
            (Default: "no") - Obsolete, use unstructured_options instead

    unit_system : utils.UnitSystem, optional
            A UnitSystem object.
            Dictates the length unit to which the
            output will be scaled from the existing
            ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments
            are defined, the latter will override the first.
            (Default: 1.0)

    filetype : str, optional
            Select the type of the output file.
            Can be "HDF5" or "ADF", in
            both upper- and lower-case.
            (Default: "ADF")

    unstructured_options : str, optional
            "mixed" or "separated" or "ngon".
            It controls the format of unstructured meshes.
            "mixed" - output all elements in a common section.
            "separated" - output elements in different sections
            based on their types.
            "ngon" - output elements as arbitrary polyhedral elements.
            (Default: "mixed")

    write_families : str, optional
            "yes" or "no".
            It controls whether to group boundary conditions under Famliy_t nodes and write them with FamilySpecified type or not.
            (Default: "no")

    version : str, optional
            "v3.2.0" or "v4.2.0"
            It controls the CGNS library version of the output file.
            (Default: the value of the keyword "Output CGNS Library Version" in ANSA defaults)

    bc_correspondence : str, optional
            "yes" or "no".
            It controls whether to group surface elements in different Element_t sections per boundary condition or not.
            (Default: "no")

    ignore_shell_orientation : str, optional
            "yes" or "no".
            It controls whether to respect the orientation of surface elements or not. If "no" is selected the orientation is the one of the underlying solid facet.
            (Default: "no")

    write_unmeshed_volumes : str, optional
            "yes" or "no".
            It controls whether to write the surface elements of unmeshed volumes. The zone under which these elements will be written corresponds to volume PID.
            (Default: "no")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputCGNS(
                    "C:/users/data.cgns",
                    mode="visible",
                    filetype="HDF5",
                    unstructured_options="ngon",
                )


    """


def OutputFibersim(
    filename: str, mode: str = "", pid: int = None, mid: int = None
) -> int:
    """

    Output a Fibersim file.

    Parameters
    ----------
    filename : str
            The filesystem path.

    mode : str, optional
            "all", "model" or "visible".
            (Default: what set at the last execution)

    pid : int, optional
            PID start (obsolete)

    mid : int, optional
            MID start (obsolete)

    Returns
    -------
    int
            This function returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import os
            import ansa


            def main():
                ansa.base.OutputFibersim(filename="pillar.h5", mode="all")


    """


def OutputFluent(
    filename: str,
    mode: str = "",
    format: str = "ascii",
    write_solver_info: str = "off",
    write_comments: str = "none",
    model_check: str = "off",
    model_check_template: str = None,
    cancel_output_if_model_check_error: str = "on",
    unit_system: utils.UnitSystem = None,
    scale: float = 1.0,
) -> int:
    """

    OutputFluent output a FLUENT file. It supports variable number of arguments.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path to
            the file.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "binary", "ascii", "hdf5".
            (Default: "ascii")

    write_solver_info : str, optional
            "on", "off".
            (Default: "off")

    write_comments : str, optional
            "none" , "off", "at_eof".
            (Default: "none")

    model_check : str, optional
            "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The name of template to run if model_check is "on".

    cancel_output_if_model_check_error : str, optional
            "on" or "off".
            (Default: "on")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: 1.0)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputFluent(
                    "C:/temp/data.msh", write_comments="at_eof", write_solver_info="on"
                )


    """


def OutputFluent2D(
    filename: str,
    mode: str = "",
    format: str = "ascii",
    write_solver_info: str = "off",
    write_comments: str = "none",
    unit_system: utils.UnitSystem = None,
    scale: float = 1.0,
) -> int:
    """

    Outputs a FLUENT2D file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path to the file.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "binary", "ascii".
            (Default: "ascii")

    write_solver_info : str, optional
            "on", "off".
            (Default: "off")

    write_comments : str, optional
            "none" , "off", "at_eof".
            (Default: "none")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: 1.0)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputFluent2D(
                    "C:/temp/data.msh", write_comments="at_eof", write_solver_info="on"
                )


    """


def OutputFreeForm(filename: str, mode: str = "", solids: str = "off") -> int:
    """

    This function outputs a model in Free Format.

    Parameters
    ----------
    filename : str
            The file system path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    solids : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                OutputFreeForm("/temp/users/folder/data.free", "all", "off")


    """


def OutputIdeasMseries(
    filename: str, mode: str = "", format: str = "", output_pyramids: str = "off"
) -> int:
    """

    This function outputs an I-DEAS M-Series format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "MS_8", "MS_9", "MS_10" or "MS_11".
            (Default: what set at the last execution)

    output_pyramids : str, optional
            "on", "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputIdeasMseries("c:/temp/users/folder/data.mse", "all", "MS 8")


    """


def OutputIdeasV(filename: str, mode: str = "") -> int:
    """

    This function outputs a .unv format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputIdeasV("C:/temp/users/folder/data.unv", "all")


    """


def OutputInventor(
    filename: str, mode: str = "", format: str = "All in ONE", angle: float = 0.0
) -> int:
    """

    Outputs an Inventor format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "All in ONE" or "Separate PIDs".
            (Default: "All in ONE")

    angle : float, optional
            The angle.
            (Default: 0.0)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputInventor("C:/temp/users/folder/data.iv", "all", "All in ONE", 20)


    """


def OutputLSDyna(
    filename: str,
    mode: str,
    write_comments: str,
    format: str,
    enddata: str,
    disregard_includes: str,
    output_element_thickness: str,
    thickness: float,
    apply_subcontainer_rules: str,
    lf_mode: str,
    output_numbering_rules: str,
    include_output_mode: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    update_include_fname: str,
    output_parameter_keywords: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    fields_format: str,
    comment_output_lock_views: str,
    advanced_options: str,
    include: object,
    configuration: object,
    substructure: int,
    comment_output_annotations: str,
    comment_output_attributes: str,
    mbcontainer: object,
    target_unit_system: object,
    create_include_output_directory: str,
    substructures: Any,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_connections_user_defined_geometry: str,
    output_primer_kinematic_entities: str,
    comment_output_fe_perimeters: str,
    comment_output_features: str,
    comment_output_as_hypermesh: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs an LS Dyna format file like the FILE>OUTPUT>LS-DYNA functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all" , "model", "visible" or "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be used
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "as_v_11_2_4", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    format : str, optional
            "960", "970", "971", "971R5/6", "971R71", "971R8", "971R9", "971R10", "R11", "R11.1", "R11.2", "R12", or "R13".
            (Default: what set at the last execution)

    enddata : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_element_thickness : str, optional
            "off", "at_element_card" or "at_property_card".
            (Default: what set at the last execution)

    thickness : float, optional
            The thickness of the element.
            (Default: "0.0")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    lf_mode : str, optional
            "system native", "unix" or "dos".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    update_include_fname : str, optional
            "on" or "off". Corresponds to the "Update Include
            ReferenceFile" option of the Output Parameters
            of the GUI function.
            (Default: "off")

    output_parameter_keywords : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    fields_format : str, optional
            "short", "long", "short_i10_keyword_option" or "short_i10_percent_sign".
            (Default: what set at the last execution)

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of w, dw, followed by Header, UHeader, Nodes, UNodes,
            Elements, UElements, Properties, UProperties,
            Materials, UMaterials, Sets, USets, Contacts, UContacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    include : object, optional
            The reference to the include entity.
            Should not be used along with "configuration" or
            "mbcontainer" argument.

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" or
            "mbcontainer" argument.
            Outputs either an inactive configuration when no other.

    substructure : int, optional
            Deprecated. Use the "substructures" argument instead.

            The id of the substructure entity to be output. If set to -1 all substructures will be output. This option must be used along with mode='model'.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    mbcontainer : object, optional
            The reference to an ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN entity
            Should not be used along with "include" or
            "configuration" argument.
            If used, mode argument must be
            set to "custom_mbcontainer"

    target_unit_system : object, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from
            ANSA's unit system to the argument's unit system before
            output. If no unit system is defined in ANSA, no conversion
            will take place.

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    substructures : Any, optional
            It can be either a list with the Substructure entities we want to output or 'all' in order to output all available Substructures. This option must be used along with mode='model'.

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off". (Default: "off")

    output_primer_kinematic_entities : str, optional
            This argument controls the output of the Primer
            Kinematic Entities at the end of the file.
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_as_hypermesh : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def get_include_by_name(name):
                ents = base.NameToEnts(name)
                for ent in ents:
                    if base.GetEntityType(constants.LSDYNA, ent) == "INCLUDE":
                        return ent
                return 0


            def main():
                base.OutputLSDyna(filename="C:/temp/users/folder/data.key", disregard_includes="on")
                include_entity = get_include_by_name("data.key")
                if include_entity:
                    base.OutputLSDyna(include=include_entity)


            # ...or...


            def main():
                loadcase = base.GetFirstEntity(constants.LSDYNA, "ANSA_LOADCASE")
                base.OutputLSDyna(
                    filename="C:/users/folder/data.key",
                    mbcontainer=loadcase,
                    mode="custom_mbcontainer",
                )


    """


def OutputMSeries(
    filename: str, mode: str = "", format: str = "", output_pyramids: str = "off"
) -> int:
    """

    This function outputs an M-Series format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "MS_8", "MS_9", "MS_10" or "MS_11".
            (Default: what set at the last execution)

    output_pyramids : str, optional
            "on", "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputMSeries("c:/temp/users/folder/data.mse", "all", "MS 8")


    """


def OutputMedina(
    filename: str,
    mode: str = "",
    model: str = "nastran",
    analysis: str = "",
    transformation: str = "",
    units: str = "",
    output_ansa_parts: str = "",
    output_ansa_lockviews: str = "",
    disregard_includes: str = "off",
) -> int:
    """

    Parameters
    ----------
    filename : str
            The name of the output file.

    mode : str, optional
            Accepted values: "all" or "model" or "visible".
            (Default: what set at the last execution)

    model : str, optional
            Accepted values: "nastran", "abaqus", "ls-dyna",
            "pamcrash", "ansys" or "permas".
            (Default: "nastran")

    analysis : str, optional
            Accepted values: "0", "1", "2", "3", "4", "5", "6".
            (Default: what set at the last execution)

    transformation : str, optional
            "0"(impl.) or "1"(local) coord. system.
            (Default: what set at the last execution)

    units : str, optional
            Accepted values: "0", "1", "2", "3", "4", "5", "6".
            (Default: what set at the last execution)

    output_ansa_parts : str, optional
            Accepted values: "on" or "off".
            (Default: what set at the last execution)

    output_ansa_lockviews : str, optional
            Export ANSA LockViews as MEDINA Layers.
            Accepted values: "on" or "off".

    disregard_includes : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputMedina(
                    "C:/temp/users/folder/output.bif",
                    "visible",
                    "nastran",
                    "1",
                    "0",
                    "1",
                    "on",
                    "on",
                    "on",
                )


    """


def OutputMetaPost(filename: str) -> int:
    """

    This function outputs a Meta-Post format file like the FILE>OUTPUT>META-POST functionality.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputMetaPost("C:/temp/users/folder/data.ses")


    """


def OutputMetaProject(
    filename: str,
    mode: str,
    deck: str,
    label: str,
    title: str,
    geometry_name: str,
    label_name: str,
    parts: object,
) -> int:
    """

    Parameters
    ----------
    filename : str

    mode : str, optional

    deck : str, optional

    label : str, optional

    title : str, optional

    geometry_name : str, optional

    label_name : str, optional

    parts : object, optional

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    """


def OutputMoldex3D(
    filename: str, mode: str = "", format: str = "shell", fast_cool: str = "no"
) -> int:
    """

    OutputMoldex3D is a wrapper of OUTPUT_MOLDEX3D. It supports variable number of arguments.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path to the file.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "shell" or "solid".
            (Default: "shell")

    fast_cool : str, optional
            "yes" or "no".
            (Default: "no")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputMoldex3D("C:/users/data.msh", mode="all")


    """


def OutputNastran(
    filename: str,
    mode: str,
    write_comments: str,
    format: str,
    continuation_lines: str,
    enddata: str,
    split_pyramid: str,
    disregard_includes: str,
    output_element_thickness: str,
    thickness: float,
    second_as_first: str,
    first_as_r: str,
    cweld_el_as_grid: str,
    apply_subcontainer_rules: str,
    lf_mode: str,
    beginbulk: str,
    output_numbering_rules: str,
    version: str,
    include_output_mode: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    update_include_fname: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    output_parameter_keywords: str,
    output_pcompg_as_pcomp: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    comment_output_as_hypermesh: str,
    comment_output_lock_views: str,
    advanced_options: str,
    include: object,
    configuration: object,
    comment_output_annotations: str,
    comment_output_attributes: str,
    mbcontainer: object,
    target_unit_system: object,
    second_as_first_solids: str,
    comment_output_names_as_plain_comment: str,
    create_include_output_directory: str,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_fe_perimeters: str,
    comment_output_features: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs a Nastran format file like the FILE>OUTPUT>NASTRAN functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be used
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "as_v_11_2_4", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    format : str, optional
            "short", "long" or "free".
            (Default: what set at the last execution)

    continuation_lines : str, optional
            "on" or "off".
            (Default: "off")

    enddata : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    split_pyramid : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_element_thickness : str, optional
            "off", "at_element_card" or "at_property_card".
            (Default: what set at the last execution)

    thickness : float, optional
            The thickness of the element.
            (Default: "0.0")

    second_as_first : str, optional
            "on" or "off". Convert second order shells to
            first order for output.
            (Default: "off")

    first_as_r : str, optional
            "on" or "off".
            (Default: "off")

    cweld_el_as_grid : str, optional
            "on" or "off".
            (Default: "off")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    lf_mode : str, optional
            "system native", "unix" or "dos".
            (Default: what set at the last execution)

    beginbulk : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    version : str, optional
            Nastran version. One of "msc nastran", "md nastran",
            "nx nastran" or "ne nastran".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    update_include_fname : str, optional
            "on" or "off". Corresponds to the "Update Include
            ReferenceFile" option of the Output Parameters
            of the GUI function.
            (Default: "off")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_parameter_keywords : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_pcompg_as_pcomp : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_as_hypermesh : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of w, dw, followed by Header, UHeader, Nodes, UNodes,
            Elements, UElements, Properties, UProperties,
            Materials, UMaterials, Sets, USets, Contacts,
            Ucontacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    include : object, optional
            The reference to the include entity.
            Should not be used along with "configuration" or
            "mbcontainer" argument.

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" or
            "mbcontainer"argument.
            Outputs either an inactive configuration when no
            other actives, or the active one.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    mbcontainer : object, optional
            The reference to an ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN entity
            Should not be used along with "include" or
            "configuration" argument.
            If used, mode argument must be
            set to "custom_mbcontainer".

    target_unit_system : object, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from
            ANSA's unit system to the argument's unit system before
            output. If no unit system is defined in ANSA, no conversion
            will take place.

    second_as_first_solids : str, optional
            "on" or "off". Convert second order solids to
            first order for output.
            (Default: "off")

    comment_output_names_as_plain_comment : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off".
            (Default: "off")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def get_include_by_name(name):
                ents = base.NameToEnts(name)
                for ent in ents:
                    if base.GetEntityType(constants.NASTRAN, ent) == "INCLUDE":
                        return ent
                return False


            def main():
                base.OutputNastran(
                    filename="C:/temp/users/folder/data.nas", disregard_includes="on"
                )
                include_entity = get_include_by_name("data.nas")
                if include_entity:
                    base.OutputNastran(include=include_enity)


            # ...or...


            def main():
                loadcase = base.GetFirstEntity(constants.NASTRAN, "ANSA_LOADCASE")
                base.OutputNastran(
                    filename="C:/users/folder/data.nas",
                    mbcontainer=loadcase,
                    mode="custom_mbcontainer",
                )


    """


def OutputOpenFoam(
    dirname: str,
    mode: str = "",
    version: str = "SolverInfo",
    initial_conditions_folder: str = "On",
    solver_info: str = "On",
    scale: float = 1.0,
    sets_folder: str = "Off",
    model_check: str = "off",
    model_check_template: str = None,
    cancel_output_if_model_check_error: str = "on",
    binary_io_single_precision: str = "Off",
    unit_system: utils.UnitSystem = None,
    binary_io_64bit_integers: str = "Off",
) -> int:
    """

    This function outputs an OpenFOAM directory.

    Parameters
    ----------
    dirname : str
            The directory name to output the OpenFoam case. It consists of
            path/Case_dir_name, where Case_dir_name CAN NOT be a path. If
            Case_dir_name does not exist, it is created.

    mode : str, optional
            "all" or "model" or "visible".
            If left blank, the value in .defaults is used.

    version : str, optional
            "v1.4" to "v7.0" or "SolverInfo".
            (Default: "SolverInfo")

    initial_conditions_folder : str, optional
            "On" or "Off".
            (Default: "On")

    solver_info : str, optional
            It outputs solver info. Available arguments are "On" or Off".
            (Default: "On")

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            (Default: 1.0) (no scaling takes place).

    sets_folder : str, optional
            "On" or "Off".
            (Default: "Off")

    model_check : str, optional
            "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The name of the template to run if model_check is "on".

    cancel_output_if_model_check_error : str, optional
            "on" or "off".
            (Default: "on")

    binary_io_single_precision : str, optional
            "On" or "Off".
            (Default: "Off")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.
            unit_system and scale arguments cannot be declared at the
            same time.

    binary_io_64bit_integers : str, optional
            "On" or "Off".
            (Default: "Off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import utils


            def main():
                # Read OpenFoam case
                dir = utils.SelectSaveDir("/home/user/")
                base.OutputOpenFoam(dir, mode="all", version="v1.4", scale=10.0)


    """


def OutputOpenFoamPoints(
    dirname: str,
    filename: str,
    mode: str,
    scale: float,
    binary_io_single_precision: str,
    unit_system: object,
    binary_io_64bit_integers: str,
) -> int:
    """

    OutputOpenFoamPoints is a wrapper of OUTPUT_OPENFOAM_POINTS. It supports variable
    number of arguments.

    Parameters
    ----------
    dirname : str
            The directory name to output the file. It consists of path/Case_dir_name,
            where Case_dir_name CAN NOT be a path. If Case_dir_name does not exist,
            it is created.

    filename : str
            The filename. By default, "points" filename is assumed and it is written
            in the constant/polyMesh/ directory.

    mode : str
            "all" or "visible" or "model". By default, "all" for NODES is assumed.

    scale : float
            A float number for scaling the mesh (scale factor).
            If left blank 1.0 is assumed (no scaling takes place).

    binary_io_single_precision : str, optional
            "On" or "Off".
            (Default: "Off")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.
            unit_system and scale arguments cannot be declared at the same time.

    binary_io_64bit_integers : str, optional
            "On" or "Off".
            (Default: "Off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import utils


            def main():
                dir = utils.SelectSaveDir("/home/user/")
                base.OutputOpenFoamPoints(dirname=dir, filename="trans_points")


    """


def OutputPamCrash(
    filename: str,
    mode: str,
    write_comments: str,
    enddata: str,
    expand_ges: str,
    disregard_includes: str,
    output_element_thickness: str,
    thickness: float,
    apply_subcontainer_rules: str,
    output_metric_files: str,
    substructure: int,
    output_rmat: str,
    format: str,
    lf_mode: str,
    output_numbering_rules: str,
    analysis: str,
    include_output_mode: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    output_comments_as_cdata: str,
    update_include_fname: str,
    output_parameter_keywords: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    comment_output_lock_views: str,
    advanced_options: str,
    include: object,
    configuration: object,
    comment_output_annotations: str,
    comment_output_attributes: str,
    mbcontainer: object,
    target_unit_system: object,
    create_include_output_directory: str,
    substructures: Any,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_fe_perimeters: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_features: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs a Pam-Crash format file like the FILE>OUTPUT>PAM-CRASH functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be used
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "as_v_11_2_4", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    enddata : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    expand_ges : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_element_thickness : str, optional
            "off", "at_element_card" or "at_property_card".
            (Default: what set at the last execution)

    thickness : float, optional
            The value of element thickness.
            (Default: "0.0")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_metric_files : str, optional
            "on" or "off".

    substructure : int, optional
            Deprecated. Use the "substructures" argument instead.

            -1 for all substructures or substructure id.

    output_rmat : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    format : str, optional
            The pamcrash version.
            (Default: what set at the last execution)

    lf_mode : str, optional
            "system native", "unix" or "dos".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    analysis : str, optional
            "explicit", "implicit_pcg" or "implicit".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_comments_as_cdata : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    update_include_fname : str, optional
            "on" or "off". Corresponds to the "Update Include
            ReferenceFile" option of the Output Parameters
            of the GUI function.
            (Default: "off")

    output_parameter_keywords : str, optional
            "on" or "off".
            (Default: "off")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" of "off".
            (Default: "off")

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of dw, wo, followed by Header, UHeader, Nodes, UNodes,
            Elements, UElements, Properties, UProperties,
            Materials, UMaterials, Sets, USets, Contacts, UContacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    include : object, optional
            The reference to an include entity.
            Should not be used along with "configuration" or
            "mbcontainer" argument.

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" or
            "mbcontainer" argument.
            Outputs either an inactive configuration when no other.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    mbcontainer : object, optional
            The reference to an ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN entity
            Should not be used along with "include" or
            "configuration" argument.
            If used, mode argument must be
            set to "custom_mbcontainer".

    target_unit_system : object, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from
            ANSA's unit system to the argument's unit system before
            output. If no unit system is defined in ANSA, no conversion
            will take place.

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    substructures : Any, optional
            It can be either a list with the Substructure entities we want to output or 'all' in order to output all available Substructures. This option must be used along with mode='model'.

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def get_include_by_name(name):
                ents = base.NameToEnts(name)
                for ent in ents:
                    if ent._ansaType(constants.PAMCRASH) == "INCLUDE":
                        return ent
                return 0


            def main():
                base.OutputPamCrash(
                    filename="C:/temp/users/folder/data.pc", disregard_includes="on"
                )
                include_entity = get_include_by_name("data.pc")
                if include_entity:
                    base.OutputPamCrash(include=include_entity)


            # ...or...


            def main():
                loadcase = base.GetFirstEntity(constants.PAMCRASH, "ANSA_LOADCASE")
                base.OutputPamCrash(
                    filename="C:/users/folder/data.pc",
                    mbcontainer=loadcase,
                    mode="custom_mbcontainer",
                )


    """


def OutputPatran(filename: str, mode: str = "") -> int:
    """

    This function outputs a Patran format file like the FILE>OUTPUT>PATRAN functionality.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputPatran("C:/temp/users/folder/data.pat", "all")


    """


def OutputPermas(
    filename: str,
    mode: str,
    write_comments: str,
    version: str,
    assign_surfaces_by: str,
    assign_contacts_by: str,
    assign_pretensions_by: str,
    preserve_ids_in_names: str,
    element_sets_as_surfaces: str,
    echo_header: str,
    disregard_includes: str,
    apply_subcontainer_rules: str,
    create_plota_at_solid_skin: str,
    lf_mode: str,
    output_numbering_rules: str,
    include_output_mode: str,
    advanced_options: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    update_include_fname: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_lock_views: str,
    output_fin_keyword: str,
    include: object,
    configuration: object,
    comment_output_annotations: Callable,
    comment_output_attributes: str,
    mbcontainer: object,
    create_include_output_directory: str,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_fe_perimeters: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_features: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    It outputs a PERMAS file. It supports variable number of arguments.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be used
            along with the mbcontainer argument
            (Default: what set at the last execution)

    write_comments : str, optional
            "none" or "at_eof".
            (Default: "at_eof")

    version : str, optional
            The Permas version.
            (Default: what set at the last execution)

    assign_surfaces_by : str, optional
            "Ids" or "Names".
            (Default: what set at the last execution)

    assign_contacts_by : str, optional
            "Ids" or "Names".
            (Default: what set at the last execution)

    assign_pretensions_by : str, optional
            "Ids" or "Names".
            (Default: what set at the last execution)

    preserve_ids_in_names : str, optional
            "on" or "off"..
            (Default: what set at the last execution)

    element_sets_as_surfaces : str, optional
            "on" or "off"..
            (Default: what set at the last execution)

    echo_header : str, optional
            "on" or "off"..
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    create_plota_at_solid_skin : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    lf_mode : str, optional
            "system native", "unix" or "dos".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    advanced_options : str, optional
            One of dw, wo, followed by Header, UHeader, Nodes, UNodes,
            Elements, UElement, Properties, UProperties,
            Materials, UMaterials, Sets, USets, Contacts, Ucontacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    update_include_fname : str, optional
            "on" or "off". Corresponds to the "Update Include
            ReferenceFile" option of the Output Parameters
            of the GUI function.
            (Default: "off")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    output_fin_keyword : str, optional
            "on" or "off".

    include : object, optional
            The reference to an include entity.
            Should not be used along with "configuration" or
            "mbcontainer" argument.

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" or
            "mbcontainer" argument.
            Outputs either an inactive configuration when no other.

    comment_output_annotations : Callable, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    mbcontainer : object, optional
            The reference to an ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN entity
            Should not be used along with "include" or
            "configuration" argument.
            If used, mode argument must be
            set to "custom_mbcontainer".

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputPermas(
                    filename="C:/temp/users/folder/out.dat",
                    mode="all",
                    write_comments="at_eof",
                    lf_mode="unix",
                )


            # ...or...


            def main():
                loadcase = base.GetFirstEntity(0, "ANSA_LOADCASE")
                base.OutputPermas(
                    filename="C:/users/folder/data.dat",
                    mbcontainer=loadcase,
                    mode="custom_mbcontainer",
                )


    """


def OutputRadTherm(filename: str, mode: str) -> int:
    """
    .. deprecated:: 22.0.0
            Use :py:func:`OutputTAITHERM` instead.


    This function outputs a RADTHERM format file, like the FILE>OUTPUT>RADTHERM functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model)

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    See Also
    --------
    base.OutputTAITHERM

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputRadTherm("/home/test.tdf", "all")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 22.0.0. Use :py:func: OutputTAITHERM instead.",
        DeprecationWarning,
    )


def OutputRadioss(
    filename: str,
    mode: str,
    write_comments: str,
    subsets: str,
    disregard_includes: str,
    apply_subcontainer_rules: str,
    version: str,
    lf_mode: str,
    output_numbering_rules: str,
    include_output_mode: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    update_include_fname: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    comment_output_misc: str,
    comment_output_lock_views: str,
    output_parameter_keywords: str,
    output_engine: str,
    merge_engine_with_starter: str,
    advanced_options: str,
    include: object,
    configuration: object,
    comment_output_annotations: str,
    mbcontainer: object,
    material_user_as_law: str,
    target_unit_system: object,
    create_include_output_directory: str,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_connections_user_defined_geometry: str,
    output_hypercrash_kinematic_entities: str,
    comment_output_fe_perimeters: str,
    write_starter_end: str,
    comment_output_features: str,
    comment_output_as_hypermesh: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs a Radioss format file like the FILE>OUTPUT>RADIOSS functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be used
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "none", "above_key" or "at_eof".
            (Default: what set at the last execution)

    subsets : str, optional
            "on" or "off".
            (Default: "off")

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    version : str, optional
            The RADIOSS version.
            (Default: what set at the last execution)

    lf_mode : str, optional
            "dos", "unix" or "system native".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    update_include_fname : str, optional
            "on" or "off". Corresponds to the "Update Include
            ReferenceFile" option of the Output Parameters
            of the GUI function.
            (Default: "off")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_misc : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    output_parameter_keywords : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_engine : str, optional
            "on" or "off".
            (Default: "on")

    merge_engine_with_starter : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of dw, wo, followed by Header, UHeader, Nodes, UNodes,
            Elements, UElements, Properties, UProperties,
            Materials, UMaterials, Sets, USets, Contacts, Ucontacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    include : object, optional
            The reference to an include entity.
            Should not be used along with "configuration" or
            "mbcontainer" argument.

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" or
            "mbcontainer" argument.
            Outputs either an inactive configuration when no other.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    mbcontainer : object, optional
            The reference to an ANSA_SUBSYSTEM,
            ANSA_SIMULATION_MODEL, ANSA_LOADCASE
            or ANSA_SIMULATION_RUN entity
            "configuration" argument.
            If used, mode argument must be
             set to "custom_mbcontainer".

    material_user_as_law : str, optional
            "on" or "off". Output material types USER1,
            USER2 and USER3 as LAW29, LAW30
            and LAW31 respectively (or not).
            (Default: what set at the last execution)

    target_unit_system : object, optional
            A UnitSystem object. Dictates the unit system of the file.
            Setting this option will perform a unit conversion from
            ANSA's unit system to the argument's unit system before
            output. If no unit system is defined in ANSA, no conversion
            will take place.

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off". (Default: "off")

    output_hypercrash_kinematic_entities : str, optional
            This argument controls the output of the HyperCrash Kinematic Entities. Accepted values: "on" or "off". (Default: "off")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off". (Default: "off")

    write_starter_end : str
            Accepted values: "on" or "off". (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off". (Default: "off")

    comment_output_as_hypermesh : str, optional
            Accepted values: "on" or "off". (Default: "off")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def get_include_by_name(name):
                ents = base.NameToEnts(name)
                for ent in ents:
                    if ent._ansaType(constants.RADIOSS, ent) == "INCLUDE":
                        return ent
                return 0


            def main():
                base.OutputRadioss(filename="C:/temp/users/folder/dataD00", disregard_includes="on")
                include_entity = get_include_by_name("data.key")
                if include_entity:
                    base.OutputRadioss(include=include_entity)


            # ...or...


            def main():
                loadcase = base.GetFirstEntity(constants.RADIOSS, "ANSA_LOADCASE")
                base.OutputRadioss(
                    filename="C:/users/folder/dataD00",
                    mbcontainer=loadcase,
                    mode="custom_mbcontainer",
                )


    """


def OutputSCTetra(
    filename: str,
    mode: str,
    format: str,
    model_check: str,
    model_check_template: str,
    cancel_output_if_model_check_error: str,
    unit_system: object,
    scale: float,
) -> int:
    """

    Outputs an SCTETRA file.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.
            The boundary file will be written alongside it, with the same name and a ".s" extension.

    mode : str
            "all" or "model" or "visible".
            (Default: "all")

    format : str, optional
            "pre" or "mdl".
            (Default: what set at the last execution)

    model_check : str, optional
            "on" or "off". If left blank, "off" is assumed.

    model_check_template : str, optional
            The name of template to run if model_check is "on".

    cancel_output_if_model_check_error : str, optional
            "on" or "off".
            (Default: "on")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: "1.0")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # this will also write a boundary file in "C:/users/data.s"
                base.OutputSCTetra(filename="C:/users/data.pre", mode="all")


    """


def OutputStarCCM(
    filename: str,
    mode: str,
    compress_file: str,
    state_name: str,
    model_check: str,
    model_check_template: str,
    cancel_output_if_model_check_error: str,
    unit_system: object,
    scale: float,
) -> int:
    """

    OutputStarCCM is a wrapper of OUTPUT_STAR_CCM. It supports variable number of arguments.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include
            the full path to the file.

    mode : str
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    compress_file : str, optional
            "yes" or "no".
            (Default: "yes")

    state_name : str, optional
            The name of the state to be written.
            (Default: "default")

    model_check : str, optional
            "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The name of template to run if model_check is "on".

    cancel_output_if_model_check_error : str, optional
            "on" or "off".
            (Default: "on")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.
            unit_system and scale arguments cannot be declared at the
            same time.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: "1.0")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputStarCCM(
                    filename="C:/temp/users/folder/data.ccm", mode="model", state_name="my_state"
                )


    """


def OutputStarCD(
    filename: str,
    mode: str,
    renumber_cell_vertex: str,
    keep_material_ids: str,
    version: str,
    write_comments: str,
    write_bnd_file: str,
    model_check: str,
    model_check_template: str,
    cancel_output_if_model_check_error: str,
    unit_system: object,
    scale: float,
) -> int:
    """

    Outputs STAR CD file. It supports variable number of arguments.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path
            to the file.

    mode : str
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    renumber_cell_vertex : str, optional
            "on", "off".
            (Default: "off")

    keep_material_ids : str, optional
            "on", "off".
            (Default: "off")

    version : str, optional
            "v3", "v4".
            (Default: "v3")

    write_comments : str, optional
            "none", "off", "at_eof".
            (Default: "none")

    write_bnd_file : str, optional
            "on" or "off".
            (Default: "on")

    model_check : str, optional
            "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The name of template to run if model_check is "on".

    cancel_output_if_model_check_error : str, optional
            "on" or "off".
            (Default: "on")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: "1.0")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputStarCD(
                    filename="C:/temp/users/folder/data.inp",
                    mode="visible",
                    renumber_cell_vertex="on",
                )


    """


def OutputStereoLithography(
    filename: str,
    mode: str,
    format: str,
    output_colors: str,
    output_exponent: str,
    unit_system: object,
    scale: float,
) -> int:
    """

    Outputs a stereolithography file.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    format : str, optional
            "ascii" or "binary".
            (Default: "ascii")

    output_colors : str, optional
            "on" or "off". Specifies whether to output property colors.
            (Default: "on")

    output_exponent : str, optional
            "on" or "off". Specifies whether to output in exponent format.
            (Default: "off")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputStereoLithography(
                    filename="C:/temp/users/folder/data.stl",
                    mode="all",
                    format="binary",
                    output_exponent="on",
                )


    """


def OutputTheseus(
    filename: str,
    mode: str,
    write_comments: str,
    output_numbering_rules: str,
    output_parts_in_xml: str,
    disregard_includes: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    comment_output_misc: str,
    comment_output_lock_views: str,
    model_check: str,
    model_check_template: str,
    cancel_output_if_model_check_error: str,
    comment_output_annotations: str,
    comment_output_attributes: str,
    create_include_output_directory: str,
    comment_output_ids: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_fe_perimeters: str,
    comment_output_features: str,
    force_relative_reference: str,
) -> int:
    """

    This function outputs a Theseus format file like the FILE>OUTPUT>THESEUS functionality.

    Parameters
    ----------
    filename : str
            The name of the output file. It must reference the full
            path to the file.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    write_comments : str, optional
            "above_key" or "at_eof".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_misc : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    model_check : str, optional
            Run a check template before output.
            Accepted values: "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The check template to execute during output.
            This argument is valid only if 'model_check' is "on".

    cancel_output_if_model_check_error : str, optional
            Cancel output if model checking fails. Model checking
            will fail if at least one error or warning was encountered.
            Accepted values: "on", "off".
            This argument is valid only if 'model_check' is "on".
            (Default: "on")

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include output
             directories.
            (Default: "off")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                status = base.OutputTheseus(
                    filename="C:/temp/users/folder/data.tfe", disregard_includes="on"
                )


    """


def OutputTosca(filename: str) -> int:
    """

    Outputs a Tosca parameter format file.

    Parameters
    ----------
    filename : str
            The name of the output file.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputTosca("C:/temp/users/folder/output.par")


    """


def OutputUh3d(
    filename: str,
    mode: str,
    renumber_nodes_facets_comps: str,
    auto_renumber_comps: str,
    model_check: str,
    model_check_template: str,
    cancel_output_if_model_check_error: str,
    unit_system: object,
    scale: float,
) -> int:
    """

    Outputs a UH3D format file.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    renumber_nodes_facets_comps : str, optional
            "on" or "off".
            (Default: "off")

    auto_renumber_comps : str, optional
            "on" or "off".
            (Default: "on")

    model_check : str, optional
            Run a check template before output.
            Accepted values: "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The check template to execute during output.
            This argument is valid only if `model_check` is "on".

    cancel_output_if_model_check_error : str, optional
            Cancel output if model checking fails. Model checking
            will fail if at least one error or warning was encountered.
            Accepted values: "on", "off".
            This argument is valid only if `model_check` is "on".
            (Default: "on")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: "1.0")

    Returns
    -------
    int
            Returns 0 on success and 1 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputUh3d("C:/temp/users/folder/data.uh3d", "all", "off", "off")


    """


def OutputUniversal(filename: str, mode: str) -> int:
    """

    This function outputs a .unv format file, like the FILE>OUTPUT>UNIVERSAL functionality.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    mode : str
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputUniversal("C:/temp/users/folder/data.unv", "all")


    """


def OutputVrml(filename: str, mode: str, length: str) -> int:
    """

    This function outputs a VRML format file.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    mode : str, optional
            "all" or "model" or "visible".

    length : str, optional
            "m" or "as-is".
            -"m" option outputs the file in meters.
            -"as-is" option states that no conversion will occur.
            (Default: "m")

    Returns
    -------
    int
            Returns 0 on success and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputVrml("C:/temp/users/folder/data.wrl", "all")


    """


def OutputWaveFront(
    filename: str, mode: str, out_parts: str, out_normals: str, unit_system: object
) -> int:
    """

    This function outputs a Wave-Front format file.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    out_parts : str, optional
            "yes" or "no". (Default: "no").
            Groups faces by parts (wavefront 'objects').

    out_normals : str, optional
            "yes" or "no". (Default: "no").
            Outputs the vertex normals.

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputWaveFront("C:/temp/users/folder/data.wave", "visible", "no", "no")


    """


def PasteNodes(
    source_nodes: object,
    target_nodes: object,
    allow_collapse: bool,
    move_target: str,
    delete_remaining_nodes: bool,
) -> int:
    """

    Paste pairs of nodes to each other. The source nodes will be pasted to the
    destination nodes. The source and destination matrices may contain either
    references to nodes or node ids.

    Parameters
    ----------
    source_nodes : object
            A list of the nodes to paste from.

    target_nodes : object
            A list of the nodes to paste to.

    allow_collapse : bool, optional
            Allow collapsing emements upon pasting.

    move_target : str, optional
            "average_position", "fe_position", "geom_position".

    delete_remaining_nodes : bool, optional
            Delete excessive nodes.

    Returns
    -------
    int
            Returns the number of node pairs sent for paste.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                n1 = base.CreateEntity(constants.NASTRAN, "GRID", {"X1": 0, "X2": 0, "X3": 0})
                n2 = base.CreateEntity(
                    constants.NASTRAN, "GRID", {"X1": 10, "X2": 10, "X3": 10, "Name": "source"}
                )
                b1 = base.CreateEntity(
                    constants.PAMCRASH, "BEAM", {"IPART": 1, "N1": n1._id, "N2": n2._id, "x1": 1}
                )

                val = base.PasteNodes(
                    n1,
                    n2,
                    allow_collapse=True,
                    move_target="average_position",
                    delete_remaining_nodes=True,
                )


    """


def PbmsectFromCrossSection(
    cross_ref: object, property: object, point_id: int, set_id: int
) -> object:
    """

    This function translates a cross section in NASTRAN's PBRSECT form with property.
    POINT and SET3 keywords needed for the description of the cross section are created with
    succesive ids starting with point_id, set_id respectively.

    Parameters
    ----------
    cross_ref : object
            A cross section object.

    property : object
            A reference to the property object.

    point_id : int
            The starting point id.

    set_id : int
            The starting set id.

    Returns
    -------
    object
            Returns a dictionary of results. The contents of the dictionary are:
            "error"    : (integer)  1 if error occurred, 0 otherwise.
            "npoints"  : (integer)  number of POINTs created.
            "nsets"    : (integer)  number of SET3s created.
            "bulkdata" : (string)   NASTRAN bulk data.

    Examples
    --------
    ::

            import ansa
            from ansa import utils
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.NASTRAN, "CROSS_SECTION", 1)
                prop = base.GetEntity(constants.NASTRAN, "PBAR", 1)
                results = base.PbmsectFromCrossSection(cross, prop, 1, 1)
                if results["error"] == 0:
                    print(results["bulkdata"])


    """


def PbrsectFromCrossSection(
    cross_ref: object, property: object, point_id: int, set_id: int
) -> object:
    """

    This function translates a cross section in NASTRAN's PBRSECT form with property.
    POINT and SET3 keywords needed for the description of the cross section are created with
    succesive ids starting with point_id, set_id respectively.

    Parameters
    ----------
    cross_ref : object
            A reference to the cross section object.

    property : object
            A reference to the property object.

    point_id : int
            The starting point id.

    set_id : int
            The starting set id.

    Returns
    -------
    object
            Returns a dictionary of results. The contents of the dictionary are:
            "error"    : (integer)  1 if error occurred, 0 otherwise.
            "npoints"  : (integer)  number of POINTs created.
            "nsets"    : (integer)  number of SET3s created.
            "bulkdata" : (string)   NASTRAN bulk data.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.NASTRAN, "CROSS_SECTION", 1)
                prop = base.GetEntity(constants.NASTRAN, "PBAR", 1)
                results = base.PbrsectFromCrossSection(cross, prop, 1, 1)
                if results["error"] == 0:
                    print(results["bulkdata"])


    """


def PedestrianActivateHardPartsDistanceContour(
    hard_parts: int, external_parts: int, impact_angle: float
):
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    Creates a contour graph of the distance between the hood and the hard parts on the given direction defined by the impact angle.

    Parameters
    ----------
    hard_parts : int
            The hard_parts set id.

    external_parts : int
            The external_parts set id.

    impact_angle : float
            The impact angle.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianConv2LineElements() -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    Pedestrian function for converting all created curves from pedestrian tool to line elements.
    The function cannot be called if the PedestrianMarkingParameters function has not been called
    before.

    Returns
    -------
    int
            Returns 0 in all cases.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianCreateBLEPoints() -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function creates Bonnet Leading Edge target points and calculates the appropriate data according to the values
    set by the PedestrianTargetsParameters function. The Upper Bumper Refence Line and the Bonnet Leading Edge
    must exist in base.

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianCreateLoadCases(
    external_parts: int,
    device_set: int,
    device_include: int,
    device_cid: int,
    targets_set: int,
    master_filename: str,
    files_prefix_name: str,
    output_path: str,
    transf_filename: str,
    meta_filename: str,
    z_level: float,
    velocity: float,
    dyna_trsfm_mode: str,
    device_type: str,
    point_type: str,
    write_out_set: bool,
    use_point_names: bool,
    files_extension: str,
) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    Sets the various parameters of the Pedestrian function for multi-positioning of
    the test device and creation of the load cases.

    Parameters
    ----------
    external_parts : int
            The set id of the external parts.

    device_set : int
            The set id of the test device.

    device_include : int
            The include id of the test device. Only if DYNA_TRSFM_MODE is "INCLUDE_TRANSFORM".

    device_cid : int
            The id of the headforms coordinate system.

    targets_set : int
            The set id that contains the target points for the creation of the load cases.
            If this is not defined the function works on all database's target points.

    master_filename : str, optional
            The full path name of master file that contains the include hierarchy.

    files_prefix_name : str, optional
            Prefix of include files that will be created.
            (Default: "PedShot")

    output_path : str, optional
            The output directory.

    transf_filename : str, optional
            Name of transformations list file that will be created.
            (Default: "TransfList.csv")

    meta_filename : str, optional
            Name of the Meta file that will be created.
            (Default: "MetaList.csv")

    z_level : float, optional
            The height from the ground.

    velocity : float, optional
            Velocity of the test device. If a value is defined previously in target
            point's card, then the function disregards this one.

    dyna_trsfm_mode : str, optional
            Values supported "NODE_TRANSFORM", "INCLUDE_TRANSFORM".
            It works only for LSDYNA. (Default: "NODE_TRANSFORM")

    device_type : str, optional
            Values supported are "HEADFORM" and "LEGFORM".

    point_type : str, optional
            Values supported are "TARGET", "CONTACT" or "TEST".
            (Default: "TARGET")

    write_out_set : bool, optional
            Values supported "ON", "OFF". If this flag is on the definition of the test
            device set will be written out in the include file.

    use_point_names : bool, optional
            Values supported "ON", "OFF" If this flag is on the created master files
            and directories will get target point's name.

    files_extension : str, optional
            The preferred extension of all the include files that
            will be created (e.g .inc). Default value is the default
            extension of the current deck.

    Returns
    -------
    int
            Returns 0 in all cases.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianCreateRaster() -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function creates a raster of target points for pedestrian headform according to the values
    set by the PedestrianTargetsParameters function. The WAD and Side Reference Lines must exist in
    the base.

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianDetectCriticalPoints() -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function calculates the critical target points for pedestrian headform or legform according to the values
    set by the PedestrianTargetsParameters function. The critical criterion is the distance from hard parts
    at the shot direction.

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianMarkVehicle() -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function marks the vehicle for pedestrian headform or legform testing according to the values
    set by the PedestrianMarkingParameters function.

    Returns
    -------
    int
            Returns 0 on success, non-zero on failure.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianMarkingParameters(
    external_parts: int,
    apply: str,
    test_type: str,
    windscreen: int,
    bumper_beam: int,
    ground_z: float,
    lbrl_angle: float,
    ubrl_angle: float,
    bc_angle: float,
    blerl_angle: float,
    blerl_height: float,
    bsrl_angle: float,
    adult_radius: float,
    child_radius: float,
    exclusion_sphere: str,
    disregard_sides: bool,
    disregard_dist: float,
    gridsize: float,
    stepsize: float,
    wiper_blades: int,
    bonnet: int,
    offset_wad_lines: bool,
    bumper: int,
    wad_project_limit: float,
    smooth_curves: bool,
    different_pids: bool,
    boundaries_only: bool,
    inclined_ground: bool,
    ground_point_1: object,
    ground_point_2: object,
    upper_legform_2015: bool,
    bc_matching_dist: float,
    geom_points_curves: bool,
    wad_tapes_to_ble: bool,
    wad_tapes_y_limits: object,
    forward_angle_limit: float,
    rotate_back_inclined: bool,
    ec_proposal: bool,
    bc_gauge_limits: object,
    custom_legform_targets: bool,
    custom_upper_leg_points: str,
    custom_lower_leg_points: str,
    rename_inclined_targets: bool,
) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function sets the parameters to apply a selected regulation or protocol of Pedestrian Testing.

    Parameters
    ----------
    external_parts : int
            The set id of the external parts.

    apply : str
            Apply the needed regulation or protocol ("EURONCAP_GRID", "EUPHASE_1",
            "EUPHASE_2", "JNCAP", "TRIAS_63", "EURONCAP_OLD", "EURONCAP_GRID_V7").

    test_type : str
            Supported values are "HEADFORM", "LEGFORM" or "BOTH".

    windscreen : int
            Set id of windscreen.

    bumper_beam : int, optional
            Set id of bumper beam (integer). For Legform marking of EURONCAP protocol.

    ground_z : float, optional
            Z coordinate of ground.

    lbrl_angle : float, optional
            Lower bumper reference line angle.

    ubrl_angle : float, optional
            Upper bumper reference line angle.

    bc_angle : float, optional
            Bumper corner angle.

    blerl_angle : float, optional
            Bonnet leading edge angle.

    blerl_height : float, optional
            Bonnet leading edge height.

    bsrl_angle : float, optional
            Bonnet side reference line angle.

    adult_radius : float, optional
            Adult headform radius.Add post-fix _Inclined_Angle at Target Points\names
            when Ground Type is Inclined.

    child_radius : float, optional
            Child headform radius.

    exclusion_sphere : str, optional
            Values supported are "ON", "OFF" (deprecated).

    disregard_sides : bool, optional
            The excluded points according the sides lines will be deleted. If is False
            the excluded points will not be deleted and will be marked as 'EXCLUDED'.
            For EURONCAP_GRID only.

    disregard_dist : float, optional
            Disregard distance from side lines. For EURONCAP_GRID only.

    gridsize : float, optional
            Grid size of EURONCAP_GRID.

    stepsize : float, optional
            Resolution of lines.

    wiper_blades : int, optional
            Set id of wiper blades. For EURONCAP_GRID only.

    bonnet : int, optional
            Bonnet set id. For EURONCAP_GRID only.

    offset_wad_lines : bool, optional
            To offset or not the wad_line.

    bumper : int, optional
            Set id of bumper beam (integer). For Legform marking of EURONCAP protocol.
            ptional): integer Bumper set id. For Legform testing.

    wad_project_limit : float, optional
            The projection of the flexible tape's edge on the car's
            surface, will not be performed for WADs less than this
            value.

    smooth_curves : bool, optional
            Smooth created curves for stepsize values less than 20.

    different_pids : bool, optional
            Create a different PID for each curve in PedestrianConv2LineElements.

    boundaries_only : bool, optional
            Create only the lines of EuroNCAP Grid.

    inclined_ground : bool, optional
            Use inclined ground according ground_point_1 and ground_point_2.

    ground_point_1 : object, optional
            First Ground Point. A tupple containing the (x,y,z) coordinates is
            required.

    ground_point_2 : object, optional
            Second Ground Point. A tupple containing the (x,y,z) coordinates is
            required.

    upper_legform_2015 : bool, optional
            Apply the EuroNCAP 2015 proposal for Upper Legform.
            (Default: False)

    bc_matching_dist : float, optional
            BLE and BSRL matching distance for Bonnet Corner Points calculation.
            (Default: 1mm)

    geom_points_curves : bool, optional
            Create 3D points on Targets of EuroNCAP Grid and Curves between them.
            (Default: False)

    wad_tapes_to_ble : bool, optional
            Create WAD tapes from Ground to BLE for covering possible gaps (e.g grills).
            For EURONCAP_GRID only. (Default: False)

    wad_tapes_y_limits : object, optional
            An array that contains the Y-coordinate limits of WAD tapes on the right
            and on the left side of the car. Default values are (blank, blank).

    forward_angle_limit : float, optional
            If the vehicle's Forward Angle is greater than this value then horizontal
            projection will be performed. For EURONCAP_GRID (version >= 8.1.0).
            (Default: 60)

    rotate_back_inclined : bool, optional
            Rotate back the created entities when Ground type is 'Inclined'.
            (Default: False)

    ec_proposal : bool, optional
            Enable proposal of the EC to GRSP - December 2014. For EU_PHASE2.
            (Default: False)

    bc_gauge_limits : object, optional
            An array that contains the EC proposal Gauge lower and upper limit.
            For EU_PHASE2 and ec_proposal = True. Default values are (75, 1001).

    custom_legform_targets : bool, optional
            The mark() function will create additional legform target points
            at user defined Y coordinates of WAD 775(or BLE) and UBRL.
            The Y coordinates must be set by variables custom_upper_leg_points
            and custom_lower_leg_points. (Default: False)

    custom_upper_leg_points : str, optional
            The Y-coordinates of Upper legform additional points that will be created.
            They should be given in comma separated format.
            (e.g 80, 160, -80, -160 e.t.c)
            Default value is blank. It applies only if the custom_legform_points=True.

    custom_lower_leg_points : str, optional
            The Y-coordinates of Lower legform additional points that will be created.
            They should be given in comma separated format.
            (e.g 80, 160, -80, -160 e.t.c)
            Default value is blank. It applies only if the custom_legform_points=True.

    rename_inclined_targets : bool, optional
            Add post-fix '_Inclined_Angle' at Target Points names when
            Ground Type is 'Inclined'. (Default: True)

    Returns
    -------
    int
            Returns 0 in all cases.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def PedestrianTargetsParameters(
    external_parts: int,
    windscreen: int,
    raster_zone: str,
    raster_length: float,
    paste_tol: float,
    follow_all_lines: bool,
    critical_mode: str,
    hard_parts_head: int,
    hard_parts_leg: int,
    impact_angle_head: float,
    impact_angle_leg: float,
    critical_zone: str,
    points_per_area: int,
    points_distance: int,
    ble_points: int,
) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function sets the parameters for target points creation functions (PedestrianCreateRaster, PedestrianCreateBLEPoint, PedestrianDetectCriticalPoints).

    Parameters
    ----------
    external_parts : int, optional
            The set id of the external parts.

    windscreen : int, optional
            The set id of the windscreen.

    raster_zone : str, optional
            Accepted values: "ADULT", "CHILD" or "BOTH".

    raster_length : float, optional
            Length of raster's box. Default value is 80 mm.

    paste_tol : float, optional
            Paste tolerance between raster points and boundary lines.
            (Default: 20 mm)

    follow_all_lines : bool, optional
            (Default: False)

    critical_mode : str, optional
            Values "HEADFORM" or "LEGFORM" are supported.
            (Default: "HEADFORM")

    hard_parts_head : int, optional
            Sef id of hard parts for headform mode.

    hard_parts_leg : int, optional
            Set id of hard parts for lower legform mode.

    impact_angle_head : float, optional
            Impact angle for headform mode.

    impact_angle_leg : float, optional
            Impact angle for legform mode.

    critical_zone : str, optional
            Accepted values: "ADULT", "CHILD" or "BOTH". For headform mode.

    points_per_area : int, optional
            The number of points that will be detected in each area.
            (Default: 1)

    points_distance : int, optional
            The minimum desired distance between two consecutive critical points in each
            area. (Default: 50mm)

    ble_points : int, optional
            The number of target points that will be calculated in each BLE segment.
            (Default: 4)

    Returns
    -------
    int
            Returns 0 in all cases.

    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def Peel() -> int:
    """

    When applied the function works in same way as the TOPO>PEEL function.
    It will exclude all shells with free edges or solids with freefacets, from actions to continue.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Peel()


    """


def PickEntities(
    deck: int,
    types: str | List[str],
    initial_type: str = "",
    initial_entities: Entity | List[Entity] = [],
    containers: Entity | List[Entity] = [],
    recursive: bool = False,
    filter_visible: bool = False,
    prop_from_entities: bool = False,
    mat_from_entities: bool = False,
    model_browser_filter: dict = {},
    ret_init: bool = False,
    multi: bool = True,
) -> List[Entity] | None:
    """

    This function puts ANSA in select mode. It supports the selection of all entities
    that are visible in the Database Browser.

    Parameters
    ----------
    deck : int
            The deck that corresponds to the types argument.

    types : str | List[str]
            A string or list of strings with "ansa keywords"
            of the types that will be available for pick.
            Such types can be SHELL, SOLID, GRID etc.
            Additionally, the following keywords can be used:
            "__PROPERTIES__"
            "__MATERIALS__"
            "__ELEMENTS__"
            "__ALL_ENTITIES__"
            "__CONNECTIONS__"
            "__KINETIC__"

    initial_type : str, optional
            Defines the initial picking type.
            If this option is missing then the function will try to define the
            appropriate initial picking type.

    initial_entities : Entity | List[Entity], optional
            A reference to an entity or a list with references to entities.
            The entities will appear preselected. If this option is missing
            then no entities will appear preselected.

    containers : Entity | List[Entity], optional
            A reference to an entity or a list with references to entities.
            Only the entities that belong to the given containers (e.g Parts, Properties, Includes etc) will be available for pick.
            If the entities in containers themselves match the types argument, then only these entities will be available for pick.
            If this option is missing then all entities defined by types argument will be available for pick.

    recursive : bool, optional
            Recursively search any containers contained in a higher level
            container for any or the types.
            Used only when containers argument is given.
            (Default: False)

    filter_visible : bool, optional
            Only the entities that satisfy all collection criteria, have visibility
            status, and the status is active will be available for pick. In all
            other cases the parameter is ignored.
            (Default: False)

    prop_from_entities : bool, optional
            In case types argument is a property, this argument controls if the property
            must be acquired from the entities referenced by the entities in containers
            or not. For example, if types is "PSHELL", containers is "PART", and
            prop_from_entities is True, if the part contains shells, the corresponding
            PSHELL will be available for pick. Otherwise, if prop_from_entities is False,
            the corresponding PSHELL will not be available for pick.
            Used only when containers argument is given.
            (Default: False)

    mat_from_entities : bool, optional
            In case types is a material, this argument controls if the material must be
            acquired from the entities referenced by the entities in container or not.
            For example, if types is "MAT1", container is "PART", and mat_from_entities
            is True, if the part contains elements with MAT1 material, the corresponding
            material will be available for pick. Otherwise, if mat_from_entities is False,
            the corresponding material will not be available for pick.
            Used only when containers argument is given.
            (Default: False)

    model_browser_filter : dict, optional
            This argument is a Python dictionary which determines which entities will be available for pick  when containers argument is a Part, a Group, a Subsystem, a Simulation Model or a Simulation Run. In order to apply this, use types=None. It is a Python dictionary with 2 keywords and 2 values.
            {
            "container": container_value,
            "collect_mode": collect_mode_value
            }
            The possible values of container_value and collect_mode_value vary
            according to the entity they will be applied on. More specifically:

            - When collecting entities from a Part/Group:
            container_value: "all"
            collect_mode_value: "contents" : Will return entities that strictly belong to
                                                                the Part/Group.
                                             "contents_related": Will return the entities that strictly belong to
                                                                            this Part/Group + their properties and materials.
                                             "contents_affected": Will return the entities that strictly belong to
                                                                              this Part/Group
                                                                             + their properties and materials
                                                                             + all entities that are geometrically related
                                                                             to it(use same nodes or are otherwise connected)
            - When collecting entities from a Subsystem/Simulation Model / Simulation Run:
            container_value: "all": Will collect entities of any type, belonging to the
                                               Subsystem/Simulation Model/Simulation Run.
                                       "geometry": Will collect geometry entities belonging to the
                                                          Subsystem/Simulation Model /  Simulation Run.
                                       "connections": Will collect connections(like SPOTWELD) belonging to the
                                                               Subsystem/Simulation Model /  Simulation Run.
                                       "model_setup_entities": Will collect Model Setup Entities (like RBE3 directly
                                                                              connected to geometry) belonging to the
                                                                              Subsystem/Simulation Model/Simulation Run.
                                       "interfaces ": Will collect Interfaces (like A_POINTs) belonging to the
                                                             Subsystem/Simulation Model/Simulation Run.
            collect_mode_value: "contents": Will collect entities that directly belong to the
                                                               containers (see above mentioned argument) of the
                                                               Subsystem/Simulation Model/Simulation Run
                                             "missing": Will collect entities that should-but-don't belong to
                                                             the containers (see above mentioned argument) of
                                                             the Subsystem/Simulation Model/Simulation Run.
                                             "misplaced": Will collect entities that do-but-shouldn't belong to
                                                                 the containers (see abovem entioned argument) of
                                                                 the Subsystem/Simulation Model/Simulation Run.

            Please note that Missing and Misplaced are not defined for the GEOMETRY_OUT_OF_SUBSYSTEMS subsystem.

    ret_init : bool, optional
            If set to True, a list with the selected entities will be returned, or an empty list if no entities are selected.
            (Default: False)

    multi : bool, optional
            Set to False for single entity selection mode.
            (Default: True)

    Returns
    -------
    List[Entity] | None
            Returns a list containing the selected entities in the order they were picked on success, or None when no entites are selected, Cancel or Esc are pressed or on failure.
            If ret_init=True, it will return a list containing the selected entities in the order they were picked on success, an empty list when no entities are selected, or None when Cancel or Esc are pressed or on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                types = ("FACE",)
                results = base.PickEntities(constants.NASTRAN, types)
                base.DeleteEntity(results, True)


            # ...or...


            def main():
                types = (
                    "CBAR",
                    "CBEAM",
                    "CROD",
                )

                preselected = []
                preselected.append(base.GetEntity(constants.NASTRAN, "CBAR", 1))
                preselected.append(base.GetEntity(constants.NASTRAN, "CBEAM", 2))
                preselected.append(base.GetEntity(constants.NASTRAN, "CROD", 3))

                include = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)

                results = base.PickEntities(
                    constants.NASTRAN,
                    types,
                    initial_type="CBEAM",
                    initial_entities=preselected,
                    containers=include,
                )
                for ent in results:
                    ansa.base.DeleteEntity(ent, True)


            # ...or...


            def main():
                types = ["PBAR", "CBAR"]

                include1 = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)
                set1 = base.GetEntity(constants.NASTRAN, "SET", 1)
                base.AddToInclude(include1, set1)

                container_entities = [include1]
                results = base.PickEntities(
                    constants.NASTRAN, types, containers=container_entities, recursive=True
                )
                vals = ("EID", "PID")

                for ent in results:
                    ret = base.GetEntityCardValues(constants.NASTRAN, ent, vals)
                    print("EID:", ret["EID"], ", PID:", ret["PID"])


            # ...or...


            def main():
                part1 = base.GetPartFromName("Part_1", "ANSAPART")

                container_entities = []
                container_entities.append(part1)

                my_container_type = "all"  # possible_values: 'all'/'geometry'/'model_setup_entities'/'interfaces'/'connections'
                my_collect_mode = "contents_related"  # possible_values: for parts: 'contents'/'contents_related'/'contents_affected' for subsystems/simmodels/simruns: 'contents'/'missing'/'misplaced'
                my_md_ent_args = {"container": my_container_type, "collect_mode": my_collect_mode}

                results = base.PickEntities(
                    constants.NASTRAN,
                    types=None,
                    containers=container_entities,
                    model_browser_filter=my_md_ent_args,
                )

                vals = ("EID", "PID")

                for ent in results:
                    ret = base.GetEntityCardValues(constants.NASTRAN, ent, vals)
                    print("EID:", ret["EID"], ", PID:", ret["PID"])


    """


def PickNodes(DECK: int, ENTITIES: object) -> list:
    """

    This function puts ANSA in select mode for node selection.

    Parameters
    ----------
    DECK : int
            The deck constants.

    ENTITIES : object
            An object or a list of object were the selection will be activated.

    Returns
    -------
    list
            Returns a list containing the selected nodes.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = ("FACE",)
                nodes = base.PickNodes(constants.NASTRAN, ents)

                for node in nodes:
                    ret = base.GetEntityCardValues(constants.NASTRAN, node, ("NID",))
                    print(ret["NID"])


    """


def PickPointOnSurface(ENTITIES: object) -> object:
    """

    The function allows you to pick any point on the surface of a shell, solid and face entity.

    Parameters
    ----------
    ENTITIES : object
            A list of surface entities or a single entity.

    Returns
    -------
    object
            Returns a list containing the selected coordinates.
            It is a list which contains lists with xyz coordinates.
            Returns None when selection is canceled.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent_types = ("FACE", "SHELL", "SOLID")
                entities = base.PickEntities(constants.NASTRAN, ent_types)
                all_coordinates = base.PickPointOnSurface(entities)

                for xyz in all_coordinates:
                    connections.CreateConnectionPoint("SpotweldPoint_Type", xyz)
                base.RedrawAll()


    """


def PidToPart() -> int:
    """

    This function creates a new part for every pid and assigns all the items of a certain
    pid to their respective part. The part name and module id are taken from the name and
    id of the property from which the parts are created. The original parts remain empty.
    For more information refer to the user's guide as this function has the same effect as
    the PID-PART button on the part manager.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.PidToPart()


    """


def PlaneCut(
    x1: float,
    y1: float,
    z1: float,
    x2: float,
    y2: float,
    z2: float,
    x3: float,
    y3: float,
    z3: float,
    entities: object,
    produce_plane_faces: bool,
    perform_topology: bool,
) -> int:
    """

    Cuts a number of faces, shells, cons or curves by a plane, defined by three points.

    Parameters
    ----------
    x1 : float
            The x coordinate of the first point.

    y1 : float
            The y coordinate of the first point.

    z1 : float
            The z coordinate of the first point.

    x2 : float
            The x coordinate of the second point.

    y2 : float
            The y coordinate of the second point.

    z2 : float
            The z coordinate of the second point.

    x3 : float
            The x coordinate of the third point.

    y3 : float
            The y coordinate of the third point.

    z3 : float
            The z coordinate of the third point.

    entities : object
            A list of entities where the cut will be applied, a string with value 'visible'
            or a string with value 'all' . If it is called with 'visible', it works with all the
            visible entities. If it is called with 'all', it works with all the entities.

    produce_plane_faces : bool
            If True, new planar face will be created lying on the plane that will
            intersect with the face(s)/shell(s).

    perform_topology : bool
            If False, the performed plane-cut will get released into red bounds.
            If True, all cuts will be pasted.

    Returns
    -------
    int
            Always returns 1

    See Also
    --------
    FacesCut

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entities = []
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 33))
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 1))
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 6))
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "SHELL", 169))
                base.PlaneCut(
                    x1=60.309193,
                    y1=21.035368,
                    z1=30,
                    x2=60.309193,
                    y2=21.035368,
                    z2=0,
                    x3=57.37714,
                    y3=77.776794,
                    z3=0,
                    entities=entities,
                    produce_plane_faces=False,
                    perform_topology=True,
                )


    """


def PositionPedestrian(
    head_set_id: int,
    bonnet_set_id: int,
    angle: float,
    move_back: float,
    target_x: float,
    target_y: float,
    target_z: float,
    coord_id: int,
    node_1: int,
    node_2: int,
    node_3: int,
    undo_trans: bool,
    target_or_contact: int,
    get_all_contact_points: bool,
    z_level: float,
    use_cid_for_lowest_point: bool,
    consider_inclination: bool,
) -> object:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function performs positioning of the test device for Pedestrian testing.

    Parameters
    ----------
    head_set_id : int
            The set id of the FMH.

    bonnet_set_id : int
            The set id of the bonnet.

    angle : float
            The approach angle.

    move_back : float
            The move back distance,

    target_x : float
            The x coordinate of the target point.

    target_y : float
            The y coordinate of the target point.

    target_z : float
            The z coordinate of the target point.

    coord_id : int, optional
            The coordinate system id.

    node_1 : int, optional
            The first node for CS definition.

    node_2 : int, optional
            The second node for CS definition.

    node_3 : int, optional
            Thethird node for CS definition.

    undo_trans : bool, optional
            If set to True, the head will return to the original
            position after the return of function.

    target_or_contact : int, optional
            If set to 0, the positioning mode will be Target Point.
            If set to 1 will be Contact Point.
            If set to 2 will be Test Point.

    get_all_contact_points : bool, optional
            If set to True,  the function will also calculate  the contact
            point coordinates for all the other positioning modes,
            besides the one that is selected.

    z_level : float, optional
            The height of the ground in z axis.

    use_cid_for_lowest_point : bool, optional
            If the 'z_level' is not blank, then the legform lowest point will be
            defined from the 'coord_id'. Otherwise the function will compute
            the lowest point from the impactor's nodes.
            (Default: False)

    consider_inclination : bool, optional
            The inclination angle calculated in 'Car Marking' tab will be added to
            the impact angle during the positioning of the impactor. Considering
            the fact that the car will not be rotated during simulation, then for
            achieving the equivalent load case we need to rotate the ground plane
            in the opposite direction. This is the reason why the inclination angle
            is always positive, regardless how the Ground P-1 and P-2 are defined.
            (Default: False)

    Returns
    -------
    object
            PositionPedestrian returns an array a[] of 26 entries that define the
            transformation in an LS_DYNA way and also contains other information of the positioning.
            Specifically rotate through an angle a[6], about a line with direction cosines a[0], a[1] and a[2],
            passing through the point a[3], a[4] and a[5]. Translation vector is a[7], a[8] and a[9].
            The function also returns the coordinates of the true target point at a[10], a[11] and a[12],
            the coordinates of the contact point for the current positioning mode at a[13], a[14] and a[15],
            the coordinates of the contact point if the positioning mode was Target Point at a[16], a[17] and a[18],
            the coordinates of the contact point if the positioning mode was Contact Point at a[19], a[20] and a[21],
            the coordinates of the contact point if the positioning mode was Test Point at a[22], a[23] and a[24],
            and the result of the positioning at a[25]. If a[25] is equal to 1 then the positioning was successfull otherwise
            will be equal to zero.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                array = base.PositionPedestrian(
                    head_set_id=4,
                    bonnet_set_id=5,
                    coord_id=1,
                    angle=50,
                    target_x=-3758.4949,
                    target_y=-521.35895,
                    target_z=856.2096,
                    move_back=0.0,
                    target_or_contact=1,
                    get_all_contact_points=True,
                )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def Prepare2GetOldAndNewEntitiesMap() -> int:
    """

    The function is used in the case of transformations, where new entities are created from
    selected ones. If a dictionary of old and new entities needs to be aquired, this function must be
    called, prior to the transformation. After the transform has been completed, the map can
    be aquired calling the GetOldAndNewEntitiesMap().

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = (
                    base.GetPartFromModuleId("9"),
                    base.GetEntity(constants.NASTRAN, "SHELL", 20),
                )
                base.Prepare2GetOldAndNewEntitiesMap()
                base.GeoTranslate("COPY", 1, "NEW INSTANCE", "NONE", 125, 200, 56, ents)
                map = base.GetOldAndNewEntitiesMap()


    """


def PrincipalInertias(inertias_list: object, deck: int) -> object:
    """

    Function takes as input a list of 6 inertia values m_in in the form
    [ixx, iyy, izz, ixy, iyz, ixz] (order does matter!) and returns a python dictionary with keys
    "principal_inertias" associated with a list of the 3 principal inertia values
    and "principal_axes" associated with a list of 9 values of the three principal axes vectors (x,y,z).

    Parameters
    ----------
    inertias_list : object
            A list of 6 inertia values.

    deck : int, optional
            Defines deck specific calculations. If not provided the current deck is used.

    Returns
    -------
    object
            Returns a dictionary with keys:
            -"principal_inertias": Associated with a list of the 3 principal inertia values.
            -"principal_axes" Associated with a list of 9 values of the three principal axes vectors (x,y,z).

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m_in = [5049.46, 1075.04, 4335.84, -17.9481, -7.00252, -87.6953]
                # print(m_in)

                ret = base.PrincipalInertias(m_in)
                print(ret)

                m_out = ret["principal_inertias"]
                print("principal_inertias= ", m_out)

                m_frame = ret["principal_axes"]
                print("principal_axes", m_frame)

                print("I1 = ", ret["principal_inertias"][0])
                print("I2 = ", ret["principal_inertias"][1])
                print("I3 = ", ret["principal_inertias"][2])
                print(m_frame)


    """


def PrintFastenerWeights(fast: object, file_name: str) -> int:
    """

    This function prints the weights for the DCOUP3Ds formed internally by ABAQUS for
    every attachment point of an ABAQUS FASTENER. Weigths are printed in a specified
    text file or in Ansa Text if no file is specified.

    Parameters
    ----------
    fast : object
            A fastener object.

    file_name : str
            The path of the file to be exported.

    Returns
    -------
    int
            Returns 1 on failure, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                fast = base.GetEntity(constants.ABAQUS, "FASTENER", 1)
                base.PrintFastenerWeights(fast, "")


    """


def ProjectAndMarkPoints(
    points_coordinates: object,
    projection_tolerance: float,
    parts: object,
    move_to_perimeter_tolerance: float,
) -> object:
    """

    Projects every point to every part, if part is within tolerance.
    Creates mark in closest projection.

    Parameters
    ----------
    points_coordinates : object
            A list containing tuples of (x, y, z) coordinates.

    projection_tolerance : float
            Maximum distance between the projected points and the parts.

    parts : object, optional
            A list of the parts where the points will be projected.

    move_to_perimeter_tolerance : float, optional
            Maximum distance between the projected points and the perimeters.

    Returns
    -------
    object
            Returns a list containing references to the closest projection of each point.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("9"), base.GetPartFromModuleId("8"))
                coords = ((5000, -825, 485), (2018, -806, 566))
                node_matrix = base.ProjectAndMarkPoints(coords, 10.0, parts)


    """


def ProjectConnection(
    connection: object,
    use_weld_spot_as_mesh_grid: bool,
    if_close_move_on_perimeter: bool,
    use_nearest_mesh_grid_as_weld: bool,
    project_weld_spot_on_perimeter: bool,
    mark_projected_hot_as_weld_spot: bool,
    use_weld_spot_as_mesh_grid_max_dist: float,
    if_close_move_on_perimeter_max_dist: float,
    use_nearest_mesh_grid_as_weld_max_dist: float,
    project_weld_spot_on_perimeter_max_dist: float,
) -> int:
    """

    Projects a connection point (spotweld or gumdrop).
    Specify the ID of the connection you wish to project. Optionally, specify the parameters
    of the projection, in pairs of [variable - value] from the list below:

    Parameters
    ----------
    connection : object
            The connection entity to be projected.

    use_weld_spot_as_mesh_grid : bool, optional
            Use weld spot as mesh grid.

    if_close_move_on_perimeter : bool, optional
            If close, move on perimeter.

    use_nearest_mesh_grid_as_weld : bool, optional
            Use nearest mesh grid as weld.

    project_weld_spot_on_perimeter : bool, optional
            Project weld spot on perimeter.

    mark_projected_hot_as_weld_spot : bool, optional
            Mark projected hot as weld spot.

    use_weld_spot_as_mesh_grid_max_dist : float, optional
            The max distance of the argument 'use_weld_spot_as_mesh_grid'.
            (Value > 0.0)

    if_close_move_on_perimeter_max_dist : float, optional
            The max distance of the argument 'if_close_move_on_perimeter'.
            (Value > 0.0)

    use_nearest_mesh_grid_as_weld_max_dist : float, optional
            The max distance of the argument 'use_nearest_mesh_grid_as_weld'.
            (Value > 0.0)

    project_weld_spot_on_perimeter_max_dist : float, optional
            The max distance of the argument 'project_weld_spot_on_perimeter'.
            (Value > 0.0)

    Returns
    -------
    int
            Returns 0 on input error, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import connections
            from ansa import constants


            def main():
                # project spotweld connection with ID: 100001
                cnctn = base.GetEntity(constants.NASTRAN, "SpotweldPoint_Type", 100001)
                connections.ProjectConnection(
                    cnctn, use_weld_spot_as_mesh_grid=True, use_weld_spot_as_mesh_grid_max_dist=12.5
                )


    """


def ProjectCurves(
    CURVES: object, PARTS_PROPERTIES_FACES: object, PROJECTION_TOLERANCE: float
) -> int:
    """

    Projects every curve to every part/property/face, if part/property/face is within PROJECTION_TOLERANCE.

    Parameters
    ----------
    CURVES : object
            A list of curves to be projected.

    PARTS_PROPERTIES_FACES : object
            A list of entities were the projection is going to take place.

    PROJECTION_TOLERANCE : float
            A float that specifies the projection tolerance.

    Returns
    -------
    int
            Returns 0 if CURVES or PARTS_PROPERTIES_FACES length is zero.
            Returns 1 in other cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = (base.GetPartFromModuleId("9"), base.GetPartFromModuleId("8"))
                curves = []
                curves.append(base.GetEntity(constants.NASTRAN, "CURVE", 166))
                curves.append(base.GetEntity(constants.NASTRAN, "CURVE", 167))

                return_value = base.ProjectCurves(curves, parts, 0.5)


    """


def ProjectPoint(x: float, y: float, z: float, geo_element: object) -> object:
    """

    This function computes the projection point of one point on Cons or Curve.
    The input data are the coordinates of the point to be projected and on Cons
    or Curve.

    Parameters
    ----------
    x : float
            The x coordinate of the point.

    y : float
            The y coordinate of the point.

    z : float
            The z coordinate of the point.

    geo_element : object
            A CONS or Curve object.

    Returns
    -------
    object
            Returns a list with the result of the projection.
            The output list can be :
            a) (0) - On error.
            b) (1, ProjectedPoint_x, ProjectedPoint_y, ProjectedPoint_z) - When the point to be
                projected is projected on Cons or Curve, between end points.
            c) (2, ProjectedPoint_x, ProjectedPoint_y, ProjectedPoint_z, SnapPoint_x,SnapPoint_y,
                SnapPoint_z) - When the point to be projected is projected on extension of Cons or
                Curve, out from end points. The Snap Point is the nearest of the two end points of
                Cons or Curve.

            The first value of the list is a flag with values 0, 1 or 2, to represent the three above
            situations.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cons = base.GetEntity(constants.NASTRAN, "CONS", 12)
                ret = base.ProjectPoint(57.37714, 77.776794, 0, cons)
                for entry in ret:
                    print(entry)


    """


def ProjectPointDirectional(
    target: object,
    point_x: float,
    point_y: float,
    point_z: float,
    vec_x: float,
    vec_y: float,
    vec_z: float,
    tolerance: float,
    project_on: str,
) -> object:
    """

    This function computes the projection point of one point on faces and macros.
    The input data is the point to be projected and the id of 'Cons'.

    Parameters
    ----------
    target : object
            A list of entities, where the projection is going to take place.

    point_x : float
            The x coordinate of the point.

    point_y : float
            The y coordinate of the point.

    point_z : float
            The z coordinate of the point.

    vec_x : float
            The x component of the vector along which the projection is going to take place.

    vec_y : float
            The y component of the vector along which the projection is going to take place.

    vec_z : float
            The z component of the vector along which the projection is going to take place.

    tolerance : float
            The projection tolerance.

    project_on : str
            "faces", "macros" or "elements".

    Returns
    -------
    object
            Returns a list with the coordinates of the projection. or None if no projection is found.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                face = base.GetEntity(ansa.constants.NASTRAN, "FACE", 1)
                m = base.ProjectPointDirectional(
                    face, 100, 100, 100, 0, 0, 1, 10, project_on="faces"
                )


    """


def ProjectPointOnFacesDirectional(
    target_faces: object,
    point_x: float,
    point_y: float,
    point_z: float,
    vec_x: float,
    vec_y: float,
    vec_z: float,
    tolerance: float,
) -> object:
    """

    This function Projects a point on an array of faces according to a user specified direction and fills
    the coordinates of the nearest projection.

    Parameters
    ----------
    target_faces : object
            A list containing the faces that we want to project to.

    point_x : float
            The x coordinate of the point to be projected.

    point_y : float
            The y coordinate of the point to be projected.

    point_z : float
            The z coordinate of the point to be projected.

    vec_x : float
            The x component of the directional vector.

    vec_y : float
            The y component of the directional vector.

    vec_z : float
            The z component of the directional vector.

    tolerance : float
            The distance within which projections are accepted.
            If negative value is given the distance is considered infinite.

    Returns
    -------
    object
            Returns a list with the coordinates of the projection. If no projection is found None is returned.

    Examples
    --------
    ::

            # The folowing block will attempt to project point ( 0, 0, 0 ) on all database faces , on the direction of X axis, with infinite tolerance.
            # If a projection is found the coordinates will be printed

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACES", True)
                proj = base.ProjectPointOnFacesDirectional(faces, 0, 0, 0, 1, 0, 0, 0.5)

                if ret:
                    print("ProjX = ", proj0)
                    print("ProjY = ", proj1)
                    print("ProjZ = ", proj2)


    """


def ProjectPointOnMacrosDirectional(
    target_macros: object,
    point_x: float,
    point_y: float,
    point_z: float,
    vec_x: float,
    vec_y: float,
    vec_z: float,
    tolerance: float,
) -> object:
    """

    Projects a point on an array of macros according to a user specified
    direction and fills the coordinates of the nearest projection.

    Parameters
    ----------
    target_macros : object
            A list containing the macros that we want to project to.

    point_x : float
            The x coordinate of the point to be projected.

    point_y : float
            The y coordinate of the point to be projected.

    point_z : float
            The z coordinate of the point to be projected.

    vec_x : float
            The x component of the directional vector.

    vec_y : float
            The y component of the directional vector.

    vec_z : float
            The z component of the directional vector.

    tolerance : float
            The distance within which projections are accepted.
            If negative value is given the distance is considered infinite.

    Returns
    -------
    object
            Returns a list with the coordinates of the projection. If no projection is found None is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "MACROS", 1)
                proj = base.ProjectPointOnMacrosDirectional(faces, 0, 0, 0, 1, 0, 0, tolerance=0.5)

                if proj:
                    print("ProjX = ", proj0)
                    print("ProjY = ", proj1)
                    print("ProjZ = ", proj2)


    """


def ProjectPointToPlane(
    POINT: object, PLANE_ORIGIN: object, PLANE_VECTOR: object
) -> object:
    """

    This function calculates the projection of a point ( x,y,z ) to the given plane.

    Parameters
    ----------
    POINT : object
            A list with the coordinates of the point for the projection.

    PLANE_ORIGIN : object
            A list with the coordinate of a point on the plane.

    PLANE_VECTOR : object
            A list with the components of the normal vector to the plane.

    Returns
    -------
    object
            Returns a list with 3 elements (x,y,z) on success and 0 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                point = (x, y, z)
                plane_origin = (x_p, y_p, z_p)
                plane_vector = (dx, dy, dz)
                proj = base.ProjectPointToPlane(point, plane_origin, plane_vector)


    """


def ReadCheckTemplatesFromDefaultStorage() -> object:
    """

    This function reads the default xml file containing check templates. The file is read from
    the default storage path. Use Checks Manager to create, remove and update check templates.
    This function should becalled before any other function regarding check templates is used.

    Returns
    -------
    object
            The return value is a list of size 2. If the default storage doesn't exist (e.g no templates
            were created from Checks Manager), the first element of the list will be 1. Otherwise, the first
            element will be 0. The second element will contain the number of templates read, and can be 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = base.ReadCheckTemplatesFromDefaultStorage()
                # if no errors were detected then:
                print(m[0])  # should be 0
                print(m[1])  # should be the number of templates read


    """


def ReadCheckTemplatesFromFile(file: str) -> object:
    """

    Reads check templates from a given file.

    Parameters
    ----------
    file : str
            The path of the file to read.

    Returns
    -------
    object
            The function will return a list of two integers. The first item is an error code.
            If the error code is 0, then the file was read successfully. In this case, the
            second integer is the number of templates read from file. If some error was
            encountered, the first integer will be a non-zero integer indicating the error
            type:

            Error Code - Explanation
                 0     - No error
                 2     - The file argument was invalid (e.g it was not a string)
                 3     - The file could not be read

    """


def ReadMaterialDatabase(deck: int, path: str) -> int:
    """

    Load Material Database from file FILE, for the deck DECK.

    Parameters
    ----------
    deck : int
            The deck constant.

    path : str
            The full path to the file name.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.ReadMaterialDatabase(constants.LSDYNA, "/home/material_data/dyna_mat_db.key")


    """


def ReadNumberingRules(
    filename: str, ref_ent: Any = None, existing_rules: str = "merge_existing_rules"
) -> int:
    """

    This function reads numbering rules from a file and assigns them to the whole model, or to an INCLUDE or ANSA PART.

    Parameters
    ----------
    filename : str
            The path to the filename containing the rules.

    ref_ent : Any, optional
            (name or reference) A reference to INCLUDE or PART.

    existing_rules : str, optional
            'merge_existing_rules' or 'delete_existing_rules'.

    Returns
    -------
    int
            Returns 0 if file does not exist, or 1 if it exists.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                status = base.ReadNumberingRules(
                    "/ansa/rules.ansa_rules", existing_rules="delete_existing_rules"
                )
                status = base.ReadNumberingRules(
                    "/ansa/rules_for_include.ansa_rules", "include_name", "merge_existing_rules"
                )


    """


def RedrawAll() -> int:
    """

    This function redraws the model on the screen.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RedrawAll()


    """


def ReduceSurfData() -> int:
    """

    Reduce the data of surfaces. Works on visible faces.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ansa.base.ReduceSurfData()


    """


def ReferenceEntities(entities: object, group_results: bool) -> object:
    """

    Creates a list of the entities that are using the entity.

    Parameters
    ----------
    entities : object
            A reference to an entity or is a list with references to entities.

    group_results : bool, optional
            Affects the way the referenced entities are returned by the function.
            If this option is set to True, then the return is a dictionary whose
            items have the input entity as key and a list with its referenced
            entities as data.
            If this option is missing then all referenced entities will be
            returned in a one -dimensional list.

    Returns
    -------
    object
            Returns a list with the entities that are using the specified entities, or a dictionary (if group_results=True)

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                mat = base.GetEntity(constants.NASTRAN, "MAT1", 1)
                ents = base.ReferenceEntities(mat)
                for ent in ents:
                    base.SetEntityCardValues(
                        constants.NASTRAN, ent, {"Comment": "use of material with id 1"}
                    )


            # ...or...


            def main():
                mat = base.GetEntity(constants.NASTRAN, "MAT1", 1)
                ents = base.ReferenceEntities(mat, group_results=True)

                for key, entities_mat in ents.items():
                    for ent in entities_mat:
                        base.SetEntityCardValues(
                            constants.NASTRAN, ent, {"Comment": "use of material with id 1"}
                        )


    """


def RegisterMappingData(
    entity: object,
    data_label: str,
    data_index: int,
    mapping_type: str,
    mapping_label: str,
    mapping_value: Any,
) -> int:
    """

    This function can be used to assign mapping data to any entity
    that the user wishes to use as a 'source' entity in a Results Mapping
    procedure. By 'source' entity, we mean any entity that carries information
    that can be mapped to a 'target' entity.

    An entity can have many different sets of mapping data, for example data
    pertaining to pressure results or, data containing stress results. So data_label
    is a string such as "presure", "initial stress", "temperature", or any other name
    with which the mapping data will be called later.

    Furthermore, an element may carry different sets of data on its various
    integration points, for example a fully integrated shell element with four
    quadrature points may have four different sets of stress data, one for each
    quadrature point. For this reason, data_index is used. For usual elements
    with only one quadrature point, data_index may be set to 1. In case of more
    than one quadrature points, data_index takes the values 1,2,3, etc.

    The mapping_type argument identifies the kind of data that follows, and can
    be set to either "scalar", "vector", "tensor", or "tag". Use "scalar" to pass
    a single number a data, "vector" to pass a matrix of 3 numbers as data and
    "tensor" to pass a matrix of 6 (Txx, Tyy, Tzz, Txy, Txz, Tyz) or 9 (asymmetric
    tensor,Txx, Tyy, Tzz, Txy, Txz, Tyz, Tyx, Tzx, Tzy ) numbers. Finally,
    use "tag" to create values that can be used in order to group data together.
    Tag type mappings are not interpolated during the Results mapping procedure.
    This type of data is retrieved with the RetrieveTagValue function.

    The mapping_label argument is a name for the value that is being registered.

    The mapping_value argument is the actual value, according to the type
    of data defined by mapping_type.

    Repeat repeat mapping_type, mapping_label and mapping_value arguments as many
    times as nessesary to register mapping data to the source entity.

    Parameters
    ----------
    entity : object
            An ANSA entity (element, node, etc.) to be used as a
            source in a Results Mapping procedure.

    data_label : str
            A text label for the name of the specific mapping. Can
            be used later to retrieve data for the specific label.

    data_index : int
            Index number of source entity for which to register
            data values.

    mapping_type : str
            Can be set to 'scalar', 'vector', 'tensor' or 'tag' to
            specify the type of mapping data.

    mapping_label : str
            A text label for the mapping data. Can be used later
            to retrieve data of the specific mapping.

    mapping_value : Any
            Depending on the mapping_type can receive different
            data. For the mapping_type:
            'scalar' a float value must be used
            'vector' a list of three float values must be used
            'tensor' a list of 6 of 9 float values can be used for
            a symmetric and asymmetric tensor respectively
            'tag' a string value can be used.

    Returns
    -------
    int
            Returns 0 on success, or non-zero otherwise.

    See Also
    --------
    RetrieveMappedData, RetrieveTagValue

    Examples
    --------
    ::

            Assume that a pressure (ABAQUS DLOAD) is applied in element 'shell', and that
            the magniture magn_val, as well as its LOAD TYPE and STEP have been
            extracted. The following can be used to create a data set with
            name "pressure", containg one scalar value named "magn", the magnitude of the
            pressure, and two tags named "load_type"  with the value of the LOAD TYPE
            and "STEP" with the value of the step of the DLOAD, and assign this data set
            to the first integration point of element 'shell'. The existence of
            tags "load_type" and "step" will force a grouping of all "pressure" data
            contained in all elements according to these tag values. Consequently, there
            will be groups of "pressure" data, each belonging to the same STEP and having
            the same "LOAD TYPE", and the subsequent mapping will be applied to each one
            of these groups separately. In this way, inconsistencies (for example,
            merging source DLOADs belonging to different STEPs into the same target
            DLOAD) are avoided.
            \t
            i.e. RegisterMappingData(shell, "pressure", 1, "scalar", "magn", magn_val, "tag", "load_type", load_type_val, "tag", "step", step_val)

            import ansa
            from ansa import base
            from ansa import constants


            def InitElemPress(ents):
                length = len(ents)
                for i in range(length):
                    load = ents[i]
                    type = base.GetEntityType(constants.ABAQUS, load)
                    if type == "DLOAD":
                        ret = base.GetEntityCardValues(
                            constants.ABAQUS, load, ("EID", "magn", "LOAD TYPE", "STEP")
                        )
                        shell = base.GetEntity(constants.ABAQUS, "SHELL", ret["EID"])
                        print("The src step is :", ret["STEP"])
                        base.RegisterMappingData(
                            shell,
                            "pressure",
                            1,
                            "scalar",
                            "magn",
                            ret["magn"],
                            "tag",
                            "load_type",
                            ret["LOAD TYPE"],
                            "tag",
                            "step",
                            ret["step"],
                        )


    """


def Release(
    nodes: object, mode: str, elements: object, faces: object, ret_ents: bool
) -> object:
    """

    Release nodes or edges or faces from elements that belong to.

    Parameters
    ----------
    nodes : object, optional
            A list of nodes/edges to be released
            (required if mode="nodes" or mode="edges").

    mode : str
            "nodes", "edges", "faces" or "elements".

    elements : object, optional
            A list of elements to be released.
            (required if mode="elements").

    faces : object, optional
            A list of solid faces to be released
            (required if mode="faces").

    ret_ents : bool, optional
            If True, a dictionary is returned with the
            released nodes as keys and the created nodes as data.

    Returns
    -------
    object
            Returns 1 if one or more nodes has been released, zero otherwise.
            If ret_ents=True, a dictionary is returned with the released nodes as keys and
            the created nodes as data.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                nodes = []
                node = base.GetFirstEntity(constants.NASTRAN, "GRID")
                while node:
                    ret = base.GetEntityCardValues(constants.NASTRAN, node, ("NID",))
                    if ret["NID"] > 10000:
                        nodes.append(node)
                    node = base.GetNextEntity(constants.NASTRAN, node)
                base.Release(nodes, "edges")


    """


def ReloadRepresentation(
    parts: object,
    property_conflicts: str,
    material_conflicts: str,
    set_conflicts: str,
    ret_results: bool,
    coord_conflicts: str,
    node_conflicts: str,
) -> object:
    """

    This function reloads a part or group representation from the DM.

    Parameters
    ----------
    parts : object
            Can be either a single ANSA part/group or a list
            that contains several ANSA parts/groups.

    property_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    material_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    set_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    ret_results : bool, optional
            If True, the function returns a dictionary.
            If False, the function returns 1 or 0.

    coord_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    node_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    Returns
    -------
    object
            Returns 0 in the case where the given part is not a valid ANSA part, or 1 otherwise.
            If the ret_results argument is True, ANSA returns a dictionary. The keys of the dictionary
            are the names of the parts that were reloaded. The data of the of the dictionary consists
            of dictionaries as well. The keys of these dictionaries are the names of the representations
            and the data are the results of the reload (Success or Failure)

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import dm


            # Example 1  -- Single Part
            def main():
                part = base.GetPartFromModuleId("100")
                dm.ReloadRepresentation(part)


            # Example 2  -- A list of Parts
            def main():
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                dm.ReloadRepresentation(parts)


            # Example 3  -- With optional arguments
            def main():
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                dm.ReloadRepresentation(
                    parts,
                    property_conflicts="Offset",
                    material_conflicts="KeepOld",
                    set_conflicts="KeepNew",
                )


    """


def RemoveFromHighlight(container: object, entities: object) -> int:
    """

    Remove one or more entities that are contained into HighlightContainer.

    Parameters
    ----------
    container : object
            A reference to a highlight container.

    entities : object
            A list of entities to be removed from the container.

    Returns
    -------
    int
            Returns 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = []
                ents.append(base.GetEntity(constants.ABAQUS, "SHELL", 1))
                ents.append(base.GetEntity(constants.ABAQUS, "SHELL", 3))

                containers = base.CollectEntities(constants.ABAQUS, None, "HIGHLIGHT_CONTAINER")
                for container in containers:
                    base.RemoveFromHighlight(container, ents)


    """


def RemoveFromInclude(include: object, entities: object) -> int:
    """

    Removes an entity or a list containing entities, from an Include file.

    Parameters
    ----------
    include : object
            The include object.

    entities : object
            A reference or a list of references of ansa entities.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)
                m = []
                for i in range(1, 10):
                    m.append(base.GetEntity(constants.NASTRAN, "GRID", i))
                base.AddToInclude(include, m)
                base.RemoveFromInclude(include, m)


    """


def RemoveFromLview(lock_view: object, entities: object) -> int:
    """

    Remove an entity or a list containing entities, from a lock view.

    Parameters
    ----------
    lock_view : object
            A reference to lock view object.

    entities : object
            An entity or a list of entities to be removed.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                lview = base.CreateEntity(constants.NASTRAN, "LOCK_VIEW", {"Name": "new lview"})
                m = []
                for i in range(1, 10):
                    m.append(base.GetEntity(constants.NASTRAN, "GRID", i))
                base.AddToLview(lview, m)
                base.RemoveFromLview(lview, base.GetEntity(constants.NASTRAN, "GRID", 4))


    """


def RemoveFromSet(set: object, entities: object, as_excluded: bool) -> int:
    """

    Remove an entity or a list containing entities, from a set.

    Parameters
    ----------
    set : object
            The reference of the set entity.

    entities : object
            A reference or a list of references of the entities to be removed.

    as_excluded : bool, optional
            Denote if the entities will be defined as excluded.
            (Default: False)

    Returns
    -------
    int
            Returns 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "new set"})
                m = []
                for i in range(1, 100):
                    m.append(base.GetEntity(constants.NASTRAN, "GRID", i))
                base.AddToSet(set, m)
                base.RemoveFromSet(set, m)


            # ...or...


            def main():
                set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "new set"})
                for i in range(1, 100):
                    base.AddToSet(set, base.GetEntity(constants.NASTRAN, "GRID", i))
                    base.RemoveFromSet(set, base.GetEntity(constants.NASTRAN, "GRID", i))


    """


def Renumber(rules: object) -> int:
    """

    This function applies numbering rules.
    If the argument 'rules' is not defined, all the existing rules will be applied.
    Otherwise the selected rules will be applied.

    Parameters
    ----------
    rules : object, optional
            A reference to general/per type numbering rule to be renumbered or
            a list of references to general/per_type numbering rules to be renumbered.

    Returns
    -------
    int
            Always returns 1.

    See Also
    --------
    CreateNumberingRule, SetStatusOfNumberingRules

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                general_element_rule = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "TOOL",
                    0,
                    "ELEMENT",
                    "PER_GROUP",
                    1,
                    99999999,
                    "new_elements_rule",
                )
                general_node_rule = base.CreateNumberingRule(
                    constants.NASTRAN, "TOOL", 0, "GRID", "PER_GROUP", 1, 99999999, "new_grids_rule"
                )

                base.Renumber(general_element_rule)
                base.Renumber(general_node_rule)

                prop_rule = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "PROPERTY",
                    "pshell_1",
                    "SHELL",
                    "PER_GROUP",
                    10000,
                    20000,
                    "new_prop_rule",
                )
                base.SetStatusOfNumberingRules(True, True, (prop_rule,))
                base.Renumber()


    """


def RenumberOpenFoamMesh(mode: str) -> int:
    """

    Renumber Mesh in order to reduce the bandwidth of the matrix for the solution.

    Parameters
    ----------
    mode : str
            Accepted values: "all", "model" or "visible".

    Returns
    -------
    int
            Returns 0 on error, or 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RenumberOpenFoamMesh("all")


    """


def ReplaceInclude(include: object, filename: str, deck: int) -> int:
    """

    ReplaceInclude function initialy empties an "include" of its contents, then inputs a new include from a file by replacing the current include.

    Parameters
    ----------
    include : object
            A reference to the include object that will be replaced.

    filename : str
            The path of the new include that will replace the current one.

    deck : int
            The deck constant.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.NASTRAN, "INCLUDE", 5)
                result = ReplaceInclude(
                    entity,
                    "home/gvlachos/fem_g/includes_tests/nastran/include_3",
                    constants.NASTRAN,
                )
                if result == 0:
                    print("Unsuccesfull replace")


    """


def ReplaceIncludeWithText(include: object, text: str, deck: int) -> int:
    """

    This function replaces an "include" with text.

    Parameters
    ----------
    include : object
            A reference to the include object that will be replaced

    text : str
            The text.

    deck : int, optional
            The deck constant.

    Returns
    -------
    int
            Returns 1 on success or 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.NASTRAN, "INCLUDE", 5)
                result = base.ReplaceIncludeWithText(entity, "Include Body Text Here")
                result = base.ReplaceIncludeWithText(
                    entity, "Include Body Text Here", deck=constants.NASTRAN
                )
                if result == 0:
                    print("Unsuccesfull replace")


    """


def ReplaceMaterial(
    old_material: object, new_material: object, entities: object, deck: int
) -> int:
    """

    The ReplaceMaterial function replaces all instances of material `old_material' in the model
    with `new_material'. Upon successfull completion, the old material remains unused and can be
    deleted. If entities is given, only those entities will have their property's material replaced
    by 'new_material'. If deck is not given, current deck is always chosen for materials compatibility.

    Parameters
    ----------
    old_material : object
            The current material to be replaced.

    new_material : object
            The new material that will replace the current one.

    entities : object, optional
            A list with entities (or an entity), whose Property's Material will be
            replaced by the 'new_material'. In this case the first argument
            doesn't have any effect and can be None.

    deck : int, optional
            The deck from which the old material of each entity in 'entities' will
            be derived from. Current deck will be assigned if no deck is specified.

    Returns
    -------
    int
            Returns 0 on success. On error, the return value is 1 if any of the arguments is invalid,
            and 2 if the materials are incompatible to substitute each other.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_mat_old = base.GetEntity(constants.NASTRAN, "MAT1", 1)
                p_mat_new = base.GetEntity(constants.NASTRAN, "MAT1", 2)

                status = base.ReplaceMaterial(p_mat_old, p_mat_new)

                if status == 0:
                    print("Successfully changed material")
                    base.DeleteEntity(p_mat_old, False)
                elif status == 1:
                    print("Invalid argument is given")
                else:
                    print("The two materials are incompatible to each other")
                p_mat_new = base.GetEntity(constants.NASTRAN, "MAT1", 1)
                entities = base.GetEntity(constants.NASTRAN, "SHELL", 1)
                base.ReplaceMaterial(None, p_mat_new, entities, constants.NASTRAN)


    """


def ReplacePart(
    part_name: str,
    file_path: str,
    connections_int: str,
    connections_ext: str,
    connectors_int: str,
    connectors_ext: str,
    bconditions_int: str,
    bconditions_ext: str,
    titems_int: str,
    titems_ext: str,
    orequests_int: str,
    orequests_ext: str,
    sbuilders_int: str,
    sbuilders_ext: str,
    gnbuilders_int: str,
    gnbuilders_ext: str,
    dpatches: str,
    mass_elements: str,
    resmaps: str,
    prefer_compatible_mesh: str,
    nodes_by_name_tolerance: float,
    add_in_sets_tolerance: float,
    old_with_new_tolerance: float,
    keep_name_of_nodes_tolerance: float,
    shell_expansion_factor: float,
    property_conflicts: str,
    material_conflicts: str,
    set_conflicts: str,
    coord_conflicts: str,
    node_conflicts: str,
) -> int:
    """

    This function replaces a single part with the contents of an ANSA database, based on a series
    of user defined arguments.

    Varlen is a list of (argument name, value) pairs. Any pair of argument-value can be omited and the default value will be used instead.

    Parameters
    ----------
    part_name : str
            The name of the part to be replaced.

    file_path : str
            The full path to the database to replace the selected part.

    connections_int : str, optional
            Determines whether the internal Connections will be kept and
            re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    connections_ext : str, optional
            Determines whether the external Connections will be kept and
            re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    connectors_int : str, optional
            Determines whether the internal Connectors will be kept and
            re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            By default, the same value used for internal connections is assumed.

    connectors_ext : str, optional
            Determines whether the external Connectors will be kept and
            re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            By default, the same value used for internal connections is assumed.

    bconditions_int : str, optional
            Determines whether the internal Boundary Condition items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    bconditions_ext : str, optional
            Determines whether the external Boundary Condition items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    titems_int : str, optional
            Determines whether the internal Trim items will be kept and
            re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    titems_ext : str, optional
            Determines whether the external Trim items will be kept and
            re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    orequests_int : str, optional
            Determines whether the internal Output Request items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    orequests_ext : str, optional
            Determines whether the external Output Request items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    sbuilders_int : str, optional
            Determines whether the internal Set Builder items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    sbuilders_ext : str, optional
            Determines whether the external Set Builder items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    gnbuilders_int : str, optional
            Determines whether the internal General Builder items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    gnbuilders_ext : str, optional
            Determines whether the external General Builder items will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    dpatches : str, optional
            Determines whether the Damping Patches will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    mass_elements : str, optional
            Determines whether the Mass Elements will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    resmaps : str, optional
            Determines whether the Result Mappers will be kept
            and re-applied during replace.
            Accepted values: 'KEEP' and 'DELETE'.
            (Default: 'KEEP')

    prefer_compatible_mesh : str, optional
            It defines whether elements in SETS will be replaced with
            their compatible ones. If the value is "YES" and no compatible
            elementis found, then all the elements in the specified
            'Add_in_Sets_Tolerance' are added in the SET.
            Accepted values: "YES" or "NO".
            (Default: "NO")

    nodes_by_name_tolerance : float, optional
            Determines if nodes will be pasted by name and if so the value
            of tolerance to be used. By default no action will be taken.

    add_in_sets_tolerance : float, optional
            Determines whether nodes will be put to sets and if so the value
            of tolerance to be used. By default no action will be taken

    old_with_new_tolerance : float, optional
            Determines whether old and new nodes will be pasted and if so the
            value of  tolerance to be used. By default no action will be taken.

    keep_name_of_nodes_tolerance : float, optional
            Determines whether the name of nodes will be kept and if so the value
            of tolerance to be used. By default no action will be taken.

    shell_expansion_factor : float, optional
            A number to determine the expansion number of shells for sets
            during re-application.
            (Default: 1.)

    property_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    material_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    set_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    coord_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    node_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    Returns
    -------
    int
            Returns 0 if the part has been replaced successfully and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ReplacePart(
                    "a_parts_name",  # Part name
                    "/home/ansa_dbs/some_db.ansa",  # The Ansa db to replace the defined part
                    connections_ext="DELETE",  # Delete any external Connections
                    connectors_int="DELETE",  # Delete any internal Connectors
                    bconditions_ext="KEEP",  # Keep-reapply any extern Boundary Conditions
                    titems_int="DELETE",  # Delete any internal Trim Items
                    sbuilders_int="DELETE",  # Delete all internal Set Builders
                    gnbuilders_ext="DELETE",  # Delete all external General Builders
                    mass_elements="DELETE",  # Delete any Mass Elements
                    orequests_int="KEEP",  # Keep-reapply any internal Output Requests
                    dpatches="DELETE",  # Delete any Damping Patches
                    nodes_by_name_tolerance=0.5,  # Paste nodes based on name
                    add_in_sets_tolerance=1.2,  # Add in sets using tolerance = 1.2
                    prefer_compatible_mesh="YES",  # Prefer compatible elements to add in sets
                    old_with_new_tolerance=1.0,  # Paste old with new using tolerance = 0.8
                    keep_name_of_nodes_tolerance=0.8,  # Keep name of nodes using tolerance = 0.8
                    shell_expansion_factor=1.2,  # Use a shell expansion factor = 1.2
                    property_conflicts="Offset",
                    material_conflicts="KeepOld",
                    set_conflicts="KeepNew",
                )


    """


def ReplaceProperty(
    old_property: object, new_property: object, entities: object
) -> int:
    """

    The ReplaceProperty function replaces all instances of property 'old_property' in the model with 'new_property'. Upon successfull completion, the old property remains unused and can be deleted. If entities is given only those entities will have their property replaced by 'new_property'.

    Parameters
    ----------
    old_property : object
            The current property to be replaced.

    new_property : object
            The new property to replace the current one.

    entities : object, optional
            A list with entities whose Property will be replaced by the 'new_property'.
            In this case the first argument doesn't have any effect and can be None.

    Returns
    -------
    int
            Returns 0 on success. On error, the return value is 1 if any of the two arguments is invalid,
            and 2 if the properties are incompatible to substitute each other.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_prop_old = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                p_prop_new = base.GetEntity(constants.NASTRAN, "PSHELL", 2)

                status = base.ReplaceProperty(p_prop_old, p_prop_new)

                if status == 0:
                    print("Successfully changed property")
                    base.DeleteEntity(p_prop_old, False)
                elif status == 1:
                    print("Invalid argument is given")
                else:
                    print("The two properties are incompatible to each other")
                entities = base.CollectEntities(constants.ABAQUS, None, "SHELL")
                base.ReplaceProperty(None, p_prop_new, entities)


    """


def ReportPenetratedPairsOfPIDs(
    check_type: int,
    fix: bool,
    user_thickness: float,
    factor: float,
    min_distance: float,
    max_distance: float,
) -> object:
    """

    Checks the existence of intersections and thickness penetrations between elements.
    User can request auto fixing of penetrations (where possible).
    Final penetrated / intersected PID pairs are returned to the user.

    Parameters
    ----------
    check_type : int
            Defines the type of penetration check:
            1 = intersections,
            2 = property thickness,
            3 = user thickness,
            4 = distance range.

    fix : bool, optional
            A flag for fixing existing penetrations (True or False).

    user_thickness : float, optional
            The user defined thickness for the check.

    factor : float, optional
            The scale factor for the element thicknesses.

    min_distance : float, optional
            The minimum distance for distance range penetration check.

    max_distance : float, optional
            The maximum distance for distance range penetration check.

    Returns
    -------
    object
            Returns -1 if there is an error in input data and 0 if no penetrations/intersections are found.

            On success, returns a list containing all the penetrated/intersected pid pairs.
            The returning list has lists as members, each containing 2 members, the IDs of the
            penetrated/intersected properties.
            Intersected pairs are reported first and then a submatrix with 1 member only
            (with value 0) to separate intersections and penetrations.
            If no intersections are found , then the 0 list will be the first member of the
            returning list.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ReportPenetratedPairsOfPIDs(check_type=1)
                # Will perform intersections only check.


            # ...or...


            def main():
                base.ReportPenetratedPairsOfPIDs(2, True, 1.2, 1.2)
                # Will perform property thickness check with factor=1.2 and attempt to fix existing penetrations.


    """


def ResetSpiderCog(entity: object, reset_on: str) -> object:
    """

    This function resets the coordinates of the master node of a spider element to the
    center of the nodes of its connectivity.

    Parameters
    ----------
    entity : object
            A reference to a spider entity.

    reset_on : str, optional
            One of "average_position" or "cog". Decide whether the
            master will be reset at the average coordinates of the slaves,
            or at the centroid of the convex hull that contains them.

    Returns
    -------
    object
            Returns a reference to the node that was relocated on success, or None on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                rbe2 = base.GetEntity(constants.NASTRAN, "RBE2", 1)
                cog_node = base.ResetSpiderCog(rbe2, "cog")
                if cog_node:
                    ret = base.GetEntityCardValues(constants.NASTRAN, cog_node, ("X1", "X2", "X3"))


    """


def ResultantForce(
    deck: int,
    force_pressure_matrix: object,
    replace: bool,
    application_to: str,
    node: object,
    ret_ents: bool,
) -> object:
    """

    Create the resultant force from the forces and/or pressures contained in FORCE_PRESSURE_MATRIX,
    replace or not these forces and/or pressures, and apply it on the CALCULATED POINT or
    on the model's COG, or on USER SPECIFIED POINT.

    Parameters
    ----------
    deck : int
            One of NASTRAN, ABAQUS, ANSYS, SESTRA.

    force_pressure_matrix : object
            A list with references to entities that are forces or pressures.

    replace : bool
            False: The resultant force that will be created will not replace the elements
            contained in FORCE_PRESSURE_MATRIX.
            True: The resultant force that will be created will replace the elements
            contained in FORCE_PRESSURE_MATRIX and the elements in the matrix will be
            deleted.

    application_to : str
            "CALCULATED POINT" - The resultant force will be applied to the point
            that is calculated and a new grid at that point will be created. If this option
            is selected the last variable NODE is useless.
            "USER SELECTED GRID" - The resultant force will be applied to GRID.
            If this option is selected the last variable NODE is necessary.
            "MODEL COG" - The resultant force will be applied to the Model COG
            and a new grid at that point will be created. If this option is selected the
            last variable NODE is useless.

    node : object, optional
            An element of type GRID or POINT.

    ret_ents : bool, optional
            False: The function will return only the resultant force that will be created.
            True: The function will return a named tuple with both the resultant force and
            the resultant moment.

    Returns
    -------
    object
            Returns an element that is the resultant force on success, or 0 on error if the ret_ents is False or omitted.
            If ret_ents is True, returns a named tuple with the following members:
            -ret.force: the resultant force
            -ret.moment: the moment

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                type_matrix = ["FORCE", "PLOAD2"]
                force_pres_matrix = base.CollectEntities(constants.NASTRAN, None, type_matrix, True)
                p_grid = base.GetEntity(constants.NASTRAN, "GRID", 30)
                if p_grid:
                    res_force = base.ResultantForce(
                        constants.NASTRAN,
                        force_pres_matrix,
                        replace=True,
                        application_to="USER SELECTED GRID",
                        node=p_grid,
                    )


    """


def ResultsMapperImportResults(RESMAP, RESULTS) -> int:
    """

    Imports results into a RESULTS_MAPPER.

    Parameters
    ----------
    RESMAP :
            The RESULTS_MAPPER entity that will receive the results.

    RESULTS :
            A matrix containing result entities (e.g. INITIAL CONDITIONS).

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                matr = []
                for i in range(1, 100):
                    inistr = base.GetEntity(constants.ABAQUS, "INITIAL CONDITIONS TYPE=STRESS", i)
                    if inistr != 0:
                        matr.append(inistr)
                resmap = base.GetEntity(constants.ABAQUS, "RESULTS_MAPPER", 1)

                base.ResultsMapperImportResults(resmap, matr)
                base.ResultsMapperSetStatus(resmap, "ok")


    """


def ResultsMapperSetStatus(RESMAP: object, STATUS: str) -> int:
    """

    Parameters
    ----------
    RESMAP : object
            The RESULTS_MAPPER object.

    STATUS : str
            Pass STATUS = "ok" to set the status of the RESULTS_MAPPER to "ok".
            Any other value will invalidate the status.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                resmap = base.GetEntity(constants.ABAQUS, "RESULTS_MAPPER", 1)
                base.ResultsMapperSetStatus(resmap, "ok")


    """


def RetrieveMappedData(
    entity: Entity, data_label: str, data_index: int, tag: object, mapping_label: str
) -> object:
    """

    After completion of a mapping procedure, target elements will be
    automatically assigned with mapped counterparts of data that where originally
    assigned to source elements (see RegisterMappingData). Use this function to
    retrieve these values.

    An element can have many different sets of mapping data, for example data
    pertaining to pressure results or, data containing stress results. So data_label
    is a string such as "presure", "initial stress", "temperature", or any other name
    with which the mapping data will be called later.

    Furthermore, an element may carry different sets of data on its various
    integration points, for example a fully integrated shell element with four
    quadrature points may have four different sets of stress data, one for each
    quadrature point. For this reason, data_index is used. For usual elements
    with only one quadrature point, data_index may be set to 1. In case of more
    than one quadrature points, data_index takes the values 1,2,3, etc.


    Parameters
    ----------
    entity : Entity
            Target entity on which to interpolate data from
            registered source entities that are found to be
            affecting the target.

    data_label : str
            The label name at which mapping data was registered.

    data_index : int
            Index number of target entity for which to retrieve
            data values.

    tag : object
            The object that holds all the group information (tag group).

    mapping_label : str
            A text label for which to retrieve mapping data.
            Use one of the labels registered to source entities.

    Returns
    -------
    object
            Returns the value of the mapped data requested.

    See Also
    --------
    RegisterMappingData, RetrieveTagValue

    Examples
    --------
    ::

            In the example of RegisterMappingData function, the process of assigning sets
            of pressure data to source elements was described. After completion of the
            mapping procedure, the mapped pressure magniture (named "magn") on the first
            integration point of a specific target element 'shell', originating from
            source data grouped according to "tag", can be retrieved by:
            magn = RetrieveMappedData(shell, "pressure", 1, tag, "magn")

            import ansa
            from ansa import base
            from ansa import constants


            def ApplyElemPress(ents, label, tag):
                length = len(ents)
                for i in range(length):
                    shell = ents[i]
                    if label == "pressure":
                        ret = base.GetEntityCardValues(
                            constants.ABAQUS, shell, ("EID", "abaqus facet")
                        )

                        magn = base.RetrieveMappedData(shell, label, 1, tag, "magn")
                        load_type = base.RetrieveTagValue(tag, "load_type")
                        step = base.RetrieveTagValue(tag, "step")
                        print("The trg step is :", step)
                        fields = {
                            "STEP": step,
                            "by": "element",
                            "EID": ret["EID"],
                            "LOAD TYPE": load_type,
                            "magn": magn,
                            "facet": ret["abaqus facet"],
                        }
                        dload = base.CreateEntity(constants.ABAQUS, "DLOAD", fields)


    """


def RetrieveTagValue(p_tag: object, tag_label: str) -> object:
    """

    The function retrieves a specific tag value that holds the name "tag_label",
    from a specific tag group. Date retrieved this way must be registered with the
     'tag' mapping_type in a RegisterMappingData function call.

    Parameters
    ----------
    p_tag : object
            The object that holds all the group information (tag group).

    tag_label : str
            The second argument is a name for the value that is being registered
            and has been defined in the function RegisterMappingData() and belongs
            to this tag group. The p_tag can contain several "tag_name" according
            to the way the user wants to group the mapped data.

    Returns
    -------
    object
            Returns a reference to the tag data requested.

    See Also
    --------
    RegisterMappingData

    Examples
    --------
    ::


            In the example of RegisterMappingData function, the process of assigning sets
            of pressure data to source elements was described. After completion of the
            mapping procedure, the mapped pressure magniture (named "magn") on the first
            integration point of a specific target element 'shell', originating from
            source data grouped according to "tag", can be retrieved by:
            magn = RetrieveMappedData(shell, "pressure", 1, tag, "magn")


            import ansa
            from ansa import base
            from ansa import constants


            def ApplyElemPress(ents, label, tag):
                length = len(ents)
                for i in range(length):
                    shell = ents[i]
                    if label == "pressure":
                        ret = base.GetEntityCardValues(
                            constants.ABAQUS, shell, ("EID", "abaqus facet")
                        )
                        magn = base.RetrieveMappedData(shell, label, 1, tag, "magn")
                        load_type = base.RetrieveTagValue(tag, "load_type")
                        step = base.RetrieveTagValue(tag, "step")
                        print("The trg step is :", step)

                        base.CreateEntity(
                            ABAQUS,
                            "DLOAD",
                            {
                                "STEP": step,
                                "by": "element",
                                "EID": ret["EID"],
                                "LOAD TYPE": load_type,
                                "magn": magn,
                                "facet": ret["abaqus facet"],
                            },
                        )


    """


def Rigidize(
    ElementsToBeReplaced: object,
    PartForRigid: object,
    PartForReplacedElements: object,
    ElementType: str,
) -> object:
    """

    This function will replace all the elements in the given list with a Rigid Element
    having the correct mass and inertia properties of the replaced elements. The created
    element is connected to the rest of the structure at the nodes where the replaced
    elements where connected.

    Parameters
    ----------
    ElementsToBeReplaced : object
            A list of elements that will be replaced.

    PartForRigid : object, optional
            The ANSA part where the created element
            will be placed. If zero a new part named
            "Rigidized Part" will be created.

    PartForReplacedElements : object, optional
            The ANSA part where the replaced elements
            will be moved. If zero they will be deleted.

    ElementType : str, optional
            Type of constrained element. Available options are "RBE2", "RBE3". (default  is "RBE2")

    Returns
    -------
    object
            Returns a reference to the newly created rigid element, or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                part = base.GetPartFromModuleId("1")
                shells = base.CollectEntities(constants.LSDYNA, part, "ELEMENT_SHELL")
                rigid = base.Rigidize(shells, None, None)


    """


def RmLogos(faces: object, height: float) -> int:
    """

    Removes depression logos bellow a user specified height.

    Parameters
    ----------
    faces : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces . If it is called with 'all',
            it works with all the faces.

    height : float
            The height, below which the search will be applied.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE")
                base.RmLogos(faces, 1.54)


    """


def RmdblFemFem(TOLERANCE: float, NUM_SETS: int) -> int:
    """

    This function identifies which regions fall outside a user specified distance.
    The failed elements are added to either one or two sets, according to the arguments.

    Parameters
    ----------
    TOLERANCE : float
            The tolerance for searching.

    NUM_SETS : int
            1 or 2. Denotes the number of sets.

    Returns
    -------
    int
            Returns 1 if comparison was possible, or 0 if the two groups of shells were not found.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RmdblFemFem(0.5, 2)


    """


def RmdblFemFemSymmetric(
    ORIGIN_X: float,
    ORIGIN_Y: float,
    ORIGIN_Z: float,
    NORMAL_X: float,
    NORMAL_Y: float,
    NORMAL_Z: float,
    TOLERANCE: float,
    NUM_SETS: int,
) -> int:
    """

    This function identifies which regions fall outside a user specified distance,
    when they are symmetrical according to the specified plane.

    Parameters
    ----------
    ORIGIN_X : float
            The x coordinate of the plane point.

    ORIGIN_Y : float
            The y coordinate of the plane point.

    ORIGIN_Z : float
            The z coordinate of the plane point.

    NORMAL_X : float
            The x coordinate of the normal point.

    NORMAL_Y : float
            The y coordinate of the normal point.

    NORMAL_Z : float
            The z coordinate of the normal point.

    TOLERANCE : float
            The search tolerance.

    NUM_SETS : int
            1 or 2 to denote the number of sets.

    Returns
    -------
    int
            Returns 1 if the comparison was possible, or 0 if the two groups of shells were not found.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RmdblFemFemSymmetric(100.0, 100.0, -100.0, 0.0, 1.0, 0.0, 0.05, 2)


    """


def RmdblGeomFem(TOLERANCE: float) -> int:
    """

    This function checks the distance between the middle point of each shell
    element and the Faces. All visible shell elements that fall outside the
    specified search distance are identified and added to a set.

    Parameters
    ----------
    TOLERANCE : float
            The search tolerance.

    Returns
    -------
    int
            Returns 1 if no failed elements are found, or 0 if failed elements are added to a set.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RmdblGeomFem(0.5)


    """


def RmdblGeomFemSymmetric(
    ORIGIN_X: float,
    ORIGIN_Y: float,
    ORIGIN_Z: float,
    NORMAL_X: float,
    NORMAL_Y: float,
    NORMAL_Z: float,
    TOLERANCE: float,
) -> int:
    """

    This function checks the distance between the symmetrical middle point of
    each shell element and the Faces. All visible shell elements that fall
    outside the specified search distance are identified and added to a set.

    Parameters
    ----------
    ORIGIN_X : float
            The x coordinate of the plane point.

    ORIGIN_Y : float
            The y coordinate of the plane point.

    ORIGIN_Z : float
            The z coordinate of the plane point.

    NORMAL_X : float
            The x coordinate of the normal point.

    NORMAL_Y : float
            The y coordinate of the normal point.

    NORMAL_Z : float
            The z coordinate of the normal point.

    TOLERANCE : float
            The search tolerance.

    Returns
    -------
    int
            Returns 1 if no failed elements are found, or 0 if failed elements are added to a set.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RmdblGeomFemSymmetric(100.0, 100.0, -100.0, 0.0, 1.0, 0.0, 0.05)


    """


def RmdblRotate(
    INPUT: object,
    LINK_DELETE_SET: str,
    ORIGIN_X: float,
    ORIGIN_Y: float,
    ORIGIN_Z: float,
    NORMAL_X: float,
    NORMAL_Y: float,
    NORMAL_Z: float,
    ANGLE: float,
    STEPS: int,
    TOLERANCE: float,
    SIMILARITY: float,
) -> int:
    """

    This function identifies rotated faces and deletes them or replaces
    them with linked faces or adds them to sets.

    Parameters
    ----------
    INPUT : object
            Alist of entities, parts, properties, materials,
            sets or faces or a single face object.

    LINK_DELETE_SET : str
            'link',  'delete', 'delete_compress' or 'set'.

    ORIGIN_X : float
            The x coordinate of the plane point.

    ORIGIN_Y : float
            The y coordinate of the plane point.

    ORIGIN_Z : float
            The z coordinate of the plane point.

    NORMAL_X : float
            The x coordinate of the normal point.

    NORMAL_Y : float
            The y coordinate of the normal point.

    NORMAL_Z : float
            The z coordinate of the normal point.

    ANGLE : float
            The totational symmetry angle.

    STEPS : int
            The rotational steps.

    TOLERANCE : float
            The node search tolerance.

    SIMILARITY : float
            The similarity factor.

    Returns
    -------
    int
            Returns 1 on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                face = base.GetEntity(0, "FACE", 2)
                if base.RmdblRotate(
                    face,
                    "link",
                    1154.8691,
                    147.96068,
                    626.11774,
                    0.9945314411284798,
                    -9.714062580163621e-6,
                    -0.10443760104744756,
                    60.0,
                    5,
                    0.05,
                    90,
                ):
                    print("rmdbl OK")
                else:
                    print("rmdbl Not OK")


    """


def RmdblSameSide(
    tolerance: float,
    similarity: float,
    positive_negative_both: str,
    link_delete_set: str,
) -> int:
    """

    This function identifies and removes identical Faces.

    Parameters
    ----------
    tolerance : float
            The search tolerance.

    similarity : float
            The similarity factor (from 0-100).

    positive_negative_both : str, optional
            One of 'positive', 'negative' or 'both' to specify
            with group of faces to keep.

    link_delete_set : str, optional
            One of 'link', 'delete', 'delete_compress' or 'set.

    Returns
    -------
    int
            Returns 1 on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RmdblSameSide(0.05, 90, "positive", "delete")


    """


def RmdblSymmetric(
    POSITIVE_NEGATIVE_BOTH: str,
    LINK_DELETE_SET: str,
    ORIGIN_X: float,
    ORIGIN_Y: float,
    ORIGIN_Z: float,
    NORMAL_X: float,
    NORMAL_Y: float,
    NORMAL_Z: float,
    TOLERANCE: float,
    SIMILARITY: float,
) -> int:
    """

    This function identifies symmetrical faces and deletes them or replaces
    them them with linked faces or adds them to sets.

    Parameters
    ----------
    POSITIVE_NEGATIVE_BOTH : str
            One of 'positive', 'negative' or 'both', to specify
            which group of faces to keep.

    LINK_DELETE_SET : str
            One of 'link',  'delete', 'delete_compress' or 'set'.

    ORIGIN_X : float
            The x coordinate of the plane point.

    ORIGIN_Y : float
            The y coordinate of the plane point.

    ORIGIN_Z : float
            The z coordinate of the plane point.

    NORMAL_X : float
            The x coordinate of the normal point.

    NORMAL_Y : float
            The y coordinate of the normal point.

    NORMAL_Z : float
            The z coordinate of the normal point.

    TOLERANCE : float
            The node search tolerance.

    SIMILARITY : float
            The similarity factor.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RmdblSymmetric(
                    "positive", "link", 100.0, 100.0, -100.0, 0.0, 1.0, 0.0, 0.05, 90
                )


    """


def RmdblTranslate(
    INPUT: object,
    LINK_DELETE_SET: str,
    NORMAL_X: float,
    NORMAL_Y: float,
    NORMAL_Z: float,
    DISTANCE: float,
    STEPS: int,
    TOLERANCE: float,
    SIMILARITY: float,
) -> int:
    """

    This function identifies translated faces and deletes them or replaces
    them them with linked faces or adds them to sets.

    Parameters
    ----------
    INPUT : object
            A list of entities, parts, properties, materials, sets or faces,
            or a single face object.

    LINK_DELETE_SET : str
            One of 'link',  'delete', 'delete_compress' or 'set'.

    NORMAL_X : float
            The x coordinate of the normal point.

    NORMAL_Y : float
            The y coordinate of the normal point.

    NORMAL_Z : float
            The z coordinate of the normal point.

    DISTANCE : float
            The translational distance.

    STEPS : int
            The rotational steps.

    TOLERANCE : float
            The node search tolerance.

    SIMILARITY : float
            The similarity factor.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                input = []
                for i in range(47, 62):
                    face = base.GetEntity(0, "FACE", i)
                    input.append(face)
                if base.RmdblTranslate(
                    input, "link", 0.0, 0.0016, 0.9999987, 80.53702530509626, 5, 0.05, 90
                ):
                    print("rmdbl OK")
                else:
                    print("rmdbl Not OK")


    """


def RotateDummyAroundHPoint(KIN_JOINT, INCR_ANGLE, AXIS, ANGLE_MODE) -> int:
    """

    This function applies the increment angle to Dummy's H-Point Kinematic Joint.
    A rotation of the whole Dummy model around its H-Point is performed.

    Parameters
    ----------
    KIN_JOINT :
            Name or ID of H-Point Kinematic Joint

    INCR_ANGLE :
            The increment angle in degrees.

    AXIS :
            1 or 2 or 3, is the Bryant rotation

    ANGLE_MODE :
            0 or 1.
            If 0, the 'INCR_ANGLE' argument is the increment angle.
            If 1, it is the total angle.

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Rotate Dummy Model around its H-point 20 degrees at axis R.
                base.RotateDummyAroundHPoint("H-POINT", 20.0, 1, 0)

                # The total rotation angle of Dummy model will be 90 degrees at axis S'.
                base.RotateDummyAroundHPoint("H-POINT", 90.0, 2, 1)


    """


def RotateDummyPart(RIGID_BODY, INCR_ANGLE, AXIS, ANGLE_MODE) -> int:
    """

    This function applies the increment angle to the corresponding Kinematic Joint of
    the selected Dummy's Rigid Body.

    Parameters
    ----------
    RIGID_BODY :
            Name or ID of Rigid Body or the Rigid Body.

    INCR_ANGLE :
            The increment angle in degrees.

    AXIS :
            1 or 2 or 3, is the Bryant rotation.

    ANGLE_MODE :
            0 or 1.
            If 0, the 'ANGLE' argument is the increment angle.
            If 1, it is the total angle.

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Rotate Rigid Body 'Lower leg left' 10 degrees at axis R.
                base.RotateDummyPart("Lower leg left", 10.0, 1, 0)

                # The total rotation angle of Rigid Body 'Lower leg right' will be 40 degrees at axis R.
                base.RotateDummyPart("Lower leg right", 40.0, 1, 1)


    """


def RotatePart(
    parts: object,
    transformation_mode: str,
    x1: float,
    y1: float,
    z1: float,
    x2: float,
    y2: float,
    z2: float,
    angle: float,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: bool,
    ext_connectors: str,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function rotates parts based on the arguments provided. The list PARTS contains the part/s to be rotated.

    Parameters
    ----------
    parts : object
            A part or a list of part entities to be rotated.

    transformation_mode : str
            Accepted values: "COPY", "MOVE" or "LINK".

    x1 : float
            First point to specify the rotation axis.

    y1 : float
            First point to specify the rotation axis.

    z1 : float
            First point to specify the rotation axis.

    x2 : float
            Second point to specify the rotation axis.

    y2 : float
            Second point to specify the rotation axis.

    z2 : float
            Second point to specify the rotation axis.

    angle : float
            Specifies the rotation angle.

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not. Used only in COPY and
            LINK cases. Supported values are 0, to denote that offset will not take
            place and any other integer to denote the actual property offset value.
            Alternatively, you can set the value to "auto_offset", so that pids will be
            automatically offset by ANSA or "current_property" to assign the current
            PID to all the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source Module Id. It is
            taken into account only when used with the 'NEW PART' option. It is ignored in
            any other case.

    set_mode : str, optional
            Supported values are "COPY", "EXPAND" and "NONE".
            Used only in COPY and LINK cases.
            (Default: "NONE")

    connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved entities should
            be released or not in a MOVE transformation. Supported values are True or False.
            (Default: False)

    ext_connectors : str, optional
            Determines whether external connections and connectors will be included in a
            MOVE transformation. Supported values are "INCLUDE" and "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: "False")

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = list()
                parts.append(base.GetPartFromModuleId("100"))
                parts.append(base.GetPartFromModuleId("200"))

                base.RotatePart(
                    parts,  # Parts to be rotated
                    transformation_mode="MOVE",  # Parts will be rotated-moved
                    x1=10,
                    y1=10,
                    z1=10,  # First point to specify the rotation axis
                    x2=10,
                    y2=10,
                    z2=15,  # Second point to specify the rotation axis
                    connectivity=True,  # Connecting nodes will NOT be released
                    ext_connectors="INCLUDE",  # External connections and connectors will also be moved
                    angle=45,
                )  # Rotation angle set to 45 degrees


    """


def RunCrossSection(CSECTION_ref: object) -> str:
    """

    Calculates the already created ANSA Cross Section CSECTION.

    Parameters
    ----------
    CSECTION_ref : object
            A cross section or a list of cross section entities.

    Returns
    -------
    str
            If a single cross section is provided, then the return value is an empty string or a string that contains an error message, depending on whether the calculation was successfull or not.
            If a list of cross section entities is provided, then the return value is a dictionary whose keys are the cross section objects and the values are an empty string or a string that contains an error message, depending on whether the calculation of each cross section was successfull or not.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.NASTRAN, "CROSS_SECTION", 1)
                msg = base.RunCrossSection(cross)
                print("Run message: ", msg)


    """


def SaveNumberingRules(FILENAME: str) -> int:
    """

    This function saves all the numbering rules to a file.

    Parameters
    ----------
    FILENAME : str
            The path to the filename where the rules will be saved.

    Returns
    -------
    int
            Returns 1 in case of successfully saving the rules and 0 if the numbering rules are not saved.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                status = base.SaveNumberingRules("/home/demo/rules.ansa_rules")


    """


def SavePart(
    parts: object,
    save_parts: str,
    filename: str,
    entities: bool,
    hierarchy: bool,
    connections: str,
    connectors: str,
    titems: str,
    bconditions: str,
    orequests: str,
    setbuilders: str,
    generalbuilders: str,
    dpatches: str,
    resmap,
) -> int:
    """

    This function saves a sequence of parts into a single or separate databases,
    according to a series of arguments provided by the user.

    Parameters
    ----------
    parts : object
            The part entity or list / tuple of part entities to be saved.

    save_parts : str
            Enter "SeparateDBs" to save each part in a seperate database.
            Enter "SingleDB" to save all parts in one database.

    filename : str
            A string that contains the path to a folder or database depending on the
            value of save_parts.

    entities : bool, optional
            Determines whether the parts' entities should be saved or not.
            (Default: True)

    hierarchy : bool, optional
            Determines whether the full hierarchy should be saved or not.
            (Default: False)

    connections : str, optional
            Determines whether internal and external connections should be saved or
            not. Supported values are "INTERNAL", to include internal connections,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exlude all connections.
            (Default: "EXCLUDE")

    connectors : str, optional
            Determines whether internal and external connectors should be saved or
            not. Supported values are "INTERNAL", to include internal connectors,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exlude all connectors.
            (Default: "EXCLUDE")

    titems : str, optional
            Determines whether internal and external Trim Items should be saved
            or not. Supported values are "INTERNAL", to include internal Trim Items,
            "ALL AFFECTED", to include internal and external ones, and "EXCLUDE" to
            exlude all Trim Items.
            (Default: "EXCLUDE")

    bconditions : str, optional
            Determines whether internal and external Boundary Conditions should
            be saved or not. Supported values are "INTERNAL", to include internal
            Boundary Conditions, "ALL AFFECTED", to include internal and external ones,
            and "EXCLUDE" to exlude all Boundary Conditions.
            (Default: "EXCLUDE")

    orequests : str, optional
            Determines whether internal and external Output Requests should be
            saved or not. Supported values are "INTERNAL", to include internal
            Output Requests, "ALL AFFECTED", to include internal and external ones,
            and "EXCLUDE" to exlude all Output Requests.
            (Default: "EXCLUDE")

    setbuilders : str, optional
            Determines whether internal and external Set Builders should be
            saved or not. Supported values are "INTERNAL", to include internal
            Set Builders, "ALL AFFECTED", to include internal and external ones,
            and "EXCLUDE" to exlude all Set Builders.
            (Default: "EXCLUDE")

    generalbuilders : str, optional
            Determines whether included General Entity Builders should be
            saved or not. Supported values are "INTERNAL", to include and
            "EXCLUDE" to exlude General Entity Builders.
            (Default: "EXCLUDE")

    dpatches : str, optional
            Determines whether included Damping Patches should be
            saved or not. Supported values are "INTERNAL", to include and
            "EXCLUDE" to exlude Damping Patches.
            (Default: "EXCLUDE")

    resmap : , optional
            Determines whether included Result Mappers should be
            saved or not. Supported values are "INTERNAL", to include and
            "EXCLUDE" to exlude Result Mappers.
            (Default: "EXCLUDE")

    Returns
    -------
    int
            Returns 0 if all files been saved successfully and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))
                base.SavePart(
                    parts,  # Array with parts to be saved
                    "SeparateDBs",  # Save each part in a separate database
                    "C:/temp/users/folder/",  # Path to folder where all databases will be saved
                    hierarchy=True,  # Save also each part's parents
                    connections="INCLUDE",  # Save internal Connections
                    connectors="INCLUDE",  # Save internal connectors
                    bconditions="ALL AFFECTED",
                )  # Save also internal Boundary Conditions


            # ...or...


            def main():
                part = base.GetPartFromModuleId("100")
                base.SavePart(
                    part,  # Part to be saved
                    "SingleDB",  # All parts will be saved in a single database
                    "C:/user/folder/new_db.ansa",  # Database to save all parts
                    hierarchy=True,  # Save also each part's parents
                    orequests="INCLUDE",  # Save Output Requests as well
                    titems="EXCLUDE",  # Save Boundary Conditions as well
                    dpatches="INTERNAL",
                )  # Save included Damping Patches as well


    """


def SaveUnusedIdsOfNumberingRules(FILENAME: str) -> int:
    """

    This function saves all the unused ids, of each numbering rule, to a file.

    Parameters
    ----------
    FILENAME : str
            The path to the filename where the ids will be saved.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                status = base.SaveUnusedIdsOfNumberingRules("/home/demo/unused_ids.txt")


    """


def SaveVisibleAs(filename: str, empty_hierarchy: bool) -> int:
    """

    This function saves all currently visible entities in a new file, under a new file name.

    Parameters
    ----------
    filename : str
            The full path to the filename of the newly created ANSA DB.

    empty_hierarchy : bool, optional
            Determines whether all visible entities will be saved or just an empty
            hierarchy of parts which currently include all visible entities. True
            or False is supported.
            (Default:0)

    Returns
    -------
    int
            Returns 0 if the file has been saved successfully and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SaveVisibleAs("C:/temp/users/folder/new_db.ansa", empty_hierarchy=True)


    """


def ScalePart(
    parts: object,
    transformation_mode: str,
    x: float,
    y: float,
    z: float,
    factor: float,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: bool,
    ext_connectors: str,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function scales parts based on the arguments provided.

    Parameters
    ----------
    parts : object
            A list of part entities to be scaled.

    transformation_mode : str
            Accepted values: "COPY" or "MOVE".

    x : float
            Specifies the coordinate needed to define the reference point.

    y : float
            Specifies the coordinate needed to define the reference point.

    z : float
            Specifies the coordinate needed to define the reference point.

    factor : float
            Specifies the scale factor to be used.

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not. Used only in COPY and
            LINK cases. Supported values are 0, to denote that offset will not take
            place and any other integer to denote the actual property offset value.
            Alternatively, you can set the value to "auto_offset", so that pids will be
            automatically offset by ANSA or "current_property" to assign the current
            PID to all the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source Module Id. It is
            taken into account only when used with the 'NEW PART' option. It is ignored in
            and other case.

    set_mode : str, optional
            Supported values are "COPY", "EXPAND" and "NONE". Default value is NONE
            Used only in COPY and LINK cases.

    connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved entities should
            be released or not in a MOVE transformation. Supported values are True and False.
            (Default: False)

    ext_connectors : str, optional
            Determines whether external connections and connectors will be included in a
            MOVE transformation. Supported values are "INCLUDE" and "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: "False")

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on succes and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))

                base.ScalePart(
                    parts,  # Parts to be scaled
                    transformation_mode="MOVE",  # Parts will be scaled-moved
                    x=10,
                    y=10,
                    z=10,  # Coordinate needed to define the reference point
                    factor=0.5,  # Scale factor set to 0.5
                    connectivity=True,  # Connecting nodes will NOT be released
                    ext_connectors="INCLUDE",
                )  # External connections and connectors will also be moved


    """


def SeatBeltComponentCalculateTotalLength(SEATBELT, COMPONENT) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.

    This function calculates the total length of a created seatbelt component.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    COMPONENT :
            Name or Index of the Component.

    Returns
    -------
    int
            Returns the total_length of the seatbelt entity.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Create the seatbelt component with index '3' of seatbelt entity with id: 2.
                base.SeatBeltCreateSingleComponent(2, 3)
                # Calculate the total length of component 3.
                length = base.SeatBeltComponentCalculateTotalLength(2, 3)
                print("length = ", length)


    """


def SeatBeltCreateAllComponents(SEATBELT) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.

    This function creates or recreates all components of a predefined seatbelt entity.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Create all seatbelt components of seatbelt entity "Default SeatBelt Entity".
                base.SeatBeltCreateAllComponents("Default SeatBelt Entity")

                # Create all seatbelt components of seatbelt entity with id: 2.
                base.SeatBeltCreateAllComponents(2)


    """


def SeatBeltCreateSingleComponent(SEATBELT, COMPONENT) -> int:
    """

    This function creates or recreates a single component of a predefined seatbelt entity.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    COMPONENT :
            Name or Index of the Component.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Create the seatbelt component 'Component_1' of seatbelt entity "Default SeatBelt Entity".
                base.SeatBeltCreateSingleComponent("Default SeatBelt Entity", "Component_1")

                # Create the seatbelt component with index '3' of seatbelt entity with id: 2.
                base.SeatBeltCreateSingleComponent(2, 3)


    """


def SeatBeltDeleteComponent(SEATBELT, COMPONENT, DELETE_CONTENTS) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.


    This function deletes a component of a predefined seatbelt entity,
    with an option to delete its contents.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    COMPONENT :
            Name or Index of the Component.

    DELETE_CONTENTS :
            Flag to delete the contained created elements.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Delete the seatbelt component 'Component_1' of seatbelt entity "Default SeatBelt Entity".
                # Keep the created elements.
                base.SeatBeltDeleteComponent("Default SeatBelt Entity", "Component_1", 0)


    """


def SeatBeltDeleteComponentPoints(SEATBELT, COMPONENT) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.


    This function deletes the points of a component of a predefined seatbelt entity.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    COMPONENT :
            Name or Index of the Component.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Delete the points of seatbelt component 'Component_1' of seatbelt entity "Default SeatBelt Entity".
                base.SeatBeltDeleteComponentPoints("Default SeatBelt Entity", "Component_1")


    """


def SeatBeltEmptyComponent(SEATBELT, COMPONENT) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.


    This function deletes the created elements of a component of a predefined seatbelt entity.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    COMPONENT :
            Name or Index of the Component.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Delete all created elements of the seatbelt component 'Component_1' of seatbelt entity "Default SeatBelt Entity".
                base.SeatBeltEmptyComponent("Default SeatBelt Entity", "Component_1")


    """


def SeatBeltFillParts2Wrap(SEATBELT, PARTS) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.

    This function adds an entity or a matrix of entities in parts2wrap item of a seatbelt entity.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    PARTS :
            Entity or a matrix of entities to be added.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Add all properties of type PSHELL of part with module id = 10 and add them in seatbelt's parts2wrap item.
                part = base.GetPartFromModuleId("10")
                pshells = base.CollectEntities(
                    ansa.constants.LSDYNA, part, "PSHELL", prop_from_entities=True
                )
                base.SeatBeltFillParts2Wrap("Default SeatBelt Entity", pshells)


    """


def SeatBeltResetAllComponentPaths(SEATBELT) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.

    This function resets all saved paths of a seatbelt entity.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SeatBeltResetAllComponentPaths(1)


    """


def SeatBeltResetComponentPath(SEATBELT, COMPONENT) -> int:
    """

    This function resets the saved path of a created component of a predefined seatbelt entity.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    COMPONENT :
            Name or Index of the Component.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SeatBeltResetComponentPath(1, 1)


    """


def SeatBeltSetComponentParameters(
    seatbelt: object,
    component: object,
    points_prefix: str,
    generic_type: str,
    starting_elements: str,
    starting_length: float,
    starting_anchor: str,
    elem_property_1d: int,
    rds_nstrand_property: int,
    start_elem_property_2d: int,
    main_elements: str,
    el_length: float,
    offset: float,
    num_of_shells: int,
    entry_dx: float,
    entry_dy: float,
    entry_dz: float,
    exit_dx: float,
    exit_dy: float,
    exit_dz: float,
    shells_property: int,
    ending_elements: str,
    ending_length: float,
    ending_anchor: str,
    end_elem_property_2d: int,
    num_to_extend: int,
    create_trias_at_end: bool,
    create_trias_at_start: bool,
    is_frozen: bool,
    dyna_cross_sect_dist: float,
) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.

    This function performs the setup of the creation parameters for a specific seatbelt
    component of a predefined seatbelt entity.

    Parameters
    ----------
    seatbelt : object
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    component : object
            Name or Index of the Component.

    points_prefix : str, optional
            The prefix of name that will be set at the selected path
            points of the seatbelt component.

    generic_type : str, optional
            "1D", "2D". The generic type of the seatbelt component.
            The 1D type can create only 1D elements and the 2D type
            can create both 1D and 2D elements.

    starting_elements : str, optional
            The type of starting elements that will be created.
            LS-DYNA: "1D_BELT", "2D_BELT", "NONE".
            PAM-CRASH: "BARS", "BELTS", "NONE".
            ABAQUS: "CONNECTOR", "TRUSS", "NONE".
            RADIOSS: "TRUSS", "NSTRAND", "NONE".

    starting_length : float, optional
            The total length of component's starting part.

    starting_anchor : str, optional
            The type of starting anchor entity that will be created.
            "SLIPRING", "RETRACTOR", "PRETENSIONER"(LS-DYNA), "NONE".

    elem_property_1d : int, optional
            The id of the 1D elements property. If not set, a default
            property will be created.

    rds_nstrand_property : int, optional
            The id of the Radioss Nstrand elements property.
            If not set,a default property will be created.

    start_elem_property_2d : int, optional
            The id of the Ls-Dyna 2D seatbelt elements property.
            If not set, a default property will be created.

    main_elements : str, optional
            "SHELLS", "2D_BELT"
            The type of elements that will be created at the main part.
            If not set regular shells will be created.
            The option "2D_BELT" stands only for Ls-Dyna deck.

    el_length : float, optional
            The length of all elements that will be created.

    offset : float, optional
            Offset of seatbelt elements from the parts that will be
            wrapped.

    num_of_shells : int, optional
            The number of 2D elements that will be created at the width
            of the seat belt.

    entry_dx : float, optional
            Entry vector dx. The starting part's width direction will be
            alligned with this vector.

    entry_dy : float, optional
            Entry vector dy. The starting part's width direction will be
            alligned with this vector.

    entry_dz : float, optional
            Entry vector dz. The starting part's width direction will be
            alligned with this vector.

    exit_dx : float, optional
            Exit vector dx. The ending part's width direction will be
            alligned with this vector.

    exit_dy : float, optional
            Exit vector dy. The ending part's width direction will be
            alligned with this vector.

    exit_dz : float, optional
            Exit vector dz. The ending part's width direction will be
            alligned with this vector.

    shells_property : int, optional
            The id of the 2D elements property.If not set, a default
            property will be created.

    ending_elements : str, optional
            The type of ending elements that will be created.
            LS-DYNA: "1D_BELT", "2D_BELT", "NONE".
            PAM-CRASH: "BARS", "BELTS", "NONE".
            ABAQUS: "CONNECTOR", "TRUSS", "NONE".
            RADIOSS: "TRUSS", "NSTRAND", "NONE".

    ending_length : float, optional
            The total length of component's ending part.

    ending_anchor : str, optional
            The type of ending anchor entity that will be created.
            "SLIPRING", "RETRACTOR", "PRETENSIONER"(LS-DYNA), "NONE".

    end_elem_property_2d : int, optional
            The id of the Ls-Dyna 2D seatbelt elements property.
            If not set, a default property will be created.

    num_to_extend : int, optional
            The number of Ls-Dyna 1D seatbelt elements that will extend
            1D starting and ending part.

    create_trias_at_end : bool, optional
            Create trias at end of the starting part of the component
            (instead of rigid body line elements).

    create_trias_at_start : bool, optional
            Create trias at start of the ending part of the component
            (instead of rigid body line elements).

    is_frozen : bool, optional
            Freeze/unfreeze component.

    dyna_cross_sect_dist : float, optional
            The Cross Section Distance of the component. It is measured approximately
            from the Starting point of the component and across its centerline.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Set parameters of the component 'Component_1' of seatbelt entity "Default SeatBelt Entity".
                base.SeatBeltSetComponentParameters(
                    "Component_1",
                    points_prefix="belt_point",
                    generic_type="2D",
                    starting_elements="2D_BELT",
                    starting_length=150,
                    starting_anchor="SLIPRING",
                    el_length=10,
                    num_of_shells=5,
                )
                # Create the seatbelt component.
                base.SeatBeltCreateSingleComponent("Default SeatBelt Entity", "Component_1")


    """


def SeatBeltSetComponentPoints(SEATBELT, COMPONENT, NODES) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.

    This function sets the path points of a specific seatbelt component.
    The nodes that will be added are named according the PREFIX_NAME parameter and their index.

    Parameters
    ----------
    SEATBELT :
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    COMPONENT :
            Name or Index of the Component.

    NODES :
            Matrix of nodes that will be used as path points.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                nodes = []
                nodes.append(base.GetEntity(constants.LSDYNA, "NODE", 1001))
                nodes.append(base.GetEntity(constants.LSDYNA, "NODE", 1101))
                nodes.append(base.GetEntity(constants.LSDYNA, "NODE", 1201))
                # Set the path points for component 2 of seatbelt entity with id 1.
                base.SeatBeltSetComponentPoints(1, 2, nodes)


    """


def SeatBeltSetParameters(
    seatbelt: object,
    create_contact: bool,
    contact_id: object,
    disable_parts2wrap: bool,
    auto_recreate: bool,
) -> int:
    """

    This function is deprecated. Use the ASeatbelt object instead.

    This function performs the setup of the general creation parameters for a predefined seatbelt entity.

    Parameters
    ----------
    seatbelt : object
            Name or ID of SeatBelt Entity or the SeatBelt Entity.

    create_contact : bool, optional
            Flag for creating a contact entity

    contact_id : object, optional
            The predefined contact that will be updated after the creation
            of seatbelt. If it is not set and the CREATE_CONTACT
            flag is not zero, a default contact will be created.

    disable_parts2wrap : bool, optional
            Flag for disabling parts2wrap item of a seatbelt entity.
            If it is equal to True then the function will run on visible parts.

    auto_recreate : bool, optional
            Flag for auto-recreating the seatbelt after dummy articulation.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                contact = base.GetEntity(ansa.constants.NASTRAN, "CONTACT", 1)
                # Set parameters of the seatbelt entity "Default SeatBelt Entity".
                base.SeatBeltSetParameters(
                    "Default SeatBelt Entity",
                    create_contact=True,
                    contact_id=contact,
                    disable_parts2wrap=True,
                    auto_recreate=True,
                )
                # Create the seatbelt entity.
                base.SeatBeltCreateAllComponents("Default SeatBelt Entity")


    """


def SectionForcePlaneEnts(section_force: object) -> object:
    """

    This function gathers all entities that are intersected from the plane of a section
    force output entity (DATABASE_CROSS_SECTION_PLANE for Ls-Dyna, SECF for Pam-Crash).

    Parameters
    ----------
    section_force : object
            A section force entity.

    Returns
    -------
    object
            Returns a list that contains the intersected entities.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                sects = base.CollectEntities(constants.LSDYNA, None, "DATABASE_CROSS_SECTION_PLANE")
                for sect in sects:
                    print(
                        "Plane of "
                        + sect._ansaType(constants.LSDYNA)
                        + " with id "
                        + str(sect._id)
                        + ", intersects the following entities:"
                    )
                    ents = base.SectionForcePlaneEnts(sect)

                    for ent in ents:
                        print(ent._ansaType(constants.LSDYNA) + " with id " + str(ent._id))


    """


def SelectEntitiesList(
    deck: int,
    types: object,
    available_entities: object,
    multi: bool,
    initial_entities: object,
) -> object:
    """

    Shows the ansa help list that coresponds to ENTITY_TYPES in order to select one entity.
    If ENTITY_TYPES matrix has only one type and this is one of the following: TABLED, TABLEM, TABLES1, TABLEST, TABDMP1
    then the ansa tables window is shown instead.

    Parameters
    ----------
    deck : int
            The deck constant.

    types : object
            A list of types that will be listed.

    available_entities : object, optional
            A reference to an entity or a list with references to entities.
            Only these entities will be available for selection, provided that
            they belong to the defined types. If this option is missing
            then all entities of the defined types will be available for selection.
            Not supported for the types that are available through the ansa tables window.

    multi : bool, optional
            Set to True for multiple selection list.

    initial_entities : object, optional
            A reference to an entity or a list with references to entities. The entities will appear preselected. If this option is missing then no entities will appear preselected.

    Returns
    -------
    object
            Returns the selected entity in case of a single selection list or a list with the selected entities in case of a multiple selection list.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                types = ["SHELL"]
                entity = base.SelectEntitiesList(constants.NASTRAN, types)
                print("Selected entity ", entity._id)

                entities = base.SelectEntitiesList(constants.NASTRAN, types, multi=True)
                for entity in entities:
                    print("Selected entity ", entity._id)
                # Or with preselected entities
                initial_entities = []
                initial_entities.append(base.GetEntity(constants.NASTRAN, "SHELL", 1))
                entity = base.SelectEntitiesList(
                    constants.NASTRAN, types, initial_entities=initial_entities
                )
                print("Selected entity ", entity._id)

                initial_entities.append(base.GetEntity(constants.NASTRAN, "SHELL", 5))
                initial_entities.append(base.GetEntity(constants.NASTRAN, "SHELL", 8))
                entities = base.SelectEntitiesList(constants.NASTRAN, types, multi=True)
                for entity in entities:
                    print("Selected entity ", entity._id)


    """


def SetANSAdefaultsValues(fields: object, mbcontainer_type: str) -> int:
    """
    .. deprecated:: 22.0.0
            Use :py:func:`BCSettingsSetValues` instead.


    Function is obsolete. Use BCSettingsSetValues() instead.

    Parameters
    ----------
    fields : object
            A dictionary with keys the ANSA defaults keywords and values the
            new default values.

    mbcontainer_type : str, optional
            If this argument is provided:
            - fields that can be customized per
            container will be modified for this container
            type only (i.e. Output Parameters).
            - for fields that cannot be customized per
            container, their global default value will be
            modified .

            Accepted values are:
            "ANSA_SUBSYSTEM",
            "ANSA_SIMULATION_MODEL",
            "ANSA_LOADCASE",
            "ANSA_SIMULATION_RUN"

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base

            base.SetANSAdefaultsValues({"element_type": "tria"})
            base.SetANSAdefaultsValues(
                {"outpcomments": "At end of file"}, mbcontainer_type="ANSA_SUBSYSTEM"
            )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 22.0.0. Use :py:func: BCSettingsSetValues instead.",
        DeprecationWarning,
    )


def SetConfigurationIncludes(
    include_config: object, includes: object, load_option: int, incomplete_unload: bool
) -> object:
    """

    Sets includes to includes configuration.

    Parameters
    ----------
    include_config : object
            A refernce to an include configuration object.

    includes : object
            A list of includes to add to the cofiguration.

    load_option : int
            1, to update the include configuration.
            2, to reload the include configuration.
            Please note that this option renders all objects to entities invalid,
            including those to configurations and includes.

    incomplete_unload : bool, optional
            If set to True, information is returned in case of an Include
            that failed to unload.

    Returns
    -------
    object
            If incomplete_unload argument is not specified, or "incomplete_unload = False" is given as argument,
            the function returns 1 on sucess and 0 on error.
            If the argument "incomplete_unload = True", the function returns an object with two variables:
            a) success (integer: 0 on failure, 1 on success)
            b) incomplete_entities (list of includes that failed to unload).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                includes_mat = []
                config = base.CreateEntity(
                    constants.NASTRAN, "INCLUDE_CONF", {"Name": "INCLUDE_CONFIGURATION1"}
                )
                includes_mat.append(
                    base.CreateEntity(constants.NASTRAN, "INCLUDE", {"Name": "include_1"})
                )
                includes_mat.append(
                    base.CreateEntity(constants.NASTRAN, "INCLUDE", {"Name": "include_2"})
                )
                base.SetConfigurationIncludes(configuration, includes_mat, 2)
                # Configuration will not be reloaded as it is not the current configuration. Use LoadIncludeConfiguration instead.


    """


def SetCrossSectionsSettings(fields: object) -> int:
    """

    Set or change values of Cross Sections' global parameters.

    Parameters
    ----------
    fields : object
            A dictionary with pairs of labels - values: (parameter name, set value).
            Recognizable parameter names and set values are:
            "Transparent Plane" --> [0 | 1]
            "Transparency" --> integer value between 0 and 100
            "Cross curves resolution" --> float value
            "Automatically Update After Every Run" --> [0 | 1]
            "Calculate offsets and orientation of beams" --> [0 | 1]
            "Boundary elements accumulation factor" --> integer value between -20 and 20

            "<result> visibility" --> [0 | 1], (<result>: any Cross Section result)
            "<result> format" --> ["Default" | "Float" | "Scientific"], (<result>: any Cross Section result)
            "<result> decimal digits" --> integer value between 0 and 6, (<result>: any Cross Section result)

            "Extracted type" --> ["PBAR", "BEAM_SECTION", "Nastran PBAR" | "PBEAM", "BEAM_TAPER_SECTION", "Nastran PBEAM"]
            "Assign values based on" --> ["X-Y" | "1-2"]
            "Segments' distortion angle limit" --> float value
            "Segments' thickness mode" --> ["Initial" | "Adapted to beam property stiffness"]
            "Restrictions" --> ["Version < 2013.1" | "Version >= 2013.1"]
            "POINT start id" --> integer value
            "SET3 start id" --> integer value

            "Enable similarity" --> [0 | 1]
            "Similarity mode" --> ["Geometry" | "Results"]
            "factor(%)" --> float value between 0. and 100.
            "tol geom" --> float value
            "tol thick" --> float value
            "tol E" --> float value
            "tol n" --> float value
            "<result> tolerance" --> float value, (<result>: any Cross Section result)

            "Assume nonhomogeneous if E differs more than" --> float value
            "Definition of reference E, v" --> ["user_selection" | "specify"]
            "Eref" --> float value
            "vref" --> float value

    Returns
    -------
    int
            Returns zero on success, non zero on error.

    See Also
    --------
    GetCrossSectionsSettings

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetCrossSectionsSettings(
                    {
                        "Automatically Update After Every Run": 1,
                        "Calculate offsets and orientation of beams": 0,
                        "Dh visibility": 0,
                        "xs format": "Float",
                        "xs decimal digits": 2,
                        "Enable similarity": 1,
                        "Similarity mode": "Results",
                        "xs tolerance": "0.15",
                    }
                )


            if __name__ == "__main__":
                main()


    """


def SetCurrentAnsaModel(model: Entity) -> int:
    """

    This function sets the current ansa model. Different databases can be opened and handled
    in Ansa in separate model instances, but only one instance can be current at any single moment.
    All ansa functionality will run on the current model. The function should only be used in combination
    with the following functions:SetCurrentAnsaModel(), GetCurrentAnsaModel(), DestroyAnsaModel().

    Parameters
    ----------
    model : Entity
            The model object to be set as current.

    Returns
    -------
    int
            Returns 0 if the model has been successfully set as current.
            Otherwise, 1 is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import utils


            def main():
                old_model = (
                    base.GetCurrentAnsaModel()
                )  # Request for the current model instance. It will set current again at the end of all actions
                new_model = base.CreateNewAnsaModel()  # Create a new model instance
                base.SetCurrentAnsaModel(new_model)  # Set the new model as current
                utils.Merge(
                    "C:/temp/users/folder/new_data1.ansa"
                )  # In the new model merge a ansa database
                utils.Merge("C:/temp/users/folder/new_data1.ansa")  # Merge a second database
                base.SaveAs(
                    "C:/temp/users/folder/merge_dbs.ansa"
                )  # Save current model in a new database
                base.SetCurrentAnsaModel(old_model)  # Set the original current model as current
                base.DestroyAnsaModel(old_model)  # Destroy ansa old_model


    """


def SetCurrentDeck(deck: int) -> int:
    """

    The SetCurrentDeck function will change the current ANSA deck.

    Parameters
    ----------
    deck : int
            The current deck constant.

    Returns
    -------
    int
            Returns the integer of the previous ANSA 'current deck'.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                print("Switch form current to ABAQUS deck")
                old_deck = base.SetCurrentDeck(constants.ABAQUS)

                print("Reverting to previous deck")
                base.SetCurrentDeck(old_deck)


    """


def SetCurrentEntity(entity: object, current: object, deck: int) -> int:
    """

    Sets the current entity.

    Parameters
    ----------
    entity : object
            In order to set an object as current, entity is a
            reference to that object.
            In order to remove an object of a particular type
            from current, entity is a string  with "ansa keyword"
            of the type to be removed from current.

    current : object, optional
            This argument controls if the object
            will be set as current or will be removed from
            current, if possible.
            In order to set an object as current, do not pass
            current as argument.
            In order to remove an object of a particular type
            from current, pass current = None as argument.

    deck : int, optional
            The deck which the entity argument belongs to.
            Can be used only to remove an object of a particular
            type from current.
            Should be used to specify "ansa keyword" that exists
            in more than one decks (e.g. CONTROL, see Example).

    Returns
    -------
    int
            Returns 1 on failure, 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.CreateEntity(constants.NASTRAN, "PSHELL", {"Name": "TestCurrent"})
                base.SetCurrentEntity(ent)


            # Examples to remove an object of a particular type from current.
            def main():
                ent = base.CreateEntity(constants.NASTRAN, "INCLUDE", {"Name": "TestInclude"})
                base.SetCurrentEntity(ent)  # Set ent as current include.
                base.SetCurrentEntity(
                    "INCLUDE", current=None, deck=constants.NASTRAN
                )  # Remove ent from current include.


            def main():
                control = base.CreateEntity(
                    constants.LSDYNA, "CONTROL", {"Name": "TestDynaControl"}
                )
                base.SetCurrentEntity(control)  # Set control as current CONTROL (LSDYNA)
                base.SetCurrentEntity(
                    "CONTROL", current=None, deck=constants.LSDYNA
                )  # deck should be given to distinguish
                # keyword "CONTROL" between decks.
                # ("CONTROL" also exists in other decks)


    """


def SetCurrentMenu(menuName: str) -> int:
    """

    Switches from the current menu to the specified one.

    Parameters
    ----------
    menuName : str
            The menu name. Accepted values are 'TOPO', 'MESH', 'VOLUME MESH',
            'MORPH', 'HEXA BLOCK', 'CROSS' or 'KINETICS'.

    Returns
    -------
    int
            Returns 1 on successful menu switch, or 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetCurrentMenu("VOLUME MESH")


    """


def SetCurvesResolution(resolution: float, curves: object) -> int:
    """

    Sets the given resolution to the curves.

    Parameters
    ----------
    resolution : float
            The resolution that will be applied to the curves.

    curves : object
            A list of curves.
            If None, the resolution will be applied to the whole database.

    Returns
    -------
    int
            Returns 0 if None is given as the curves argument, otherwise 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_SetCurvesResolution():
                curves = base.CollectEntities(constants.NASTRAN, None, "CURVE")
                base.SetCurvesResolution(0.1, curves)


    """


def SetEdgesRightOrder(m: object) -> object:
    """

    Sorts input morphing edges in order to form a sequence of consecutive edges.

    Parameters
    ----------
    m : object
            A list that contains the input morphing edges that we want to sort in order to form
            a sequence of consecutive morphing edges. Input morphing edges are regarded to
            be able to form a sequence of consecutive morphing edges.

    Returns
    -------
    object
            Returns a list with the sorted morphing edges.
            In case of failure, returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                m = []
                # edges in random order
                m.append(base.GetEntity(constants.NASTRAN, "MORPHEDGE", 92))
                m.append(base.GetEntity(constants.NASTRAN, "MORPHEDGE", 20))
                m.append(base.GetEntity(constants.NASTRAN, "MORPHEDGE", 73))
                m.append(base.GetEntity(constants.NASTRAN, "MORPHEDGE", 56))

                # sort edges to form a sequence of consecutive edges
                sorted_moedges = base.SetEdgesRightOrder(m)

                # apply Edge Fit with the sequence of the consecutive edges
                base.MorphEdgeFit(sorted_moedges, 4, 1, 1)


    """


def SetEntityAttributeToSet(set: object, entities: object, attribute: object) -> int:
    """

    Changes the value that an entity's attribute has in a set.

    Parameters
    ----------
    set : object
            A reference to a set that already contains the ENTITY.

    entities : object
            A reference to an entity or a list with references to entities.
            If ENTITY is 0, the attribute's value is changed in every entity that
            belongs to the defined SET.

    attribute : object
            A dictionary with the following possible pair:
            "Oriented": "SPOS", "SNEG" or " ".
            "Output as": "PART_IO" or "PART" for properties and
            "BOX_SHELL", "BOX_SOLID", "BOX_SLDIO" or "BOX" for boxes.
            "Output Face as": "Solidfacets" or "Shells"

    Returns
    -------
    int
            Returns 1 on success. Throws an exception on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                set = base.GetEntity(constants.ABAQUS, "SET", 1)
                shells = base.CollectEntities(constants.ABAQUS, set, "SHELL")
                base.SetEntityAttributeToSet(set, shells, {"Oriented": "SPOS"})


            # ...or...


            def main():
                set = base.GetEntity(constants.LSDYNA, "SET", 1)
                box = base.GetEntity(constants.LSDYNA, "DEFINE_BOX_GENERAL", 1)
                base.SetEntityAttributeToSet(set, box, {"Output as": "BOX_SHELL"})


    """


def SetEntityCardValues(
    deck: int,
    entity: Entity,
    fields: dict,
    items: Iterable[Iterable] = None,
    debug: int = 1,
) -> int | Tuple[int, dict]:
    """

    Sets or changes values of an entity, by using its Edit Card.

    Parameters
    ----------
    deck : int
            The deck constant.

    entity : Entity
            The ANSA entity to set the values to.

    fields : dict
            A dictionary with keys the name of the ANSA card
            labels and values the desired card field values.
            The fields dictionary you can also use as a pair:
            __table_curves: Curves willing to insert into a table.
            __table_values: The Rate values that will be used for the above curves.

    items : Iterable[Iterable], optional
            A pair of lists, one that contains curves and another that contains x values.
            Only for use with TABLE entities
            (e.g. [ [curve1, curve2, ...], [x1, x2, ...] ])

    debug : int, optional
            If debug is set to ansa.constants.REPORT_ALL returns a tuple that has two items:
                    an integer that values 0 on success, non zero on error
            and     a dictionary that holds any errors / warnings found. This dictionary has as keys the fields that were used upon calling the function and lead to errors / warnings. The data for each field is a dictionary with two keys:
                            'type' that holds the words 'error' or 'warning' as data.
                            'message' that holds the error message generated by this field.

            If debug is ansa.constants.REPORT_SILENCE returns a tuple that has two items:
                    an integer that values 0 on success, non zero on error and an empty dictionary

            If not given ony an integer will be returned.

    Returns
    -------
    int | Tuple[int, dict]
            When debug argument is not given: Returns 0 on success, non zero on error.
            If debug argument is given: Returns a tuple with an integer as before and a dictionary with errors.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                prop = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                vals = {"T": 1.2, "Name": "PSHELL property"}

                base.SetEntityCardValues(constants.NASTRAN, prop, vals)


            # Example for table entities:
            def main():
                table = base.GetEntity(constants.ABAQUS, "ABQ_TABLE", 1)

                curves = []
                a_curve = base.GetEntity(constants.ABAQUS, "DEPENDENCY_DATA_TABLE", 2)
                curves.append(a_curve)
                a_curve = base.GetEntity(constants.ABAQUS, "DEPENDENCY_DATA_TABLE", 3)
                curves.append(a_curve)

                values = []
                values.append(5.0)
                values.append(6.0)

                fields = {"Name": "fixed_table", "__table_curves": curves, "__table_values": values}

                base.SetEntityCardValues(constants.ABAQUS, table, fields)


            import pprint


            def main():
                ent = base.GetEntity(ansa.constants.ABAQUS, "SOLID", 16583)

                list = {"G21": 8, "G3": 146564655656}
                debug_mode = constants.REPORT_ALL
                ret, debug_report = base.SetEntityCardValues(
                    constants.ABAQUS, ent, list, debug=debug_mode
                )

                if not ret:
                    pprintt.pprint("No errors or warnings found!")
                else:
                    pprint.pprint(debug_report)
                debug_mode = constants.REPORT_SILENCE
                ret = base.SetEntityCardValues(constants.ABAQUS, ent, list, debug=debug_mode)


    """


def SetEntityId(entity: object, id: int, force: bool, respect_frozen: bool) -> int:
    """

    Assign a new ID to the entity.

    Parameters
    ----------
    entity : object
            A reference to an entity.

    id : int
            The new id to be assigned.

    force : bool, optional
            False: if the new_id is already reserved by an entity of the
            same type the function will not be executed.
            True: if the new_id is already reserved by an entity of the
            same type then the entity with the requested new id will take a new id
            and the function will be executed.

    respect_frozen : bool, optional
            False: Ignore if the entity has a frozen id, or if new_id is frozen.
            The function will be executed.
            True: if entity has a frozen id, or if new_id is frozen
            the execution of the function will be stopped.

    Returns
    -------
    int
            Returns 1 if the new id has been assigned to the entity successfully, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "SHELL", 1)
                if ent and base.SetEntityId(ent, 1000000, True, False):
                    print("Entity has Id: 1000000")


    """


def SetEntityPart(ent: object, part: object) -> int:
    """

    This function assigns one or more entities to a specific part. It can also be used to assign a part to a group. Moreover, it can be used to move a part to the top level of the hierarchy (by using None as the argument for the entity to tranfer to)

    Parameters
    ----------
    ent : object
            An entity or a list of entities to be assigned.

    part : object
            The part entity to transfer ent into.
            None argument is also accepted for the following kinds of entities:
            GEBs, RESULTs_MAPPERs, INVERSE FORMINGs, SPCs, AIRBAGs, MOTIONs,
            DEFINE_HEX_SPOTWELD_ASSEMBLY, DISPLAY MODELs, Nastran PEM entities
            (TRMCPLs, ACPEMCPLs), Nastran Thermal BCs (QVECT etc), CONNECTIONs.

    Returns
    -------
    int
            Returns 1 on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(
                    constants.NASTRAN, "SHELL", 10000
                )  # Get entity with specific id
                part = base.GetPartFromModuleId("300")  # Get parent part
                base.SetEntityPart(ent, part)  # Assign entity to parent part

                ents = []
                ents.append(base.GetPartFromModuleId("100"))  # Add a part reference in matrix
                for i in range(1, 100):
                    ents.append(
                        base.GetEntity(constants.NASTRAN, "SHELL", i)
                    )  # Add entities of type GRID in matrix
                part = base.GetPartFromModuleId("200")  # Get parent part
                base.SetEntityPart(ents, part)  # Set all matrix entities in part


    """


def SetEntityVisibilityValues(deck: int, fields: object) -> int:
    """

    This function enables/disables the corresponding the visibility flags of the database browser
    When status equals "enable" or "on" the visibility flag is turned on,
    othewise the visibility flag is turned off.
    The name is the exact match of the string located inside the brackets () on the
    title bar of the entity's EDIT card.

    Parameters
    ----------
    deck : int
            The deck.

    fields : object, optional
            A dictionary with key-value pairs the visibilty flags and the "on"/"off" switches.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                m = base.SetEntityVisibilityValues(
                    constants.NASTRAN, {"BEAM": "enable", "SHELL": "off"}
                )
                # will turn Nastran's "BEAM" visibility flag on and "SHELL" visibility flag off.
                m = base.SetEntityVisibilityValues(
                    constants.ABAQUS, {"GASKET": "on", "FASTENER": "disable"}
                )
                # will turn Abaqus's "GASKET" visibility flag on and "FASTENER" visibility flag off.
                m = base.SetEntityVisibilityValues(constants.NASTRAN, {"all": "on"})
                # will turn all Nastran's deck visibility flags on.


    """


def SetGeneralComment(text: str) -> int:
    """

    This function sets a string text as a General Comment.
    If a comment already exists, it will be replaced.

    Parameters
    ----------
    text : str
            The general comment text.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa


            def main():
                ansa.base.SetGeneralComment("User Comment")


    """


def SetIncludeFileInDM(
    filename: str,
    module_id: str,
    deck_name: str,
    st_version_conflict: str,
    entity_representation: str,
    entity_name: str,
    entity_version: str,
) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`AddIncludeFile` instead.


    This function adds a new file in DM, under the includes directory, based on the arguments provided. The file
    specified by the string variable 'file_path' will be copied in DM, under a directory structure which will be created
    based on the string variables 'module_id', 'deck' and a number of optional ones, which can be set to define
    more accurately the save path. Varlen is the list of optional (argument name,value) pairs.

    Parameters
    ----------
    filename : str
            The include's filename.

    module_id : str
            The module id of the include file.

    deck_name : str
            A string specifying the deck, i.e. constants.

    st_version_conflict : str, optional
            Defines the action to be taken in case another entry with the
            characteristis defined above, has already been added in DM.
            In such a case you can decide either to create a new study version
            by setting the variable to 'NEW_ST_VERSION' or overwite the
            existing file in DM by setting the variable to 'OVERWRITE'.

    entity_representation : str, optional
            Defines the representation name to be used during the building of the
            DM directory structure where the new file will be added. If it is not set,
            the default representation 'common' will be used.

    entity_name : str, optional
            Defines the name to be assigned to new file to be created in DM. If this
            is not set, the name will be extracted from the string variable 'file_path'.
            The file_path's last section will be assigned as name. If this also fails,
            then the file will be assigned the default name 'Default_DM_Name'.

    entity_version : str, optional
            Defines the version name to be used during the building of the DM directory
            structure where the new file will be added. If it is not set, the default
            version 'A1' will be used.

    Returns
    -------
    int
            Returns 0 if the file has been successfully added in the DM and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # 1st ex.
                base.SetIncludeFileInDM(
                    "/home/temp_dir/include_file.key",  # The file's path to be copied in DM
                    "10001",  # The file's corresponding module id
                    "LSDYNA",  # The file's corresponding deck
                    entity_representation="crash",  # The file's corresponding representation
                    entity_version="AB",  # The files corresponding version
                    st_version_conflict="OVERWRITE",
                )  # In case of study version conflicts, overwrite existing file in DM

                #  2nd ex.
                base.SetIncludeFileInDM(
                    "/home/temp_dir/include_file.key",  # The file's path to be copied in DM
                    "10001",  # The file's corresponding module id
                    "LSDYNA",  # The file's corresponding deck
                    entity_representation="crash",  # The file's corresponding representation
                    st_version_conflict="NEW_ST_VERSION",
                )  # In case of study version conflicts, create new study version in DM

                # 3rd ex.
                base.SetIncludeFileInDM(
                    "/home/temp_dir/include_file.key",  # The file's path to be copied in DM
                    "10001",  # The file's corresponding module id
                    "LSDYNA",
                )  # The file's corresponding deck


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: AddIncludeFile instead.",
        DeprecationWarning,
    )


def SetIncludesInDM(includes: object, st_version_option: str) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`AddIncludes` instead.


    This function adds new files in DM, under the includes directory, based on the DM field values of the
    specified include entities, provided in matrix includes. For each of the include entities, the file specified
    in the field 'FullPathName' will be copied in DM, under a directory structure which will be created based
    on the include's corresponding DM values. Varlen is the list of optional (argument name,value) pairs.

    Parameters
    ----------
    includes : object
            An include entity or a list of include entities.

    st_version_option : str, optional
            Defines the action to be taken in case another entry with the
            attributes defined above, has already been added in DM.
            In such a case you can decide either to create a new study version
            by setting the variable to 'NEW_ST_VERSION',
            overwite the existing file in DM by setting the variable
            to 'OVERWRITE', or skip the specific include by setting the variable
            to "SKIP". The default value is 'NEW_ST_VERSION'.

    Returns
    -------
    int
            Returns 0 if the files have been successfully added in DM and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                includes = base.CollectEntities(constants.NASTRAN, None, "INCLUDE")
                print(len(includes))

                print(base.SetIncludesInDM(includes))


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: AddIncludes instead.",
        DeprecationWarning,
    )


def SetLoadCurveData(CURVE: object, VALUES: object) -> int:
    """

    Sets the data values of an existing load curve.

    Parameters
    ----------
    CURVE : object
            The load curve entity whose data will be set.

    VALUES : object
            Values can be a list with lists of x,y pairs of data.
            It can also be a text file path.

    Returns
    -------
    int
            Returns 1 on success or 0 otherwise.

    See Also
    --------
    CreateLoadCurve

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Using a data file:
                curve = base.CreateLoadCurve("DEFINE_CURVE", {"Name": "new curve name"})
                base.SetLoadCurveData(curve, "/home/user/data.txt")

            \tWhere /home/user/data.txt may contain the following data:
            \t\t0.0\t2.0
            \t\t1.0\t4.0
            \t\t2.0\t8.0
            \t\t3.0\t16.0
            \t
                # Using a list:

                mat = ((0.0, 2.0), (1.0, 4.0), (2.0, 8.0), (3.0, 16.0))
                curve = base.CreateLoadCurve("DEFINE_CURVE", {"Name": "new curve name"})
                base.SetLoadCurveData(curve, mat)

                # Both examples will add 4 rows and 2 columns of data into curve.


    """


def SetOrderedAttributeOfSet(SET, ordered_option) -> int:
    """

    This function changes the status of the set's ordered attribute.

    Parameters
    ----------
    SET :
            A reference to a set.

    ordered_option :
            Can be "YES" or "NO".

    Returns
    -------
    int
            Returns 0 if SET is not a valid reference, or 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                set = base.GetEntity(constants.NASTRAN, "SET", 1)
                base.SetOrderedAttributeOfSet(set, "YES")


    """


def SetStarFormat(star_format) -> int:
    """

    This function sets the active STAR format.

    Parameters
    ----------
    star_format :
            "STAR-CD" or "STAR-CCM+".

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetStarFormat("STAR-CCM+")


    """


def SetStatusOfNumberingRules(activate: bool, do_subrules: bool, rules: object) -> int:
    """

    This function activates or deactivates numbering rules.
    If no argument is defined, all the existing rules are activated, otherwise only the selected ones.

    Parameters
    ----------
    activate : bool
            Set to True to activate rules or False to deactivate them.

    do_subrules : bool
            If set to True, then if a general rule is selected, all subrules
            will follow the status of the general rule.

    rules : object, optional
            A list of references to numbering rules to be activated/deactivated.
            If no arguments are defined, the function sets as active or inactive,
            all the existing numbering rules.

    Returns
    -------
    int
            Always returns 1.

    See Also
    --------
    CreateNumberingRule, CreateNumberingRuleWithIncrement, Renumber

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                rule1 = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "TOOL",
                    None,
                    "ELEMENT",
                    "PER_GROUP",
                    1,
                    1000000,
                    "element_rule",
                    preserve_ids=True,
                )
                rule2 = base.CreateNumberingRuleWithIncrement(
                    constants.NASTRAN,
                    "TOOL",
                    None,
                    "GRID",
                    "PER_GROUP",
                    1,
                    1000000,
                    50,
                    "grid_rule",
                )
                base.SetStatusOfNumberingRules(True, True)
                base.Renumber()


    """


def SetTypesToCompareSettingsValues(key: str, fields: object) -> int:
    """

    Sets or changes values of parameters concerning the 'Compare Settings' window
    in Compare process (not 'Advanced' options).

    Parameters
    ----------
    key : str
            A string describing the parameters' full name in tree view,
            e.g., "GEOMETRY (PARTS)::PROPERTY::PSHELL".

    fields : object, optional
            A list or a dictionary that holds a pair of the "compare" command
            with its value (On/Off, True/False)

    Returns
    -------
    int
            Returns 0 on success, non-zero otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetTypesToCompareSettingsValues(
                    "GEOMETRY (PARTS)::MATERIAL::MAT1", ["compare", "ON"]
                )


    """


def SetViewAngles(
    f_key: str, rot_x: float, rot_y: float, rot_z: float, coord_id: object
) -> int:
    """

    The SetViewAngles function sets the Graphics view screen to the defined angles's values.

    Parameters
    ----------
    f_key : str, optional
            The function key.

    rot_x : float, optional
            The around X-axis(roll) rotation angle.

    rot_y : float, optional
            The around Y-axis(pitch) rotation angle.

    rot_z : float, optional
            The around Z-axis(yaw) rotation angle.

    coord_id : object, optional
            The coordinate system in order to align the view
            based on a local coordinate system.

    Returns
    -------
    int
            Returns 0 on error, or 1 on success.

    See Also
    --------
    ZoomAll, ZoomIn, ZoomOut, ZoomInEnt, GetZoom, SetZoom

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetViewAngles(rot_x=90.0, rot_y=22.5, rot_z=-180.0)
                base.SetViewAngles(f_key="F10")


    """


def SetViewButton(fields: object) -> int:
    """

    This function enables/disables/sets the corresponding visibility flag to the value inputted.
    When the value equals "on"/"off", the view flag is turned on/off. The name of the visibility flag
    to set is the name of the buttton as seen inside the pulldown menu or the tooltip of it.

    Parameters
    ----------
    fields : object
            A dictionary with a pair of visibility flags and 'on'/'off'

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetViewButton({"SHADOW": "on", "VIEWMODE": "PID", "GRIDs": "off"})
                # will turn shadow view flag on and will set viewmode button to mode "PID".
                base.SetViewButton({"VIEWMODE": "STEP PRESS 3"})
                # will set viewmode button to third step of EL PRESS.
                base.SetViewButton({"VIEWMODE": "Subsystem"})
                # will set viewmode button to Subsystem
                base.SetViewButton({"VIEWMODE": "MBCONTAINERS>Classification"})
                # will set viewmode button to Classification
                base.SetViewButton({"VIEWMODE": "EL.STRESS>VON MISES STRESS"})
                # will set viewmode button to EL.STRESS VON MISES STRESS.
                base.SetViewButton({"VIEWMODE": "STEP FILM 1 T"})
                # will set viewmode button to the first step of EL.FILM T.
                base.SetViewButton({"CURVES": "on", "CURVES>Default color": "on"})
                # will turn curves view flag on and set curves draw mode to "Default color".
                base.SetViewButton({"POINTs>Color by entity": "on"})
                # will set points draw mode to "Color by entity".


    """


def SetZoom(trans: object) -> int:
    """

    This function sets the Graphic window minimum and maximum limits and the rotation center point of it.

    Parameters
    ----------
    trans : object
            A list of 9 values in the form [xmin, ymin, zmin, xmax, ymax, zmax, rtcn_x, rtcn_y, rtcn_z].

    Returns
    -------
    int
            Returns 1 on success and 0 on error.

    See Also
    --------
    GetZoom

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                zoom = base.GetZoom()
                if zoom:
                    base.SetZoom(zoom)


    """


def ShrinkSurfs(faces: object, per_face: bool) -> int:
    """

    Shrinks the surfaces of the input faces.

    Parameters
    ----------
    faces : object, optional
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.
            If no faces are given, the function shrinks the surfaces of the "visible" faces.

    per_face : bool, optional
            If True surface will shrink per face, else surface will shrink until the limits
            of the lying faces.
            (Default: False)

    Returns
    -------
    int
            Returns 1 on success and 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                faces = base.CollectEntities(ansa.constants.NASTRAN, None, "FACE")
                ShrinkSurf = base.ShrinkSurfs(faces, True)
                print(ShrinkSurf)


    """


def SizeBoxCylindrical(
    curve: object,
    rad1: float,
    rad2: float,
    max_length_surface: float,
    max_length_volume: float,
    auto_sort: bool,
) -> object:
    """

    Script function for creating cylindrical sizeboxes.

    Parameters
    ----------
    curve : object
            A list of CURVEs or POINTs.

    rad1 : float
            The inner cylindrical radius.

    rad2 : float
            The outer cylindical radius.

    max_length_surface : float
            The maximum surface length.

    max_length_volume : float
            The maximum volume length

    auto_sort : bool, optional
            True (default): The order of objects in curve list will be reorder
            in order to have an improved result.
            False: The order of objects in curve list will be preserved.

    Returns
    -------
    object
            It returns the object of the created cylindrical sizebox for success, or 0 for failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curve = base.GetEntity(constants.NASTRAN, "CURVE", 2)
                base.SizeBoxCylindrical(curve, 10.0, 20.0, 1.6, 19.3)


    """


def SizeBoxDelete(sizebox: object) -> int:
    """

    Script function for deleting a sizebox.

    Parameters
    ----------
    sizebox : object
            A list with the sizeboxe elements that will be deleted.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def sizeBoxDel():
                sb = base.GetEntity(constants.NASTRAN, "SIZE_BOX", 1)
                base.SizeBoxDelete(sb)

                # Using a list
                sblist = []
                sblist.append(base.GetEntity(constants.NASTRAN, "SIZE_BOX", 2))
                sblist.append(base.GetEntity(constants.NASTRAN, "SIZE_BOX", 3))
                base.SizeBoxDelete(sblist)


    """


def SizeBoxInsert(pnt1: object, pnt2: object, edg: object, par: str) -> int:
    """

    Script function for the insertion of control points.

    Parameters
    ----------
    pnt1 : object
            .The first control point to get direction

    pnt2 : object
            The second control point to get direction.

    edg : object
            The sizebox edge element to insert the point.

    par : str
            A value between 0-1 or ~distance should be given (ie: "0.5" or "~111").

    Returns
    -------
    int
            Returns the new id on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                a = base.GetEntity(constants.NASTRAN, "SIZEBOXEDGE", 3)
                b = base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 8)
                c = base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 10)
                pnt1 = base.SizeBoxInsert(c, b, a, "0.2")


    """


def SizeBoxJoin(hatch: object, flag: int) -> int:
    """

    Script function for joining a sizebox hatch.

    Parameters
    ----------
    hatch : object
            The sizebox hatch element that will be joined.

    flag : int
            0 or 1, whether to leave or delete the points that are left from joined hatches.

    Returns
    -------
    int
            1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "SIZEBOXFACE", 4)
                base.SizeBoxJoin(ent, 1)


    """


def SizeBoxMinMax(
    coordinate: object,
    min_xyz: object,
    max_xyz: object,
    max_length_surface: float,
    max_length_volume: float,
) -> object:
    """

    Script function for creating a sizebox from two points (min, max).

    Parameters
    ----------
    coordinate : object
            The coordinate element (None for global).

    min_xyz : object
            A list containing the minimum coordinates [xmin, ymin, zmin].

    max_xyz : object
            A list containing the maximum coordinates [xmax, ymax, zmax].

    max_length_surface : float
            The maximum surface length.

    max_length_volume : float
            The maximum volume length.

    Returns
    -------
    object
            Returns a reference to the newly created size box entity on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def minmaxbox(min_coords, max_coords):
                base.SizeBoxMinMax(None, min_coords, max_coords, 10, 10)


    """


def SizeBoxOrtho(
    loaded_elements: object,
    db_or_visible: str,
    coordinate: object,
    min_flag: bool,
    max_length_surface: float,
    max_length_volume: float,
    directions: object,
) -> object:
    """

    Script function for the creation of a sizebox

    Parameters
    ----------
    loaded_elements : object, optional
            A list with elements from which the Sizebox will be created.

    db_or_visible : str, optional
            Can have values 'DB' or 'Visible' in order to take the elements
            from which the Sizebox will be created.

    coordinate : object, optional
            A local coordinate object instead of the global.

    min_flag : bool, optional
            True or False for minimum volume morph.

    max_length_surface : float, optional
            The value for the maximum surface length.

    max_length_volume : float, optional
            The value for the maximum volume length.

    directions : object, optional
            A list of 2 directions to define specific orientation for the hexa box. Must be perpendicular to each other.

    Returns
    -------
    object
            Returns a reference to the newly created size box entity on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SizeBoxOrtho(db_or_visible="DB")
                base.SizeBoxOrtho(db_or_visible="Visible", min_flag=True)

                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL", filter_visible=True)
                base.SizeBoxOrtho(
                    loaded_elements=shells,
                    min_flag=True,
                    max_length_surface=11,
                    max_length_volume=2,
                )

                vectors = [[0.0, 0.5, 0.5], [1.0, 0.0, 0.0]]
                mesh.SizeBoxOrtho(shells, directions=vectors)


    """


def SizeBoxSplit(pnt: object) -> int:
    """

    Script function for splitting sizebox(es).

    Parameters
    ----------
    pnt : object
            The sizebox point element, where the box(es) will be cut.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                a = base.GetEntity(constants.NASTRAN, "SIZEBOXEDGE", 12)
                b = base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 22)
                c = base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 10)
                pnt = base.SizeBoxInsert(c, b, a, "0.6")

                ent = base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", pnt)
                base.SizeBoxSplit(ent)


    """


def Skin(
    apply_thickness: bool,
    new_pid: bool,
    offset_type: int,
    ok_to_offset: bool,
    max_thickness: float,
    delete: bool,
    entities: object,
    similarity: int,
    treat_chamfers: bool,
    new_part: bool,
    part: object,
    property: object,
    deviation: float,
    larger_side: bool,
    fail_on_all_errors: bool,
) -> int:
    """

    This function turns the solid description of a thin part into shell description by isolating
    the smaller or larger area side of the solid description.

    Parameters
    ----------
    apply_thickness : bool
            If True, applies new thickness.

    new_pid : bool
            If True, creates new property.

    offset_type : int
            1, produces geometry offset.
            2, produces link offset using distance.
            3, produces link offset using thickness.

    ok_to_offset : bool
            If False, keeps the smaller or larger area side (NO offset).
            If True, offset skin.

    max_thickness : float
            The maximum thickness of solids.

    delete : bool
            If True, deletes original Faces.

    entities : object, optional
            If nothing passed, it works on visible faces,
            else it works on the faces entities contained in a list.

    similarity : int, optional
            Similarity percentage is a minimum similarity factor between the two
            opposite skin side areas.
            Range [50, 90]

    treat_chamfers : bool, optional
            If True, tries to trim or extend middle surface in order to take into account chamfers.

    new_part : bool, optional
            If True, creates new ANSAPART.

    part : object, optional
            A reference to an ANSAPART. When given, all the resulting faces will
            be placed in this part (and the option "new_part" is then disregarded).

    property : object, optional
            A reference to a Property. When given, all the resulting faces will be
            placed in this property (and the option "new_pid" is then disregarded).

    deviation : float, optional
            This is the thickness difference threshold for stable thickness parts.

    larger_side : bool, optional
            When TRUE it selects the solid side that is larger in area.
            Default value is FALSE.

    fail_on_all_errors : bool, optional
            When TRUE, this function works as before (default behavior is fail on all errors found).
            When FALSE, this function returns a dictionary with keys "skinned", "check", "failed".
            Each key contains as value a list of dictionaries about every part in this category.
            Those dictionaries have keys "skin" and "orig" and value a list of faces.
            User should always check skin result under "check" category and manually
            delete "orig" faces if middle surface is acceptable.

    Returns
    -------
    int
            Returns the number of solid descriptions that have been turned into shell descriptions
            and 0 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE")

                num_shell_descriptions = base.Skin(
                    apply_thickness=True,
                    new_pid=True,
                    offset_type=2,
                    ok_to_offset=True,
                    max_thickness=5.0,
                    delete=True,
                    entities=faces,
                )


    """


def StoreLockView(name: str, overwrite: bool) -> object:
    """

    This function accepts as an argument a string with the name of the model view to store.
    The current visible model is stored. It also supports a variable number of arguments
    in order to ovewrite an existing model view.

    The stored view affects the dislayed entities along with the view angle and their
    zoom position.

    Parameters
    ----------
    name : str
            The name of the lock view to store.

    overwrite : bool, optional
            Set to True in order to overwrite an existing model view.
            (Default: False)

    Returns
    -------
    object
            Returns a reference to the created view on success and None if the view already exists.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetViewAngles(rot_x=20.0, rot_y=45.0, rot_z=-180.0)
                lockview = base.StoreLockView("X_+90_Y+45_Z-180", True)


    """


def SurfsCoons(
    faces_array: object,
    join_perimeters: bool,
    respect_user_selection: bool,
    ret_ents: bool,
) -> object:
    """

    This script function creates a new multi-patch Surface, using the Coons interpolation principal.
    It takes a list of cons or curves, puts in line the elements of table (automatically) and then creates faces.

    Parameters
    ----------
    faces_array : object
            A list with entities ( CONS, CURVES, ELEMENTS, CONNECTION CURVES etc ).
            Based on these entities, the function will create the new faces.

    join_perimeters : bool, optional
            A boolean value to join the perimeters of the created faces or not.

    respect_user_selection : bool, optional
            If set to True, then the order of entries in faces_array will be respected
            and thus Cons will be created in that order.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns the number of the created faces on success, otherwise 0.
            If ret_ents=True it will return a list with the created entities,
            or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves_arr = base.CollectEntities(constants.NASTRAN, None, "CURVE")
                base.SurfsCoons(curves_arr, respect_user_selection=True)


    """


def SurfsUntrim(elem: object, del_old_faces: int, convert_links: bool) -> int:
    """

    This script function defines a new face that is bounded at the parametric limits of the surface.

    Parameters
    ----------
    elem : object
            A list of face objects.

    del_old_faces : int
            Denotes if the old faces will be deleted or not.

    convert_links : bool, optional
            If set to True, the linked faces will be converted, else they will be deleted.
            (Default: False)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                faces = []
                faces.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 117))
                faces.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 118))
                faces.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 29))
                faces.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 27))
                faces.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 26))

                base.SurfsUntrim(faces, True, True)


    """


def SymmetryPart(
    parts: object,
    transformation_mode: str,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: int,
    ext_connectors: bool,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function performs transform > symmetry on parts based on the arguments provided.
    The list PARTS contains the part/s to be transformed.

    Parameters
    ----------
    parts : object
            An part entity or a list of parts entities.

    transformation_mode : str
            Supported values are "COPY", "MOVE" or "LINK".

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not.
            Used only in COPY and LINK cases. Supported values are
            0, to denote that offset will not take place and any
            other integer to denote the actual property offset value. Alternatively,
            you can set the value to "auto_offset", so that pids will be automatically
            offset by ANSA or "current_property" to assign the current PID to all
            the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source Module
            Id for the production of the new Module Id. It is taken into account
            only when GROUP OPTIONS is set to "NEW PART". It is ignored in any
            other case.

    set_mode : str, optional
            Determine the options regarding the set, if any, in which the new entities
            will belong. Supported values are "COPY", "EXPAND" and "NONE". It is taken
            into account only when TRANSFORMATION MODE is "COPY" or "LINK".
            (Default: "NONE")

    connectivity : int, optional
            Determines whether the connecting nodes between moved and unmoved entities
            should be released or not. It is valid only when TRANSFORMATION MODE is
            "MOVE". Supported values are 1 and 0.
            (Default: 0)

    ext_connectors : bool, optional
            Determines whether external connections and/or connectors will be
            included in case the TRANSFORMATION MODE is "MOVE".
            Supported values are "INCLUDE" and
            "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: "False")

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = []
                parts.append(base.GetPartFromModuleId("100"))
                parts.append(base.GetPartFromModuleId("200"))
                base.SymmetryPart(
                    parts,  # Parts to be symmetry transformed.
                    transformation_mode="LINK",  # Parts will be symmetry-linked.
                    connectivity=True,  # Connecting nodes will NOT be released.
                    ext_connectors="INCLUDE",  # External connections and connectors will also be moved.
                    group_options="SAME PART",  # Linked entities will be put in the same part.
                    pid_offset=True,  # The entities' pids will be offset.
                    set_mode="EXPAND",
                )  # The set in which the initial entities belonged will expand
                # to include also the new entities.


    """


def SynchronizeMaterials(
    entities: object,
    source_deck: int,
    target_decks: int,
    delete_released: bool,
    update_from_mdb: bool,
    return_synced_materials: bool,
    sync_defined_flag: bool,
) -> object:
    """

    This function synchronizes materials used from PROPERTIES, from SOURCE_DECK to TARGET_DECKS.

    Parameters
    ----------
    entities : object
            A property/material object or a list of property/material objects
            that will be synchronized.

    source_deck : int
            The deck from which the synchronization will be
            performed.

    target_decks : int
            The decks to which the synchronization will be performed.
            Zero value means all decks except source_decks.

    delete_released : bool, optional
            A flag that indicates if released materials will be
            deleted or not, after synchronization.

    update_from_mdb : bool, optional
            A flag that indicates if synchronized materials will be
            updated from Material Database.

    return_synced_materials : bool, optional
            A flag that indicates whether the materials synced
            will be returned in a list.

    sync_defined_flag : bool, optional
            A flag that indicates whether the flag "DEFINED" of synchronized
            materials will be updated according to the source material or not.

    Returns
    -------
    object
            Returns 0 or a list of the synced materials if the returned_synced_materials flag is set to True.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def sync_mat():
                trg_decks = (constants.LSDYNA, constants.PAMCRASH)
                props = []
                props.append(base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 1))
                props.append(base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 2))

                synced_mats = base.SynchronizeMaterials(
                    props, constants.LSDYNA, trg_decks, True, False, True, True
                )

                for mat in synced_mats:
                    print(mat)


    """


def FillHoleGeom(
    diameter: Any,
    create_point: bool,
    convert_to_connection_point: bool,
    create_curve: bool,
    only_internal_perimeters: bool,
    always_produce_new_faces: bool,
    set_id: int,
    pid_id: int,
) -> int:
    """

    This function fills holes on Faces. The holes can be of any shape. Such internal openings
    can be inputs individually, or automatically among the visible ones if they fall below a
    user specified diameter value. There is the option to create automatically 3D Curves,
    Points or Connection Points of the removed holes, in order to mark their shape and position
    for reference, fill only internal perimeters, always produce new faces, add new faces to a
    SET and/or PID.

    Parameters
    ----------
    diameter : Any
            (object/float) A CONS or a list of CONS that belong to internal
            openings, which are automatically identified, or a float diameter
            of the holes to be filled, that fall below that value.
            The function automatically identifies whether the input is an object
            or a float.

    create_point : bool
            Defines whether to create a 3d point at the center of the
            hole or not.

    convert_to_connection_point : bool
            Defines whether to convert the 3d point to connection point
            or not.

    create_curve : bool
            Defines whether to create a 3d curve at the hole edges or
            not.

    only_internal_perimeters : bool, optional
            Defines whether to fill only internal perimeters  or not.
            (Default: False)

    always_produce_new_faces : bool, optional
            Defines whether to always create new faces
            or to allow expanding the existing ones.
            (Default: False)

    set_id : int, optional
            Defines the SET where the result faces will be added to.

    pid_id : int, optional
            Defines the PID where the result faces will be added to.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Using a float as diameter
                base.FillHoleGeom(
                    4, False, False, True, always_produce_new_faces=True, set_id=4, pid_id=5
                )


            # ...or...


            def main():
                # Two internal openings, where the respective CONS belong, are identified and filled by the function.
                cons = []
                cons.append(base.GetEntity(constants.NASTRAN, "CONS", 146))
                cons.append(base.GetEntity(constants.NASTRAN, "CONS", 144))
                base.FillHoleGeom(cons, False, False, False, only_internal_perimeters=True)


    """


def Topo(
    cons: object, paste_with_frozen_faces: bool, paste_different_pids: bool
) -> int:
    """

    This script function automatically creates topological conditions between input adjacent CONS.
    This function uses as criteria the tolerance values that are set by the TOLERANCES(SETTINGS) function.
    In case that no input cons is given, topology performs on visible cons.

    Parameters
    ----------
    cons : object, optional
            A cons, a list of cons, a string with value 'visible' or a string with value
            'all' . If it is called with 'visible', it works with all the visible cons.
            If it is called with 'all', it works with all the cons.
            In case that no input cons is given, topology performs on visible cons.

    paste_with_frozen_faces : bool, optional
            If True, topology performs on CONS that belong to frozen faces.

    paste_different_pids : bool, optional
            If True, topology performs on CONS that belong to different PIDs.
            (Default: True)

    Returns
    -------
    int
            Returns 0 if no CONS is input for topology, otherwise 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ents = []
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 2))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 3))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 6))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 7))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 76))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 72))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 9))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 10))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 12))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 92))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 88))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 100))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 96))

                ansa.base.Topo(cons=ents, paste_with_frozen_faces=True, paste_different_pids=True)


            # ...or...


            def main2():
                ansa.base.Topo()  # topology between visible CONS


    """


def TopoHotPoints(entities: object) -> int:
    """

    The function creates topological conditions among the input hot points. The operation is
    performed according to the hotpoints tolerance defined in Settings > Tolerances.
    It must be noted that in case of linked faces, all the hot points belonging to the geometric
    and the linked faces must be input to the function.

    Parameters
    ----------
    entities : object
            A list of faces, cons, parts, properties or sets (array or a single entry).
            All hot points will be collected and topological conditions will be created.

    Returns
    -------
    int
            Returns the number of topological conditions created.
            If no topological conditions are created, 0 is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE")
                ret = base.TopoHotPoints(faces)
                print(ret)


    """


def TransformCreate(name: str = "", entity: Entity | None = None) -> Entity:
    """

    The TransformCreate function creates an empty transformation. The parameters
    of the function are pairs of arguments. The first argument of the pair
    is a string, holding the parameter name, while the second is the value of
    the parameter.

    Parameters
    ----------
    name : str, optional
            The name of the new transformation.

    entity : Entity|None, optional
            A set or include or submodel, where the transformation will be applied.

    Returns
    -------
    Entity
            Returns a reference to the newly created transformation, on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                trsfm = base.TransformCreate(name="my_trsfm")


    """


def TransformDeleteLine(transform: object, position: int) -> int:
    """

    The TransformDeleteLine function deletes the line in position "position" in transformation "transform".

    Parameters
    ----------
    transform : object
            The existing transformation entity from which the line will be deleted.

    position : int
            The index in the transformation list, that specifies which line will be deleted.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    TransformModify, TransformInfo, TransformInsertLine, TransformModifyLine, TransformCreate

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Create a transformation entity
                trsfm = base.TransformCreate(name="my_trsfm")

                # Add lines
                vals = (
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Rotate",
                    "definition",
                    "Nodes",
                    "N0",
                    16,
                    "N1",
                    17,
                    "N2",
                    14,
                    "Angle",
                    44,
                )
                base.TransformInsertLine(trsfm, vals, 100)
                vals = (
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Rotate",
                    "definition",
                    "Coordinates",
                    "ux",
                    5,
                    "uy",
                    4,
                    "uz",
                    7.1,
                    "x0",
                    14,
                    "y0",
                    14.1,
                    "z0",
                    14.2,
                    "Angle",
                    45,
                )
                base.TransformInsertLine(trsfm, vals, 100)
                vals = (
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Translate",
                    "definition",
                    "Nodes",
                    "N1",
                    18,
                    "N2",
                    19,
                    "Distance",
                    43,
                )
                base.TransformInsertLine(trsfm, vals, 100)

                # Delete the 2nd line
                base.TransformDeleteLine(trsfm, 2)


    """


def TransformInfo(entity: object, labels: object, deck: int) -> object:
    """

    TransformInfo function gets values from an already existing transformation.

    Parameters
    ----------
    entity : object
            The transformation entity to extract info from.

    labels : object
            A list of labels to retrieve info from.
            Available labels given  are:
            "id"
            "name"
            "entity"
            "entities"
            "matrix"

    deck : int, optional
            The deck for which, when using the "matrix" parameter inside the "labels" argument,
            the returned strings will match.
            Notice: If left blank the strings correspond to the labels of the fields of
            the transformation edit card of the Nastran deck in ANSA.

    Returns
    -------
    object
            On success, the function returns a dictionary with keys the labels given and values:
            Key             Type
            "id":           integer         The id of the transformation.
            "name":         string          The name of the transformation.
            "entity":       object          The set/include on which the transformation is applied.
            "entities":     object          A list of the sets/includes on which the transformation is applied
            "matrix":       object          A list with the lines of the transformation. Each item of the list is
                                            a dictionary. For each dictionary, there is an entry with key "type" and
                                            data the name of the sub-transformation entry. It also contains all
                                            key/value pairs, where the keys correspond to the edit card and are in
                                            synch with TransformInsertLine function.

            On failure, it returns None.

    Examples
    --------
    ::

            # Some node defined transformations in these scripts require the Nodes to exist in the database

            # NASTRAN or any other deck
            import ansa
            from ansa import base
            from ansa import constants


            def NastranOrAnyDeckExample():
                trsfm = base.TransformCreate("NastranOrAnyDeckTransform")

                list_vals_dicts_nas = [
                    {"type": "move", "ux": 1, "uy": 2, "uz": 3, "d": 22},
                    {
                        "type": "rotate",
                        "Angle": 34,
                        "ux": 1.1,
                        "uy": 2.2,
                        "uz": 3.3,
                        "x0": 4.4,
                        "y0": 5.5,
                        "z0": 6.6,
                    },
                    {"type": "scale", "x0": 1, "y0": 2, "z0": 3, "sx": 1.1, "sy": 1.2, "sz": 1.5},
                ]

                for val_dict in list_vals_dicts_nas:
                    base.TransformInsertLine(trsfm, val_dict)

                ret = base.TransformInfo(trsfm, ("id", "name", "matrix"))

                print("Transformation with id = ", ret["id"])

                for line in ret["matrix"]:
                    print(line)


            # LS-DYNA example
            import ansa
            from ansa import base
            from ansa import constants


            def LsDynaDeckExample():
                trsfm = base.TransformCreate("LsDynaTransform")

                list_vals_dicts_dyn = [
                    {"deck": constants.LSDYNA, "type": "Translate", "a1": 1, "a2": 2, "a3": 3},
                    {
                        "deck": constants.LSDYNA,
                        "type": "Rotate",
                        "a7": 34,
                        "a1": 1.1,
                        "a2": 2.2,
                        "a3": 3.3,
                        "a4": 4.4,
                        "a5": 5.5,
                        "a6": 6.6,
                    },
                    {"deck": constants.LSDYNA, "type": "Scale", "a1": 1.1, "a2": 1.2, "a3": 1.5},
                    {
                        "deck": constants.LSDYNA,
                        "type": "mirror",
                        "a1": 1.1,
                        "a2": 2.2,
                        "a3": 3.3,
                        "a4": 4.4,
                        "a5": 5.5,
                        "a6": 6.6,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "pos6n",
                        "a1": 1,
                        "a2": 19,
                        "a3": 32,
                        "a4": 44,
                        "a5": 55,
                        "a6": 66,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 1,
                        "a2": 1.6,
                        "a3": 3.2,
                        "a4": 4.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 2,
                        "a2": 2.6,
                        "a3": 2.2,
                        "a4": 6.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 3,
                        "a2": 3.6,
                        "a3": 1.2,
                        "a4": 5.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 4,
                        "a2": 4.6,
                        "a3": 0.2,
                        "a4": 7.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 5,
                        "a2": 5.6,
                        "a3": -1.2,
                        "a4": 9.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 6,
                        "a2": 6.6,
                        "a3": -2.2,
                        "a4": 8.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "pos6p",
                        "a1": 1,
                        "a2": 2,
                        "a3": 3,
                        "a4": 4,
                        "a5": 5,
                        "a6": 6,
                    },
                    {"deck": constants.LSDYNA, "type": "Rotate", "a1": 1, "a2": 2, "a3": 45.8},
                    {
                        "deck": constants.LSDYNA,
                        "type": "transl2nd",
                        "a1": 10,
                        "a2": 20,
                        "a3": 40.5,
                    },  # nodes must exist
                    {
                        "deck": constants.LSDYNA,
                        "type": "rotate3na",
                        "a1": 10,
                        "a2": 20,
                        "a3": 40,
                        "a4": 36.78,
                    },  # nodes must exist
                    {
                        "deck": constants.LSDYNA,
                        "type": "matrix",
                        "M11": 1,
                        "M12": 0,
                        "M13": 0,
                        "M21": 0,
                        "M22": 1,
                        "M23": 0,
                        "M31": 0,
                        "M32": 0,
                        "M33": 1,
                        "M41": 2.3,
                        "M42": 4.5,
                        "M43": 6.7,
                    },
                ]

                for val_dict in list_vals_dicts_dyn:
                    base.TransformInsertLine(trsfm, val_dict)

                ret = base.TransformInfo(trsfm, ("id", "name", "matrix"), constants.LSDYNA)

                print("Transformation with id = ", ret["id"])

                for line in ret["matrix"]:
                    print(line)


            # PAM-CRASH example
            import ansa
            from ansa import base
            from ansa import constants


            def PamCrashDeckExample():
                trsfm = base.TransformCreate("PamcrashTransform")

                list_vals_dicts_pam = [
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Move",
                        "Tx": 1,
                        "Ty": 2,
                        "Tz": 3,
                        "Distance": 22,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Move",
                        "N1": 18,
                        "N2": 25,
                        "Distance": 15,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Rotate",
                        "Angle": 34,
                        "rx": 1.1,
                        "ry": 2.2,
                        "rz": 3.3,
                        "N0": 28,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Rotate",
                        "Angle": 36,
                        "N0": 22,
                        "N1": 23,
                        "N2": 38,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Scale",
                        "ScalX": 1.1,
                        "Scaly": 1.2,
                        "Scalz": 1.5,
                        "Ns": 33,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "NPOS",
                        "a": 1.1,
                        "N1": 1,
                        "N2": 3,
                        "N3": 31,
                        "N1'": 32,
                        "N2'": 40,
                        "N3'": 50,
                    },
                ]

                for val_dict in list_vals_dicts_pam:
                    base.TransformInsertLine(trsfm, val_dict)

                ret = base.TransformInfo(trsfm, ("id", "name", "matrix"), constants.PAMCRASH)

                print("Transformation with id = ", ret["id"])

                for line in ret["matrix"]:
                    print(line)


            # ABAQUS example
            import ansa
            from ansa import base
            from ansa import constants


            def AbaqusDeckExample():
                trsfm = base.TransformCreate("AbaqusTransform")

                list_vals_dicts_abq = [
                    {
                        "deck": constants.ABAQUS,
                        "type": "Translate",
                        "definition": "Coordinates",
                        "ux": 1,
                        "uy": 2,
                        "uz": 3,
                        "Distance": 22,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Translate",
                        "definition": "Nodes",
                        "N1": 18,
                        "N2": 25,
                        "Distance": 15,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rotate",
                        "definition": "Coordinates",
                        "Angle": 34,
                        "ux": 1.1,
                        "uy": 2.2,
                        "uz": 3.3,
                        "x0": 4.4,
                        "y0": 5.5,
                        "z0": 6.6,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rotate",
                        "definition": "Nodes",
                        "Angle": 36,
                        "N0": 22,
                        "N1": 23,
                        "N2": 38,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Scale",
                        "definition": "Coordinates",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "x0": 4.4,
                        "y0": 5.5,
                        "z0": 3.3,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Scale",
                        "definition": "Nodes",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "N0": 39,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rectangular",
                        "definition": "Coordinates",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "x1": 1.1,
                        "y1": 2.1,
                        "z1": 3.1,
                        "x2": 2.4,
                        "y2": 2.9,
                        "z2": 3.4,
                        "x3": 1.3,
                        "y3": 6.3,
                        "z3": 4.1,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rectangular",
                        "definition": "Nodes",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "N0": 26,
                        "N1": 27,
                        "N2": 55,
                    },
                ]

                for val_dict in list_vals_dicts_abq:
                    base.TransformInsertLine(trsfm, val_dict)

                ret = base.TransformInfo(trsfm, ("id", "name", "matrix"), constants.ABAQUS)

                print("Transformation with id = ", ret["id"])

                for line in ret["matrix"]:
                    print(line)


            # RADIOSS example
            import ansa
            from ansa import base
            from ansa import constants


            def RadiossDeckExample():
                trsfm = base.TransformCreate("RadiossTransform")

                list_vals_dicts_rds = [
                    {
                        "deck": constants.RADIOSS,
                        "type": "Translate",
                        "definition": "Coordinates",
                        "Xt": 1,
                        "Yt": 2,
                        "Zt": 3,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Translate",
                        "definition": "Nodes",
                        "N1": 18,
                        "N2": 25,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Rotate",
                        "definition": "Coordinates",
                        "Angle": 34,
                        "x1": 1.1,
                        "y1": 2.2,
                        "z1": 3.3,
                        "x2": 4.4,
                        "y2": 5.5,
                        "z2": 6.6,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Rotate",
                        "definition": "Nodes",
                        "Angle": 36,
                        "N1": 23,
                        "N2": 38,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Scale",
                        "Fsx": 1.1,
                        "Fsy": 1.2,
                        "Fsz": 1.5,
                        "Nc": 39,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Symmetry",
                        "definition": "Coordinates",
                        "x1": 10.1,
                        "y1": 20.2,
                        "z1": 30.3,
                        "x2": 40.4,
                        "y2": 50.5,
                        "z2": 60.6,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Symmetry",
                        "definition": "Nodes",
                        "N1": 27,
                        "N2": 55,
                    },
                ]

                for val_dict in list_vals_dicts_rds:
                    base.TransformInsertLine(trsfm, val_dict)

                ret = base.TransformInfo(trsfm, ("id", "name", "matrix"), constants.RADIOSS)

                print("Transformation with id = ", ret["id"])

                for line in ret["matrix"]:
                    print(line)


    """


def TransformInsertLine(entity: object, fields: object, position: int) -> int:
    """

    The TransformInsertLine function inserts new transformation lines in a "transform" entity, after the position "position".

    Parameters
    ----------
    entity : object
            The "transform" entity, where the new lines will be added.

    fields : object
            Can be a list, tuple or dictionary.
            In case of dictionary, it must contain pairs of 'field name' - 'value'.
            In case of list or tuple, it must contain consecutive entry pairs of 'field name' - 'value'.
            If a deck is specified as one of the entries as in the examples below then the labels
            of that deck are considered. In any other case the labels of the field of the
            transformation edit card of the Nastran deck are expected.
            (All cases are covered in the example.)

    position : int, optional
            Index in transformation matrix, that specifies after which existing line,
            the new line will be inserted. If the index given is out of the range of the
            existing lines the new line is appended.
            (In case of zero, the new line is inserted first.)

    Returns
    -------
    int
            Returns 0 on success, 1 on failure.

    Examples
    --------
    ::

            # Some node defined transformations in this script require the Nodes to exist in the database

            # NASTRAN or any other deck
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def NastranOrAnyDeckExample():
                trsfm = base.TransformCreate("NastranOrAnyDeckTransform")

                list_vals_dicts_nas = [
                    {"type": "move", "ux": 1, "uy": 2, "uz": 3, "d": 22},
                    {
                        "type": "rotate",
                        "Angle": 34,
                        "ux": 1.1,
                        "uy": 2.2,
                        "uz": 3.3,
                        "x0": 4.4,
                        "y0": 5.5,
                        "z0": 6.6,
                    },
                    {"type": "scale", "x0": 1, "y0": 2, "z0": 3, "sx": 1.1, "sy": 1.2, "sz": 1.5},
                ]

                for val_dict in list_vals_dicts_nas:
                    base.TransformInsertLine(trsfm, val_dict)


            # LS-DYNA example
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def LsDynaDeckExample():
                trsfm = base.TransformCreate("LsDynaTransform")

                list_vals_dicts_dyn = [
                    {"deck": constants.LSDYNA, "type": "Translate", "a1": 1, "a2": 2, "a3": 3},
                    {
                        "deck": constants.LSDYNA,
                        "type": "Rotate",
                        "a7": 34,
                        "a1": 1.1,
                        "a2": 2.2,
                        "a3": 3.3,
                        "a4": 4.4,
                        "a5": 5.5,
                        "a6": 6.6,
                    },
                    {"deck": constants.LSDYNA, "type": "Scale", "a1": 1.1, "a2": 1.2, "a3": 1.5},
                    {
                        "deck": constants.LSDYNA,
                        "type": "mirror",
                        "a1": 1.1,
                        "a2": 2.2,
                        "a3": 3.3,
                        "a4": 4.4,
                        "a5": 5.5,
                        "a6": 6.6,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "pos6n",
                        "a1": 1,
                        "a2": 19,
                        "a3": 32,
                        "a4": 44,
                        "a5": 55,
                        "a6": 66,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 1,
                        "a2": 1.6,
                        "a3": 3.2,
                        "a4": 4.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 2,
                        "a2": 2.6,
                        "a3": 2.2,
                        "a4": 6.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 3,
                        "a2": 3.6,
                        "a3": 1.2,
                        "a4": 5.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 4,
                        "a2": 4.6,
                        "a3": 0.2,
                        "a4": 7.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 5,
                        "a2": 5.6,
                        "a3": -1.2,
                        "a4": 9.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "point",
                        "a1": 6,
                        "a2": 6.6,
                        "a3": -2.2,
                        "a4": 8.8,
                    },
                    {
                        "deck": constants.LSDYNA,
                        "type": "pos6p",
                        "a1": 1,
                        "a2": 2,
                        "a3": 3,
                        "a4": 4,
                        "a5": 5,
                        "a6": 6,
                    },
                    {"deck": constants.LSDYNA, "type": "Rotate", "a1": 1, "a2": 2, "a3": 45.8},
                    {
                        "deck": constants.LSDYNA,
                        "type": "transl2nd",
                        "a1": 10,
                        "a2": 20,
                        "a3": 40.5,
                    },  # nodes must exist
                    {
                        "deck": constants.LSDYNA,
                        "type": "rotate3na",
                        "a1": 10,
                        "a2": 20,
                        "a3": 40,
                        "a4": 36.78,
                    },  # nodes must exist
                    {
                        "deck": constants.LSDYNA,
                        "type": "matrix",
                        "M11": 1,
                        "M12": 0,
                        "M13": 0,
                        "M21": 0,
                        "M22": 1,
                        "M23": 0,
                        "M31": 0,
                        "M32": 0,
                        "M33": 1,
                        "M41": 2.3,
                        "M42": 4.5,
                        "M43": 6.7,
                    },
                ]

                for val_dict in list_vals_dicts_dyn:
                    base.TransformInsertLine(trsfm, val_dict)


            # PAM-CRASH example
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def PamCrashDeckExample():
                trsfm = base.TransformCreate("PamcrashTransform")

                list_vals_dicts_pam = [
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Move",
                        "Tx": 1,
                        "Ty": 2,
                        "Tz": 3,
                        "Distance": 22,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Move",
                        "N1": 18,
                        "N2": 25,
                        "Distance": 15,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Rotate",
                        "Angle": 34,
                        "rx": 1.1,
                        "ry": 2.2,
                        "rz": 3.3,
                        "N0": 28,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Rotate",
                        "Angle": 36,
                        "N0": 22,
                        "N1": 23,
                        "N2": 38,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "Scale",
                        "ScalX": 1.1,
                        "Scaly": 1.2,
                        "Scalz": 1.5,
                        "Ns": 33,
                    },
                    {
                        "deck": constants.PAMCRASH,
                        "type": "NPOS",
                        "a": 1.1,
                        "N1": 1,
                        "N2": 3,
                        "N3": 31,
                        "N1'": 32,
                        "N2'": 40,
                        "N3'": 50,
                    },
                ]

                for val_dict in list_vals_dicts_pam:
                    base.TransformInsertLine(trsfm, val_dict)


            # ABAQUS example
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def AbaqusDeckExample():
                trsfm = base.TransformCreate("AbaqusTransform")

                list_vals_dicts_abq = [
                    {
                        "deck": constants.ABAQUS,
                        "type": "Translate",
                        "definition": "Coordinates",
                        "ux": 1,
                        "uy": 2,
                        "uz": 3,
                        "Distance": 22,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Translate",
                        "definition": "Nodes",
                        "N1": 18,
                        "N2": 25,
                        "Distance": 15,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rotate",
                        "definition": "Coordinates",
                        "Angle": 34,
                        "ux": 1.1,
                        "uy": 2.2,
                        "uz": 3.3,
                        "x0": 4.4,
                        "y0": 5.5,
                        "z0": 6.6,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rotate",
                        "definition": "Nodes",
                        "Angle": 36,
                        "N0": 22,
                        "N1": 23,
                        "N2": 38,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Scale",
                        "definition": "Coordinates",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "x0": 4.4,
                        "y0": 5.5,
                        "z0": 3.3,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Scale",
                        "definition": "Nodes",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "N0": 39,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rectangular",
                        "definition": "Coordinates",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "x1": 1.1,
                        "y1": 2.1,
                        "z1": 3.1,
                        "x2": 2.4,
                        "y2": 2.9,
                        "z2": 3.4,
                        "x3": 1.3,
                        "y3": 6.3,
                        "z3": 4.1,
                    },
                    {
                        "deck": constants.ABAQUS,
                        "type": "Rectangular",
                        "definition": "Nodes",
                        "sx": 1.1,
                        "sy": 1.2,
                        "sz": 1.5,
                        "N0": 26,
                        "N1": 27,
                        "N2": 55,
                    },
                ]

                for val_dict in list_vals_dicts_abq:
                    base.TransformInsertLine(trsfm, val_dict)


            # RADIOSS example
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def RadiossDeckExample():
                trsfm = base.TransformCreate("RadiossTransform")

                list_vals_dicts_rds = [
                    {
                        "deck": constants.RADIOSS,
                        "type": "Translate",
                        "definition": "Coordinates",
                        "Xt": 1,
                        "Yt": 2,
                        "Zt": 3,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Translate",
                        "definition": "Nodes",
                        "N1": 18,
                        "N2": 25,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Rotate",
                        "definition": "Coordinates",
                        "Angle": 34,
                        "x1": 1.1,
                        "y1": 2.2,
                        "z1": 3.3,
                        "x2": 4.4,
                        "y2": 5.5,
                        "z2": 6.6,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Rotate",
                        "definition": "Nodes",
                        "Angle": 36,
                        "N1": 23,
                        "N2": 38,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Scale",
                        "Fsx": 1.1,
                        "Fsy": 1.2,
                        "Fsz": 1.5,
                        "Nc": 39,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Symmetry",
                        "definition": "Coordinates",
                        "x1": 10.1,
                        "y1": 20.2,
                        "z1": 30.3,
                        "x2": 40.4,
                        "y2": 50.5,
                        "z2": 60.6,
                    },
                    {
                        "deck": constants.RADIOSS,
                        "type": "Symmetry",
                        "definition": "Nodes",
                        "N1": 27,
                        "N2": 55,
                    },
                ]

                for val_dict in list_vals_dicts_rds:
                    base.TransformInsertLine(trsfm, val_dict)


    """


def TransformMatrix4x3(
    input_function_type: str,
    pid_offset: object,
    group_offset: str,
    input_sets_type: str,
    matrix: object,
    entities: object,
    draw_results: bool,
    keep_connectivity: bool,
) -> int:
    """

    This function transforms entities according to the input given by the arguments.

    Parameters
    ----------
    input_function_type : str
            The first argument determines whether the entities will be
            copied or moved. the values are "COPY", "MOVE" and "LINK" respectively.

    pid_offset : object
            Determines if the pids of the entities will be offset or not.
            Use 0 to denote that offset will not take place and any other integer to denote
            the exact offset value. Use string value "AUTO_OFFSET" in order to assign
            different PID to every entity, by letting ANSA offset the original PID.

    group_offset : str
            It is used only in COPY and LINK mode.
            The available options are: "SAME PART", "NEW PART" and "NEW INSTANCE".

    input_sets_type : str
            Controls the way sets will be treated. It is used only in COPY and LINK mode.
            The available options are: "COPY", "EXPAND" and "NONE".

    matrix : object
            The 4x3 transformation matrix.

    entities : object
            A list containing references to the entities to be copied/moved.
            The list can contain different types of entities (ex. sets, properties,
            materials, parts, groups, FE-Model entities).

    draw_results : bool, optional
            Defines whether the results should be redrawn at the end of the transformation.
            Values can be True or False. (Default: False)

    keep_connectivity : bool, optional
            Determine whether the connecting nodes between moved and unmoved entities
            should be released or not in a MOVE transformation. Value can be True or False.
            (Default: False)

    Returns
    -------
    int
            Returns 0 on success and 1 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [-375.289, -181.557, 158.522]]

                ents = []
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 504))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 505))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 510))
                ents.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 511))
                ansa.base.TransformMatrix4x3(
                    input_function_type="LINK",
                    pid_offset="AUTO_OFFSET",
                    group_offset="NEW PART",
                    input_sets_type="EXPAND",
                    matrix=matrix,
                    entities=ents,
                    draw_results=True,
                    keep_connectivity=True,
                )


    """


def TransformModify(
    entity: object, name: str, transforms: object, abaqus_type: str
) -> object:
    """

    The TransformModify function modifies the parameters "params" of the already
    existing transformation "transform".

    Parameters
    ----------
    entity : object
            The transformation to be modified.

    name : str, optional
            The name of the transformation.

    transforms : object, optional
            Set or include or submodel, where the transformation is applied.

    abaqus_type : str, optional
            Valid values [rectangular | option], for Abaqus NMAP.

    Returns
    -------
    object
            Returns a reference to the transformation that is modified, on success.
            Otherwise, 0 is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                transform = base.GetEntity(ansa.constants.RADIOSS, "TRANSFORM", 1)
                trsfm = base.TransformModify(entity=transform, name="my_modified_trsfm")


    """


def TransformModifyLine(entity: object, fields: object, position: int) -> int:
    """

    The TransformInsertLine function modifies the specified values of the
    line in position "position", in the transformation entity.

    Parameters
    ----------
    entity : object
            The transformation entity, whose line will be modified.

    fields : object
            Can be a list, tuple or dictionary.
            In case of dictionary, it must contain pairs of 'field name' - 'value'.
            In case of list or tuple, it must contain consecutive entry pairs of 'field name' - 'value'.
            If a deck is specified as one of the entries as in the examples below then the labels
            of that deck are considered. In any other case the labels of the field of the
            transformation edit card of the Nastran deck are expected.
            (All field name cases are covered in the example of TransformInsertLine)

    position : int
            The line's position index in the transformation entity,  to modify its values.
            The defined index must not be negative, less than zero and out of range.

    Returns
    -------
    int
            Returns 0 on success, 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                trsfm = base.GetEntity(constants.ABAQUS, "NMAP", 1)
                if trsfm == None:
                    print("TRSFM with ID 1 does not exist!")
                    return
                else:
                    print("TRSFM with ID 1, is named: ", trsfm._name)
                # The following examples assume that the selected Transformation entity has at least 6 lines.
                # Using a dictionary
                vals = {
                    "deck": constants.ABAQUS,
                    "type": "Translate",
                    "definition": "Coordinates",
                    "ux": 5,
                    "uy": 4,
                    "uz": 14.2,
                    "Distance": 42,
                }
                base.TransformModifyLine(trsfm, vals, 1)

                # Using a list
                vals = [
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Scale",
                    "definition",
                    "Nodes",
                    "sx",
                    5,
                    "sy",
                    4,
                    "sz",
                    7.1,
                    "N0",
                    14,
                ]
                base.TransformModifyLine(trsfm, vals, 2)

                # Using a tuple
                vals = (
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Scale",
                    "definition",
                    "Coordinates",
                    "sx",
                    5,
                    "sy",
                    4,
                    "sz",
                    7.1,
                    "x0",
                    14,
                    "x1",
                    14.1,
                    "x2",
                    14.2,
                )
                base.TransformModifyLine(trsfm, vals, 3)

                # More examples
                vals = (
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Rotate",
                    "definition",
                    "Nodes",
                    "N0",
                    16,
                    "N1",
                    17,
                    "N2",
                    14,
                    "Angle",
                    44,
                )
                base.TransformModifyLine(trsfm, vals, 4)

                vals = (
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Rotate",
                    "definition",
                    "Coordinates",
                    "ux",
                    5,
                    "uy",
                    4,
                    "uz",
                    7.1,
                    "x0",
                    14,
                    "y0",
                    14.1,
                    "z0",
                    14.2,
                    "Angle",
                    45,
                )
                base.TransformModifyLine(trsfm, vals, 5)

                vals = (
                    "deck",
                    constants.ABAQUS,
                    "type",
                    "Translate",
                    "definition",
                    "Nodes",
                    "N1",
                    18,
                    "N2",
                    19,
                    "Distance",
                    43,
                )
                base.TransformModifyLine(trsfm, vals, 6)


    """


def TransformPart(
    parts: object,
    transformation_mode: str,
    x1: float,
    y1: float,
    z1: float,
    x2: float,
    y2: float,
    z2: float,
    x3: float,
    y3: float,
    z3: float,
    x4: float,
    y4: float,
    z4: float,
    x5: float,
    y5: float,
    z5: float,
    x6: float,
    y6: float,
    z6: float,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: bool,
    ext_connectors: str,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function transforms parts in a way that immitates the GUI function Model Browser>Parts>Actions>Transform>>Copy/Move/Link>Transform. The transformation takes place between two coordinate systems (defined implicitly via the x1-6, y1-6, z1-6 arguments of the function). It is a simultaneous translation and rotation procedure.

    Parameters
    ----------
    parts : object
            A list of part entities to be transformed.

    transformation_mode : str
            Supported values are "COPY", "MOVE" and "LINK"

    x1 : float
            The x coordinate of the origin point.

    y1 : float
            The y coordinate of the origin point.

    z1 : float
            The z coordinate of the origin point.

    x2 : float
            The x coordinate of the 1st origin vector (i.e of the unit vector that defines the x direction of the origin coordinate system).

    y2 : float
            The y coordinate of the 1st origin vector.

    z2 : float
            The z coordinate of the 1st origin vector.

    x3 : float
            The x coordinate of the 2nd origin vector (i.e of the unit vector that, together with the 1st origin vector, defines the xy plane of the origin coordinate system).

    y3 : float
            The y coordinate of the 2nd origin vector.

    z3 : float
            The z coordinate of the 2nd origin vector.

    x4 : float
            The x coordinate of the destination point.

    y4 : float
            The y coordinate of the destination point.

    z4 : float
            The z coordinate of the destination point.

    x5 : float
            The x coordinate of the 1st destination vector (i.e of the unit vector that defines the x direction of the destination coordinate system).

    y5 : float
            The y coordinate of the 1st destination vector.

    z5 : float
            The z coordinate of the 1st destination vector.

    x6 : float
            The x coordinate of the 2nd destination vector (i.e of the unit vector that, together with the 1st destination vector, defines the xy plane of the destination coordinate system).

    y6 : float
            The y coordinate of the 2nd destination vector.

    z6 : float
            The z coordinate of the 2nd destination vector.

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not. Used only in COPY and
            LINK cases. Supported values are 0, to denote that offset will not take
            place and any other integer to denote the actual property offset value.
            Alternatively, you can set the value to "auto_offset", so that pids will be
            automatically offset by ANSA or "current_property" to assign the current
            PID to all the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source Module Id. It is
            taken into account only when used with the 'NEW PART' option. It is ignored in
            and other case.

    set_mode : str, optional
            Supported values are "COPY", "EXPAND" and "NONE". Default value is NONE
            Used only in COPY and LINK cases.

    connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved
            entities should be released or not in a MOVE transformation.
            Supported values are True and False.
            (Default: False)

    ext_connectors : str, optional
            Determines whether external connections and connectors will be included in a
            MOVE transformation. Supported values are "INCLUDE" and "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: False)

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))

                base.TransformPart(
                    parts,  # Parts to be transformed
                    transformation_mode="COPY",  # Parts will be transformed-Copied
                    x1=10,
                    y1=10,
                    z1=10,  # Origin point
                    x2=1,
                    y2=0,
                    z2=0,  # 1st origin vector
                    x3=0,
                    y3=1,
                    z3=0,  # 2nd origin vector
                    x4=10,
                    y4=10,
                    z4=13,  # Destination point
                    x5=0,
                    y5=-1,
                    z5=0,  # 1st destination vector
                    x6=0,
                    y6=0,
                    z6=1,  # 2nd destination vector
                    group_options="NEW PART",  # A new part will be created
                    pid_offset=True,  # The entities' pids will be offset
                    set_mode="EXPAND",
                )  # Treat sets


    """


def TranslateDummy(
    KIN_JOINT: object, TRVEC_X: float, TRVEC_Y: float, TRVEC_Z: float, MODE: int
) -> int:
    """

    This function performs a translation of the whole Dummy. There are
    two tranlation modes. By target point, the dummy will move such that its H-Point
    matches the new target point and by vector, which actually is the Translation Vector.

    Parameters
    ----------
    KIN_JOINT : object
            The name or the ID of the H-Point Kinematic Joint,
            or the H-Point Kinematic Joint.

    TRVEC_X : float
            The x-coordinate of the target point,
            or V[0] of the translation vector.

    TRVEC_Y : float
            The y-coordinate of the target point,
            or V[1] of the translation vector.

    TRVEC_Z : float
            The z-coordinate of the target point,
            or V[2] of the translation vector.

    MODE : int
            0 or 1 (by Vector or by Target Point respectively).

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Move Dummy model at point (50., 0., 0.) of the global coordinate system;
                base.TranslateDummy("H-POINT", 50.0, 0.0, 0.0, 1)


    """


def TranslatePart(
    parts: object,
    transformation_mode: str,
    x: float,
    y: float,
    z: float,
    pid_offset: int,
    group_options: str,
    part_suffix: str,
    set_mode: str,
    connectivity: bool,
    ext_connectors: str,
    copy_groups_hierarchy: bool,
    existing_part: object,
) -> int:
    """

    This function translates parts based on the arguments provided. The list PARTS
    contains the part/s to be translated.

    Parameters
    ----------
    parts : object
            A list of part entities to be translated.

    transformation_mode : str
            Supported values are "COPY", "MOVE" and "LINK".

    x : float
            The x translational distance.

    y : float
            The y translational distance.

    z : float
            The z translational distance.

    pid_offset : int, optional
            Determines if the parts' pids will be offset or not.
            Used only in COPY and LINK cases. Supported values are
            0, to denote that offset will not take place and any
            other integer to denote the actual property offset value. Alternatively,
            you can set the value to "auto_offset", so that pids will be automatically
            offset by ANSA or "current_property" to assign the current PID to all
            the new entities. (Default: 0)

    group_options : str, optional
            Supported values are "NEW PART", "CURRENT PART", "EXISTING PART",
            "SAME PART" and "NEW INSTANCE". The option NEW INSTANCE is valid
            only when used with option COPY. The "existing_part" argument should be
            specified if "EXISTING PART" is used. Used only in COPY and LINK cases.
            (Default: "NEW INSTANCE")

    part_suffix : str, optional
            Determines the alphanumeric string to be appended at the source
            Module Id. It is taken into account only when used with the
            'NEW PART' option. It is ignored in and other case.

    set_mode : str, optional
            Supported values are "COPY", "EXPAND" and "NONE".
            Used only in COPY and LINK cases.
            (Default: "NONE")

    connectivity : bool, optional
            Determines whether the connecting nodes between moved and unmoved
            entities should be released or not in a MOVE transformation.
            Supported values are True and False.
            (Default: False)

    ext_connectors : str, optional
            Determines whether external connections and connectors will be included in a
            MOVE transformation. Supported values are "INCLUDE" and "EXCLUDE".
            (Default: "EXCLUDE")

    copy_groups_hierarchy : bool, optional
            Determines whether the exact groups hierarchy will be created for the new
            entities, in the case of COPY.
            (Default: "False")

    existing_part : object, optional
            A part which already exist in the model. It is mandatory
            when "EXISTING PART" value is set to "group_offset"
            argument.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("100"), base.GetPartFromModuleId("200"))

                base.TranslatePart(
                    parts,  # Parts to be translated
                    transformation_mode="MOVE",  # Parts will be translated-moved
                    x=10,
                    y=10,
                    z=10,  # Translation distance
                    connectivity=False,  # Connecting nodes will be released
                    ext_connectors="INCLUDE",
                )  # External connections and connectors will also be moved


    """


def TypesInCategory(deck: int, category: object) -> object:
    """

    The TypesInCategory function returns a list with all the ANSA types which belong to the given
    category. This list can then be used as an argument for subsequent calls to other
    functions such as CollectEntities (see Example). The returned list's contents vary
    among decks.

    Parameters
    ----------
    deck : int
            The deck for which to extract the category types.

    category : object
            The given category. Can take one of the following:
            "__PROPERTIES__"
            "__MATERIALS__"
            "__ELEMENTS__"
            "__CONNECTIONS__"
            "__VISIBLE__"
            "__ALL_ENTITIES__",
            "__MBCONTAINERS__",
            "__COORD_SYSTEMS__"
            "__CONNECTION_TEMPLATES__"

    Returns
    -------
    object
            Returns a list containing all the ANSA types that belong to the specified category of the specified deck.
            In case of an error None is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                material_types = base.TypesInCategory(constants.NASTRAN, "__MATERIALS__")

                mats = base.CollectEntities(constants.NASTRAN, None, material_types, recursive=True)
                for mat in mats:
                    base.SetEntityCardValues(constants.NASTRAN, mat, {"DEFINED": "YES"})


    """


def UnFreezeVisibleFaces() -> int:
    """

    Unfreezes the visible faces.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.UnFreezeVisibleFaces()


    """


def UnlinkPart(parts: object) -> int:
    """

    The function unlinks an array of selected parts/groups.

    Parameters
    ----------
    parts : object
            A list of parts.

    Returns
    -------
    int
            Returns 0 if the parts/groups have been unlinked successfully.
            Otherwise 1 is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                parts = (base.GetPartFromModuleId("55"), base.GetPartFromModuleId("68FRONT"))
                base.UnlinkPart(parts)


    """


def UnloadInclude(include: object) -> int:
    """

    Unloads include from current configuration (makes a current configuration of none exists),
    has the same effect as removing include from current configuration through includes manager
    and updating the configuration.

    Parameters
    ----------
    include : object
            The include object to be unloaded.

    Returns
    -------
    int
            Returns 0 on success, 1 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.NASTRAN, "INCLUDE", 5)
                base.UnloadInclude(entity)


    """


def ZoomAll() -> int:
    """

    This function zooms all the model on the screen.
    Equivalent to the F9 function key.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                m = base.ZoomAll()


    """


def ZoomIn() -> int:
    """

    This function zooms in the model on the screen.
    Zoom in takes place according to the center of the screen.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ZoomIn()


    """


def ZoomInEnt(entities: object) -> int:
    """

    Performs the zoom in selected entities

    Parameters
    ----------
    entities : object
            A reference to an entity or a list containing references
            to perform the zoom command. These references can be
            references to entities, properties, materials or parts.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entities = (
                    base.GetEntity(constants.NASTRAN, "PSHELL", 1),
                    base.GetEntity(constants.NASTRAN, "CROD", 5432),
                    base.GetPartFromModuleId("8"),
                )
                base.ZoomInEnt(entities)
                shell = base.GetEntity(constants.NASTRAN, "SHELL", 2932)
                base.ZoomInEnt(shell)


    """


def ZoomOut() -> int:
    """

    This function zooms out the model on the screen.
    Zoom out takes place according to the center of the screen.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ZoomOut()


    """


def F11SolidsOptionsSet(
    criterion_name: str,
    criterion_status: bool,
    criterion_calculation: str,
    criterion_value: float,
) -> int:
    """

    This function enables/disables/changes the corresponding visibility flag/pulldown menu and values.
    The True value turns the visibility flag on, and the False value turns the visibility flag off. Pulldown menus values change setting the exact pulldown menu option instead.

    Parameters
    ----------
    criterion_name : str
            The criterion name of the F11 window to enable, disable or change.

    criterion_status : bool
            True or False, to set the criterion active or inactive.

    criterion_calculation : str
            A string to set the respective criterion's calculation field.
            An empty string should be given if you don't care for this argument.
            Using a string that doesn't match any of the criterion calculation names, will return an error.

    criterion_value : float
            A float to set the respective criterion's value field.

    Returns
    -------
    int
            Returns 1 on success or 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ansa.base.F11SolidsOptionsSet("aspect ratio", True, "PAM-CRASH", 0.4)
                # will turn Solid's "aspect ratio" visibility flag on, calculation type to "PAM-CRASH" and criterion value to 0.4.
                m = ansa.base.F11SolidsOptionsGet("aspect ratio")
                print(
                    "F11SolidsOptionsGet returned: status: "
                    + str(m["status"])
                    + " calculation: "
                    + str(m["calculation"])
                    + " value: "
                    + str(m["value"])
                )
                m = ansa.base.F11SolidsOptionsSet("min length", True, "", 4.5)
                # will turn Solid's "min length" visibility flag on, minimum length value to 4.5.
                m = ansa.base.F11SolidsOptionsGet("min length")
                print(
                    "F11SolidsOptionsGet returned: status: "
                    + str(m["status"])
                    + " calculation: "
                    + str(m["calculation"])
                    + " value: "
                    + str(m["value"])
                )


    """


def HotPointsProject(
    x: float, y: float, z: float, entities: object, remesh: bool
) -> int:
    """

    This function takes the coordinates of a hot point and projects it to any element of a list.

    Parameters
    ----------
    x : float
            The x coordinate of a hot point.

    y : float
            The y coordinate of a hot point.

    z : float
            The z coordinate of a hot point.

    entities : object
            A list of entities: FACES, CURVES, CONS, LINEAR ELEMENTS,
            where the hot point will be projected.

    remesh : bool, optional
            In case of CONS, if set to True, the Macro Area will be remeshed, else not.

    Returns
    -------
    int
            Returns the number of succeeded projections, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_HotPointsProject():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE", filter_visible=True)
                curves = base.CollectEntities(constants.NASTRAN, None, "CURVE", filter_visible=True)

                for face in faces:
                    ents.append(face)
                for curve in curves:
                    ent.append(curve)
                base.HotPointsProject(10.0, 10.0, 10.0, ents)


    """


def ReleaseCons(cons: object) -> int:
    """

    This script function releases CONS, based on the 'cons' arguments.

    Parameters
    ----------
    cons : object, optional
            Accepted values: a CONS, a list of CONS, a string with value 'visible' or
            a string with value 'all'.
            If it is called with 'visible', it works with all the visible CONS.
            If it is called with 'all', it works with all the CONS in database.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def test_ReleaseCons():
                cons = base.CollectEntities(
                    ansa.constants.NASTRAN, None, "CONS", filter_visible=True
                )

                mat = []
                for con in cons:
                    mat.append(con)
                base.ReleaseCons(mat)
                # base.ReleaseCons('visible')


    """


def SetNodeTolerance(arg: float) -> int:
    """

    This function changes the hot points matching distance of database.

    Parameters
    ----------
    arg : float
            A variable for resolution.

    Returns
    -------
    int
            Returns 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetNodeTolerance(0.1)


    """


def SetCurveTolerance(arg: float) -> int:
    """

    This function changes the CONS matching distance of db.

    Parameters
    ----------
    arg : float
            A variable for resolution.

    Returns
    -------
    int
            Returns 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetCurveTolerance(0.1)


    """


def ShellResult(matrix_shells: object) -> int:
    """

    Function for acquiring the result for each shell.
    It takes as input a list of shells and returns a list in the shell - result format.

    Parameters
    ----------
    matrix_shells : object
            A list of shell objects.

    Returns
    -------
    int
            Returns a list with the shell (position 0) and result (position 1).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL", filter_visible=True)
                sensitivities = base.ShellResult(shells)

                for sens in sensitivities:
                    id = base.GetEntityCardValues(constants.NASTRAN, sens[0], ("EID",))
                    print("shell id = ", id["EID"], " value:", sens[1])


    """


def ShortestPath(entities: object, begin: object, end: object, mode: str) -> object:
    """

    This function finds the shortest path between two entities on a given container of entities.

    Parameters
    ----------
    entities : object
            A list of entities to find the shortest path on.

    begin : object
            A list of entities where the paths begin.

    end : object
            A list of entities where the paths end, corresponding to the "begin" list.

    mode : str, optional
            One of "distance" or "counter".
            Depicts if the shortest path is based on distance or on the smaller counter
            of "entities" between "begin" and "end".

    Returns
    -------
    object
            Returns None when something has failed, or a list on success.
            The list has minimum length between 'start' and 'end', each entity of the list is a list of entities.
            That entity-list is empty when the pair of 'start' and 'end' entities does not have a common path.
            If the pair has shortest path, then the entity-list always has at least two elements (the first element
            is the entity from 'start'-list and the last element is the entity of the 'end'-list).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p = base.PickEntities(constants.NASTRAN, ("PSHELL",))
                shells = base.CollectEntities(constants.NASTRAN, p, "SHELL")

                routes = []
                while True:
                    e = base.PickEntities(constants.NASTRAN, ("SHELL",))
                    if not e:
                        break
                    routes.extend(e)
                if len(routes) < 2:
                    print("ERROR ", len(routes))
                    return
                print("Continue Len of routes:", len(routes))

                for ent in routes:
                    print("NID:", ent._id)
                beg_ents = []
                end_ents = []
                for i in range(0, len(routes), 2):
                    beg_ents.append(routes[i])
                    end_ents.append(routes[i + 1])
                list_distance = base.ShortestPath(
                    entities=shells, begin=beg_ents, end=end_ents, mode="distance"
                )

                colors_matrix = ("RED", "GREEN", "MAGENTA", "GRAY", "WHITE")

                color_counter = 0
                for path in list_distance:
                    container = base.CreateEntity(constants.NASTRAN, "HIGHLIGHT_CONTAINER")
                    cur_color_matrix = (colors_matrix[color_counter % 5],)
                    color_counter = color_counter + 1
                    print("\\n cur path ", color_counter, " len ", len(path))
                    base.AddToHighlight(container, path, cur_color_matrix)
                    for ent in path:
                        print("NID:", ent._id)
                base.RedrawAll()


    """


def ImportCSVFileCreatePoints(filename: str) -> object:
    """

    This function takes a full path of a csv file and creates points from the file.

    Parameters
    ----------
    filename : str
            The full path of the csv file.

    Returns
    -------
    object
            Returns a list with the created points on success, otherwise return 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def test_ImportCSVFileCreatePoints():
                file = "/home/user/my_csv.txt"  # input the full path of the csv or txt file

                list_points = base.ImportCSVFileCreatePoints(file)
                print("The created points are: ", len(list_points))


    """


def GetActiveNastranHeader() -> object:
    """

    Gets the active Nastran header.

    Returns
    -------
    object
            Returns a reference to the active Nastran header, or None if it doesn't exist.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                header_1 = base.CreateEntity(constants.NASTRAN, "Nastran Header")
                header_2 = base.CreateEntity(constants.NASTRAN, "Nastran Header")
                base.SetActiveNastranHeader(header_1)
                active_header = base.GetActiveNastranHeader()
                fields = ("__id__",)
                values = base.GetEntityCardValues(constants.NASTRAN, active_header, fields)
                print("Active header id: ", values["__id__"])


    """


def SetActiveNastranHeader(header: object) -> int:
    """

    Sets the active nastran header.

    Parameters
    ----------
    header : object
            A nastran header object.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                header_1 = base.CreateEntity(constants.NASTRAN, "Nastran Header")
                header_2 = base.CreateEntity(constants.NASTRAN, "Nastran Header")
                base.SetActiveNastranHeader(header_1)


    """


def SetNastranHeaderText(header: object, text: str) -> int:
    """

    Sets the text in nastran header.

    Parameters
    ----------
    header : object
            The header object.

    text : str
            The text to set.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                header = base.CreateEntity(constants.NASTRAN, "Nastran Header")
                text = "SOL  101\\n"
                text += "TIME = 31500000.\\n"
                text += "CEND\\n"
                text += "DISPLACEMENT = ALL\\n"
                base.SetNastranHeaderText(header, text)


    """


def GetNastranHeaderText(header: object) -> str:
    """

    Gets the text of nastran header.

    Parameters
    ----------
    header : object
            The nastran header object.

    Returns
    -------
    str
            Returns the text of the given nastran header.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                header = base.CreateEntity(constants.NASTRAN, "Nastran Header")
                text = "SOL  101\\n"
                text += "TIME = 31500000.\\n"
                text += "CEND\\n"
                text += "DISPLACEMENT = ALL\\n"
                base.SetNastranHeaderText(header, text)
                header_text = base.GetNastranHeaderText(header)
                print(header_text)


    """


def OutputSimulayt(
    filename: str,
    mode: str,
    write_material_attributes: str,
    write_material_orientation: str,
) -> int:
    """

    This function outputs a SIMULAYT Layup file.

    Parameters
    ----------
    filename : str
            The path of the output file.

    mode : str, optional
            Accepted values: "all", "model" or "visible".
            (Default: what set at the last execution)

    write_material_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    write_material_orientation : str, optional
            Control the output of 209/220 lines. Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputSimulayt("C:/temp/users/folder/data.Layup", "all")


    """


def FacesNewExistingSurface(
    entities_list: object,
    face: object,
    join_perimeters: bool,
    respect_user_selection: bool,
    ret_ents: bool,
) -> object:
    """

    This function creates a new face on a existing surface.

    Parameters
    ----------
    entities_list : object
            A list with entities (CONS, CURVES, ELEMENTS, CONNECTIONS, CURVES etc).
            Based on these entities the new face will be created.

    face : object
            The entity (FACE) with the existing surface.

    join_perimeters : bool, optional
            If set to True, the perimeters will be joined.

    respect_user_selection : bool, optional
            If set to True, then the order of entries in faces_array will be
            respected and thus Cons will be created in that order.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 1 on success, otherwise 0.
            If ret_ents=True it will return a list with the created entities or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                mat_ents = []
                mat_ents.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 32))
                mat_ents.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 40))

                face = base.GetEntity(ansa.constants.NASTRAN, "FACE", 1)

                base.FacesNewExistingSurface(mat_ents, face, True, True)
                # base.FacesNewExistingSurface(mat_ents, face, False)


    """


def SurfaceExtend(
    face: object, extend_value: object, untrim: bool, delete_original_face: bool
) -> object:
    """

    This function creates a new surface, and optionally a face, as a tangential extension of an existing surface.

    Parameters
    ----------
    face : object
            The face object to be extended.

    extend_value : object
            The value for extension.

    untrim : bool, optional
            Flag to create or not a new face.

    delete_original_face : bool, optional
            Flag to delete or not the original face.

    Returns
    -------
    object
            Returns the existing face or the created face on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                face = base.GetEntity(constants.NASTRAN, "FACE", 1)
                ret_face = base.SurfaceExtend(face, 50.0, True, False)
                dict_id = base.GetEntityCardValues(constants.NASTRAN, ret_face, ("ID",))
                print("ID of the new face: ", dict_id["ID"])


    """


def HotPointsIntersect(
    entity1: object, entity2: object, extend: bool, paste_hot_points: bool
) -> int:
    """

    This function defines nodes or Hot Points as the intersection between two 3D-curves, CONS or Working Planes.
    It also defines a Weld Spot as the intersection of a CONS or 3D-curve with a Face.

    Parameters
    ----------
    entity1 : object
            The first entity for the intersection.

    entity2 : object
            The second entity for the intersection.

    extend : bool, optional
            This flag indicates whether the intersections will be made in extend situation.

    paste_hot_points : bool, optional
            This flag pastes hot points of two separate cons.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_HotPointsIntersect():
                curves = base.CollectEntities(constants.NASTRAN, None, "CURVE", filter_visible=True)
                face = base.GetEntity(constants.NASTRAN, "FACE", 1)

                for curve in curves:
                    # ret = base.HotPointsIntersect(curve, face, True, True)
                    ret = base.HotPointsIntersect(curve, face)
                    print(ret)


    """


def CalcShellThetaByVector(element: object, vector: object) -> float:
    """

    A function that calculates a shell's theta angle according to a given vector.

    Parameters
    ----------
    element : object
            The shell object.

    vector : object
            A list defining a 3d vector.

    Returns
    -------
    float
            Returns the Theta Angle (degrees) of the projected vector upon the shell.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                element = base.GetEntity(ansa.constants.ABAQUS, "SHELL", 1)
                vector = (0.707, 0.707, 0.0)

                angle = base.CalcShellThetaByVector(element, vector)
                print("Shell theta using vector {} is {}".format(vector, angle))


    """


def GetEntityCardValues(deck: int, entity: Entity, fields: Iterable[str]) -> dict:
    """

    Gets values from an entity using its Edit Card. The labels are taken from the fields in the edit card.
    The respective values of these fields are then assigned the entity's parameters.

    In addition to the Edit Card labels, this function also recognizes the following strings as labels and returns their values:
    -"__id__" for entity's ID.
    -"__type__" for entity's ANSA type.
    -"__prop__" for entity's property. "__prop__" has no meaning for entities that don't take a property.
    -"MBContainer" for entity's Model Browser Container. "MBContainer" has no meaning for entities that can't be in a Model Browser Container.
    -"__part__" for entity's PART. If an entity takes a PART but doesn't have one, None will be returned.

    Parameters
    ----------
    deck : int
            The selected deck.

    entity : Entity
            The ANSA entity where the values will be extracted from.

    fields : Iterable[str]
            A list of card field labels to extract the values from.

    Returns
    -------
    dict
            Returns a Dictionary with the requested labels as keys and the retrieved values as the dictionary's values.
            If the function fails to find the requested fields, the dictionary's value will be empty.

    See Also
    --------
    SetEntityCardValues, GetEntity, GetEntityType

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # Using positional arguments
            def main():
                prop = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                vals = ("T", "MID1")
                ret = base.GetEntityCardValues(constants.NASTRAN, prop, vals)
                if ret["MID1"]:
                    print(ret["MID1"])
                print(ret["T"])
                print(prop._name)


            # ...or...


            # Using named arguments
            def main():
                prop = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                vals = ("T", "MID1")
                ret = base.GetEntityCardValues(entity=prop, fields=vals, deck=constants.NASTRAN)
                if ret["MID1"]:
                    print(ret["MID1"])
                print(ret["T"])

                print(prop._name)


            # ...or...


            # Using the object's method 'get_entity_values' (more info on the 'base.Entity' class)
            def main():
                rbe_id = 100
                rbe = base.GetEntity(constants.NASTRAN, "RBE2", rbe_id)
                mb_ent = rbe.get_entity_values(constants.NASTRAN, ["MBContainer"])


            # Numbering Rules parsing
            def main():
                num_rules_list = base.GetEntityCardValues(
                    constants.NASTRAN, renum, ["Number of Rules"]
                )
                if num_rules_list:
                    if "Number of Rules" not in num_rules_list:
                        return 0
                    num_rules = num_rules_list["Number of Rules"]
                    if num_rules:
                        for id in range(num_rules):
                            print(
                                base.GetEntityCardValues(
                                    constants.NASTRAN, renum, ["Name_" + str(id + 1)]
                                )
                            )
                            print(
                                base.GetEntityCardValues(
                                    constants.NASTRAN, renum, ["Type_" + str(id + 1)]
                                )
                            )
                            print(
                                base.GetEntityCardValues(
                                    constants.NASTRAN, renum, ["From_" + str(id + 1)]
                                )
                            )
                            print(
                                base.GetEntityCardValues(
                                    constants.NASTRAN, renum, ["To_" + str(id + 1)]
                                )
                            )


    """


def Remesh1DElements(
    elements: object,
    target_el_length: float,
    distortion_angle: float,
    mode: str,
    target_num_of_els: int,
    divide_each_el_into: int,
) -> int:
    """

    Remesh line elements "elems" (beams, bars, etc), so as after remeshing to have the element length
    near to "target_el_length". From the given "elems", groups of continued elements are created, based
    on value "distortion_angle".

    Parameters
    ----------
    elements : object
            A line element object or a list of line elements.

    target_el_length : float, optional
            Required for "Target element length" mode. The target element length.

    distortion_angle : float, optional
            Required for "Target element length" and "Target number of elements" mode. The angle limit value of normal vectors of two line elements. If the angle is greater than this value, these two elements will belong to separate branches. Accepted values:
            0 deg < distortion_angle < 90 deg

    mode : str, optional
            The re-mesh method used. Accepted values:
            "Target element length"
            "Target number of elements"
            "Divide each element into"
             If it is omitted  the "Target element length" mode is applied.

    target_num_of_els : int, optional
            Required for "Target number of elements" mode. The target number of elements.

    divide_each_el_into : int, optional
            Required for "Divide each element into" mode. The number of elements that the initial element will be divided into.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def remesh1Delems():
                entities = base.CollectEntities(constants.NASTRAN, None, "CBEAM")
                base.Remesh1DElements(entities, 10.0, 10.0)


    """


def CreateInvoluteCurve(
    center: object,
    vector1: object,
    vector2: object,
    radius: float,
    start_angle: float,
    end_angle: float,
    part: object,
    cross_curve: object,
) -> object:
    """

    This function creates an involute curve.

    Parameters
    ----------
    center : object
            A list with the 3 coordinates of the center point for curve.

    vector1 : object
            A list with the 3 coordinates of the first vector.

    vector2 : object
            A list with the 3 coordinates of the second vector.

    radius : float
            The radius for the curve.

    start_angle : float
            The start angle of the curve.

    end_angle : float
            The end angle of the curve.

    part : object, optional
            The part of the created curve.

    cross_curve : object, optional
            If True and a CROSS SECTION exists, a cross involute
            curve will be created.

    Returns
    -------
    object
            Returns the created curve on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                face = base.GetEntity(constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face)

                center = [-77.310834, 74.904328, 0.000000]
                vector1 = [0.0, 0.0, 1.0]
                vector2 = [0.0, 1.0, 0.0]

                curve = base.CreateInvoluteCurve(center, vector1, vector2, 5.0, 0.0, 90.0, part)


    """


def CreateEpicycloidCurve(
    center: object,
    vector1: object,
    vector2: object,
    radius_basic: float,
    radius: float,
    start_angle: float,
    end_angle: float,
    part: object,
    cross_curve: object,
) -> object:
    """

    This function creates a list of epicycloid curves.

    Parameters
    ----------
    center : object
            A list with 3 objects the coordinates of center point for curve.

    vector1 : object
            A list with 3 objects the coordinates of first vector.

    vector2 : object
            A list with 3 objects the coordinates of second vector.

    radius_basic : float
            The basic radius for the curve.

    radius : float
            The radius for the curve.

    start_angle : float
            The start angle of the curve.

    end_angle : float
            The end angle of the curve.

    part : object, optional
            The part of the created curve.

    cross_curve : object, optional
            If True and a CROSS SECTION exists, a cross epicycloid curve will be created.

    Returns
    -------
    object
            Returns a list containing the created curves on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                face = base.GetEntity(constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face)

                center = [-77.310834, 74.904328, 0.000000]
                vector1 = [0.0, 0.0, 1.0]
                vector2 = [0.0, 1.0, 0.0]

                created_curves_list = base.CreateEpicycloidCurve(
                    center, vector1, vector2, 20.0, 5.0, 0.0, 360.0, part
                )


    """


def CreateEllipseCurve(
    center: object,
    vector1: object,
    vector2: object,
    radius_x: float,
    radius_y: float,
    start_angle: float,
    end_angle: float,
    part: object,
    cross_curve: bool,
) -> object:
    """

    This function creates an ellipse curve.

    Parameters
    ----------
    center : object
            A list with 3 objects the coordinates of center point for curve.

    vector1 : object
            A list with 3 objects the coordinates of first vector.

    vector2 : object
            A list with 3 objects the coordinates of second vector.

    radius_x : float
            The radius for x direction for the curve.

    radius_y : float
            The radius for y direction for the curve.

    start_angle : float
            The start angle of the curve.

    end_angle : float
            The end angle of the curve.

    part : object, optional
            The part of the created curve.

    cross_curve : bool, optional
            If True and a CROSS SECTION exists a cross ellipse curve will be created.

    Returns
    -------
    object
            Returns the created ellipse curve on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                face = base.GetEntity(ansa.constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face)

                center = [77.310834, 74.904328, 0.000000]
                vector1 = [0.0, 0.0, 1.0]
                vector2 = [0.0, 1.0, 0.0]

                curv = base.CreateEllipseCurve(center, vector1, vector2, 5.0, 5.0, 0.0, 90.0, part)


    """


def SurfaceExtrudeHelical(
    entity: object,
    center: object,
    vector: object,
    angle_deg: float,
    length: float,
    ratio: float,
    anti_clockwise: int,
    part: object,
    property: object,
) -> object:
    """

    This function creates a helical surface.

    Parameters
    ----------
    entity : object
            The guidline for the surface.

    center : object
            A list with 3 objects the coordinates of center point for the surface.

    vector : object
            A list with 3 objects the coordinates of a vector.

    angle_deg : float
            The angle in degrees.

    length : float
            The length of the created face.

    ratio : float
            Start/End radius ratio (r1/r2).

    anti_clockwise : int
            The direction: -1 anti-clockwise, 1 clockwise.

    part : object, optional
            The part for the created face.

    property : object, optional
            The property for the created face.

    Returns
    -------
    object
            Returns a reference to the newly created face object on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.NASTRAN, "CURVE", 3)
                part = base.GetEntityPart(entity)
                pid = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                center = []
                center.append(88.855791)
                center.append(-54.135956)
                center.append(0.000000)

                vector = []
                vector.append(88.855791 - 88.855791)
                vector.append((-54.135956) - (-54.135956))
                vector.append(20.000000 - 0.000000)

                face = base.SurfaceExtrudeHelical(
                    entity, center, vector, 180.0, 20.0, 1, 1, part, pid
                )


    """


def InputTheseus(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    read_only: str = "wp",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    advanced_options: str = "",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    comment_input_ids: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    InputTheseus inputs a Theseus model in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset",  "offset:value", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    advanced_options : str, optional
            Defines the entity types to be read.
            dr, Header, Nodes, Elements, Properties, Materials, Sets, Contacts.
            When this argument is defined, only the provided types will be read.
            When dr exists in the beginning of the string, the provided types will not be read.
            If left blank everything will be read.

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            If left blank, the current ANSA defaults value is assumed.

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure.
            If the "new_include" argument is enabled, it returns a reference to a new INCLUDE
            containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputTheseus(filename="C:/temp/users/folder/data.tfe", elements_id="offset")


    """


def KineticsKinTableCreate(name: str, interpolation: str, items: object) -> object:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`TableCreate` instead.


    Creates a KIN_TABLE entity and sets the table values.

    Parameters
    ----------
    name : str
            Name of the KIN_TABLE.

    interpolation : str
            Type of interpolation. Can be 'linear', 'cubic' or 'akima'.

    items : object
            A list with the table data.

    Returns
    -------
    object
            Returns the created KIN_TABLE on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # create a new model
                ansa.session.New("discard")

                # tables to be used for data set/get
                input_data_mat = []
                output_data_mat = []

                # fill input data
                for i in range(0, 10):
                    input_data_mat.append([i, i * i])
                print("\\ninput data: ")
                print(input_data_mat)

                # create a table
                print("\\ncreating kin table: ")
                test_kin_table = base.KineticsKinTableCreate(
                    name="new_kin_table_name", interpolation="linear", items=input_data_mat
                )

                # print something
                print("\\nnew kin table: ")
                print(test_kin_table)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: TableCreate instead.",
        DeprecationWarning,
    )


def KineticsKinTableGetData(entity: object) -> object:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`TableGetData` instead.


    Retrieves tha data from a KIN_TABLE as a list.

    Parameters
    ----------
    entity : object
            Reference to a KIN_TABLE.

    Returns
    -------
    object
            Returns the KIN_TABLE data as a list on success, or an empty list otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # create a new model
                ansa.session.New("discard")

                # tables to be used for data set/get
                input_data_mat = []
                output_data_mat = []

                # fill input data
                for i in range(0, 10):
                    input_data_mat.append([i, i * i])
                print("\\ninput data: ")
                print(input_data_mat)

                # create a table
                print("\\ncreating kin table: ")
                test_kin_table = base.KineticsKinTableCreate(
                    name="new_kin_table_name", interpolation="linear", items=input_data_mat
                )

                # print something
                print("\\nnew kin table: ")
                print(test_kin_table)

                # get data from the table
                print("\\ngetting kin table: ")
                output_data_mat = ansa.base.KineticsKinTableGetData(test_kin_table)

                # print something
                print("\\ndata in kin table: ")
                print(output_data_mat)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: TableGetData instead.",
        DeprecationWarning,
    )


def KineticsKinTableSetData(entity: object, items: object) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`TableSetData` instead.


    Sets the data of a KIN_TABLE. Will overwrite the data using the new list.

    Parameters
    ----------
    entity : object
            A reference to a KIN_TABLE.

    items : object
            A list with the table data.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # create a new model
                ansa.session.New("discard")

                # tables to be used for data set/get
                input_data_mat = []
                output_data_mat = []

                # fill input data
                for i in range(0, 10):
                    input_data_mat.append([i, i * i])
                print("\\ninput data: ")
                print(input_data_mat)

                # create a table
                print("\\ncreating kin table: ")
                test_kin_table = base.KineticsKinTableCreate(
                    name="new_kin_table_name", interpolation="linear", items=input_data_mat
                )

                # print something
                print("\\nnew kin table: ")
                print(test_kin_table)

                # get data from the table
                print("\\ngetting kin table: ")
                output_data_mat = ansa.base.KineticsKinTableGetData(test_kin_table)

                # print something
                print("\\ndata in kin table: ")
                print(output_data_mat)

                # modify input data
                input_data_mat = [[x[0], x[1] + 1] for x in input_data_mat[0:-2]]

                # print something
                print("\\nmodified input_data")
                print(input_data_mat)

                ret_val = ansa.base.KineticsKinTableSetData(test_kin_table, input_data_mat)
                print("\\nreturn value is:")
                print(ret_val)

                # get data from the table
                print("\\ngetting kin table: ")
                output_data_mat = ansa.base.KineticsKinTableGetData(test_kin_table)

                # print something
                print("\\ndata in kin table: ")
                print(output_data_mat)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: TableSetData instead.",
        DeprecationWarning,
    )


def KineticsResultsWriteToXML(kin_result: object, file_name: str) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`ResultsWriteToXML` instead.


    Exports (writes) the contents of a KIN_RESULTS entity to an XML file.

    Parameters
    ----------
    kin_result : object
            A kinetics result solver.

    file_name : str
            The filepath for the output.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                kin_results = base.CollectEntities(constants.NASTRAN, None, "KIN_RESULTS")
                for i_kin_result, kin_result in enumerate(kin_results):
                    print("now writing file number: ", i_kin_result)
                    base.KineticsResultsWriteToXML(
                        kin_result, "some_prefix_" + str(i_kin_result) + ".xml"
                    )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: ResultsWriteToXML instead.",
        DeprecationWarning,
    )


def KineticsResultsGetData(res_entity: object, kin_entity: object) -> object:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`ResultsGetData` instead.


    Gets the results for a kinetics entity from a KIN_RESULTS entity.

    Parameters
    ----------
    res_entity : object
            The KIN_RESULTS entity.

    kin_entity : object
            The entity for which we need the results.

    Returns
    -------
    object
            Returns a dictionary with the results of the selected entity.
            If no results are found, the dictionary will be empty.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                current_kin_result = base.GetEntity(constants.NASTRAN, "KIN_RESULTS", 1)
                current_marker = base.GetEntity(constants.NASTRAN, "KIN_MARKER", 1)
                current_marker_result = base.KineticsResultsGetData(
                    current_kin_result, current_marker
                )
                for key, data in current_marker_result.items():
                    print(key)
                    print(data)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: ResultsGetData instead.",
        DeprecationWarning,
    )


def GetCurrentCompareAdvancedFilterConfiguration() -> str:
    """

    This function returns the name of the advanced filter configuration currently used by compare.

    Returns
    -------
    str
            Returns the name of the currently used advanced filter configuration of compare.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                old_fil = base.GetCurrentCompareAdvancedFilterConfiguration()
                print(old_fil)
                base.SetCurrentCompareAdvancedFilterConfiguration("new_name")
                new_fil = base.GetCurrentCompareAdvancedFilterConfiguration()
                print(new_fil)
                base.SetCurrentCompareAdvancedFilterConfiguration(old_fil)
                restored = base.GetCurrentCompareAdvancedFilterConfiguration()
                print(restored)


    """


def SetCurrentCompareAdvancedFilterConfiguration(name: str) -> int:
    """

    This function changes the name of the advanced filter configuration currently used by compare.

    Parameters
    ----------
    name : str
            The name of the filter that will be set as current.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                old_fil = base.GetCurrentCompareAdvancedFilterConfiguration()
                print(old_fil)

                base.SetCurrentCompareAdvancedFilterConfiguration("new_name")
                new_fil = base.GetCurrentCompareAdvancedFilterConfiguration()
                print(new_fil)

                base.SetCurrentCompareAdvancedFilterConfiguration(old_fil)
                restored = base.GetCurrentCompareAdvancedFilterConfiguration()
                print(restored)


    """


def SaveFileAsJT(
    filename: str,
    outputmode: str = "ALL",
    units: str = "METERS",
    output_connections: int = 0,
    diameter: float = 10.0,
    output_ansa_annotations: int = 0,
    output_jt_iso_file: int = 0,
    connections_group_by: str = "CONNECTIVITY_NUMBER",
) -> int:
    """

    This function saves all or visible entities to a CAD file with extension ".jt".

    Parameters
    ----------
    filename : str
            The whole path to the file.

    outputmode : str, optional
            "VISIBLE": Outputs a single part with the visible entities.
            "ALL": Outputs hierarchy and all entities.

    units : str, optional
            The units of the resulted ".jt" file (METERS, MILLIMETERS, INCHES, FEET).

    output_connections : int, optional
            Set to 1, to export Spotwelds.
            Set to 0, to not export spotwelds (default).
            Works only if outputmode is ALL.

    diameter : float, optional
            The diameter of the geometrical sphere that represents the spotweld.
            Works only if outputmode is ALL.
            (Default: 10.0)

    output_ansa_annotations : int, optional
            Set to 1, to export ansa annotations.
            Set to 0, to not export ansa annotations (default).

    output_jt_iso_file : int, optional
            Set to 1, to export jt file version 9.5, the version used in ISO 14306:2012.
            Set to 0, to export jt file version 10.2 (default).

    connections_group_by : str, optional
            CONNECTIVITY_NUMBER: Group connections by their connectivity number
            CONNECTIVITY_TYPE_NUMBER: Group connections by their type and connectivity number.
            Works only if outputmode is ALL.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # The following example outputs each part of the hierarchy to a separate jt file
            def main():
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                for part in parts:
                    vals = base.GetEntityCardValues(constants.NASTRAN, part, ("Name",))
                    name = vals["Name"]
                    status = base.Or(part)  # make the part the only visible part
                    base.SaveFileAsJT("/home/user/" + name + ".jt", "VISIBLE", "METERS", 1, 20.0)


            if __name__ == "__main__":
                main()


            # The following example outputs all hierarchy with the ansa annotations
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.SaveFileAsJT(
                    filename="/home/user/test.jt",
                    outputmode="VISIBLE",
                    units="METERS",
                    output_ansa_annotations=1,
                )


            if __name__ == "__main__":
                main()


            # The following example outputs all hierarchy and the connections
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.SaveFileAsJT(
                    filename="/home/dpap/test7.jt",
                    outputmode="ALL",
                    units="METERS",
                    output_connections=1,
                    connections_group_by="CONNECTIVITY_NUMBER",
                )


            if __name__ == "__main__":
                main()


    """


def InputMoldflow(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    length: str = "m",
) -> int:
    """

    This function inputs a Moldflow input file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    length : str, optional
            Accepted values: "m" or "as-is". "m" option states that the input file
            is in meters and converts it to the current ANSA units. "as-is" option
            states that no conversion will occur.
            (Default: "m")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputMoldflow(filename="C:/temp/users/folder/data.udm", nodes_id="nooffset")


    """


def SaveAs(filename: str, version: str, silent: bool) -> int:
    """

    This function saves the current file in ANSA with a new filename.

    Parameters
    ----------
    filename : str
            The name of the new file with which the current
            file is going to be saved must contain the full
            pathname.

    version : str, optional
            Valid values are: 'vXX', where XX is the
            previous version. For example, if current
             version is v22, the available argument is
            'v21' and  'previous'.

    silent : bool, optional
            If set to True the active database path will not
            be updated to the pathname given. False by
             default. The version argument takes precedence
            and overrides the silent argument.

    Returns
    -------
    int
            Returns 0 if the file has been successfully saved and 1 otherwise.

    See Also
    --------
    ansa.base.DataBaseName

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SaveAs("C:/temp/users/folder/new_data.ansa")


    """


def NewShellsOnLine(
    radius: float,
    length: float,
    line_elements: object,
    property: object,
    rbody_type: str,
    dofs: str,
    shells_along_line: bool,
    part: object,
    ret_ents: bool,
) -> object:
    """

    This function creates shell elements in the form of a cylinder around line elements that can
    describe their actual radial dimension.
    The shells can be connected with the selected line elements by user-specified constraints.

    Parameters
    ----------
    radius : float
            The radius of cylinder description.

    length : float
            The length of shell elements to be created.

    line_elements : object
            A list of the instances of the line elements that will be wrapped.

    property : object
            An instance of the property that will be assigned to the created shell elements.

    rbody_type : str, optional
            Type of element-constrain that connects the created shell elements to
            the line elements.
            Default keyword: "" (no connection between shells and line elements).
            Valid keywords:
            ""
            "RBE2","RBODY","RIGID""CERIG","MPC_RIGID"
            "RBE3","INTERP.","COUPLING","RBE3","MPC_WLSCON"
            "CBAR","BEAM"
            "CBEAM"
            "CROD","TRUSS","LINK","FLA2"
            "RBAR"
            "CGAP","GAP"
            "TRIAS"

    dofs : str, optional
            Active pin flags of the connecting elements.
            Default value depents of the RbodyType.

    shells_along_line : bool, optional
            If set to True, the length of the generated shells will be controlled by the
            line elements along direction of the second.

    part : object, optional
            Part instance where the generated elements will be placed.
            By default the generated elements are placed to the part that contains
            each sequence of line elements.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 0 on success and 1 on failure.
            If ret_ents=True it will return a list with the created entities,
            or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Creates Shells from the collected CBARs.
                # The existing CBARs will be connected with the shells with RBE2 elements with degrees of freedom 126.
                # Assigns the PSHELL propetry with PID 1.
                # The new elements will be placed to the "ShellsFromLine" part.
                LineElems = base.CollectEntities(constants.NASTRAN, None, "CBAR")
                Property = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                Part = base.NewPart("ShellsFromLine", "777")
                iret = base.NewShellsOnLine(10, 5, LineElems, Property, "RBE2", "126", False, Part)

                # Creates Shells from the collected CBARs
                # The existing CBARs will not be connected with the shells.
                # Assigns the PSHELL propetry with PID 1
                # The new elements will be placed to the part that contains each sequence of CBARS.
                LineElems = base.CollectEntities(constants.NASTRAN, None, "CBEAM")
                Property = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                iret = base.NewShellsOnLine(10, 5, LineElems, Property, "", "")
                # equivalent is also:
                # iret = ansa.base.NewShellsOnLine(10,5,LineElems,Property)


    """


def LoadDistribute(
    deck: int,
    type: int,
    entities: object,
    load_info: object,
    force_app_point: object,
    weight: str,
    pressure_dist: str,
    radius: float,
) -> int:
    """

    This function generates a load that is distributed over the provided entities.
    The load can be either force or pressure.

    Parameters
    ----------
    deck : int
            The loads will be generated according to the provided deck.

    type : int
            Flag controling the distribution type.
            Valid values:[1-3]
            Performance for force distribution:
            type = 1 -> Distribution based on edge length.
            type = 2 -> Distribution based on shell area
            type = 3 -> Distribution based on mass of the elements
            Performance for pressure distribution:
            type = 1 -> Force/Moment equilibrium.
            type = 2 -> Constant pressure
            type = 3 -> Hertz-like contact

    entities : object
            Entities to perfom the distribution.
            (1d elements, shells, solids, edges, solidfacets, sets)

    load_info : object
            A dictionary that holds the loading data indexed with the deck's keywords.
            Dictionary keywords for force distribution:
            NASTRAN - FORCE:
            {"F","N1","N2","N3","Load_Set"}
            LS-DYNA - LOAD:
            {"LF","DOF","CID","LCID"}
            PAM-CRASH - CONLO
            {"SCAF","DOF","IFRAM","LCUR","ISENS","CLOAD"}
            ABAQUS - CLOAD:
            {"Magnitude","DOF","CID","Amplitude","Step"}
            RADIOSS - CLOAD:
            {"SCALE","DOF","ISKEQ","IFUNC","ISENS"}
            ANSYS - F:
            {"VALUE","DOF","TABLE"}
            PERMAS - CONLOAD:
            {"F","N1","N2","N3","LPAT"}
            Dictionary keywords for force distribution:
            NASTRAN - PLOAD4:
            {"Magnitude","DOF","CID","SID"}
            ABAQUS - DLOAD:
            {"Magnitude","DOF","CID","Amplitude","Step"}
            ANSYS - SFE:
            {"Magnitude","DOF","CID"}
            PERMAS - DISLOAD PRESS:
            {"Magnitude","DOF","LPAT"}
            Keywords that stand for the magnitude of the load (F,LF,SCAF etc), N1, N2, N3 and
            CLOAD accept variable of double type.
            The variable of the "DOF" keyword is int type and the accepted values are:
            1 -> Load on x direction.
            2 -> Load on y direction.
            3 -> Load on z direction.
            All other keyword variables can be assigned with either the id of the
            desired entity (int) or the instance of the entity (object).

    force_app_point : object, optional
            Grid where the resultant force is applied.
            By default, it is assumed that the force is applied on the CoG of
            the provided entities.

    weight : str, optional
            Optional additional weight factor F(G).

    pressure_dist : str, optional
            Handles whether a pressure or force distribution will be applied.
            Accepted values:
            "force" -> Force loads will be applied.
            "pressure" -> Pressure loads will be applied.

    radius : float, optional
            Used for pressure distribution for the case of Hertz-like contact.
            Pressure loads will be applied within the area of the provided radius
            having center the provided coordinate system.
            The area is circular when DOF = 3 (similar to Hertzian circular contact) and
            rectangular in the other cases (similar to Hertzian line contact)

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Distribute force to the nodes of a selected face
                ent = base.PickEntities(constants.ABAQUS, ("FACE",))
                nfo = {"F": 1000, "DOF": 3}
                ierror = base.LoadDistribute(constants.ABAQUS, 2, ent, nfo, pressure_dist="force")

                # Distribute pressure to the elements of a selected face
                ent = base.PickEntities(constants.ABAQUS, ("FACE",))
                coord = base.GetEntity(constants.ABAQUS, "ORIENTATION_R", 99)
                nfo = {"F": 1000, "DOF": 3, "CID": coord, "STEP": 3}
                ierror = base.LoadDistribute(
                    constants.ABAQUS, 3, ent, nfo, pressure_dist="pressure", radius=50.0
                )


    """


def CheckAndFixPenetrationCS(fix_factor: float) -> int:
    """

    Checks the existence of thickness penetrations cross sections.

    Parameters
    ----------
    fix_factor : float
            The fix factor that will be used for fixing.
            Must be greater than 1.

    Returns
    -------
    int
            Returns 0 if no penetration were found and 1 if they were found and fixed.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                a = 1.4
                b = base.CheckAndFixPenetrationCS(a)
                print("result =", b)


    """


def FacesFlangeWidth(
    entities: object, extend_value: float, delete_old_flange: bool
) -> object:
    """

    This function defines new flange Faces of uniform width based on existing Faces.

    Parameters
    ----------
    entities : object
            A list with the selected cons.

    extend_value : float
            The extend value for the new flange.

    delete_old_flange : bool, optional
            Flag to delete or not the old flange.

    Returns
    -------
    object
            Returns the created faces in a list, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                list_ents = []
                list_ents.append(base.GetEntity(constants.NASTRAN, "CONS", 579))
                list_ents.append(base.GetEntity(constants.NASTRAN, "CONS", 1465))

                created_faces = base.FacesFlangeWidth(list_ents, -20.0, False)
                print(len(created_faces))


    """


def CurvesMiddle(
    entities1: object,
    entities2: object,
    respect_user_sel: bool,
    part: object,
    connect_curves: object,
) -> object:
    """

    This function defines a chain of 3D-curves along the middle distance of two string of 3D-curves or CONS.

    Parameters
    ----------
    entities1 : object
            A list with entities for the first chain.

    entities2 : object
            A list with entities for the second chain.

    respect_user_sel : bool, optional
            True for respect user selection, false for
            auto ordering the entities for both chains.

    part : object, optional
            The part for the created curves.

    connect_curves : object, optional
            A list with two float variables defining nodes matching distance
            in the first place and angle in the second, respectively.
            If list is given then script function will merge the created curves, according
            to the input values, else curves per segment will be created.

    Returns
    -------
    object
            Returns a list with the created curves on successs, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                list_ents1 = []
                list_ents1.append(base.GetEntity(constants.NASTRAN, "CONS", 118))
                list_ents1.append(base.GetEntity(constants.NASTRAN, "CONS", 158))

                list_ents2 = []
                list_ents2.append(base.GetEntity(constants.NASTRAN, "CONS", 282))
                list_ents2.append(base.GetEntity(constants.NASTRAN, "CONS", 110))

                part = base.GetEntityPart(list_ents1[0])

                created_curves_list = base.CurvesMiddle(
                    list_ents1, list_ents2, True, part, [0.05, 45]
                )


    """


def SurfacePlane2d(
    working_plane: object,
    point1: object,
    point2: object,
    part: object,
    property: object,
) -> object:
    """

    This function defines a bounded plane surface.

    Parameters
    ----------
    working_plane : object
            The working plane where the surface will be build, or it can be a list with 9 floats,
            that define a temporary working plane.
            The first triple defines the origin point (x1, y1, z1), the second triple defines the
            vector of the temporary X axis of the working plane (dx1, dy1, dz1) and the third
            triple defines the temporary Y axis of the working plane (dx2, dy2, dz2).

    point1 : object
            The list with the coordinates of the first point (2d).

    point2 : object
            The list with the coordinates of the second point (2d).

    part : object, optional
            The part that will be used for the new surface.

    property : object, optional
            The property that will be used for the new suface.

    Returns
    -------
    object
            Returns a reference to the newly created face object on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_SurfsPlane2d():
                wplane = base.GetEntity(constants.NASTRAN, "WPLANE", 1)

                point1 = []
                point1.append(0.0)
                point1.append(0.0)

                point2 = []
                point2.append(10.0)
                point2.append(-80.0)

                face = base.GetEntity(constants.NASTRAN, "FACE", 1)
                part = base.GetEntityPart(face)
                pid = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                ret_face = base.SurfacePlane2d(wplane, point1, point2, part, pid)


            def test_SurfsPlane2d_2():
                plane = []
                plane.append(447.528)
                plane.append(-111.765)
                plane.append(-54.218)
                plane.append(-0.183919)
                plane.append(0.97512)
                plane.append(-0.123756)
                plane.append(-0.558264)
                plane.append(0)
                plane.append(0.829663)

                point1 = []
                point1.append(447.528)
                point1.append(-111.765)

                point2 = []
                point2.append(372.854)
                point2.append(-219.028)

                part = base.GetEntity(constants.NASTRAN, "ANSAPART", 2)
                prop = base.GetEntity(constants.NASTRAN, "PSHELL", 3)

                base.SurfacePlane2d(
                    working_plane=plane, point1=point1, point2=point2, part=part, property=prop
                )


    """


def SurfacePlane3d(
    working_plane: object,
    point1: object,
    point2: object,
    part: object,
    property: object,
) -> object:
    """

    This function defines a bounded plane surface.

    Parameters
    ----------
    working_plane : object
            The working plane where the surface will be build, or it can be a list with 9 floats,
            that define a temporary working plane.
            The first triple defines the origin point (x1, y1, z1), the second triple defines the
            vector of the temporary X axis of the working plane (dx1, dy1, dz1) and the third
            triple defines the temporary Y axis of the working plane (dx2, dy2, dz2).

    point1 : object
            The list with the coordinates of the first point (3d).

    point2 : object
            The list with the coordinates of the second point (3d).

    part : object, optional
            The part that will be used for the new surface.

    property : object, optional
            The property that will be used for the new suface.

    Returns
    -------
    object
            Returns a reference to the newly created face object on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_SurfsPlane3d():
                wplane = base.GetEntity(constants.NASTRAN, "WPLANE", 1)

                point1 = []
                point1.append(0.0)
                point1.append(0.0)
                point1.append(0.0)

                point2 = []
                point2.append(10.0)
                point2.append(-80.0)
                point1.append(0.0)

                face = base.GetEntity(constants.NASTRAN, "FACE", 1)
                part = base.GetEntityPart(face)
                pid = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                ret_face = base.SurfacePlane3d(wplane, point1, point2, part, pid)


            def test_SurfsPlane3d_2():
                plane = []
                plane.append(447.528)
                plane.append(-111.765)
                plane.append(-54.218)
                plane.append(-0.183919)
                plane.append(0.97512)
                plane.append(-0.123756)
                plane.append(-0.558264)
                plane.append(0)
                plane.append(0.829663)

                point1 = []
                point1.append(447.528)
                point1.append(-111.765)
                point1.append(-54.218)

                point2 = []
                point2.append(372.854)
                point2.append(-219.028)
                point2.append(100.438)

                part = base.GetEntity(constants.NASTRAN, "ANSAPART", 2)
                prop = base.GetEntity(constants.NASTRAN, "PSHELL", 3)

                base.SurfacePlane3d(
                    working_plane=plane, point1=point1, point2=point2, part=part, property=prop
                )


    """


def OutputAdamsSolver(filename: str, mode: str, adams_name: str) -> int:
    """

    This function outputs an AdamsSolver file.

    Parameters
    ----------
    filename : str
            The path to the directory to export.

    mode : str, optional
            "all", "model" or "visible".
            The default option is defined in ANSA Defaults.

    adams_name : str, optional
            "on" or "off". Modifies the kinematic entities names
            according to the adams hierarchy rules.
            The default option is defined in ANSA Defaults.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    InputAdamsSolver

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                dir = utils.SelectSaveDir("/home/user/")
                base.OutputAdamsSolver(dir, "all", "on")


    """


def SurfaceExtrudeHelicalMulti(
    entities: object,
    center: object,
    vector: object,
    angle_deg: float,
    length: float,
    ratio: float,
    anti_clockwise: int,
    part: object,
    property: object,
) -> object:
    """

    This function creates helical surfaces.

    Parameters
    ----------
    entities : object
            A list with entities (CONS, CURVES) which are the guidline for the surface.

    center : object
            A list with 3 objects the coordinates of center point for the surface.

    vector : object
            A list with 3 objects the coordinates of a vector.

    angle_deg : float
            The angle in degrees.

    length : float
            The length of the created face.

    ratio : float
            Start/End radius ratio (r1/r2).

    anti_clockwise : int
            The direction: -1 anti-clockwise, 1 clockwise.

    part : object, optional
            The part for the created face.

    property : object, optional
            The property for the created face.

    Returns
    -------
    object
            Returns a list containing references to the newly created faces on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = []
                ents.append(base.GetEntity(constants.NASTRAN, "CONS", 15))
                ents.append(base.GetEntity(constants.NASTRAN, "CONS", 16))
                ents.append(base.GetEntity(constants.NASTRAN, "CONS", 12))

                center = []
                center.append(95.0)
                center.append(70.0)
                center.append(351.982)

                vector = []
                vector.append(1.738036 - 95.000000)
                vector.append(130.000000 - 70.000000)
                vector.append(351.982856 - 351.982856)

                part = base.GetEntityPart(ents[0])
                pid = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                list_ret = base.SurfaceExtrudeHelicalMulti(
                    ents, center, vector, 180.0, 20.0, 1, -1, part, pid
                )

                print(len(list_ret))


    """


def ExecuteCheckTemplate(
    template: str, report_level: int, make_current: bool
) -> object:
    """

    This function executes a check template on the currently loaded base.

    Parameters
    ----------
    template : str
            The name of the template to execute as a string.

    report_level : int, optional
            One of the following values:
            -0, to show results only if an error or warning occured.
            -1, to always show results.
            -2, o never show results.
            This options is only relevant in GUI mode, and all issues are
            reported in Checks Manager.

    make_current : bool, optional
            When True, it is ensured that the Checks Manager displays the results of the given template. To be used in scripts where more than one templates are executed.

    Returns
    -------
    object
            Returns an object named "_CheckTemplateExecutionResults" that contains the following
            attributes:

            Attributes
            warnings: (integer) The number of checks that finished with warnings.
            errors: (integer) The number of checks that finished with errors.
            ok: (integer) The number of checks that finished with no errors or warnings.
            reports: (list) A list of CheckReport objects (see ansa.base.CheckReport for more information).

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ReadCheckTemplatesFromDefaultStorage()
                # we can also use ReadCheckTemplatesFromFile and give
                # a file as an argument, to read from a specific file

                # execute template 'crash1' on whole model
                results = base.ExecuteCheckTemplate("crash1", 0)


    """


def LaminateReport(
    deck: int,
    filename: str,
    laminates: object,
    layer_info: bool,
    create_vrml: bool,
    create_stl: bool,
    create_png: bool,
    png_view: str,
    layer_curves: bool,
    curves_on_geometry_plane: bool,
    curves_group: object,
    stl_format: str,
    stl_offset_pos: str,
    stl_reduce_trias: bool,
    create_iges: bool,
) -> int:
    """

    Generates a report for the given Laminates and save it in filename. PNG, STL, VRML and IGES files are
    saved in the same directory as the HTML file. It works for both Shell and Solid Laminates.

    Parameters
    ----------
    deck : int
            The deck constant.

    filename : str
            The filename to write the output HTML file along with its images.

    laminates : object
            A list with laminate properties.

    layer_info : bool, optional
            If set to True, enables Layer Info.

    create_vrml : bool, optional
            If set to True, create VRML files.

    create_stl : bool, optional
            If set to True, create STL files.

    create_png : bool, optional
            If set to True, create PNG files.

    png_view : str, optional
            Valid options are 'auto', 'manual' and 'current'.
            (Default: 'auto')

    layer_curves : bool, optional
            If set to True, create curves on layers.

    curves_on_geometry_plane : bool, optional
            If set to True, create curves on geometry plane.

    curves_group : object, optional
            A reference to a group.

    stl_format : str, optional
            Valid options are 'ascii' and 'binary'.
            (Default: 'ascii')

    stl_offset_pos : str, optional
            Decide position of layers in generated report.
            Valid options are 'geometry' and 'offset'.
            (Default: 'offset')

    stl_reduce_trias : bool, optional
            Decide whether trias reduction is performed or not.
            (Default: True)

    create_iges : bool, optional
            Create IGES files containing the curves on layers.
            (Default: False)

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import session


            def main():
                session.New("discard")
                base.InputNastran("/home/user/laminates.nas")
                group = base.NewGroup(name="group", module_id="1")

                laminates = base.CollectEntities(constants.NASTRAN, None, "LAMINATE")
                ret = base.LaminateReport(
                    constants.NASTRAN,
                    "/home/user/report/report.html",
                    laminates,
                    layer_info=True,
                    create_png=True,
                    create_stl=True,
                    create_vrml=True,
                    layer_curves=True,
                    curves_group=group,
                    stl_format="binary",
                    stl_offset_pos="offset",
                    stl_reduce_trias=True,
                    create_iges=True,
                )
                print(ret)

                laminates = base.CollectEntities(constants.NASTRAN, None, "SOLID_LAMINATE")
                ret = base.LaminateReport(
                    constants.NASTRAN,
                    "/home/antounas/report_solids/report_solids.html",
                    laminates,
                    layer_info=True,
                    create_png=True,
                    create_vrml=True,
                )
                print(ret)


    """


def OutputMoldflow(filename: str, mode: str, mesh_type: str) -> int:
    """

    OutputMoldflow outputs a Moldflow *.udm format file like the File>Output>MOLDFLOW functionality.
    It supports variable number of arguments.

    Parameters
    ----------
    filename : str
            The name of the output file.
            It must include the full path to the file.

    mode : str
            "all", "model" or "visible".
            (Default: what set at the last execution)

    mesh_type : str
            "solid 3d", "midplane" or "dual domain.
            (Default: "solid 3d")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputMoldflow(filename="C:/temp/data.udm", mode="all", mesh_type="solid 3d")


    """


def CopySpecificMatsFromMdbToMlist(
    deck: int,
    mode: str,
    materials: object,
    ovewrite_names: bool,
    overwrite_comments: bool,
    overwrite_colors: bool,
    copy_unmatched: bool,
    ret_ents: bool,
    overwrite_ids: bool,
) -> object:
    """

    This function copies/updates model materials using the Material Database.

    Parameters
    ----------
    deck : int
            The deck constant.

    mode : str
            One of: "update_by_ids", "update_by_names" or "copy".

    materials : object
            A Material Entity or a list including Material Entities.

    ovewrite_names : bool, optional
            A flag to overwrite names.

    overwrite_comments : bool, optional
            A flag to overwrite comments.

    overwrite_colors : bool, optional
            A flag to overwrite colors.

    copy_unmatched : bool, optional
            A flag to copy unmatched materials.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    overwrite_ids : bool, optional
            A flag to overwrite ids when "update_by_names" is selected.

    Returns
    -------
    object
            It returns the number of the materials successfuly copied.
            If ret_ents=True it will return a list with the copied materials,
            or None if no materials were copied.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                mats = []
                mats.append(
                    base.GetEntity(
                        constants.LSDYNA, "MAT1F MAT_ELASTIC_FLUID", 1, "Material Database"
                    )
                )
                mats.append(
                    base.GetEntity(constants.LSDYNA, "MAT51 MAT_BAMMAN", 3, "Material Database")
                )

                result = base.CopySpecificMatsFromMdbToMlist(
                    constants.LSDYNA, "update_by_ids", mats, False, False, False, True
                )


    """


def SurfaceSweep(
    entities1: object,
    entities2: object,
    reverse_first_selection: bool,
    reverse_second_selection: bool,
    ref_point: object,
    join_perimeters: bool,
    respect_user_selection: bool,
    part: object,
    property: object,
) -> object:
    """

    This function defines a new multi-patch surface.

    Parameters
    ----------
    entities1 : object
            A list with the entities for sweep.

    entities2 : object
            A list with entities used for guideline.

    reverse_first_selection : bool, optional
            A flag for reverse 1st selection.

    reverse_second_selection : bool, optional
            A flag for reverse 2nd selection.

    ref_point : object, optional
            A list with th x,y,z coordinates of a reference point.

    join_perimeters : bool, optional
            Aa flag to join perimeters of created face(s).

    respect_user_selection : bool, optional
            If set to True, then the order of entries in entities1, 2 will be respected
            and thus Face(s) will be created in that order.

    part : object, optional
            The part for the created face(s).

    property : object, optional
            The property for the created faces(s).

    Returns
    -------
    object
            Returns a list containing references to the newly created faces on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents1 = []
                con1 = base.GetEntity(constants.NASTRAN, "CONS", 15)
                ents1.append(con1)

                ents2 = []
                ents2.append(base.GetEntity(constants.NASTRAN, "CONS", 12))

                part = base.GetEntityPart(con1)
                property = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                # created_faces = base.SurfaceSweep(ents1, ents2)
                # created_faces = base.SurfaceSweep(ents1, ents2, reverse_second_selection=True)

                ref = []
                ref.append(10.0)
                ref.append(10.0)
                ref.append(10.0)

                created_faces = base.SurfaceSweep(
                    ents1, ents2, False, False, ref, True, True, part, property
                )
                print(len(created_faces))


    """


def MergeMedinaComponents(components: object, master_component: object) -> object:
    """

    Will merge any components inside the components list to the master_component.

    Parameters
    ----------
    components : object
            A list containing the components to be merged.

    master_component : object
            The component to which the components will be merged.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                components = base.CollectEntities(constants.PERMAS, None, "COMPONENT")
                master_component = base.GetEntity(constants.PERMAS, "COMPONENT", 1)
                base.MergeMedinaComponents(components, master_component)

                components = base.CollectEntities(constants.PERMAS, None, "COMPONENT")
                print(components)


    """


def GenerateMpcIQuads(surfaces: object, ret_ents: bool) -> object:
    """

    This function will generate any MpcIQuads as they are described by the Isurfaces data found the surfaces list.

    Parameters
    ----------
    surfaces : object, optional
            A list of surface objects.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns None.
            If ret_ents=True it will return a list with the created entities,
            or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                surfaces = base.CollectEntities(constants.PERMAS, search_types="MPC_ISURFACE")
                base.GenerateMpcIQuads(surfaces)


    """


def EraseMpcIQuads(surfaces: object) -> object:
    """

    This function will erase any MpcIQuads as they are described by the Isurfaces data found the surfaces list.

    Parameters
    ----------
    surfaces : object, optional
            A list of surface objects.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_erase_iquads():
                surfaces = base.CollectEntities(constants.PERMAS, None, "MPC_ISURFACE")
                base.EraseMpcIQuads(surfaces)


    """


def SurfaceGlide(
    entities1: object,
    entities2: object,
    reverse_first_selection: bool,
    reverse_second_selection: bool,
    ref_point: object,
    join_perimeters: bool,
    respect_user_selection: bool,
    part: object,
    property: object,
) -> object:
    """

    This function defines a new multi-patch surface.

    Parameters
    ----------
    entities1 : object
            A list with the entities for sweep.

    entities2 : object
            A list with entities used for guideline.

    reverse_first_selection : bool, optional
            A flag for reverse 1st selection.

    reverse_second_selection : bool, optional
            A flag for reverse 2nd selection.

    ref_point : object, optional
            A list with the x,y,z coordinates of a reference point.

    join_perimeters : bool, optional
            A flag to join perimeters of created face(s).

    respect_user_selection : bool, optional
            If set to True, then the order of entries in entities1, 2 will be respected
            and thus Face(s) will be created in that order.

    part : object, optional
            The part for the created face(s).

    property : object, optional
            The property for the created faces(s).

    Returns
    -------
    object
            Returns a list containing references to the newly created faces, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents1 = []
                con1 = base.GetEntity(constants.NASTRAN, "CONS", 15)
                ents1.append(con1)

                ents2 = []
                ents2.append(base.GetEntity(constants.NASTRAN, "CONS", 12))

                part = base.GetEntityPart(con1)
                property = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                # created_faces = base.SurfaceGlide(ents1, ents2, reverse_second_selection=True)
                # created_faces = base.SurfaceGlide(ents1, ents2)

                ref = []
                ref.append(10.0)
                ref.append(10.0)
                ref.append(10.0)

                created_faces = base.SurfaceGlide(
                    ents1, ents2, False, False, ref, True, True, part, property
                )
                print(len(created_faces))


    """


def ActivateConfiguration(
    configuration: object,
    reapply_swcnctn: int,
    reapply_gebs: int,
    deactivate_entities: int,
) -> int:
    """

    This function sets a configuration as active. It is the equivalent of "Activate" in the configurations window inside the Part Manager.
    The arguments of this function correspond to the check boxes of the wizard that pops up, when the configuration to activate
    affects Spotweld connections(reapply_swcnctn), GEBs(reapply_gebs) or other entities in general(deactivate_entities).

    Parameters
    ----------
    configuration : object
            The configuration to set active.

    reapply_swcnctn : int
            0 or 1. Set this to 1, if you wish to reapply
            the affected spotweld connections related to this
            configuration, once it has been activated.

    reapply_gebs : int
            0 or 1. Set this to 1, if you wish to reapply
            the affected GEBs related to this configuration,
            once it has been activated.

    deactivate_entities : int
            0 or 1. Set this to 1, if you wish to deactivate
            the affected entities related to this
            configuration, once it has been activated.

    Returns
    -------
    int
            Returns 1 if the configuration has been set active successfully, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                conf = base.GetPartFromModuleId("Lang_Panorama_module_id")
                base.ActivateConfiguration(conf, 0, 0, 0)


    """


def GetActiveConfiguration() -> object:
    """

    This function returns the configuration that is currently active in the model,
    or 0 if no configuration exists, or no configuration is currently active.

    Returns
    -------
    object
            Returns the configuration that is currently active in the model,
            or 0 if no configuration exists, or no configuration is currently active.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                activeconf = base.GetActiveConfiguration()
                if activeconf:
                    vals = ("Module Id",)
                    ret = base.GetEntityCardValues(constants.NASTRAN, activeconf, vals)
                    print(
                        'Found active configuration named "'
                        + activeconf._name
                        + '" with module id='
                        + ret["Module Id"]
                        + "."
                    )
                else:
                    print("No active configuration found.")


    """


def ClearActiveConfiguration() -> int:
    """

    This function is the equivalent of "ClearActive" in configuration window of Part Manager.
    After this function is executed, no configuration is active in the model.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def PrintActiveConfiguration():
                activeconf = base.GetActiveConfiguration()
                if activeconf:
                    vals = ("Name", "Module Id")
                    ret = base.GetEntityCardValues(constants.NASTRAN, activeconf, vals)
                    print(
                        'Found active configuration named "'
                        + ret["Name"]
                        + '" with module id = '
                        + ret["Module Id"]
                        + "."
                    )
                else:
                    print("No active configuration found.")


            def main():
                PrintActiveConfiguration()
                base.ClearActiveConfiguration()
                PrintActiveConfiguration()


    """


def DeactivateConfiguration(configuration: object) -> int:
    """

    This function deactivates the given configuration, if it is the active one.
    It is the equivalent of pressing "Deactivate" in the configuration window of the Part Manager.

    Parameters
    ----------
    configuration : object
            The configuration that you wish to deactivate.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def PrintActiveConfiguration():
                activeconf = base.GetActiveConfiguration()
                if activeconf:
                    vals = ("Name", "Module Id")
                    ret = base.GetEntityCardValues(constants.NASTRAN, activeconf, vals)
                    print(
                        'Found active configuration named "'
                        + ret["Name"]
                        + '" with module id='
                        + ret["Module Id"]
                        + "."
                    )
                else:
                    print("No active configuration found.")


            def main():
                activeconf = base.GetActiveConfiguration()
                PrintActiveConfiguration()
                if activeconf:
                    base.DeactivateConfiguration(activeconf)
                PrintActiveConfiguration()


    """


def GetAllConfigurations() -> object:
    """

    This function returns all the configurations that exist in the model.

    Returns
    -------
    object
            Returns a list with all the configurations that exist in the model, or 0 if there are none of them.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                configs = base.GetAllConfigurations()
                for config in configs:
                    vals = ("Module Id",)
                    ret = base.GetEntityCardValues(constants.NASTRAN, config, vals)
                    print(
                        'Found configuration named "',
                        config._name,
                        '" with module id=',
                        ret["Module Id"],
                        ".",
                    )


    """


def SurfaceRevolution(
    entities: object,
    guideline: object,
    respect_user_selection: bool,
    always_break: bool,
    deg_min: float,
    deg_max: float,
    part: object,
    property: object,
) -> object:
    """

    This function defines a multi-patch surface of revolution.

    Parameters
    ----------
    entities : object
            A list of entities for the revolution surface.

    guideline : object
            A list with two pointers of G_POINTs.

    respect_user_selection : bool, optional
            If set to True, then the order of entries in entities will be respected and
            thus Faces will be created in that order.

    always_break : bool, optional
            If set to True, then the created faces will separate where there are
            discontinuities on the surface. Else all the entities will create one face.

    deg_min : float, optional
            The minimum numerical input in degrees, defining the boundaries of the
            created face.

    deg_max : float, optional
            The maximum numerical input in degrees, defining the boundaries of the
            created face.

    part : object, optional
            The part for the created face.

    property : object, optional
            The property for the created face.

    Returns
    -------
    object
            Returns a list containing references to the newly created faces on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = []
                ents.append(base.GetEntity(constants.NASTRAN, "CONS", 13))

                part = base.GetEntityPart(ents[0])
                property = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                # 108.000000 , 71.676598 , 351.982856
                # 108.000000 , 134.225175 , 351.982856

                guide = []
                guide.append(base.GetEntity(constants.NASTRAN, "POINT", 1))
                guide.append(base.GetEntity(constants.NASTRAN, "POINT", 2))

                faces = base.SurfaceRevolution(ents, guide, True, True, 10.0, 270.0, part, property)
                print(len(faces))


    """


def ExtractCuttingCurvesFromPlane(cplane: object) -> int:
    """

    Extracts section curves of a cutting plane entity.

    Parameters
    ----------
    cplane : object
            A reference to a CUTTING PLANE entity that can be retrieved
            from a previous call to GetEntity.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "CUTTING PLANE", 1)
                if ent:
                    res = base.ExtractCuttingCurvesFromPlane(ent)
                    print(res)


    """


def Save() -> int:
    """

    This function saves all the changes made at the current file in ANSA.

    Returns
    -------
    int
            Returns 0 on success, 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Save()


    """


def ConsProjectNormal(
    entities: object,
    faces_array: object,
    max_distance: float,
    split_original: bool,
    connect_with_faces: bool,
    nearest_target: bool,
    delete_faces: bool,
) -> object:
    """

    This function projects a number of selected 3D-curves, CONS, element edges or line elements
    on a number of selected Faces, in a direction that is normal to each Face.

    Parameters
    ----------
    entities : object
            The projected entity, a list with the projected entities, a string with
             value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible entities.
            If it is called with 'all', it works with all the entities.

    faces_array : object
            A face, a list of faces, a string with value 'visible' or a string
            with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    max_distance : float, optional
            The maximum allowed projection distance from every point of
            the curves, if max_dist < 0.
            There is no limitation.

    split_original : bool, optional
            If set to True, the projection trace intersects with a face perimeter,
            this inserts a hotpoint at the respective point on the original curve.

    connect_with_faces : bool, optional
            If set to True, it results in the creation of Faces between the
            original CONS and their projections. The newly created Faces,
            will also be returned in a list.

    nearest_target : bool, optional
            If set to True, the projection will take place on the nearest faces within
            the range of maximum projection distance and will avoid double projection
            on opposite positioned faces.
            (Default: False)

    delete_faces : bool, optional
            If True, if the trace of the projection forms a closed loop inside the target faces (not touching the outer perimeters), faces inside the loop will be deleted.
            (Default: False)

    Returns
    -------
    object
            Returns a list containing two lists. The first list contains the newly created CONS.
            The second list contains the newly created faces, if connect_with_faces flag is True,
            otherwise it is None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves = base.CollectEntities(constants.NASTRAN, None, "CURVE", filter_visible=True)
                faces = base.GetEntity(constants.NASTRAN, "FACE", 1)

                ret_list = base.ConsProjectNormal(curves, faces, 0.0, True, True)

                print(len(ret_list))
                print(len(ret_list[0]))
                print(len(ret_list[1]))


    """


def ConsProjectUser(
    entities: object,
    faces_array: object,
    user_vector: object,
    max_distance: float,
    split_original: bool,
    connect_with_faces: bool,
    nearest_target: bool,
    delete_faces: bool,
) -> object:
    """

    This function projects a number of selected 3D-curves, CONS, element edges or line elements
    on a number of selected Faces, in a direction that the user defines to each Face.

    Parameters
    ----------
    entities : object
            The projected entity, a list with the projected entities, a string with
             value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible entities.
            If it is called with 'all', it works with all the entities.

    faces_array : object
            A face, a list of faces, a string with value 'visible' or a string
            with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    user_vector : object
            A list with coordinates for the user defined vector.

    max_distance : float, optional
            The maximum allowed projection distance from every point of
            the curves, if max_dist < 0.
            There is no limitation.

    split_original : bool, optional
            If set to True, the projection trace intersects with a face perimeter,
            this inserts a hotpoint at the respective point on the original curve.

    connect_with_faces : bool, optional
            If set to True, it results in the creation of Faces between the
            original CONS and their projections. The newly created Faces,
            will also be returned in a list.

    nearest_target : bool, optional
            If set to True, the projection will take place on the nearest faces within
            the range of maximum projection distance and will avoid double projection
            on opposite positioned faces.
            (Default: False)

    delete_faces : bool, optional
            If True, if the trace of the projection forms a closed loop inside the target faces (not touching the outer perimeters), faces inside the loop will be deleted.
            (Default: False)

    Returns
    -------
    object
            Returns a list containing two lists. The first list contains the newly created CONS.
            The second list contains the newly created faces, if connect_with_faces flag is True,
            otherwise it is None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves = base.CollectEntities(
                    ansa.constants.NASTRAN, None, "CURVE", filter_visible=True
                )
                faces = base.GetEntity(ansa.constants.NASTRAN, "FACE", 1)
                vector = [1.0, 0.0, 0.0]

                ret_list = base.ConsProjectUser(
                    curves, faces, vector, connect_with_faces=True, nearest_target=True
                )

                print(len(ret_list))
                print(len(ret_list[0]))
                print(len(ret_list[1]))


    """


def RemoveEmptyPartsGroups() -> int:
    """

    This function removes all the empty Groups and Parts of the file.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RemoveEmptyPartsGroups()


    """


def SafetyRaster(
    front_curve: object,
    rear_curve: object,
    left_curve: object,
    right_curve: object,
    external_parts: object,
    length_x: float,
    length_y: float,
    paste_tolerance: float,
    projection_axis: str,
    symmetry_plane: str,
    uniform_distribution: bool,
    points_on_lateral: bool,
    points_on_side: bool,
    points_on_curves_at_gaps: bool,
    delete_tol_points: bool,
    create_line_elements: bool,
    starting_point: str,
    create_surface: bool,
) -> object:
    """

    This function creates a raster of target points on quadrilateral areas defined by ANSA curves.
    These points are projected on a geometric or FE surface that is defined in external_parts set.

    Parameters
    ----------
    front_curve : object
            Curve Id, Name or Entity.

    rear_curve : object
            Curve Id, Name or Entity.

    left_curve : object
            Curve Id, Name or Entity.

    right_curve : object
            Curve Id, Name or Entity.

    external_parts : object
            Set Id, Name or Entity.

    length_x : float, optional
            Length of raster in X direction (from Front to Rear Curve).
            (Default: 50.0)

    length_y : float, optional
            Length of raster in Y direction (from Left to Right Curve).
            (Default: 50.0)

    paste_tolerance : float, optional
            Distance from curves for excluding target points.
            (Default: 5.0)

    projection_axis : str, optional
            Global projection axis for projecting the target points on surface.
            Options are: 'X', 'Y', 'Z', '-X', '-Y', '-Z'.
            (Default: '-Z')

    symmetry_plane : str, optional
            Global symmetry plane for creating the symmetric points according this.
            Options are: 'XZ', 'YZ', 'XY', 'No Symmetry'.

    uniform_distribution : bool, optional
            Option for creating a uniform raster on X and Y directions.
            (Default: True)

    points_on_lateral : bool, optional
            Option for creating target points on front and rear curves.
            (Default: True)

    points_on_side : bool, optional
            Option for creating target points on left and right curves.
            (Default: True)

    points_on_curves_at_gaps : bool, optional
            Option for creating target points on curves even if no projection
            on the external parts is found.
            (Default: True)

    delete_tol_points : bool, optional
            Option for deleting the target points that are excluded due to paste
            tolerance.
            (Default: True)

    create_line_elements : bool, optional
            Option for creating line elements between the target points.
            (Default: False)

    starting_point : str, optional
            Option for selecting the starting point of the Raster.
            The available options are: 'Center', 'Left Corner', 'Right Corner'.
            The starting point is taken into account only if the symmetry_plane
            argument is set to 'No Symmetry'.
            (Default: 'Center')

    create_surface : bool, optional
            Option for creating shell elements from the target points.
            (Default: False)

    Returns
    -------
    object
            Returns a list containing references to the newly created target point objects.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                target_points = base.SafetyRaster(
                    front_curve="FRONT",
                    rear_curve="REAR",
                    left_curve="LEFT",
                    right_curve="RIGHT",
                    external_parts=1,
                )


    """


def KineticsKinMotionDefine(
    entity: object,
    along_x: str,
    along_y: str,
    along_z: str,
    about_x: str,
    about_y: str,
    about_z: str,
    function_dx: float,
    function_dy: float,
    function_dz: float,
    function_rx: float,
    function_ry: float,
    function_rz: float,
    disp_ic_dx: float,
    disp_ic_dy: float,
    disp_ic_dz: float,
    disp_ic_rx: float,
    disp_ic_ry: float,
    disp_ic_rz: float,
    vel_ic_dx: float,
    vel_ic_dy: float,
    vel_ic_dz: float,
    vel_ic_rx: float,
    vel_ic_ry: float,
    vel_ic_rz: float,
) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`MotionDefine` instead.


    Parameters
    ----------
    entity : object
            A reference to KIN_MOTION entity.

    along_x : str, optional
            One of: 'DISP', 'VEL' or 'ACC', in order to set the x translational
            motion to prescribed displacement, velocity or acceleration.

    along_y : str, optional
            One of: 'DISP', 'VEL' or 'ACC', in order to set the y translational
            motion to prescribed displacement, velocity or acceleration.

    along_z : str, optional
            One of: 'DISP', 'VEL' or 'ACC', in order to set the z translational
            motion to prescribed displacement, velocity or acceleration.

    about_x : str, optional
            One of: 'DISP', 'VEL' or 'ACC', in order to set the x rotational motion to
            prescribed (rotational) displacement, velocity or acceleration.

    about_y : str, optional
            One of: 'DISP', 'VEL' or 'ACC', in order to set the y rotational motion to
            prescribed (rotational) displacement, velocity or acceleration.

    about_z : str, optional
            One of: 'DISP', 'VEL' or 'ACC', in order to set the z rotational motion to
            prescribed (rotational) displacement, velocity or acceleration.

    function_dx : float, optional
            Function for x translational motion.

    function_dy : float, optional
            Function for y translational motion.

    function_dz : float, optional
            Function for x translational motion.

    function_rx : float, optional
            Function for x rotational motion.

    function_ry : float, optional
            Function for y rotational motion.

    function_rz : float, optional
            Function for z rotational motion.

    disp_ic_dx : float, optional
            The x component of the displacement initial condition.

    disp_ic_dy : float, optional
            The y component of the displacement initial condition.

    disp_ic_dz : float, optional
            The z component of the displacement initial condition.

    disp_ic_rx : float, optional
            The x component of the rotational initial condition.

    disp_ic_ry : float, optional
            The y component of the rotational initial condition.

    disp_ic_rz : float, optional
            The z component of the rotational initial condition.

    vel_ic_dx : float, optional
            The x component of the initial translational velocity.

    vel_ic_dy : float, optional
            The y component of the initial translational velocity.

    vel_ic_dz : float, optional
            The z component of the initial translational velocity.

    vel_ic_rx : float, optional
            The x component of the initial rotational velocity.

    vel_ic_ry : float, optional
            The y component of the initial rotational velocity.

    vel_ic_rz : float, optional
            The z component of the initial rotational velocity.

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                kin_motion_to_change = base.GetEntity(constants.NASTRAN, "KIN_MOTION", True)
                ret_val = ansa.base.KineticsKinMotionDefine(
                    entity=kin_motion_to_change, about_z="Free"
                )
                ret_val = ansa.base.KineticsKinMotionDefine(
                    entity=kin_motion_to_change,
                    about_z="Vel",
                    function_rz="1*time",
                    disp_ic_rz=0.01,
                )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: MotionDefine instead.",
        DeprecationWarning,
    )


def KineticsSimulationSimulatorSettings(tab_type: str, settings) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`Simulator` instead.


    Modifies or sets the various options in the 'Kinetic Options' window.
    A description of the various options can be found at the tooltips of the 'Kinetic
    Options' window.
    Each group of settings has to be set in a different call to this function by
    setting the 'tab_type' to 'dynamics', 'kinematics', 'contacts', 'IC' or
    'static'.
    When the name of an option has a blank character, it should be replaced with an
    undescore and the name lower-cased (for example, "Integrator Type" should
    become "integrator_type")
    The 'Animation' tab cannot be set using this function.

    Parameters
    ----------
    tab_type : str
            'dynamics', 'kinematics', 'contacts', 'ic' or 'static'
            refering to tab of Options respectively
            (default: 'dynamics')
            For tab_type='dynamics':
            integrator_type string Select type of Integrator: 'hht-i3'
            (default - no other type at the moment)
            alpha float Coefficient for HHT Integrator
            hmax float Maximum time step size allowed
            hmin float Minimum time step size allowed (hmin<hmax and hmin<hinit)
            hinit float Initial time step size (hinit<hmax)
            tolx float Error tolerance for accelerations
            tolf float Error tolerance for forces
            tolj float Relative tolerance for redundant constraints
            maxiter int Maximum number of iterations allowed
            alimit float Euler angle singularity tolerance [DEG 0-90]
            extrapolation string Select type of Extrapolation:
            'no', 'linear', 'quadratic', 'cubical' or 'modified'
            For tab_type='kinematics':
            hinit float Initial step size
            hmin float Minimum step size allowed (hmin<hinit)
            tolx float Error tolerance for displacements
            tolf float Error tolerance for forces
            tolj float Relative tolerance for redundant constraints
            maxiter int Maximum number of iterations allowed
            alimit float Euler angle singularity tolerance [DEG 0-90]
            linear_search string Method of Line Search: 'cubical', 'linear', 'linear_modified'
            For tab_type='contacts':
            integrator_type string Type of Integrator: 'constant', 'adjustment'
            (if omited constant integrator type is assumed)
            For tab_type='contacts' and integrator_type='constant':
            hinit float Step size allowed
            tolj float Relative tolerance for redundant constraints
            tolf float Error tolerance for forces
            tol_depth float Depth tolerance for collision detection (mm)
            tol_distance float Distance tolerance for contact points clean up (mm)
            max_contact_points int Maximum number of contact points per manifold
            linearcomplementaritysolver string Select type of Linear Complementarity Solver 'JORprox', 'SORprox'
            maxiter int Maximum number of iterations allowed
            atol float Absolute tolerance
            rtol float Relative tolerance
            gtol float Gradient tolerance for spurious convergence
            For tab_type='contacts' and integrator_type='adjustment':
            hmax float Maximum step size allowed
            hmin float Minimum step size allowed
            tolj float Relative tolerance for redundant constraints
            tolf float Error tolerance for forces
            tol_depth float Depth tolerance for collision detection (mm)
            tol_distance float Distance tolerance for contact points clean up (mm)
            max_contact_points int Maximum number of contact points per manifold
            linearcomplementaritysolver string Type of Linear Complementarity Solver: 'JORprox', 'SORprox'
            maxiter int Maximum number of iterations allowed
            atol float Absolute tolerance
            rtol float Relative tolerance
            gtol float Gradient tolerance for spurious convergence
            nmax int Value of maximium integration order allowed for
            smooth extrapolation: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21
            s_atol float Absolute tolerance for stepsize adjustement and extrapolation
            s_rtol float Relative tolerance for stepsize adjustement and extrapolation
            For tab_type='ic':
            wi float Weight factor
            maxiter int Max anchor error
            maxerror float Maximum number of iterations allowed
            tolx float Error tolerance for displacements
            tolf float Error tolerance for forces
            linear_search string Method of Linear Search: 'cubical', 'linear', 'linear_modified'
            For tab_type='static':
            maxiter int Maximum number of iterations allowed
            tolx float Error tolerance for displacements
            tolf float Error tolerance for forces
            stepmax float Maximum step size allowed
            linear_search string Method of Linear Search: 'cubical', 'linear', 'linear_modified'

    settings :
            of settings has to be set in different call to this function by

    Returns
    -------
    int
            Returns 1 on all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # change whole model's Dynamics-> extrapolation & maxiter
                base.KineticsSimulationSimulatorSettings(
                    tab_type="dynamics", extrapolation="linear", maxiter=50
                )

                # change KIN_CONFIG's (id=2) Contacts (for constant integrator type) ->maxiter
                kf = base.GetEntity(base.CurrentDeck(), "KIN_CONFIG", 2)

                base.KineticsSimulationSimulatorSettings(
                    kin_config=kf, tab_type="contacts", integrator_type="constant", maxiter=4
                )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: Simulator instead.",
        DeprecationWarning,
    )


def SetMaterialDatabase(DECK: int, MDB_PATH: str) -> int:
    """

    Sets the default Material Database path MDB_PATH, for deck DECK.

    Parameters
    ----------
    DECK : int
            The deck constant.

    MDB_PATH : str
            The path of the material database file.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                result = base.SetMaterialDatabase(
                    constants.NASTRAN, "/root/users/user_20/mat_files/nas_mat_database_4.bdf"
                )


    """


def GetMaterialDatabase(deck: int, all_paths: bool) -> str:
    """

    Gets the default Material Database paths that are defined in ANSA.defaults and loaded during ANSA start up, for deck.

    Parameters
    ----------
    deck : int
            The deck constant.

    all_paths : bool, optional
            True when as a result you want to get multiple Material Databases used as default. If False ( default value) the function returns the first entry.

    Returns
    -------
    str
            Returns a string that contains the Material Database path. (if all_paths=False)
            Returns a list that contains the Material Database paths. (if all_paths=True)

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                result = base.GetMaterialDatabase(constants.NASTRAN)
                print(result)
                paths = base.GetMaterialDatabase(constants.NASTRAN, all_paths=True)
                print(paths)


    """


def UpdateMatsFromMDBBy(
    deck: int, list_mats: object, by: str, ret_ents: bool
) -> object:
    """

    This function copies/updates model materials by using the Material Database.

    Parameters
    ----------
    deck : int
            The deck constant.

    list_mats : object
            A Material Entity or a list including Material Entities.

    by : str
            Options are: "by_id" or "by_name".

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns the number of the updated materials.
            If ret_ents=True it will return a list with the created entities,
            or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                listmat = base.GetEntity(constants.LSDYNA, "__MATERIALS__", 1)
                listmat2 = base.GetEntity(constants.LSDYNA, "__MATERIALS__", 2)
                mats = (listmat, listmat2)

                result = base.UpdateMatsFromMDBBy(constants.LSDYNA, mats, "by_id")


    """


def CopySpecificMatFromMdb(
    deck: int, list_mats: object, db_mat: object, ret_ents: bool
):
    """

    This function updates list materials by a specific material from the Material Database.

    Parameters
    ----------
    deck : int
            The deck constant.

    list_mats : object
            A Material Entity or a list including Material Entities
            from the material list.

    db_mat : object
            A Material Entity from the Material Database.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                db_mat = base.GetEntity(constants.LSDYNA, "__MATERIALS__", 2, "Material Database")

                list_mats = []
                list_mats.append(base.GetEntity(constants.LSDYNA, "__MATERIALS__", 1))
                list_mats.append(base.GetEntity(constants.LSDYNA, "__MATERIALS__", 2))

                result = base.CopySpecificMatFromMdb(constants.LSDYNA, list_mats, db_mat)


    """


def ExtractCrossSectionsFromPlane(cplane: object) -> int:
    """

    Extracts Cross Sections of a cutting plane entity.

    Parameters
    ----------
    cplane : object
            A reference to a CUTTING PLANE entity that can be retrieved
            from a previous call to GetEntity.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "CUTTING PLANE", 1)
                if ent:
                    res = base.ExtractCrossSectionsFromPlane(ent)
                    print(res)


    """


def SaveFileAsIGES(file_name: str, file_units: str, entities: object) -> int:
    """

    This function saves all visible entities (or all entries in "entities") to a CAD file in IGES format (extension .iges or .igs).

    Parameters
    ----------
    file_name : str
            A filesystem path.

    file_units : str, optional
            One of the following: "KILOMETERS", "METERS", "CENTIMETERS",
            "MILLIMETERS", "MICROMETERS", "MILES", "FEET", "INCHES",
            "MILLIINCHES", "MICROINCHES"

    entities : object, optional
            A collection of ANSA entities.

    Returns
    -------
    int
            Returns 0 on error, 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SaveFileAsIGES("F:/user/temp/data.igs", "MILLIMETERS")


    """


def ZoneCut(
    cons: object,
    faces: object,
    zone_width: float,
    zones_number: int,
    extend_zones: bool,
    create_curves: bool,
) -> object:
    """

    Function ZoneCut() given a number of input CONS along with their respective
    faces, creates zones related to the user supplied input CONS.

    Parameters
    ----------
    cons : object
            A list with ANSA CONS entities (suppliance of this
            argument is mandatory).

    faces : object
            A list with ANSA face entities. Each face in
            'faces' list corresponds to the CONS with the same index -
            position at input list 'cons' (i.e., it is mandatory that
            'cons' and 'faces' have the same size and that each CONS in
            'cons' relates with its respective face in 'faces' with the
            same index) (suppliance of this argument is mandatory).

    zone_width : float, optional
            Object is a scalar (i.e., Double) that specifies the width -
            step of the zones that are going to be created (suppliance
            of this argument is optional, default value = 1.0).

    zones_number : int, optional
            A number (i.e., Integer) that specifies the number
            of zones - steps that are going to be created
            (suppliance of this argument is optional, default
            value = 1).

    extend_zones : bool, optional
            A boolean (i.e., 'True' or 'False') which
            signifies whether created zones with floating edges should
            be extended tangently to the perimeter of the face at which
            they are located (suppliance of this argument is optional,
            default value = 'False'). Set 'True' for extention of zones,
            'False' otherwise.

    create_curves : bool, optional
            A boolean (i.e., True or False) which signifies
            whether output zones created should be ANSA 3D curves
            entities or ANSA CONS entities. When set to True, output
            will be a list containing ANSA 3D curve entities. When set
            to False (default), output will be a list containing two
            other lists, where the first will contain the created ANSA
            CONS entities and the second will contain the created ANSA
            face entities. In correspondance to the input argument lists
            'cons' and 'faces' mandatory condition, each face in the
            output faces list will correspond to the respective CONS in
            the output CONS list that has the same index (suppliance of
            this argument is optional, default value = 'False').

    Returns
    -------
    object
            In case where 'create_curves' input argument is set to 'True', ZoneCut() will
            return a list with an other list with the created ANSA 3D curve entities.
            In case 'create_curves' input argument is set to 'False' function ZoneCut()
            will return a list containing two other lists, where the first list will contain
            the created ANSA CONS entities and the second one will contain the created ANSA face entities.
            In correspondace to the mandatory input argument lists 'cons' and 'faces'
            condition, each face entity in the output faces list will correspond to the
            respective CONS in the CONS output list with the same index. Consequently the
            two output lists ought to have the same number of elements.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # - list with CONS.
                # - It is going to be supplied as mandatory input argument to ZoneCut().
                cons = []

                # - list with respective faces (i.e., for each CONS entity in 'cons' list you must specify
                #   at exactly the same index-location its related face).
                # - It is going to be supplied as mandatory input argument to ZoneCut().
                faces = []

                # - Specify CONS IDs you want to select for zone-cut in cons_ids list.
                # - Change the IDs with valid ones that apply to your case - example.
                cons_ids = [947, 943, 897, 886, 895, 939]

                # - Specify for each one CONS ID in 'cons_ids' list, at exactly the same index-location its
                #   respective face towards to we want to apply zone-cut.
                # - Change the IDs with valid ones that apply to your case - example.
                face_ids = [17, 17, 17, 17, 17, 17]

                # - Collected ANSA entities specified in IDs lists 'cons_ids' and 'face_ids'  and load to
                #   respective lists 'cons' and 'faces'.
                idx = 0
                for id in cons_ids:
                    cons.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", cons_ids[idx]))
                    faces.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", face_ids[idx]))
                    idx = idx + 1
                # apply zone-cuts
                ret_list = base.ZoneCut(
                    cons,
                    faces,
                    zone_width=1.0,
                    zones_number=1,
                    extend_zones=True,
                    create_curves=False,
                )

                # Print Output list
                print("Created CONS :\\n", ret_list[0])
                print("Created FACES:\\n", ret_list[1])


    """


def CreateCurveWithBox(
    coordinates: object, cloud_width: float, multi_distance: float
) -> object:
    """

    This script function creates single or multiple curves from an exact point input or through a point cloud.

    Parameters
    ----------
    coordinates : object
            A List with (x, y, z) values, the input set of points.

    cloud_width : float, optional
            Indicates the cloud width in case of point cloud.

    multi_distance : float, optional
            Indicates the splitting tolerance in case of multiple curves.

    Returns
    -------
    object
            Returns a list containing the created curve(s) or None if it fails.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                points = base.CollectEntities(constants.NASTRAN, None, "POINT")
                vals = ("X", "Y", "Z")
                coordinates = []
                for point in points:
                    ret = base.GetEntityCardValues(constants.NASTRAN, point, vals)
                    coordinates.append((ret["X"], ret["Y"], ret["Z"]))
                ret = base.CreateCurveWithBox(coordinates, 15.0, 60.0)
                print(ret)


    """


def SwitchGroupOrPart(part: object) -> int:
    """

    This function switches parts to groups and groups to parts. That means:
    1) every part will be changed to a group and
    2) every group will be changed to a part.
    In the second case ungrouping is done and all containing parts will be set to the top level.

    Parameters
    ----------
    part : object
            A part entity or a list of part entities.

    Returns
    -------
    int
            Returns 1 on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromModuleId("300")
                ans = base.SwitchGroupOrPart(part)
                print("ans", ans)

                parts = []
                parts.append(base.GetPartFromModuleId("100"))
                parts.append(base.GetPartFromModuleId("200"))
                ans = base.SwitchGroupOrPart(parts)
                print("ans", ans)


    """


def CrossSectionsNew(
    definition: bool,
    point1: object,
    point2: object,
    point3: object,
    curves: object,
    part: object,
    ret_ents: bool,
) -> object:
    """

    Creates a new cross section for curves.

    Parameters
    ----------
    definition : bool
            The type of definition of the plane.
            True: Normal definition (2 points).
            False: 3 points definition.
            (Default: False)

    point1 : object
            A list with three doubles. The coordinates of the
            first given point.

    point2 : object
            A list with three doubles. The coordinates of the
            second given point. In normal definition it is the
            point defining the vertical vector on the plane.

    point3 : object
            A list with three doubles. The coordinates of the
            third given point. (not used in normal definition)

    curves : object
            A list of curve entities.

    part : object, optional
            The part in which the cross section will be included.
            By default the current part will be used.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns 1 if the cross section has been created and 0 if thr cross section has not been created.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curve = base.GetEntity(constants.LSDYNA, "CURVE", 85)
                curve2 = base.GetEntity(constants.LSDYNA, "CURVE", 86)
                a = [500, 0, 0]
                b = [0, 500, 0]
                c = [0, -500, 0]
                curves = [curve, curve2]
                n = 1

                base.CrossSectionsNew(False, a, b, c, curves, n)


    """


def CrossSectionsAdd(cross: object, entities: object) -> int:
    """

    Adds entities to a Cross Section.

    Parameters
    ----------
    cross : object
            The cross section entity.

    entities : object
            A list of entities.

    Returns
    -------
    int
            Returns the number of entities that were added to the cross section.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                curve = base.GetEntity(ansa.constants.LSDYNA, "CURVE", 86)
                cross = base.GetEntity(ansa.constants.LSDYNA, "CROSS_SECTION", 8)
                curves = [curve]

                a = base.CrossSectionsAdd(cross, curves)
                print(a)


    """


def CrossSectionsCut(
    definition: bool,
    point1: object,
    point2: object,
    point3: object,
    elements: object,
    part: object,
    section_type: int,
    finite: bool,
    circular: bool,
    r: float,
    l: float,
    m: float,
    rec_orientation: object,
    ret_ents: bool,
    corner_angle: float,
    cross_solver: str,
) -> object:
    """

    Creates a new cross section for curves.

    Parameters
    ----------
    definition : bool
            The type of definition of the plane.
            True: Normal definition (2 points).
            False: 3 points definition.
            (Default: False)

    point1 : object
            A list with three doubles. The coordinates of the first given point.

    point2 : object
            A list with three doubles. The coordinates of the second given point.
            In normal definition it is the point defining the vertical vector on the plane.

    point3 : object
            A list with three doubles. The coordinates of the third given point.
            (Not used in normal definition)

    elements : object
            A list of shell entities.

    part : object
            The part in which the cross section will be included.
            By default (if invalid part is given), the current part will be used.

    section_type : int
            Defines the section type of the cross section.
            0: None, 1: General, 2: Equivalent Box, 3: PBMSECT or Arbitrary.
            (Default: 0)

    finite : bool, optional
            Defines weather cross section is infinite or finite.
            True: Cross section is finite.
            False: Cross Section is infinite.
            (Default: False)

    circular : bool, optional
            Defines weather the defined finite cross section is circular (True) or
            rectangular (False).
            (Default: False)

    r : float, optional
            The radius of the defined circular cross section.
            Used only when circular = True.
            (Default: 1.0)

    l : float, optional
            The length of the L side of the rectangular cross section.
            Used only when circular = False.
            (Default: 1.0)

    m : float, optional
            The length of the M side of the rectangular cross section.
            Used only when circular = False.
            (Default: 1.0)

    rec_orientation : object, optional
            A vector defining the direction of the  rectangular cross section.
            It cannot be in the direction of the normal vector of the plane.
            Used only when circular = False.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    corner_angle : float, optional
            Defines the maximum angle (in degrees) between two consecutively
            section segments, in order for both segments to be represented in the
            same Cross Section curve. If the angle of segments exceeds the defined
            value, Cross Section curve will be broken at their matching point.
            Accepted values: 0 ~ 45.
            (Default: 30)
            (Note: This option is applied only when cross_solver = "BETA")

    cross_solver : str, optional
            Determines the solver that will be used to calculate the cross section
            properties.
            Accepted values: "BETA", "FE", "FE 2D".
            (Default: "BETA")

    Returns
    -------
    object
            Returns 1 if created succesfully and 0 if cross section was not created.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                a = [-1.0, 0.0, 0.0]
                b = [0.0, 500.0, 0.0]
                c = [0.0, -500.0, 0.0]
                ents = base.CollectEntities(constants.LSDYNA, None, "__ELEMENTS__", recursive=True)
                rec = [-20.0, -20.0, 0.0]
                base.CrossSectionsCut(
                    False,
                    a,
                    b,
                    c,
                    ents,
                    None,
                    0,
                    finite=True,
                    circular=False,
                    l=130,
                    m=150,
                    rec_orientation=rec,
                )


    """


def DeckMassInfo(apply_on: str, custom_entities: object) -> object:
    """

    Calculates the mass of a given model. Calculated values are returned in a python object.

    Parameters
    ----------
    apply_on : str
            Specifies the target elements for which the
            calculation will be held.
            Accepted values:
            -"whole_db" -> whole database.
            -"visible" -> only visible entities.
            -"custom" -> custom mode. The user must supply
             the entities (via custom_entities argument)
             for which the calculation will be held.

    custom_entities : object, optional
            If the apply_on argument equals to "custom", the user can
            provide the entities for which the calculation will be held.
            The object can be a python list or an ANSA entity
            (including SETs, PROPERTIEs, PARTs, INCLUDEs).

    Returns
    -------
    object
            Returns a python object on success, None otherwise.

            The returned object contains the following members:
            total_mass: (double) The total mass of the given model.
            cog: (double)The center of gravity: Tuple, (Cx, Cy, Cz) ->  Cx, Cy, Cz.
            inertia: (double) The inertia tensors: Tuple of 3 tuples, ((Ixx, Ixy, Ixz), (Iyx, Iyy, Iyz), (Izx, Izy, Izz)) -> Ixx,...,Izz.
            total_nsm: (double) The total NSM mass.
            added_mass: (double) The total added mass.
            net_mass: (double) The total net mass.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # The following example demonstrates the use of DeckMassInfo() in the most common cases.
            def main():
                m = []
                for i in range(1, 10):
                    m.append(base.GetEntity(constants.NASTRAN, "SHELL", i))
                mass_info = base.DeckMassInfo(apply_on="custom", custom_entities=m)
                print(mass_info.total_mass)
                print(mass_info.cog)
                print(mass_info.inertia)
                print(mass_info.total_nsm)
                print(mass_info.added_mass)
                print(mass_info.net_mass)

                p_prop = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                if p_prop:
                    mass_info = base.DeckMassInfo(apply_on="custom", custom_entities=p_prop)
                    print(mass_info.total_mass)
                mass_info = base.DeckMassInfo(apply_on="whole_db")
                print(mass_info.total_mass)

                mass_info = base.DeckMassInfo(apply_on="visible")
                print(mass_info.cog)


    """


def CrossSectionsMulticut(
    elements: object,
    curves: object,
    part: object,
    section_type: str,
    finite: bool,
    beams_per_section: str,
    connect: bool,
    common_point: str,
    delete_replaced: bool,
    morphing_boxes: bool,
    design_variables: bool,
    a_parameters: bool,
    number_of_elements: int,
    length_of_elements: float,
    circular: bool,
    radius: float,
    length: float,
    ret_ents: bool,
    beams_amount_mode: str,
    distortion_angle: float,
    max_element_length: float,
    align_neighbor_elements: bool,
    corner_angle: float,
    connect_with: str,
    path_shrinkage_factor: float,
    apply_to: str,
    connect_nodes: str,
    warping_dof_torsional: bool,
    cross_solver: str,
) -> object:
    """

    Creates equivalent beam elements of a structure by cutting it along a defined path.

    Parameters
    ----------
    elements : object
            A list of entities that the function will apply to.
            As element even a Morph Box is acceptable. In this case, the loaded
            elements of all the Morph Box entities of the list are gathered and one
            multi-cut is performed.

    curves : object
            A list of curve entities, in order to form a chain path along which
            multi-cut will take place.
            Note that as curve even a Morph Box is acceptable. In this case,
            curves from all the Morph Box entities of the list are extracted and
            combined, in the background, in order to form the path of the
            multi-cut to be performed.

    part : object, optional
            The part in which the cross section will be included.
            By default (if invalid part is given), the current part will be used.

    section_type : str, optional
            Defines the section type of the created beam properties.
            Accepted values: "General", "Equivalent Box", "PBMSECT" or "Arbitrary".
            (Default: "General")

    finite : bool, optional
            Defines whether the  cutting plane is infinite or finite.
            True: Cutting plane is finite.
            False: Cutting plane is infinite.
            (Default: False)

    beams_per_section : str, optional
            Defines whether in case of a section with separated areas
            will create a single or multiple beams.
            Accepted values: "single" or "multiple".
            (Default: "single")

    connect : bool, optional
            Defines if the beam chain will be connected with residual structure
            with Nastran RBE2 elements.
            True: Connect.
            False: Do not connect.
            (Note: This argument is ignored if is used simultaneously
            with the argument "connect_with")

    common_point : str, optional
            Defines the location of grids of created beam elements.
            values: "shear_center", "mass_center", "path_origin".
            default: "shear_center"
            (Tip: If current deck is Abaqus for models with variable sections,
            use value "path_origin". Otherwise, created beams may not fit
            the initial structure, since beam node offsets are not available.)

    delete_replaced : bool, optional
            Defines if the replaced elements will be deleted or not.
            True: Delete.
            False: Do not delete.
            (Default: False)

    morphing_boxes : bool, optional
            Defines if morphing boxes and morphing parameters will be created or not.
            True: Create.
            False: Do not create.
            (Default: False)

    design_variables : bool, optional
            Defines if Design Variables will be created or not.
            True: Create.
            False: Do not create.
            (Default: False)

    a_parameters : bool, optional
            Defines if ANSA parameters will be created or not.
            True: Create.
            False: Do not create.
            (Default: False)

    number_of_elements : int, optional
            The number of the created beams. This argument has effect
            if beams_amount_mode = "number".
            (Default: 1)

    length_of_elements : float, optional
            The target element length of the created beams. This argument
            has effect if beams_amount_mode = "length".
            (Default: 0)

    circular : bool, optional
            Defines whether the cutting plane is circular or rectangular.
            Used only when finite = True.
            True: Circular.
            False: Rectangular.
            (Default: False)

    radius : float, optional
            The radius of the circular cutting plane. Used only when
            finite = True and circular = True.
            (Default: 1)

    length : float, optional
            The diagonal of the rectangular cutting plane.
            Used only when finite = True and circular = False.
            (Default: 1)

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    beams_amount_mode : str, optional
            Defines the mode that controls the amount of created beams.
            Accepted values: "number", "length" or "auto".
            (Default: "number")

    distortion_angle : float, optional
            Defines the maximum acceptable angle (in degrees) between two
            consecutively created beam elements. This argument has effect
            only if has a positive value and beams_amount_mode = "auto".
            (Default: 0)

    max_element_length : float, optional
            Defines the maximum acceptable element length of the created
            beams. This argument has effect only if it has a positive value
            and beams_amount_mode = "auto".
            (Default: 0)

    align_neighbor_elements : bool, optional
            Defines if nodes of elements of residual structure that are close
            to start and end planes, will be aligned on these planes.
            True: Align elements
            False: Do not align elements
            (Default: True)
            (Note: This option is applied only when connect_with="RBE2" or "RBE3")

    corner_angle : float, optional
            Defines the maximum angle (in degrees) between two consecutively
            section segments, in order both segments to be represented in the
            same Cross Section curve. If the angle of segments exceeds the
            defined value, Cross Section curve will be broken at their matching
            point.
            Accepted values: 0 ~ 45
            (Default:30)
            (Note: This option is applied only when cross_solver = "BETA")

    connect_with : str, optional
            Defines the type of elements with which the beam chain will be
            connected with residual structure.
            Accepted values: " ", "RBE2" or "RBE3" or "RSECTBT".
            (Default: " " (No connection))
            (Note: This argument overwrites argument "connect" if it is defined
            simultaneously.)

    path_shrinkage_factor : float, optional
            Used to shrink the path of multi-cut. The total shrinkage length equals
            to this factor times the average length of the loaded elements.
            (Default: 0.)
            (Note: This factor is implemented only when multi-cut is applied to
            Morph box entities.)

    apply_to : str, optional
            Defines whether multi-cut will be applied to elements or a Morph Box
            entity.
            Accepted values: "Elements", "Morph box".
            (Default: "Elements")

    connect_nodes : str, optional
            Defines whether the nodes of the residual structure should be used
            by the R-type element, or not. If not, new nodes will be created
            on the cutting plane, which will use MPC elements to connect with
            the residual structure.
            Accepted values:
            "Use existing mesh nodes" or "Create new on cutting plane"
            (Default: "Use existing mesh nodes")
            (Note: This option is applied only when connect_with="RBE2" or
            "RBE3" and align_neighbor_elements=False)

    warping_dof_torsional : bool, optional
            Determines whether the warping degree of freedom will be included
            in the RSECTBT element or not.
            True: Include the warping degree of freedom
            False: Do not include the warping degree of freedom
            (Default: False)
            (Note: This option is applied only when connect_with="RSECTBT")

    cross_solver : str, optional
            Determines the solver that will be used to calculate the cross section
            properties.
            Accepted values: "BETA", "FE", "FE 2D".
            (Default: "BETA")

    Returns
    -------
    object
            Returns 1 if created succesfully and 0 if cross section was not created.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    See Also
    --------
    CrossSectionsCut

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = base.CollectEntities(constants.LSDYNA, None, "__ELEMENTS__", recursive=True)
                curve0 = base.GetEntity(constants.LSDYNA, "CURVE", 98)
                curve1 = base.GetEntity(constants.LSDYNA, "CURVE", 99)
                curves = [curve0, curve1]

                base.CrossSectionsMulticut(
                    ents,
                    curves,
                    part=None,
                    connect=True,
                    common_point="shear_center",
                    delete_replaced=True,
                    beams_amount_mode="number",
                    number_of_elements=5,
                    circular=True,
                    radius=20.0,
                )


    """


def InputMIFForm(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function inputs a MIF format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputMIFForm(filename="C:/temp/users/folder/data.mif", nodes_id="nooffset")


    """


def OutputMIFForm(filename: str, mode: str) -> int:
    """

    This function outputs a model in MIF Format.

    Parameters
    ----------
    filename : str
            The file system path.

    mode : str, optional
            "all", "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputMIFForm(filename="C:/temp/users/folder/data.mif", mode="ALL")


    """


def AddConstrainedAdaptivity(container: object, part: object, ret_ents: bool) -> object:
    """

    The AddConstrainedAdaptivity uses the boundary nodes of the shells in container
    to identify hanging nodes in mesh and creates a *CONSTRAINED ADAPTIVITY element,
    using the hanging node as slave and the other 2 nodes of the edge as masters.

    Parameters
    ----------
    container : object
            Can contain parts, properties, macros or shells.

    part : object, optional
            Defines the part to be used to assign the newly created
            elements. By default, Current Part is used.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            It returns 0.
            If ret_ents=True it will return a list with the created entities,
            or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pshell = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                all_shells = base.CollectEntities(constants.NASTRAN, pshell, "SHELL")

                part = base.GetPartFromModuleId("1")

                base.AddConstrainedAdaptivity(all_shells, part)


    """


def CreateResult(gw_filename: str) -> object:
    """

    Function for creating an OpenFoam result based on a Gw file.

    Parameters
    ----------
    gw_filename : str
            The path to the Gw file.

    Returns
    -------
    object
            Returns a reference to the newly created OpenFoam result object on success, or None on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import morph
            from ansa import constants


            def main():
                params = []
                base.Open("../sensitivities.ansa")
                p_sens = base.CreateResult("../sensitivities/Gw")
                base.SmoothResult(p_sens)
                params.append(p_sens)
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL", filter_visible=True)

                morph.MorphMappingDeformations(params, shells, 1000000, True)


    """


def SmoothResult(
    result: object,
    flatten_top: float,
    flatten_bottom: float,
    zero_abs_range: float,
    smooth_zones: int,
    iterations: int,
) -> int:
    """

    Function for applying smoothing based on neighbours on a created result.

    Parameters
    ----------
    result : object
            An OpenFoam result object.

    flatten_top : float, optional
            Values greater than the one defined will be flattened.

    flatten_bottom : float, optional
            Values smaller than the one defined will be flattened.

    zero_abs_range : float, optional
            Set to 0 to absolute values smaller than the one defined.

    smooth_zones : int, optional
            The number of neighbours to apply smoothing to.

    iterations : int, optional
            The number of iterations.

    Returns
    -------
    int
            Returns 0 on success and 1 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import morph
            from ansa import constants


            def main():
                params = []

                base.Open("../sensitivities.ansa")
                p_sens = base.CreateResult("../sensitivities/Gw")
                base.SmoothResult(p_sens)
                # base.SmoothResult(p_sens, flatten_top=5., flatten_bottom=-1., zero_abs_range = 0.2, smooth_zones=10, iterations=3)
                params.append(p_sens)
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL", filter_visible=True)

                morph.MorphMappingDeformations(params, shells, 1000000, True)


    """


def BuildComponent(
    ents: object,
    property_conflicts: str,
    material_conflicts: str,
    set_conflicts: str,
    reject_non_empty_parts: bool,
    coord_conflicts: str,
    node_conflicts: str,
) -> object:
    """

    Changes the representation of all parts according to the field "Representation".
    If this representation is not already saved in DM, a respective batch meshing scenario
    will be created with the part loaded. A DM Root directory must be already specified.

    Parameters
    ----------
    ents : object
            A list that contains parts or groups.

    property_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    material_conflicts : str, optional
            "Offset" creates a new entity.
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value. (Default)

    set_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    reject_non_empty_parts : bool, optional
            True: Process only the empty parts. (Default)
            False: Work for all parts.

    coord_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    node_conflicts : str, optional
            "Offset" creates a new entity. (Default)
            "KeepOld" keeps the old value.
            "KeepNew" keeps the new value.

    Returns
    -------
    object
            The return is a list of same size as the ents list (input argument) disregarding
            any empty or multi-instanciated parts.
            Each entry of the returned list contains a list for each processed part.
            This is of length 4 and its entries are:
            info_list[0] = Module Id of the processed part.
            info_list[1] = Name of the representation in case it exists in DM, else empty string.
            info_list[2] = Informative message.
            info_list[3] = Reference to the batch messing scenario in case the representation does not exist in DM.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            NASTRAN = constants.NASTRAN


            # Ex 1: Giving to the function the top level group of the model
            def main():
                groups_of_model = base.CollectEntities(NASTRAN, None, "ANSAGROUP")
                for group_ent in groups_of_model:
                    ret_vals = base.GetEntityCardValues(NASTRAN, group_ent, ("Hierarchy",))
                    if ret_vals["Hierarchy"] == "":
                        top_level_group = group_ent
                    if "top_level_group" in locals():
                        results_list = base.BuildComponent(
                            [top_level_group], reject_non_empty_parts=False
                        )
                        component_list = results_list[0]
                        for info_list in component_list:
                            print("Module Id = ", info_list[0])
                            if info_list[1] != "":
                                print(info_list[2], ": ", info_list[1])
                            else:
                                print(info_list[2], ": ", info_list[3]._name)


            # Ex 2: Giving to the function all the parts of the model
            def main():
                parts = base.CollectEntities(NASTRAN, None, "ANSAPART")
                results_list = base.BuildComponent(parts, reject_non_empty_parts=False)
                for part_list in results_list:
                    info_list = part_list[0]
                    print("Module Id = ", info_list[0])
                    if info_list[1] != "":
                        print(info_list[2], ": ", info_list[1])
                    else:
                        print(info_list[2], ": ", info_list[3]._name)


    """


def SaveComponent(
    ents: object,
    conflicts_option: str,
    spin_up_attribute: str,
    save_repr_file: str,
    export_png: str,
    export_jt: str,
    lbr_assign_values: object,
) -> object:
    """

    Saves a given list of groups or includes in the DM, as components.
    A DM Root directory must be already specified.

    Parameters
    ----------
    ents : object
            A list that contains groups or includes.

    conflicts_option : str, optional
            'Overwrite'
            'Skip'
            'Spin_up' (default)

    spin_up_attribute : str, optional
            'Study Version' (default)

    save_repr_file : str, optional
            'YES' (save along with the component, a respective ansa database)
            'NO' (default)

    export_png : str, optional
            'YES' (save along with the component, an image in ".png" format)
            'NO' (default)

    export_jt : str, optional
            'YES' (save along with the component, a respective jt file)
            'NO' (default)

    lbr_assign_values : object, optional
            This argument is a Python dictionary, which accepts key-value of properties or attributes that we wish to edit right before saving the Simulation Model in DM, like {'DM/Status':'Frozen'}. It is most commonly used in the cases of DM with Lifecycle Business Rules where there is a rule that defines that certain properties/attributes are only allowed to change when a representation file is also uploaded. For these cases we use this argument and edit them simultaneously with their file upload.

    Returns
    -------
    object
            Return a list with the same size as the ents list (input argument).
            Each entry of the returned list is a string with a special id of the saved component.
            In case the component failed to be saved a string with zero value is returned '0'.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            NASTRAN = constants.NASTRAN


            def main():
                groups_of_model = base.CollectEntities(NASTRAN, None, "ANSAGROUP")
                ret = base.SaveComponent(
                    ents=groups_of_model,
                    conflicts_option="Spin_up",
                    spin_up_attribute="Study Version",
                    save_repr_file="YES",
                    export_png="YES",
                    export_jt="ES",
                )
                for item in ret:
                    if item == "0":
                        print("Failed to save component!")
                    else:
                        print("Saved! Id = ", item)


    """


def SaveComponentGui(ents: object) -> int:
    """

    Given a list of components for saving, the function launches the
    'Save Component in DM' graphical user interface.
    A DM Root directory must have been already specified.

    Parameters
    ----------
    ents : object
            A list that contains groups or includes

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            NASTRAN = constants.NASTRAN


            def main():
                groups_of_model = base.CollectEntities(NASTRAN, None, "ANSAGROUP")
                base.SaveComponentGui(groups_of_model)


    """


def SaveCompareReport(filepath: str) -> int:
    """

    While being inside the 'Compare' process the user can save the current visible state of the compare report list along
    with the physical models involved in the comparison in a file of type "*.ansa_compare".

    Parameters
    ----------
    filepath : str
            The path to the "*.ansa_compare" file.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            NASTRAN = constants.NASTRAN


            def main():
                parts = base.CollectEntities(NASTRAN, None, "ANSAPART")
                base.CompareFromFile(
                    "/path/to/file/to_compare_with/new_parts.ansa",
                    parts,
                    compare_action="SHOW_CARD",
                )
                base.SaveCompareReport("/path/to/exported_file/comparison.ansa_compare")


    """


def PedestrianCreateWADLine(length: float, name: str) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:class:`PedSafety` instead.


    This function creates a user define WAD line according to the values set by the PedestrianMarkingParameters.

    Parameters
    ----------
    length : float
            The length of the flexible tape that will be used (Wrap Around Distance).

    name : str
            The name of the curve that will be created.

    Returns
    -------
    int
            Returns 0  on success, non-zero on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.PedestrianMarkingParameters(
                    external_parts=1, apply="EURONCAP_GRID", test_type="HEADFORM", windscreen=2
                )
                base.PedestrianCreateWADLine(length=800, name="custom_line")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:class: PedSafety instead.",
        DeprecationWarning,
    )


def ReadCompareReportState(filepath: str) -> int:
    """

    Opens a file of type "*.ansa_compare" that has been saved from within Compare functionality
    either inside the Compare Report window via File>Save As, or by the function SaveCompareReport.

    Parameters
    ----------
    filepath : str
            The path to the "*.ansa_compare" file.

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ReadCompareReportState("/path/to/exported/file/comparison.ansa_compare")


    """


def LaminateElementPolarValues(
    deck: int, element: object, start: int, end: int
) -> object:
    """

    Calculates the E1, E2, v12 and G12 polar values for an element which has a Laminate Property.
    By default the values from 0 degrees to 359 degrees are calulated.

    Parameters
    ----------
    deck : int
            The deck constant.

    element : object
            A reference to an element with laminate Property.

    start : int, optional
            The starting angle in degrees. (Default: 0)

    end : int, optional
            The ending angle in degrees. (Default: 359)

    Returns
    -------
    object
            Returns a dictionary which has 4 lists with the following keys: "E1", "E2", "v12", "G12".
            Each list contains the polar values for its key.

            In case of failure it returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                element = base.GetEntity(constants.ABAQUS, "SHELL", 5225)
                ret = base.LaminateElementPolarValues(constants.ABAQUS, element, 0, 4)
                if ret:
                    for values in sorted(ret.keys()):
                        print(ret[values])


    """


def ApplyThicknessToLaminateElements(deck: int, property: object) -> int:
    """

    This function changes the elements so that their actual thickness is equal to the layers total thickness,
    with a reference plane defined in the property card.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, PAMCRASH, ABAQUS, RADIOSS, ANSYS or PERMAS.

    property : object
            A property or a list of properties of type TSHELL_LAMINATE or SOLID_LAMINATE.

    Returns
    -------
    int
            Returns 0 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                ent = base.GetFirstEntity(deck, "SOLID_LAMINATE")
                base.ApplyThicknessToLaminateElements(deck, ent)


    """


def SetDifferencesIndexSettingsValues(key: str, fields: object) -> int:
    """

    Sets or changes values of parameters concerning the 'Differences index' window in Compare process.

    You can also use this function to set up quick color filters (activate/deactivate orange, red, blue, green, yellow filters)
    through script according to the filter name.
    The function can be used with the appropriate key: <advanced filter name>:::Quick Filter Button::<color of the filter button>, and the keyword "Visible".
    "Quick Filter Button" names can be (as shown in interface):

    - Green // Matched (No diffs)
    - Orange // Matched (Diffs)
    - Red // Unmatched (Model 1)
    - Blue // Unmatched (Model 2)
    - Yellow // New

    Parameters
    ----------
    key : str
            A string describing the parameter's full name in tree view,
            e.g., "GEOMETRY (PARTS)::ANSAPART::Geometry::Differences".
            In case the setting demands a value, you can set it as: ">", "10.0" after settings_full_name.
            A percentage value is used to set geometry similarities or differences and an absolute
            one in any other case.

    fields : object, optional
            A list or a dictionary that holds pairs of 'field - value'.
            You can set "Is Difference?" and "Visible" to "ON"/"OFF", "TRUE"/"FALSE"or "YES"/"NO".
            You can ommit setting any of them.

    Returns
    -------
    int
            Returns 0 on success, non-zero on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetDifferencesIndexSettingsValues(
                    "GEOMETRY (PARTS)::ANSAPART::Attributes::Comment",
                    ["Is Difference?", "ON", "Visible", "OFF"],
                )


            # ... or ...


            def main():
                base.SetDifferencesIndexSettingsValues(
                    "GEOMETRY (PARTS)::ANSAPART::Geometry::Similarities",
                    ["<", "90.0", "Is Difference?", "ON", "Visible", "OFF"],
                )
                # for geometry similarities <90%


            # quick filters example
            def main():
                base.SetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Red:",
                    ["Is Difference?", "off", "Visible", "on"],
                )
                base.SetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Blue:",
                    ["Is Difference?", "off", "Visible", "on"],
                )
                base.SetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Green:",
                    ["Is Difference?", "off", "Visible", "off"],
                )
                base.SetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Yellow:",
                    ["Is Difference?", "off", "Visible", "off"],
                )
                base.SetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Orange:",
                    ["Is Difference?", "off", "Visible", "on"],
                )


    """


def GetDifferencesIndexSettingsValues(key: str, fields: object) -> object:
    """

    Gets the values of parameters concerning the 'Differences index' window in Compare process.

    In case the setting has a value you can get it as: "EXPR" or "EXPRESSION", e.g., "EXPR" could return "<10.000".
    For "Is Difference?" and "Visible" parameters, this function returns their current values ("ON" or "OFF").

    You can also get quick filters status according filter name and color of the button.

    Parameters
    ----------
    key : str
            A string describing the parameter's full name in a tree view.
            e.g., "GEOMETRY (PARTS)::ANSAPART::Geometry::Differences".

    fields : object, optional
            A list that containes the names of the desired parameters.

    Returns
    -------
    object
            Returns a dictionary that has as keys the names of the requested parameters and as data their values.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetDifferencesIndexSettingsValues(
                    "GEOMETRY (PARTS)::ANSAPART::Geometry::FE",
                    ["Is Difference?", "OFF", "Visible", "OFF"],
                )

                res_dict = base.GetDifferencesIndexSettingsValues(
                    "GEOMETRY (PARTS)::ANSAPART::Geometry::FE", ["Is Difference?", "Visible"]
                )
                print("-----------------")
                print("Is Difference? = ", res_dict["Is Difference?"])
                print("Visible = ", res_dict["Visible"])


            def main():
                base.SetDifferencesIndexSettingsValues(
                    "GEOMETRY (PARTS)::ANSAPART::Attributes::COG differences found",
                    [">", "1.0", "Is Difference?", "ON", "Visible", "OFF"],
                )

                res_dict = base.GetDifferencesIndexSettingsValues(
                    "GEOMETRY (PARTS)::ANSAPART::Attributes::COG differences found",
                    ["EXPR", "Is Difference?", "Visible"],
                )
                print("-----------------")
                print("Expression = ", res_dict["EXPR"])  # prints Expression = >1
                print("Is Difference? = ", res_dict["Is Difference?"])  # prints Is Difference? = ON
                print("Visible = ", res_dict["Visible"])  # prints Visible = OFF


            # get quick filters status
            def main():
                res = base.GetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Orange", ["EXPR", "Is Difference?", "Visible"]
                )
                print("-----------------")
                print("Orange Visible = ", res["Visible"])

                res = base.GetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Blue", ["EXPR", "Is Difference?", "Visible"]
                )
                print("-----------------")
                print("Blue Visible = ", res["Visible"])

                res = base.GetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Red", ["EXPR", "Is Difference?", "Visible"]
                )
                print("-----------------")
                print("Red Visible = ", res["Visible"])

                res = base.GetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Green", ["EXPR", "Is Difference?", "Visible"]
                )
                print("-----------------")
                print("Green Visible = ", res["Visible"])

                res = base.GetDifferencesIndexSettingsValues(
                    "Default:::Quick Filter Button::Yellow", ["EXPR", "Is Difference?", "Visible"]
                )
                print("-----------------")
                print("Yellow Visible = ", res["Visible"])


    """


def EditPartPosition(
    part: object,
    x0: float,
    y0: float,
    z0: float,
    dx1: float,
    dy1: float,
    dz1: float,
    dx2: float,
    dy2: float,
    dz2: float,
    dx3: float,
    dy3: float,
    dz3: float,
    apply_transformation: bool,
) -> int:
    """

    Assigns a new transformation matrix to a part or group, optionally moving it accordingly.

    Parameters
    ----------
    part : object
            A reference to the ANSAPART or ANSAGROUP.

    x0 : float
            The x0 member of the transformation matrix to assign.

    y0 : float
            The y0 member of the transformation matrix to assign.

    z0 : float
            The z0 member of the transformation matrix to assign.

    dx1 : float
            The dx1 member of the transformation matrix to assign.

    dy1 : float
            The dy1 member of the transformation matrix to assign.

    dz1 : float
            The dz1 member of the transformation matrix to assign.

    dx2 : float
            The dx2 member of the transformation matrix to assign.

    dy2 : float
            The dy2 member of the transformation matrix to assign.

    dz2 : float
            The dz2 member of the transformation matrix to assign.

    dx3 : float
            The dx3 member of the transformation matrix to assign.

    dy3 : float
            The dy3 member of the transformation matrix to assign.

    dz3 : float
            The dz3 member of the transformation matrix to assign.

    apply_transformation : bool
            If True, apart from acquiring the new transformation matrix,
            the part will also be moved accordingly.

    Returns
    -------
    int
            Returns 0 on success and 1 if an error occurs.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromModuleId("1019")
                base.EditPartPosition(part, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, True)


    """


def IsEntityActive(entity: object) -> bool:
    """

    Examines whether an entity is active or not.
    Works for all entity types, but is intended to be used for entities like connections
    and GEBs that can become inactive in the database when the parts that use them are
    turned to a "Don't Use" representation.

    Parameters
    ----------
    entity : object
            A reference to an entity object.

    Returns
    -------
    bool
            Returns True if the entity is visible, False otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_ent = base.GetEntity(constants.NASTRAN, "SpotweldPoint_Type", 100001)
                ret = base.IsEntityActive(p_ent)
                print(ret)


    """


def GetAllItemsInDM(type: str) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`QueryForAllResults` instead.


    Gets a list with all items in DM for a specific type.

    Parameters
    ----------
    type : str
            Accepted values: 'parts', includes', 'components', 'configurations'.

    Returns
    -------
    object
            Returns a list with dictionaries for each DM entry. The dictionary contains all the attributes
            of the DM entry, including its Module Id, Version, Study Version, Representation etc.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                all_dm = base.GetAllItemsInDM("parts")
                if all_dm:
                    for item in all_dm:
                        for key in item:
                            print("attribute::", key, "value::", item[key])


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: QueryForAllResults instead.",
        DeprecationWarning,
    )


def SaveUpdatesToDM(dm_items: object, dm_root: str) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`SaveUpdates` instead.


    This function may only be used along with CheckDMUpdates function.
    It accepts the CheckDMUpdates's function output.

    Parameters
    ----------
    dm_items : object
            A list that contains DM Items which were output from the CheckDMUpdates()
            function, in the same way they were given in the output array.
            Otherwise, a single result may be given.

    dm_root : str, optional
            The target DM Root, where the update will be copied.
            When unspecified, the current DM is used.

    Returns
    -------
    int
            Returns the total number of DM items that were successfully uploaded to the target DM.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dm_filters = [["Module Id", "equals", "RAIL_ROOF_SD_INR"]]
                output_array = base.CheckDMUpdates(None, dm_filters)
                print(output_array)
                if output_array["output"]:
                    # base.SaveUpdatesToDM(dm_items=output_array['output'], dm_root=str('//mnt/raid_disk/titanas/DM1'))
                    base.SaveUpdatesToDM(dm_items=output_array["output"])


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: SaveUpdates instead.",
        DeprecationWarning,
    )


def OutputResult(
    result: object, filename: str, append_or_overwrite: int, format: int
) -> int:
    """

    Function for the output of a Result to a file.

    Parameters
    ----------
    result : object
            A result object.

    filename : str
            The filename to output.

    append_or_overwrite : int
            Set to 0 to overwrite, 1 to append to the file.

    format : int, optional
            Output format
            0: For OpenFoam format.
            1: CSV with x, y, z, value.
            2: CSV with x, y, x, dx, dy, dz.

    Returns
    -------
    int
            Returns 0 on success, 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def outputSens():
                sens = base.GetEntity(0, "RESULT", 1)
                base.OutputResult(sens, "filename.txt", 1, 0)


    """


def FilletFaces(cons: object, radius: float, fillet_type: int) -> object:
    """

    This function creates continuous fillets from multiple faces, by entering a specified radius value of the fillet surface.
    In case that fillet_type equals to 1, planar faces are being generated.

    Parameters
    ----------
    cons : object
            A list of references or a single reference of the cons that will be used.

    radius : float
            The radius value of the fillet surface.

    fillet_type : int, optional
            Specifies the shape of the fillet:
            0: Round, 1: Planar.

    Returns
    -------
    object
            Returns a list with the created faces on success, or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cons = base.GetEntity(constants.NASTRAN, "CONS", 17)
                fillet_face = base.FilletFaces(cons, 20, 0)
                print(fillet_face)


    """


def SizeBoxSweepGlide(
    max_surf_elem_len: float,
    max_vol_elem_len: float,
    extrusion_type: str,
    guideline_ents: object,
    box_face: object,
    curves: object,
    points: object,
    section_type: str,
    radius: float,
    width: float,
    dx: float,
    dy: float,
    dz: float,
    height: float,
    lower_base: float,
    upper_base: float,
) -> object:
    """

    Function for creating a Size Box through extrusion. Both 'sweep' and 'glide' extrusion types are supported.

    The direction of the extrusion is defined through curves, or points, or a combination of them.
    Curves may form a connected or disconnected path (a path will be automatically created).
    Note that single points are ignored (i.e. if any points are to be used, they should be at least two).

    The user has four options in defining the cross section, one with a box face, one with curves,
    one with curves and points and, finally, one with a predefined shape.
    The box_face option expects a single box face entity (which will be pasted to the new one after creation of the box)
    The curves option expects one or more curves (unconnected ones will be automatically connected to form a closed cross
    section shape).
    The selected curves should contain at least 4 points, so that they can be adopted for the definition of the four box
    edges. The points option should only follow a previous curves-curve_entities pair, and explicitly defines the points
    to be used for the four box edges definition. These points should be part of the curve_entities provided.
    The predefined cross section includes a circular with the required radius, a square with its side length, a rectangular
    with its width and height, and a trapezoidal with its two bases' lenths and height. Except for the circular, these cross
    sections also require a vector defining the 'height' direction of the cross section.
    Note that several kind of edges may be used as a curve, including element edges (provided as edge sets), CONS, 3D curves
    and box edges. Similarly, grids, hot points and box edge corner points may be employed for any point entities.

    Parameters
    ----------
    max_surf_elem_len : float
            The maximum allowed surface element length.

    max_vol_elem_len : float
            The maximum allowed volume element length.

    extrusion_type : str
            A keyword "sweep" or "glide", denoting the type of extrusion.

    guideline_ents : object
            The entities defining the direction of extrusion.
            (Collection of curves and/or points)

    box_face : object, optional
            A box face entity to be used as a cross section.
            (Note that new face will be pasted to old)

    curves : object, optional
            The curve entities defining the cross section.
            (They do not have to form a closed perimeter)

    points : object, optional
            The point entities defining the position of the box edges (used only
            in conjunction with 'curves').
            Note that points should be among the points of the curve_entities provided above.

    section_type : str, optional
            A string specifying predefined section type ("circular", "square",
            "rectangular", trapezoidal").
            Additional data needed per case:
            -"circular" requires "radius".
            -"square" requires "width" and  height direction "dx","dy","dz".
            -"rectangular" requires "width", "height", and height direction "dx","dy","dz".
            -"trapezoidal" requires "lower_base", "upper_base", "height", and height
              direction "dx","dy","dz".

    radius : float, optional
            In case of "circular" section_type, the radius of the cross section

    width : float, optional
            In case of "square" section_type, the width of the cross section

    dx : float, optional
            In case of "square", "rectangular" or "trapezoidal" section_type,
            the x-component of the vector defining the section's height direction
            (does not need to be normalized).

    dy : float, optional
            In case of "square", "rectangular" or "trapezoidal" section_type,
            the y-component of the vector defining the section's height direction
            (does not need to be normalized).

    dz : float, optional
            In case of "square", "rectangular" or "trapezoidal" section_type,
            the z-component of the vector defining the section's height direction
            (does not need to be normalized).

    height : float, optional
            In case of "rectangular" or "trapezoidal" section_type, the height
            of the cross section.

    lower_base : float, optional
            In case of "trapezoidal" section_type, the length of the sections' lower base.

    upper_base : float, optional
            In case of "trapezoidal" section_type, the length of the sections' upper base.

    Returns
    -------
    object
            Returns the created Size boxes.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # Example using a box face
            def main():
                guide = []
                guide.append(base.GetEntity(constants.NASTRAN, "CONS", 907))
                face = base.GetEntity(constants.NASTRAN, "SIZEBOXFACE", 12)
                Box = base.SizeBoxSweepGlide(
                    1.5, 2.1, extrusion_type="sweep", guideline_ents=guide, box_face=face
                )


            # Example using curves
            def main():
                guide = []
                guide.append(base.GetEntity(constants.NASTRAN, "CONS", 1069))
                curves = []
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 1327))
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 809))
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 564))
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 895))
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 1325))
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 931))
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 573))
                curves.append(base.GetEntity(constants.NASTRAN, "CONS", 837))
                Box = base.SizeBoxSweepGlide(
                    1.5, 2.1, extrusion_type="sweep", guideline_ents=guide, curves=curves
                )


            # Example using curves and points
            def main():
                guide = []
                guide.append(base.GetEntity(constants.NASTRAN, "CONS", 813))
                curves = []
                curves.append(base.GetEntity(constants.NASTRAN, "SIZEBOXEDGE", 5))
                curves.append(base.GetEntity(constants.NASTRAN, "SIZEBOXEDGE", 6))
                curves.append(base.GetEntity(constants.NASTRAN, "SIZEBOXEDGE", 7))
                curves.append(base.GetEntity(constants.NASTRAN, "SIZEBOXEDGE", 8))
                points = []
                points.append(base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 26))
                points.append(base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 35))
                points.append(base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 36))
                points.append(base.GetEntity(constants.NASTRAN, "SIZEBOXPOINT", 40))
                Box = base.SizeBoxSweepGlide(
                    1.5,
                    2.1,
                    extrusion_type="sweep",
                    guideline_ents=guide,
                    points=points,
                    curves=curves,
                )


    """


def CreateVolumeCylinder(
    point1: object,
    point2: object,
    length: float,
    radius: float,
    part: object,
    property: object,
    volumes: bool,
) -> object:
    """

    This function defines a closed cylinder by creating the appropriate faces, connected accordingly.
    Apart from the created faces, a Volume entity is also generated.

    Parameters
    ----------
    point1 : object
            A list of x,y,z coordinates defining the start of the axis of the Cylinder.

    point2 : object
            A list of x,y,z coordinates defining the end of the axis of the Cylinder.

    length : float
            The length of the cylinder.

    radius : float
            The radius of the cylinder.

    part : object, optional
            The part for the created face(s).
            If nothing is passed, the current part is taken into consideration.

    property : object, optional
            The property for the created faces(s).
            If nothing is passed, the default property is taken into consideration.

    volumes : bool, optional
            If set to True, apart from the created faces, a Volume entity is also created.
            (Default: True)

    Returns
    -------
    object
            Returns a list with the created faces, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def create_volume_cylinder():
                point1 = []
                point1.append(1500.0)
                point1.append(1000.0)
                point1.append(560.458000)

                point2 = []
                point2.append(3500.913800)
                point2.append(2030.481080)
                point2.append(4050.930000)

                face1 = base.GetEntity(constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face1)
                properties = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                created_cylinder = base.CreateVolumeCylinder(
                    point1, point2, 789, 20, part, properties, False
                )
                base.RedrawAll()

                print(len(created_cylinder))


    """


def CreateVolumeCone(
    point1: object,
    point2: object,
    length: float,
    radius1: float,
    radius2: float,
    part: object,
    property: object,
    volumes: bool,
) -> object:
    """

    This function defines a right cone frustum by creating the appropriate faces, connected accordingly.
    Apart from the macro-face, a Volume entity is also created.

    Parameters
    ----------
    point1 : object
            A list of x,y,z coordinates defining the start of the axis of the cone,
            passing through the center of the basis (radius 1).

    point2 : object
            A list of x,y,z coordinates defining the end of the axis of the cone,
            passing through the center of the second face (radius 2).

    length : float
            The length of the Cone.

    radius1 : float
            The radius of the basis of the cone.

    radius2 : float
            The radius of the second face of the cone.

    part : object, optional
            The part for the created face(s).
            If nothing is passed, the current part is taken into consideration.

    property : object, optional
            The property for the created faces(s).
            If nothing is passed, the default property is taken into consideration.

    volumes : bool, optional
            If set toTrue, apart from the macro-face, a Volume entity is also created.
            (Default: True)

    Returns
    -------
    object
            Returns a list with the created faces, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constans


            def create_volume_cone():
                point1 = []
                point1.append(1500.0)
                point1.append(1000.0)
                point1.append(560.458000)

                point2 = []
                point2.append(3500.913800)
                point2.append(2030.481080)
                point2.append(4050.930000)

                face1 = base.GetEntity(constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face1)
                properties = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                created_cone = base.CreateVolumeCone(
                    point1, point2, 789, 500, 50, part, properties, False
                )
                base.RedrawAll()

                print(len(created_cone))


    """


def CreateVolumeSphere(
    center_point: object, radius: float, part: object, property: object, volumes: bool
) -> object:
    """

    This function defines a sphere by creating the appropriate faces, connected accordingly.
    Apart from the macro-faces, a Volume entity is also created.

    Parameters
    ----------
    center_point : object
            A list of x,y,z coordinates defining the center of the Sphere.

    radius : float
            The radius of the Sphere.

    part : object, optional
            The part for the created face(s).
            If nothing is passed, the current part is taken into consideration.

    property : object, optional
            The property for the created faces(s).
            If nothing is passed, the default property is taken into consideration.

    volumes : bool, optional
            If set toTrue, apart from the macro-faces, a Volume entity is also created.
            (Default: True)

    Returns
    -------
    object
            Returns a list with the created faces, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def create_volume_sphere():
                center_point = []
                center_point.append(2431.940000)
                center_point.append(-493.396000)
                center_point.append(560.458000)

                face1 = base.GetEntity(constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face1)
                properties = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                created_sphere = base.CreateVolumeSphere(center_point, 50, part, properties, False)
                base.RedrawAll()

                print(len(created_sphere))


    """


def CreateVolumeTorus(
    point1: object,
    point2: object,
    point3: object,
    max_radius: float,
    min_radius: float,
    part: object,
    property: object,
    volumes: object,
) -> object:
    """

    This function defines a torus by creating the appropriate faces, connected accordingly.
    Apart from the macro-faces, a Volume entity is also created.

    Parameters
    ----------
    point1 : object
            A list of x,y,z coordinates defining the center of the Torus.

    point2 : object
            A list of x,y,z coordinates defining the X-axis of the created plane.

    point3 : object
            A list of x,y,z coordinates defining the Y-axis of the created plane.

    max_radius : float
            The major radius is the outer radius of the Torus.

    min_radius : float
            The minor radius is the thickness of the Torus.

    part : object, optional
            The part for the created face(s).
            If nothing is passed, the current part is taken into consideration.

    property : object, optional
            The property for the created faces(s).
            If nothing is passed, the default property is taken into consideration.

    volumes : object, optional
            If set to True, apart from the macro-face, a Volume entity is also created.
            (Default: True)

    Returns
    -------
    object
            Returns a list with the created faces, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def create_volume_torus():
                point1 = []
                point1.append(2431.940000)
                point1.append(-493.396000)
                point1.append(560.458000)

                point2 = []
                point2.append(2423.913800)
                point2.append(-490.481080)
                point2.append(416.930000)

                point3 = []
                point3.append(2345.0)
                point3.append(1234.0)
                point3.append(3560.458000)

                face1 = base.GetEntity(constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face)
                properties = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                created_torus = base.CreateVolumeTorus(
                    point1, point2, point3, 100, 50, part, properties, False
                )
                base.RedrawAll()

                print(len(created_torus))


    """


def SetShellResult(list_shells: object, list_values: object) -> int:
    """

    Function for changing the result for each shell.
    It takes as input a list of shells and a list of values.

    Parameters
    ----------
    list_shells : object
            A list of shell objects.

    list_values : object
            A list with the new values.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def shell_sens():
                m = []
                m.append(base.GetEntity(constants.NASTRAN, "SHELL", 1))
                m.append(base.GetEntity(constants.NASTRAN, "SHELL", 2))

                m2 = [12.0, 11.0]
                base.SetShellResult(m, m2)


    """


def InsertPatch(face: object, smult: int, tmult: int, tolerance: float) -> object:
    """

    This function splits a surface into more patches without modifying it's shape.

    Parameters
    ----------
    face : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    smult : int
            The number of patches at s direction would be multiplied by this number.
            This number should be a positive integer.

    tmult : int
            The number of patches at t direction would be multiplied by this number.
            This number should be a positive integer.

    tolerance : float
            The minimum distance between two patches.
            A patch would not be created in a distance smaller than tolerance.

    Returns
    -------
    object
            Returns 1 on success and None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Open("/../../*.ansa")

                face = base.GetEntity(ansa.constants.NASTRAN, "FACE", 43)
                base.InsertPatch(face, 2, 2, 0.05)


    """


def RemoveLogosAutomatic(height: float, size: float, source_faces: object) -> int:
    """

    Automatically recognizes and removes logos present in the model.

    Parameters
    ----------
    height : float
            The maximum height of the logo.

    size : float
            The maximum size of the logo.

    source_faces : object, optional
            A list of the faces where the recognition will be performed.
            If it is omitted the recognition will be performed on the visible faces

    Returns
    -------
    int
            Returns 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.RemoveLogosAutomatic(1, 5)


            # ...or...


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE")
                base.RemoveLogosAutomatic(1, 5, source_faces=faces)


    """


def UngroupParts() -> int:
    """

    This function ungroups all the Groups of the database to their component Parts.
    It takes no arguments.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.UngroupParts()


    """


def DrapeLaminate(
    deck: int,
    laminate: object,
    seq_layer: object,
    shear_lock_angle: float,
    detail: str,
    calc_thick: bool,
    spacing: float,
    treat_offending_geometry: bool,
    algorithm: str,
    template: object,
) -> int:
    """

    Performs draping for all specified sequence/layer pairs of a given laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate Property to apply drape.

    seq_layer : object, optional
            A list containing the sequence/layer pairs for which draping will apply. At least one of arguments 'seq_layer' and 'template' must be provided.

    shear_lock_angle : float, optional
            The shear lock angle. (Default: 60.0)

    detail : str, optional
            The level of detail ("MINIMUM", "AVERAGE", "MAXIMUM" or "USER_DEFINED").
            (Default: "MAXIMUM")

    calc_thick : bool, optional
            Calculate the thickness of the layers.
            (Default: False)

    spacing : float, optional
            Used only with detail="USER_DEFINED".
            (Default: 5.0)

    treat_offending_geometry : bool, optional
            Treat offending geometry.
            (Default: True)

    algorithm : str, optional
            Algorithm used for draping.
            "Fishnet" for woven layers, or "Sliding" for UD layers.
            (Default: "Fishnet")

    template : object, optional
            A list containing the layer template ids for which draping will apply. At least one of arguments 'seq_layer' and 'template' must be provided.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    See Also
    --------
    LaminateCreate, LaminateSequenceNew, LaminateLayerNew, LaminateSequenceModify, LaminateModify, LaminateLayerModify, LaminateSequenceCopy, LaminateLayerCopy, LaminateSequenceDelete, LaminateLayerDelete, LaminateInfo, LaminateSequenceInfo, LaminateLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                lam = base.GetEntity(constants.NASTRAN, "LAMINATE", 1)
                seq_layer_pairs = ((1, 1), (1, 2))
                base.DrapeLaminate(constants.NASTRAN, lam, seq_layer_pairs, 60, "MAXIMUM", True)


    """


def SetLaminateRosette(
    deck: int, laminate: object, rosette: int, seq_layer: object, template: object
) -> int:
    """

    Sets the rosette for all the specified sequence/layer pairs of the given laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH.

    laminate : object
            A reference to a laminate Property.

    rosette : int
            The id of a valid rosette that will be set.

    seq_layer : object, optional
            A list containing the sequence/layer pairs for which the rosette will be set. At least one of arguments 'seq_layer' and 'template' must be provided.

    template : object, optional
            A list containing the layer template ids for which the rosette will be set. At least one of arguments 'seq_layer' and 'template' must be provided.

    Returns
    -------
    int
            Returns 0 on success, otherwise 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.GetEntity(constants.NASTRAN, "LAMINATE", 1)
                rosette = 1
                seq_layer_pairs = ((1, 1), (1, 2))

                base.SetLaminateRosette(constants.NASTRAN, laminate, rosette, seq_layer_pairs)


    """


def CrossSectionReinforcements(
    cross_section: object,
    edge_set: object,
    orient_type: int,
    orient_vec: object,
    angle: float,
    direction: object,
    ret_ents: bool,
) -> object:
    """

    Create equivalent beam elements of a structure, by cutting it along a defined path.

    Parameters
    ----------
    cross_section : object
            A cross section used for the creation of the reinforcements.

    edge_set : object
            An edge set, with the edges where the the reinforcements will be created.

    orient_type : int, optional
            The type of the orientation vector.
            Accepted Values: 1 (fixed), 2 (normal), 3 (relative).
            (Default: 1)

    orient_vec : object, optional
            The orientation vector.

    angle : float, optional
            If defined, rotate the vector. (deg.)

    direction : object, optional
            Vector, used to set the direction of the reinforcements path.
            The path of the edge set has 2 possible directions, and
            the most close to the direction vector will be chosen as start.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Always returns 1.
            If ret_ents=True, it will return a list with the created entities,
            or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.LSDYNA, "CROSS_SECTION", 2)
                set = base.GetEntity(constants.LSDYNA, "SET", 5)
                d = [1, 0, 0]
                or_vec = [0, 0, 1]
                or_type = 1

                base.CrossSectionReinforcements(
                    cross, set, orient_vec=or_vec, orient_type=or_type, direction=d
                )


    """


def AbqStepSetSelected(step: object, select: bool) -> object:
    """

    Sets a step as selected.

    Parameters
    ----------
    step : object
            A reference to a step that can be retrieved from a previous
            call to GetEntity.

    select : bool
            Choose whether the given step is set to selected or not.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                base.AbqStepSetSelected(p_step, True)


    """


def PerimetersOfFace(faces: object, perimeters_type: str) -> object:
    """

    The function collects the Cons of each provided face. Joined perimeters will be included.
    The argument perimeters_type controls whether all (default), the active or the joined perimeters will be collected.

    Parameters
    ----------
    faces : object
            A single face or list of faces, parts or properties.

    perimeters_type : str, optional
            Accepted values: "all" (default), "active" or "joined".

    Returns
    -------
    object
            Returns a list with the collected Cons, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import mesh
            from ansa import constants


            def main():
                # Need some documentation? Run this with F5
                face = base.GetEntity(constants.NASTRAN, "FACE", 1)
                cons = base.PerimetersOfFace(face, "active")
                mesh.NumberPerimeters(cons, "*3")


    """


def Simplify(shrink: bool, perface: bool, tol: float, faces: object) -> int:
    """

    Simplifies the geometry of surfaces and/or performs Shrink if asked.

    Parameters
    ----------
    shrink : bool
            Can be True or False, corresponding to the activation or not of the flag 'Shrink'.

    perface : bool
            Can be True or False, corresponding to the activation or not of the flag 'Per face'.

    tol : float
            Can be any positive value, corresponding to the 'Tolerance' line edit.

    faces : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    Returns
    -------
    int
            Returns the number of simplified and/or shrinked surfaces on success, or 0 in failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE")
                simplify = base.Simplify(True, True, 0.0005, faces)
                print(simplify)


    """


def LaminateChangeStacking(
    deck: int,
    property: object,
    stacking: str,
    fill_ply_drop_offs: bool,
    merge_method: str,
    merge_t_tol: float,
    merge_theta_tol: float,
    disconnect_layers: bool,
    gap: float,
    ret_node_pairs: bool,
    ret_node_bricks: bool,
    ret_facet_pairs: bool,
    drop_off_prop: object,
    force_split_woven_layers: bool,
    avoid_hanging_edges: bool,
) -> object:
    """
    .. deprecated:: 18.1.0
            Use :py:func:`LaminateChangeStackingToPerPly` instead.


    This function changes the stacking of a Laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, PAMCRASH, ABAQUS, RADIOSS, ANSYS, PERMAS.

    property : object
            One laminate property or a list of laminate properties.

    stacking : str
            One of "single element" or "per ply".

    fill_ply_drop_offs : bool, optional
            Flag for filling ply drop-offs.
            (Default: False)

    merge_method : str, optional
            Method by which the layers of different properties will be merged.
            One of "by_tolerances", "by_gplyid", "by_layer_name".
            Required only for multiple properties and stacking = "per ply".

    merge_t_tol : float, optional
            Thickness tolerance by which the layers of different properties
            will be merged. Required for merge_method = "by_tolerances".

    merge_theta_tol : float, optional
            Theta tolerance by which the layers of different properties
            will be merged. Required for merge_method = "by_tolerances".

    disconnect_layers : bool, optional
            If set to True and stacking is "per ply" the layers are disconnected.
            (Default: False)

    gap : float, optional
            The gap between the disconnected layers (0 or greater).
            (Default: 0)

    ret_node_pairs : bool, optional
            If set to True, ret.node_pairs is a list of tuples with 2 nodes.
            If set to False, ret.node_pairs is None. (default)

    ret_node_bricks : bool, optional
            If set to True, ret.node_bricks is a list of tuples with 6 or 8 nodes.
            If set to False, ret.node_bricks is None. (default)

    ret_facet_pairs : bool, optional
            If set to True, ret.facet_pairs is a list of tuples with 2 facets or shells.
            If set to False, ret.facet_pairs is None. (default)

    drop_off_prop : object, optional
            Simple solid property of the ply drop-offs. If not given
            and fill_ply_drop_offs is True, then a default solid property is created.

    force_split_woven_layers : bool, optional
            If True, woven layers are split.
            If False, woven layers are not split, except for SOLID_LAMINATE
            in LSDYNA, PAMCRASH, RADIOSS and PERMAS

    avoid_hanging_edges : bool, optional
            When stacking is "per ply" and fill_ply_drop_offs is True,
            avoid hanging edges by creating pyramids (drop-off elements)
            and by splitting hexas to pentas (layer elements).

    Returns
    -------
    object
            None on failure.
            A list of layer objects on success.

            When disconnect_layers is True and stacking is "per ply" then the list returned contains one object for each layer.
            Each layer object has data about the interface between a layer and all adjacent layers above.

            This object ret has the following members:
            ret.laminate: the laminate
            ret.sequence_pos: the sequence index
            ret.layer_pos: the layer index
            ret.node_pairs: a list of tuples with 2 nodes (bottom and top). These may be used to create beams.
            ret.node_bricks: a list of tuples with 6 or 8 nodes (penta or hexa). These may be used to create cohesives.
            ret.facet_pairs: a list of tuples with 2 facets or shells (bottom and top). These may be used to create contacts.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "SOLID_LAMINATE", 1)

                rets = base.LaminateChangeStacking(
                    deck,
                    property=prop,
                    stacking="per ply",
                    disconnect_layers=True,
                    gap=0.02,
                    ret_node_bricks=True,
                )
                if rets is None:
                    print("LaminateChangeStacking failed!")
                    return
                pcohesive = base.CreateEntity(deck, "COHESIVE_SECTION")

                for ret in rets:
                    for nodes in ret.node_bricks:
                        vals = {}
                        vals["PID"] = pcohesive._id
                        for i in range(len(nodes)):
                            vals["N" + str(i + 1)] = nodes[i]._id
                        base.CreateEntity(deck, "COHESIVE", vals)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 18.1.0. Use :py:func: LaminateChangeStackingToPerPly instead.",
        DeprecationWarning,
    )


def SurfaceInfo(faces: object) -> object:
    """

    Takes as input a list of ANSA face entities and returns a list with info
    concerning each of the input faces underlying surface.

    Parameters
    ----------
    faces : object
            A list with ANSA face entities.

    Returns
    -------
    object
            Returns a list where each one of its element corresponds to the face in the
            supplied_faces list with the same index. Each position is a five element list
            where the first position corresponds to the surface index, the second position
            corresponds to the number of patches towards s direction, the third position
            corresponds to the number of patches towards t direction, the fourth position
            corresponds to the radius towards s direction and the fifth position corresponds to
            the radius towards t direction.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faceIDs = [130, 131]
                # Collect faces with IDs specified in faceIDs list
                faces = []
                for id in faceIDs:
                    faces.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                # get surface-info for each face in faces list
                info = base.SurfaceInfo(faces)
                # print info
                idx = 0
                for i in info:
                    print("--------------------------------------------------------------")
                    print("|Face with ID(", faceIDs[idx], ") |")
                    print("--------------------------------------------------------------")
                    print("  * Surface ID                 : ", i[0])
                    print("  * Number of patches toward s : ", i[1])
                    print("  * Number of patches toward t : ", i[2])
                    print("  * Radius toward s            : ", i[3])
                    print("  * Radius toward t            : ", i[4])
                    print("--------------------------------------------------------------\\n")
                    idx = idx + 1


    """


def IsolateSimilarGroups(
    entities: object,
    separate_at_blue_bounds: int,
    separate_at_pid_bounds: int,
    similarity_factor: float,
    distance: float,
    feature_angle: float,
    feature_type: str,
    skip_connectivity_separation: bool,
    action_on_apply: str,
    search_in_same_position: bool,
) -> object:
    """

    The function first separates all input entities into connectivity groups according to the
    parameters separate_at_blue_bounds and separate_at_pid_bounds.
    Then, it detects the connectivity groups that are similar (according to the similarity_factor and distance given).

    Parameters
    ----------
    entities : object
            A list that can contain faces and shells.
            If 0 is specified, then the function works on visible.
            If skip_connectivity_separation is True, entities must
            be a list with nested lists of entities. Each of the nested
            lists is the user input connectivity group to be examined.
            Especially for parts or props, the list does not have to be
            nested (see the example).

    separate_at_blue_bounds : int
            If 1 is specified, then regions connected
            via triple bounds are placed into separate
            connectivity groups. If 0 is specified,
            then all connected entities are placed into
            the same group.

    separate_at_pid_bounds : int
            If 1 is specified, then all entities
            contained in a connectivity group will have
            the same PID.
            If 0 is specified, then each connectivity
            group can contain connected entities with
            different PIDs.

    similarity_factor : float
            Values 0 - 100.
            The minimum percentage of similar
            area between 2 matched groups of entities.

    distance : float
            The maximum allowed distance between the
            similar area of 2 matched group of entities

    feature_angle : float, optional
            Values: 0 - 180.
            The feature angle limit in degrees.
            If this value is exceeded, the groups get separated
            at this feature line.
            (Default: 0)

    feature_type : str, optional
            Values: "convex", "concave", "convex_and_concave".
            This option  is considered only when separation by feature
            angle is enabled. Groups get separated at the examined
            bound only if feature_angle is exceeded and the feature
            type is of the specified type.
            (Default: "convex_and_concave")

    skip_connectivity_separation : bool, optional
            If set to True, then the user can provide the connectivity groups.
            The list entities must be a list with inner lists, each of which
            specifies a connectivity group. Each inner list can contain faces,
            shells, parts or properties.
            (Default: False)

    action_on_apply : str, optional
            Possible values: create_instances. If this action is provided,
            instance parts are created for the detected similar groups.
            (Default: None)

    search_in_same_position : bool, optional
            If set to True, the function searches for similar groups in the same position. Default value is False.

    Returns
    -------
    object
            Returns a dictionary with all the similar groups. The key is the similar group
            name and as data a second dictionary is stored. This second dictionary contains all the
            connectivity groups that were matched as similar. The key is the connectivity group name and
            as data a list with all the containing faces and shells is stored.

            If no similar groups are found, the function returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = base.CollectEntities(constants.NASTRAN, None, "FACE")
                matched_groups = base.IsolateSimilarGroups(
                    faces, 0, 0, 90, 0.5, feature_angle=40, feature_type="convex"
                )
                for matched_group_name, matched_group_connectivity in matched_groups.items():
                    print("matched_group:", matched_group_name)
                    for (
                        connectivity_name,
                        connectivity_entities,
                    ) in matched_group_connectivity.items():
                        print(
                            "Connectivity name :",
                            connectivity_name,
                            "   Entities:",
                            connectivity_entities,
                        )


            def check_parts_similarity():
                parts = [base.GetPartFromModuleId("1"), base.GetPartFromModuleId("2")]
                matched_groups = base.IsolateSimilarGroups(
                    parts, 0, 0, 90, 0.5, skip_connectivity_separation=True
                )

                if matched_groups is None:
                    print("parts are not similar!")


    """


def SplitPropertiesToPartsSections(
    properties: object, deck: int, ret_ents: bool
) -> object:
    """

    This funtion creates sections/props for LSDYNA/RADIOSS according to the given properties.
    The provided properties will be transformed to parts and will be assigned the newly created section/prop.

    Parameters
    ----------
    properties : object
            Properties that will be edited and will be used as source to create sections/props.

    deck : int, optional
            The deck for which the action will take place.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns the number of properties that were succesfully edited.
            If ret_ents=True it will return a list with the created entities, or None if no entities are created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                test = ("SECID",)
                vals = {"Name": "Dyna property", "USER_SECID": "NO"}

                prop = base.CreateEntity(constants.LSDYNA, "SECTION_SHELL", vals)

                ret = base.GetEntityCardValues(constants.LSDYNA, prop, test)
                print("The assigned secid before split is:", ret["SECID"], ". (blank)")

                base.SplitPropertiesToPartsSections(prop, constants.LSDYNA)

                ret = base.GetEntityCardValues(constants.LSDYNA, prop, test)
                print("The assigned secid after split is:", ret["SECID"], ".")


    """


def GetCurrentEntity(deck: int, type: str) -> object:
    """

    Gets a reference to the current entity of the specified type.

    Parameters
    ----------
    deck : int
            The selected deck.

    type : str
            A string that describes the type of entity.
            It can be retrieved from the title of the entity's
            edit card, where it is displayed within brackets.

    Returns
    -------
    object
            Returns a reference to the current entity, or None if such an entity does not exist.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pshell = base.GetCurrentEntity(constants.NASTRAN, "PSHELL")

                if pshell == None:
                    print("No current entity is set for PSHELL")
                else:
                    print("Current entity for PSHELL is named: ", pshell._name)


    """


def SurfaceIntersection(
    face1: object, face2: object, extend1: float, extend2: float, project_topo: bool
) -> int:
    """

    This function generates a 3D Curve along the intersection of two selected Surfaces.

    Parameters
    ----------
    face1 : object
            The 1st selected face.

    face2 : object
            The 2nd selected face.

    extend1 : float, optional
            A float that specifies the surface extension of the 1st face.

    extend2 : float, optional
            A float that specifies the surface extension of the 2nd face.

    project_topo : bool, optional
            Enable Project and Topo.
            (Default: False)

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def Curves_SurfInt():
                face1 = base.GetEntity(ansa.constants.NASTRAN, "FACE", 7)
                face2 = base.GetEntity(ansa.constants.NASTRAN, "FACE", 8)
                surfint = base.SurfaceIntersection(face1, face2, 0, 0, True)
                print(surfint)


    """


def DeleteFromDM(names_values: object, type: str, server_id: str) -> int:
    """

    This function deletes an entry from DM, e.g. a part or include or Component.

    Parameters
    ----------
    names_values : object, optional
            A dictionary with properties and their values,
            that will be used to find the entry in DM.

    type : str, optional
            The object type, e.g. "parts", "includes", "Component".

    server_id : str, optional
            The server id, if known.

    Returns
    -------
    int
            Returns 1 if the entry was deleted successfully or 0 if it failed.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # if we know the server id:
                map = {
                    "Module Id": "A",
                    "Version": "AA",
                    "Study Version": "0",
                    "Representation": "crash",
                }
                ret = base.GetObjectId("parts", map)
                if ret:
                    base.DeleteFromDM(server_id=ret, type="parts")
                # if we don't know the server id, we search for it
                map = {
                    "Module Id": "A",
                    "Version": "AA",
                    "Study Version": "0",
                    "Representation": "crash",
                }
                base.DeleteFromDM(names_values=map, type="parts")


    """


def CreateNodeCouples(
    method: str,
    entities: object,
    second_set: object,
    sequential_nodes: str,
    number_of_nodes: int,
    distance: float,
    tolerance: float,
    connectivity_1st_set: str,
    connectivity_2nd_set: str,
) -> object:
    """

    Creates/Sorts node couples from nodes/node sets or curves.

    Parameters
    ----------
    method : str
            Valid values:
            -"nodes"
            -"curve_seq"
            -"curve_box"
            -"node_sets"
            -"edges"

    entities : object
            Valid entities are nodes, curves and edges depending on the method.

    second_set : object, optional
            Node entities. Used only in "node_sets" method.

    sequential_nodes : str, optional
            "on" or "off". Used only in "nodes" method.
            (Default: "off")

    number_of_nodes : int, optional
            Number of nodes to create on the provided curve(s).
            Used in "curve_seq" method. If distance is provided,
            nodes will be created according to the "distance" argument

    distance : float, optional
            Distance of between the created nodes.
            Used at "curve_box" and "curve_seq" method.

    tolerance : float, optional
            Maximum distance of the nodes to be in a couple.
            Used in the "node_sets" method.

    connectivity_1st_set : str, optional
            Valid values: "single", "double" or "multiple".

    connectivity_2nd_set : str, optional
            Valid values: "single", "double" or "multiple".

    Returns
    -------
    object
            Returns a that contains the node couples. On failure None is returned.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                x = [0, 100, 200, 200]
                y = [0, 200, 200, 300]
                z = [0, 0, 0, 100]
                a_curve = base.CreateCurve(4, x, y, z)

                vals_p = {"A": 50}
                property = base.CreateEntity(constants.NASTRAN, "PROD", vals_p)
                pid = property._id

                couples = base.CreateNodeCouples(method="curve_box", entities=a_curve, distance=1.5)
                for i in range(len(couples)):
                    vals = {"G1": couples[i][0]._id, "G2": couples[i][1]._id, "PID": pid}
                    base.CreateEntity(constants.NASTRAN, "CROD", vals)


    """


def CurvesTransform(
    entities: object,
    point1: object,
    point2: object,
    start_direction_point: object,
    part: object,
    respect_user_selection: bool,
) -> int:
    """

    This function defines new 3D Curves as transformation of a number of selected
    consecutive 3D Curves, CONS or Cross Section segments.
    The transformations can be simultaneous translation, rotation and scaling.

    Parameters
    ----------
    entities : object
            A list with entities for the chain that will be used for the transformation.

    point1 : object
            A list with x, y, z double coordinates that indicates the start of the
            transformation vector for the new 3D Curve.

    point2 : object
            A list with x, y, z double coordinates that indicates the end of the
            transformation vector for the new 3D Curve.

    start_direction_point : object
            A list with x, y, z double coordinates that indicates a point close to the
            start of the selected chain, defining its direction. The vector is defined
            from the "start_direction_point" to the end of the chain.

    part : object
            The part for the created curves.

    respect_user_selection : bool, optional
            True for respect user selection, False for auto
            ordering the entities of the chain.

    Returns
    -------
    int
            Returns 1 on successs, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def curves_transf():
                cons1 = base.GetEntity(constants.NASTRAN, "CURVE", 398)
                cons2 = base.GetEntity(constants.NASTRAN, "CURVE", 400)
                cons3 = base.GetEntity(constants.NASTRAN, "CURVE", 401)

                entities = []
                entities.append(cons1)
                entities.append(cons2)
                entities.append(cons3)

                point1 = [2381.000000, -637.004000, 533.965000]
                point2 = [2457.790000, -461.661000, 375.826000]
                start_dir_point = [2380.000000, -640.004000, 535.965000]

                part = base.GetEntityPart(cons1)

                created_curves = base.CurvesTransform(
                    entities, point1, point2, start_dir_point, part, True
                )
                base.RedrawAll()

                print(created_curves)


    """


def CreateLaminateRosette(
    deck: int,
    laminate: object,
    position: object,
    direction: object,
    reference: object,
    id: int,
    name: str,
    coordinate: object,
) -> object:
    """

    Creates a rosette for the specified laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate Property.

    position : object, optional
            A list with the coordinates where the rosette will be created.

    direction : object, optional
            A list with the coordinates of the rosette's direction vector.

    reference : object, optional
            A list with the coordinates of the rosette's reference vector.

    id : int, optional
            The rosette's id. If no id is given the first free id will be assigned.

    name : str, optional
            The rosette's name. If no name is given a default one will be assigned.

    coordinate : object, optional
            A reference to a coordinate system.

    Returns
    -------
    object
            Returns the id of the created rosette or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                lam = base.GetEntity(ABAQUS, "LAMINATE", 1)
                elem = base.GetEntity(ABAQUS, "SHELL", 1)

                pos = base.Cog(elem)
                dir = (0, 0, -1)
                ref = (2, 2, 2)

                id = base.CreateLaminateRosette(ABAQUS, lam, pos, dir, ref, 0, "rosette_1")


    """


def DeleteLaminateRosette(deck: int, laminate: object, rosette: int) -> int:
    """

    Deletes the specified rosette for the given Laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH..

    laminate : object
            A reference to a laminate Property.

    rosette : int
            The id of the rosette to be deleted.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.GetEntity(constants.ABAQUS, "LAMINATE", 1)
                rosette = 1
                base.DeleteLaminateRosette(constants.ABAQUS, laminate, rosette)


    """


def ModifyLaminateRosette(
    deck: int,
    laminate: object,
    rosette: int,
    position: object,
    direction: object,
    reference: object,
    name: str,
    coordinate: object,
) -> int:
    """

    Modifies the specified rosette for the given Laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate Property.

    rosette : int
            The id of the rosette that will be modified.

    position : object, optional
            A list with the coordinates of the rosette's position.

    direction : object, optional
            A list with the coordinates of the rosette's direction vector.

    reference : object, optional
            A list with the coordinates of the rosette's reference vector.

    name : str, optional
            The rosette's name.

    coordinate : object, optional
            A reference to a coordinate system.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                lam = base.GetEntity(ABAQUS, "LAMINATE", 1)
                elem = base.GetEntity(ABAQUS, "SHELL", 1)

                pos = base.Cog(elem)
                dir = (0, 0, -1)
                ref = (2, 2, 2)

                base.ModifyLaminateRosette(ABAQUS, lam, 1, pos, dir, ref, "rosette_1")


    """


def CreateLaminateOffset(
    deck: int,
    laminate: object,
    elements: object,
    position: object,
    direction: object,
    id: int,
    flag: str,
    value: float,
    name: str,
) -> int:
    """

    Creates an offset for the specified laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate property.

    elements : object
            A list with Shell elements that belong to the laminate property on which offset
            will be applied.

    position : object
            A list with the coordinates of the offset's position vector.

    direction : object
            A list with the coordinates of the offset's direction vector.

    id : int, optional
            Id of the created offset. If no id or 0 id is given the first free id will be chosen.

    flag : str, optional
            Available options are "below", "middle", "above" or "application_side".
            (Default: "middle")

    value : float, optional
            Offset's value.

    name : str, optional
            Name of the created offset.

    Returns
    -------
    int
            Returns the id of the created offset or None in case of failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                lam = base.GetEntity(constants.ABAQUS, "LAMINATE", 1)

                elements = []
                for i in range(1, 100):
                    elements.append(base.GetEntity(constants.ABAQUS, "SHELL", i))
                pos = base.Cog(lam)
                dir = (0, -1, 0)

                base.CreateLaminateOffset(
                    constants.ABAQUS, lam, elements, pos, dir, 2, "below", 3.0, "Offset_1"
                )


    """


def DeleteLaminateOffset(deck: int, laminate: object, offset: int) -> int:
    """

    Deletes the specified offset for the given Laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH.

    laminate : object
            A reference to a laminate property.

    offset : int
            The id of the offset to be deleted.

    Returns
    -------
    int
            Returns 0 on success or 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.GetEntity(constants.ABAQUS, "LAMINATE", 1)
                offset = 1
                base.DeleteLaminateOffset(constants.ABAQUS, laminate, offset)


    """


def ModifyLaminateOffset(
    deck: int,
    laminate: object,
    offset: int,
    add_elements: object,
    remove_elements: object,
    position: object,
    direction: object,
    flag: str,
    value: float,
) -> int:
    """

    Modifies the specified offset for the given Laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A reference to a laminate property.

    offset : int
            The id of the offset that will be modified.

    add_elements : object, optional
            A list with Shell elements that belong to the laminate property that will be
            added to the offset.

    remove_elements : object, optional
            A list with Shell elements that belong to the laminate property that will be
            removed from the offset.

    position : object, optional
            A list with the coordinates of the offset's position vector.

    direction : object, optional
            A list with the coordinates of the offset's direction vector.

    flag : str, optional
            Available options are "below", "middle", "above", "application_side".
            (Default: "middle")

    value : float, optional
            Offset's value.

    Returns
    -------
    int
            Returns 0 on success or 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                lam = base.GetEntity(ABAQUS, "LAMINATE", 1)
                elem = base.GetEntity(ABAQUS, "SHELL", 1)

                add_elements = []
                for i in range(101, 200):
                    add_elements.append(base.GetEntity(ABAQUS, "SHELL", i))
                rem_elements = []
                for i in range(101, 200):
                    rem_elements.append(base.GetEntity(ABAQUS, "SHELL", i))
                pos = base.Cog(elem)
                dir = (0, -1, 0)

                base.ModifyLaminateOffset(
                    ABAQUS, lam, 1, add_elements, rem_elements, pos, dir, "below", 3.0
                )


    """


def GetMacrosOfCons(cons: object) -> object:
    """

    Returns the macros that the input CONS belong to.

    Parameters
    ----------
    cons : object
            A CONS entity, a CONS ID, a list of CONS entities, a list of CONS IDs,
            or a list of CONS entities and IDs.

    Returns
    -------
    object
            Returns a list with the macros that the input CONS belong to.

    See Also
    --------
    GetFacesOfCons, GetFacesOfHotPoints, GetMacrosOfHotPoints, GetConsOfHotPoints

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def GetMacrosOfConsFromListOfConsEntitiesDemo():
                # collect all CONS of data-base
                cons_list = base.CollectEntities(constants.NASTRAN, None, "CONS")
                # collect adjacent macros of CONS contained in list cons_list
                macros_list = base.GetMacrosOfCons(cons_list)
                # pick macros contained in list faces_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfConsFromSingleConsEntityDemo():
                # collect CONS with ID 2210 from data-base (## Change here to desired ID ##)
                cons_entity = base.GetEntity(constants.NASTRAN, "CONS", 2210)
                # collect adjacent macros of cons_entity
                macros_list = base.GetMacrosOfCons(cons_entity)
                # pick macros contained in list faces_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfConsFromListOfConsIDsDemo():
                # Define a list of CONS IDs (## Change here to desired IDs ##)
                cons_ids_list = [2210, 2161, 1719]
                # collect adjacent macros of CONS list with IDs
                macros_list = base.GetMacrosOfCons(cons_ids_list)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfConsFromSingleConsIDDemo():
                # collect adjacent macros of CONS with ID 2210 (## Change here to desired ID ##)
                macros_list = base.GetMacrosOfCons(2210)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfConsFromListOfConsEntitiesAndIDsDemo():
                # Define a list of CONS entities/IDs (## Change here to desired IDs ##)
                cons_ids_list = [2210, base.GetEntity(constants.NASTRAN, "CONS", 2161), 1719]
                # collect adjacent macros of CONS list with IDs
                macros_list = base.GetMacrosOfCons(cons_ids_list)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


    """


def InputTAU(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    Inputs a TAU file in ANSA .

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA will use the light volume representation.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputTAU(filename="C:/temp/users/folder/data.cdf")


    """


def OutputTAU(
    filename: str,
    mode: str,
    cmode: str,
    unit_system: object,
    scale: float,
    write_bc_specs: str,
) -> int:
    """

    OutputTAU output a TAU file. It supports variable number of arguments.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path to the file.

    mode : str
            "all", "model" or "visible".
            (Default: "visible")

    cmode : str
            This flag controls the type of the created netCDF file.
            Select the "Standard" option in case hdf5 library is NOT installed on your
            system, or the "HDF5" option otherwise.
            (Default: "HDF5")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: "1.0")

    write_bc_specs : str, optional
            Accepted values are "on" and "off".
            This flag controls the export of the bc specifications.
            In case it is "off" only BC Marker, Name, Type and Subtype
            are exported in the .bmap file.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputTAU(filename="C:/temp/data.cdf", cmode="HDF5")


    """


def FacesExtendTarget(
    boundary_cons: object,
    range: float,
    delete_hots_flag: bool,
    patch_flag: bool,
    target_face: object,
    project_flag: bool,
) -> int:
    """

    This function extends Faces (source), according to a specified distance
    or until they reach a target Face or target group of Faces, by adding new
    Faces as extensions to the source ones.

    Parameters
    ----------
    boundary_cons : object
            A red cons or a list of red cons.

    range : float
            The appropriate extension distance.

    delete_hots_flag : bool
            True or False, in cases that a selection of CONS could be replaced
            by one CONS or not (by removing their intermediate Hot Points).

    patch_flag : bool
            If set to True, the created extension faces lay on new surfaces.
            If set to False, the new face gives the surface to the original faces too.

    target_face : object, optional
            A face or a list of target faces.

    project_flag : bool, optional
            If set to True, topology is applied between extended and target Faces.
            (Default: False)

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entities_cons = []
                entities_faces = []

                cons1 = base.GetEntity(constants.NASTRAN, "CONS", 206)
                cons2 = base.GetEntity(constants.NASTRAN, "CONS", 183)
                cons3 = base.GetEntity(constants.NASTRAN, "CONS", 23)

                face1 = base.GetEntity(constants.NASTRAN, "FACE", 1)

                entities_cons.append(cons1)
                entities_cons.append(cons2)
                entities_cons.append(cons3)
                entities_faces.append(face1)

                extend_target = base.FacesExtendTarget(
                    entities_cons, 12.0, True, True, entities_faces, True
                )
                print(extend_target)


    """


def ResultsMapperReleaseResults(mappers: object) -> object:
    """

    Releases the entities that are created by the mapper upon 'Apply'.
    After that the mapper can be deleted without deleting the aforementioned entities.

    Parameters
    ----------
    mappers : object
            A list of the mapper entities to be released.

    Returns
    -------
    object
            Returns always None.

    Examples
    --------
    ::

            import ansa
            import base


            def main():
                mappers = base.CollectEntities(
                    deck=ansa.constants.ABAQUS, search_types="RESULTS_MAPPER"
                )
                base.ResultsMapperReleaseResults(mappers)
                base.DeleteEntity(mappers, False)


    """


def OutputU3DPDF(filename: str) -> int:
    """

    This function outputs a PDF format containing all the entities of the database that is currently loaded.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    Returns
    -------
    int
            Returns 0 on success, 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputU3DPDF("C:/temp/users/folder/data.pdf")


    """


def GetLogFile(log_type: str, filename: str) -> object:
    """

    This function returns the full file name of the log file.

    Parameters
    ----------
    log_type : str, optional
            The type of the log file to return.
            Accepted values: "", "BatchMesh", "SkinResults".
            "" corresponds to ANSA input log file, which is the default value.

    filename : str, optional
            The name of the file which will produce the log file.

    Returns
    -------
    object
            Returns the name of the log file of the given process.
            If filename argument exists, the function will return the log file which will be writen
            according to the options selected on ANSA defaults, else it returns the last used log file.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputNastran(filename="C:/temp/users/folder/data.nas")
                log_name = base.GetLogFile()
                print(log_name)


            # ...or...


            def main():
                base.GetLogFile(filename="AnInputFile.nas")


            # ...or...


            def main():
                base.GetLogFile(filename="")


    """


def SeatPositionForImpactTests(
    protocol: str,
    field: object,
    field_points: object,
    SRP_body: object,
    seat_fore_aft: object,
    seat_height: object,
    seat_back_angle: object,
    head_restraint_height: object,
    head_restraint_fore_aft: object,
    base_tilt: object,
    position_name: str,
) -> int:
    """

    This function performs the setup of the seat positioning parameters and the seat adjustments.

    Parameters
    ----------
    protocol : str, optional
            The name of the impact's protocol.
            -For frontal impact: 'UN_R94', 'C_NCAP_Frontal',
             'Euro_NCAP_Full_Width', 'Euro_NCAP_ODB', 'Euro_NCAP_MPDB',
             'ASEAN_NCAP_Frontal', 'JNCAP_Frontal', 'KNCAP_Full', 'KNCAP_Offset',
             'C_IASI_Frontal', 'US_NCAP_FMVSS_208_50th',  'US_NCAP_FMVSS_208_5th'
            -For side impact: 'Euro_NCAP_MDB', 'Euro_NCAP_Pole', 'UN_R95',
             'US_NCAP_FMVSS_214_ES_2RE', 'US_NCAP_FMVSS_214_SID_2s',
             'ISO_WorldSID_50',  'C_NCAP_Side', 'UN_R135', 'ASEAN_NCAP_Side',
             'JNCAP_Side', 'KNCAP_Side', 'C_IASI_Side'
            Custom.

    field : object, optional
            The name or the PID of the seat adjustments' field.

    field_points : object, optional
            The locations of the seat adjustments' field points.
            A_SRP       float float float
            B_MostFront float float float
            C_SRP       float float float
            Cprime_SRP  float float float
            D_MostRear  float float float

    SRP_body : object, optional
            The name or the ID of the Seat Reference's Point KinBody.

    seat_fore_aft : object, optional
            A dictionary for the Seat Fore/Aft adjustment with the following key - values:
            -skip                  boolean True to skip the adjustment or False to not.
            -configuration         object  The name or the ID of the Kinematic Configuration.
            -bearing_configuration object  The name or the ID of the bearing's Kinematic
                                           Configuration.
            -characteristic        string  The name of the adjustment's characteristic (by_joint,
                                           most_forward, middle, combine).
            -value                 float   The value of the adjustment.
            -scale_factor          float   The bearing's configuration movement's scale factor.
            -target_point          float float float The location of the target point.

    seat_height : object, optional
            A dictionary for the Seat Height adjustment with the following key - values.
            -skip           boolean True to skip the adjustment or False to not.
            -configuration  object  The name or the ID of the Kinematic Configuration.
            -characteristic string  The name of the adjustment's characteristic (by_joint, height,
                                    middle, lowest).
            -value          float   The value of the adjustment.
            -lock_backrest boolean True to lock the backrest during adjustment of False to not
            -backrest_body object The name or the ID of the Backrest KinBody.

    seat_back_angle : object, optional
            A dictionary for the Seat Back Angle adjustment with the following key - values.
            -skip           boolean True to skip the adjustment or False to not.
            -configuration  object  The name or the ID of the Kinematic Configuration.
            -characteristic string  The name of the adjustment's characteristic (by_joint,
                                    head_at_0, rotate_to).
            -value          float   The value of the adjustment.
            -torso_angle    float   The value of the torso angle.

    head_restraint_height : object, optional
            A dictionary for the Head Restraint Height with the following key - values.
            -skip            boolean True to skip the adjustment or False to not.
            -configuration   object  The name or the ID of the Kinematic Configuration.
            -characteristic  string  The name of the adjustment's characteristic (by_joint,
                                     design_position, top_surface_level, middle, uppermost).
            -value           float   The value of the adjustment.
            -upper_height    float   The value of the upper height.
            -lower_height    float   The value of the lower height.
            -cog_dummy_head  float   The location of the dummy's head COG at axis Z.
            -dummy_head_body object  The name or the ID of the dummy's head KinBody.

    head_restraint_fore_aft : object, optional
            A dictionary for the Head Restraint Fore/Aft  with the following key - values.
            -skip            boolean True to skip the adjustment or False to not.
            -configuration   object  The name or the ID of the Kinematic Configuration.
            -characteristic  string  The name of the adjustment's characteristic (by_joint,
                                     most_forward, most_rearward, middle).
            -value           float   The value of the adjustment.
            -forward_angle   float   The value of the forward angle.
            -rearward_angle  float   The value of the rearward angle.
            -dummy_head_body object  The name or the ID of the dummy's head KinBody.

    base_tilt : object, optional
            A dictionary for the Seat Base Tilt  with the following key - values.
            -skip            boolean True to skip the adjustment or False to not.
            -configuration  object  The name or the ID of the Kinematic Configuration.
            -characteristic string  The name of the adjustment's characteristic (by_joint,
                                    middle, design_position).
            -value          float   The value of the adjustment.
            -lower_edge     float float float The location of the lower edge.
            -upper_height   float   The value of the upper height.
            -lower_height   float   The value of the lower height.
            -base_body      object  The name or the ID of the seat's base KinBody.

    position_name : str, optional
            The name of the created KinPosition at the end of the seat positioning.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Set parameters
                reg_type = "Euro NCAP Pole"
                # 1. Seat Fore/Aft
                length_data = {
                    "skip": False,
                    "configuration": "Lenght",
                    "bearing_configuration": 6,
                    "characteristic": "middle",
                }
                # 2. Seat Height
                height_data = {
                    "skip": False,
                    "configuration": "Height",
                    "characteristic": "by_joint",
                    "value": 20,
                    "lock_backrest": True,
                    "backrest_body": 13,
                }
                # 3. Seat Back Angle
                back_data = {
                    "skip": False,
                    "configuration": "Backrest",
                    "characteristic": "rotate_to",
                    "torso_angle": 25,
                }
                # 4. Seat Head Restraint Height
                headrest_height_data = {
                    "skip": False,
                    "configuration": 11,
                    "characteristic": "middle",
                    "upper_height": 50,
                    "lower_height": 10,
                }
                # 5. Seat Head Restraint Fore/Aft
                headrest_length_data = {
                    "skip": True,
                    "configuration": 21,
                    "characteristic": "middle",
                    "forward_angle": 100,
                    "rearward_angle": 5,
                }
                # 6. Seat Base Tilt
                tilt_data = {
                    "skip": False,
                    "configuration": 9,
                    "characteristic": "middle",
                    "base_body": 7,
                    "upper_height": 35,
                    "lower_height": 10,
                    "lower_edge": (2609.378907, -592.30011, 725.411003),
                }

                base.SeatPositionForImpactTests(
                    protocol=reg_type,
                    field=150209,
                    SRP_body=8,
                    seat_fore_aft=length_data,
                    seat_height=height_data,
                    seat_back_angle=back_data,
                    head_restraint_height=headrest_height_data,
                    head_restraint_fore_aft=headrest_length_data,
                    base_tilt=tilt_data,
                    position_name="seat position for test case",
                )


    """


def SeatDepenetrate(
    dummy_set_id: int,
    seat_set_id: int,
    frame_set_id: int,
    dx: float,
    dy: float,
    dz: float,
    factor: float,
    initial_foam: bool,
) -> object:
    """

    Provides the Decks>Safety>[Seat Depenetrate] button functionality.

    Parameters
    ----------
    dummy_set_id : int
            A set that contains the Dummy parts that penetrate the Seat's cushion.

    seat_set_id : int
            A set that contains the Seat's cushion.

    frame_set_id : int
            A set that contains the frame elements that are places underneath the Seat's cushion.

    dx : float
            The x coordinate of the move vector.

    dy : float
            The y coordinate of the move vector.

    dz : float
            The z coordinate of the move vector.

    factor : float, optional
            The property thickness factor.
            (Default: 1.0)

    initial_foam : bool, optional
            If True, reference nodes keywords will be created at the end of the
            depenetration procedure.
            (Default: False)

    Returns
    -------
    object
            Returns 1 on success and 0 on failure.
            If initial_foam=True, the function returns a list of the initial_foam entities on success,
            or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Function will position dummy described in set 1, depenetrating foam descrived in set 2,
                # with the foam frame described in set 3, the depenetration vector is [0,0,-1], thicknes factor is 1
                # and initial foam geometry reference will be created.
                base.SeatDepenetrate(1, 2, 3, 0, 0, -1, 1, True)

                # Function will position the same sets as the previous example (1, 2, 3) with the same vector ([0, 0, -1]).
                # Keywords factor and initial_foam have not been declared so the default values (1.0 and False respectively) will be used.
                base.SeatDepenetrate(1, 2, 3, 0, 0, -1)


    """


def CreateVolumeBox(
    point1: object,
    point2: object,
    point3: object,
    dim_x: float,
    dim_y: float,
    dim_z: float,
    part: object,
    property: object,
    volumes: bool,
) -> object:
    """

    This function defines a rectangular hexahedron by creating six quadrilateral faces connected accordingly.
    Apart from the six macro-faces, a Volume entity is also created.

    Parameters
    ----------
    point1 : object
            A list of x,y,z coordinates defining the center of the box.

    point2 : object
            A list of x,y,z coordinates defining the X-axis of the box.

    point3 : object
            A list of x,y,z coordinates defining the Y-axis of the box.

    dim_x : float
            The dimension of the X-axis.

    dim_y : float
            The dimension of the Y-axis.

    dim_z : float
            The dimension of the Z-axis.

    part : object, optional
            The part for the created face(s).
            If nothing is passed, the current part is taken into consideration.

    property : object, optional
            The property for the created faces(s).
            If nothing is passed, the default property is taken into consideration.

    volumes : bool, optional
            If set to True, apart from the six macro-faces, a Volume entity is also created.
            (Default: True)

    Returns
    -------
    object
            Returns a list with the created faces, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def create_volume_box():
                point1 = []
                point1.append(2431.940000)
                point1.append(-493.396000)
                point1.append(560.458000)

                point2 = []
                point2.append(2423.913800)
                point2.append(-490.481080)
                point2.append(416.930000)

                point3 = []
                point3.append(2345.0)
                point3.append(1234.0)
                point3.append(3560.458000)

                face1 = base.GetEntity(constants.NASTRAN, "FACE", 4)
                part = base.GetEntityPart(face1)
                properties = base.GetEntity(constants.NASTRAN, "PSHELL", 1)

                created_box = base.CreateVolumeBox(
                    point1, point2, point3, 50, 50, 50, part, properties, False
                )
                base.RedrawAll()

                print(len(created_box))


    """


def AddGroupsToConfiguration(groups: object, configuration: object) -> bool:
    """

    The function adds entities of type ANSAPARTS/ANSAGROUPS to a configuration.

    Parameters
    ----------
    groups : object
            A list that contains ansa entities of type ANSAPART / ANSAGROUP.

    configuration : object
            The configuration entity that we want to add to.

    Returns
    -------
    bool
            Returns True, if every entity was either succesfully added or already existed in the configuration.
            Returns False, if one or more entities failed to be added to the configuration.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                configuration = base.GetEntity(ansa.constants.NASTRAN, "ANSAGROUP", 4)
                parts = base.CollectEntities(ansa.constants.NASTRAN, None, "ANSAPART")
                print(base.AddGroupsToConfiguration(parts, configuration))


    """


def RemoveGroupsFromConfiguration(groups: object, configuration: object) -> bool:
    """

    The function removes entities of type ANSAPARTS/ANSAGROUPS from a configuration.

    Parameters
    ----------
    groups : object
            A list that contains ansa entities of type ANSAPART / ANSAGROUP.

    configuration : object
            The configuration entity that we want to remove from.

    Returns
    -------
    bool
            Returns:
            True: If every entity was either succesfully removed or was not a member
            of the configuration.
            False: If one or more entities failed to be removed from the configuration.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                configuration = base.GetEntity(constants.NASTRAN, "ANSAGROUP", 4)
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                print(base.RemoveGroupsFromConfiguration(parts, configuration))


    """


def FuseTreeStructures(model_1: object, model_2: object) -> bool:
    """

    This function fuses two part/group tree structures, by checking if the last level
    parts(/groups) of the second tree can be hanged or replace the last level groups
    of the first one. The merging only takes the parts'(/groups') "Name" and hierarchy
    position(parents) into account. Anything that cannot be hanged will be discarded
    from the second model. The second model will be replaced by the result.

    Parameters
    ----------
    model_1 : object
            The first ANSA model, that holds the first tree structure to use for the fusion.

    model_2 : object
            The second ANSA model, that holds the second tree structure to use for the fusion.
            This model will hold the result, after the fusion takes place.

    Returns
    -------
    bool
            Returns False if any of the two arguments is not a valid ANSA model.
            Returns True in any other case.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                amodel1 = base.CreateNewAnsaModel()
                base.SetCurrentAnsaModel(amodel1)
                utils.Merge("model1.ansa")

                amodel2 = base.CreateNewAnsaModel()
                base.SetCurrentAnsaModel(amodel2)
                utils.Merge("model2.ansa")

                base.FuseTreeStructures(amodel1, amodel2)


    """


def Sgraph(group_1: object, group_2: object, detailed_results: bool) -> object:
    """

    This function creates the Separation graph (SGRAPH) between two models and returns the calculated results.

    Parameters
    ----------
    group_1 : object, optional
            A list that contains elements like volumes, shells and solids and
            containers like group, parts, sets.
            These entities are going to be loaded in SGRAPH group1.

    group_2 : object, optional
            A list that contains elements like volumes, shells and solids and
            containers like group, parts, sets.
            These entities are going to be loaded in SGRAPH group2.

    detailed_results : bool, optional
            If set to True, results will contain the distance vectors coordinates calculated
            by Separation Graph, per element.
            If set to False, results will contain the distance calculated by Separation
            Graph, per element.
            (Default: False)

    Returns
    -------
    object
            Returns a dictionary.
            The keys are the elements and their respective data are lists of dictionaries.
            If the key element is shell then the list contains only one dictionary.
            This dictionary structure is described below.
               KEY               VALUE
              shell         list( nearest_entity, dist )  =  results referred to shell's COG
              node1         list( nearest_entity, dist )  =  results referred to shell's node1
              node2         list( nearest_entity, dist )  =  results referred to shell's node2
              node3         list( nearest_entity, dist )  =  results referred to shell's node3
              node4         list( nearest_entity, dist )  =  results referred to shell's node4

            If the key element is solid then list contains one dictionary for-each solid's facet.
            These dictionaries have the following structure.
               KEY                  VALUE
              facet(SOLIDFACET)  list( nearest_entity, dist )  =  results referred to facet's COG
              node1              list( nearest_entity, dist )  =  results referred to facet's node1
              node2              list( nearest_entity, dist )  =  results referred to facet's node2
              node3              list( nearest_entity, dist )  =  results referred to facet's node3
              node4              list( nearest_entity, dist )  =  results referred to facet's node4

            nearest_entity:: the entity from the other group that nodes or COGs find the projection with minimum distance.
            dist:: if argument detailed_results is set to True dist will contain the projection vector coordinates
             (x_start, y_start, z_start, x_end, y_end, z_end).
             If argument detailed_results is set to False dist will contain the projection distance.

            Faces are not supported in this function.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                part1 = parts[0]
                part2 = parts[1]
                base.SetANSAdefaultsValues({"sgraph_search_range": 5})
                base.SetANSAdefaultsValues({"sgraph_color_groups_mode": 2})
                results = base.Sgraph(group_1=part1, group_2=part2, detailed_results=True)
                vals = ("__id__", "__type__")
                for elem, value in results.items():
                    ret = base.GetEntityCardValues(entity=elem, fields=vals, deck=constants.NASTRAN)
                    if ret["__type__"]:
                        print(ret["__type__"] + " : " + str(ret["__id__"]))
                        print("--------------------------------------------------------")
                    for val_dict in value:
                        print("***************************")
                        for elem_, value_ in val_dict.items():
                            print(
                                base.GetEntityType(constants.NASTRAN, elem_)
                                + "    matched elem = "
                                + str(value_[:1])
                            )
                            print("Vector :: ", value_[1 : len(value_)])
                        print("***************************")
                    print("--------------------------------------------------------")


    """


def FacesShrink(
    entities: object, width: float, method: int, delete_old_faces: bool, ret_ents: bool
) -> int:
    """

    This script function shrinks inward a selected Face by a given distance value. The result is either a new zone in Face(s), created by cutting the old Face(s) by using its perimeters, or new smaller Face(s), or a set of 3D-curves corresponding to the Face's boundary.

    Parameters
    ----------
    entities : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    width : float
            The distance value.

    method : int
            0: For creating a new zone in Face(s) by cutting the old Face(s)
            by using its perimeters.
            1: For creating new smaller Face(s)
            2: For creating a set of 3D-curves corresponding to the Face's boundary.

    delete_old_faces : bool, optional
            If the argument 'method' is 1 (create  new smaller Face(s)),
            set to True to delete the old Face(s), or False for the old Face(s) to remain.
            (Default: False)

    ret_ents : bool, optional
            If True and named argument 'method' equals to 0 or 1 returns a list containing two lists, in success, otherwise None.
            In success, first list contains resulted CONS and second list contains resulted faces.
            If named argument 'method' equals to 2 returns a list with the created Curves, in success, otherwise None.
            If False, returns 1 in case of success or 0 otherwise.

    Returns
    -------
    int
            Returns 1 in case of success or 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_faces_shrink():
                entities = []
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 93))
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 6))

                shrink = base.FacesShrink(entities, 3.5, 0, True)
                print("Shrink:", shrink)


    """


def SizeBoxConvertToMorph(entities: object) -> object:
    """

    A function that converts size boxes to morphing boxes.

    Parameters
    ----------
    entities : object
            A list that contains size boxes.

    Returns
    -------
    object
            Returns a list containing references to the newly created box objects on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                sizeBoxes = base.CollectEntities(constants.NASTRAN, None, "SIZE_BOX")
                morphes = base.SizeBoxConvertToMorph(sizeBoxes)


    """


def LaminateLayerChangeOrientation(
    deck: int,
    laminate: object,
    sequence_pos: int,
    layer_pos: int,
    orientation_type: str,
    elements: object,
    vertical_limit: float,
    orientation_vector: object,
    orientation_element: object,
    orientation_curves: object,
) -> object:
    """

    Changes the mapped orientation of a laminate layer.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, PAMCRASH, ABAQUS, RADIOSS, ANSYS, PERMAS.

    laminate : object
            A laminate property.

    sequence_pos : int
            The index of sequence.

    layer_pos : int
            The index of layer.

    orientation_type : str
            One of "by_vector", "by_theta", "by_edges".

    elements : object, optional
            A list of elements of the layer to change orientation.
            If not given all elements of the layer are used.

    vertical_limit : float, optional
            The angle in degrees. The orientation change fails if the angle between
            the normal vector and the vector which gives the orientation is greater
            than the vertical_limit.

    orientation_vector : object, optional
            A list with three double values. Needed for "by_vector", "by_theta".

    orientation_element : object, optional
            An element needed for "by_theta".

    orientation_curves : object, optional
            A list of curves. Needed for "by_curves".

    Returns
    -------
    object
            Returns None on success and a list of failed elements if any of the given elements fail to orient.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS

                laminate = base.GetFirstEntity(deck, "LAMINATE")
                elem = base.GetEntity(deck, "SHELL", 1148)
                curves = base.GetFirstEntity(deck, "CURVE")
                set = base.GetFirstEntity(deck, "SET")
                elems = base.CollectEntities(deck, set, "SHELL")

                base.LaminateLayerChangeOrientation(
                    deck, laminate, 1, 5, "by_curves", orientation_curves=curves, elements=elems
                )
                base.LaminateLayerChangeOrientation(
                    deck,
                    laminate,
                    1,
                    6,
                    "by_theta",
                    orientation_vector=(1, 0, -1),
                    orientation_element=elem,
                )
                base.LaminateLayerChangeOrientation(
                    deck, laminate, 1, 7, "by_vector", orientation_vector=(1, 0, 1)
                )


    """


def NewSubsystem(name: str, module_id: str, subtype: str, is_folder: bool) -> object:
    """

    This function creates a new Subsystem with its name and/or its module id given by the user.

    Parameters
    ----------
    name : str, optional
            The name of the new subsystem.
            If an existing subsystem has the same name, the function will fail.

    module_id : str, optional
            The Module Id of the new subsystem.
            If an existing subsystem has the same Module Id, the function will fail.

    subtype : str, optional
            The subtype of the new subsystem.
            Accepted values: "Regular", "Connecting"

    is_folder : bool, optional
            If True, function creates a simple Group Subsystem

    Returns
    -------
    object
            Returns a reference to the newly created subsystem object on success, or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                subsystem = base.NewSubsystem(
                    name="My_Name", module_id="My_Module_Id", subtype="Regular"
                )
                print(subsystem)

                child = base.NewSubsystem(name="child of group")
                folder = base.NewSubsystem(name="Parent", is_folder=True)
                base.AddToSubsystem(folder, child)
                print(folder)


            if __name__ == "__main__":
                main()


    """


def NewConfiguration(name: str, module_id: str) -> object:
    """

    This function creates a new Configuration with its name and/or its module id given by the user.

    Parameters
    ----------
    name : str, optional
            The name of the new Configuration.
            If an existing Configuration has the same name, the function will fail.

    module_id : str, optional
            The Module Id of the new Configuration.
            If an existing Configuration has the same Module Id, the function will fail.

    Returns
    -------
    object
            Returns a reference to the newly created configuration object on success, or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                configuration = base.NewConfiguration(name="My_Name", module_id="My_Module_Id")
                print(configuration)


    """


def KineticsConvertPosition(
    position: object,
    conversion_type: str,
    output_directory: str,
    locations_type: str,
    velocities_type: str,
    sets_type: str,
    use_position_name: bool,
    position_prefix_name: str,
    include_transform_file_name: str,
    include_trasform_full_path_names: bool,
    morph_nodes_file_name: str,
    output_kinetics: bool,
    deformed_bodies: object,
    include_transform_enable_file: bool,
    morph_nodes_enable_file: bool,
) -> int:
    """

    The function performs the conversion of Rigid Bodies locations and initial velocities to keywords that are
    written in deck files. It also takes into account possible deformed bodies through the Dummy Seat depenetration
    tool as long as the corresponding nodes hold initial foam keywords, and also possible morphed nodes that have
    been produced through the Kinematics-Morph coupling of ANSA.

    Parameters
    ----------
    position : object
            The KIN_POSITION object or list of objects.

    conversion_type : str
            The conversion type.
            The available options are 'locations', 'velocities' or 'both'.

    output_directory : str
            The directory that the files will be written out.

    locations_type : str, optional
            The available options are:
            LS-DYNA:  '*DEFINE_TRANSFORMATION'
                      '*NODE'
            PAMCRASH: 'TRSFM /'
                      'NODE /'.
            ABAQUS:   '*NMAP'
                      '*NODE'
            RADIOSS:  '/TRANSFORM'
                      '/NODE'.

            The default option is defined in ANSA Defaults.

    velocities_type : str, optional
            The available options are:
            LSDYNA:   '*INITIAL_VELOCITY_SET'
                      '*INITIAL_VELOCITY_GENERATION'
                      '*INITIAL_VELOCITY_NODE'.
            PAMCRASH: 'INVEL_SET /'
                      'INVEL_RIGID /'
                      'INVEL_NODE /'
            ABAQUS:   'ROTVEL,SET'
                      'ROTATING_VELOCITY'
                      'ROTVEL,NODE'
            RADIOSS:  '/INIVEL_SET'
                      '/INIVEL_NODE'.

            The default option is defined in ANSA Defaults.

    sets_type : str, optional
            The available options are:
            LSDYNA: '*SET_NODE_LIST'
                    '*SET_NODE_GENERAL'
            PAMCRASH: 'NODE'
                      'GENERAL'

            The default option is defined in ANSA Defaults.

    use_position_name : bool, optional
            Use Position's name as prefix for the created file.
            The default option is defined in ANSA Defaults.

    position_prefix_name : str, optional
            The prefix to be used for the created file.
            The default option is defined in ANSA Defaults.

    include_transform_file_name : str, optional
            LSDYNA: The name of the separate file to write out
            the *INCLUDE_TRANSFORM keywords.
            The default option is defined in ANSA Defaults.

    include_trasform_full_path_names : bool, optional
            LSDYNA: If a Rigid Body contains an *INCLUDE, the corresponding
             *INCLUDE_TRANSFORM that is going to be created will written out
            by using its FullPathName.
            The default option is defined in ANSA Defaults.

    morph_nodes_file_name : str, optional
            The name of the separate file to write out the morphed nodes.
            The default option is defined in ANSA Defaults.

    output_kinetics : bool, optional
            Output as ANSA comments the participating Kinetic entities.
            The default option is defined in ANSA Defaults.

    deformed_bodies : object, optional
            A list that contains the names of the Rigid Bodies that have been
            deformed through the Dummy-Seat Depenetration tool and their
            nodes hold initial foam keywords.
            For each of those nodes a set will be written out and the
            corresponding transformation keyword.

    include_transform_enable_file : bool, optional
            LSDYNA: Output *INCLUDE_TRANSFORM keywords in a separate file.
            In case there are Rigid Bodies that contain *INCLUDEs.
            The default option is defined in ANSA Defaults.

    morph_nodes_enable_file : bool, optional
            Output Morphed Nodes in a separate file.
            The default option is defined in ANSA Defaults.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def convert_position():
                kin_position = base.GetEntity(constants.LSDYNA, "KIN_POSITION", 1)
                error = base.KineticsConvertPosition(
                    position=kin_position,
                    conversion_type="locations",
                    output_directory="home/user/tests",
                    locations_type="*DEFINE_TRANSFORMATION",
                    use_position_name=True,
                    morph_nodes_file_name="Morphed.key",
                    output_kinetics=True,
                )
                return error


    """


def OutputEpilysis(filename: str, include: object, mode: str) -> int:
    """

    Outputs the model to EPILYSIS DB.

    Parameters
    ----------
    filename : str, optional
            Filename of EPILYSIS DB.
            (Default: "Untitled.edb", in the current directory)

    include : object, optional
            ANSA Include entity.

    mode : str, optional
            "all", "model" or "visible".
            (Default: "all")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputNastran("test.nas")
                base.OutputEpilysis("test.edb")


    """


def Epilysis(
    jobname: str,
    output_dir: str,
    mode: str,
    include: object,
    out_edb: bool,
    scratch_dir: str,
    run_meta: bool,
    meta_args: str,
) -> int:
    """

    Solves the model with the BETA EPILYSIS solver.

    Parameters
    ----------
    jobname : str, optional
            The job name. (Default: "Untitled.edb")

    output_dir : str, optional
            The output directory. By default the current directory.

    mode : str, optional
            One of "all", "visible" or "model".
            (Default: "all")

    include : object, optional
            The ANSA Include entity.

    out_edb : bool, optional
            True to output the EPILYSIS DB.
            (Default: False)

    scratch_dir : str, optional
            The scratch directory. By default the current directory.

    run_meta : bool, optional
            Run META on finish.
            (Default:False)

    meta_args : str, optional
            META arguments.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    OutputEpilysis

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # input test.nas and solve model
                base.InputNastran("test.nas")
                base.Epilysis(jobname="test.edb", mode="all")


    """


def GetPartFromName(name: str, type: str) -> object:
    """

    This function returns an "ANSAPART" or "ANSAGROUP",
    according to the "name" given as argument.

    This function can also return an "ANSA_CONFIGURATION" or "ANSA_SUBSYSTEM",
    if the second optional argument "type" is used.

    Parameters
    ----------
    name : str
            The name.

    type : str, optional
            The type of the entity.
            For Configurations use type: "ANSA_CONFIGURATION".
            For Subsystems use type: "ANSA_SUBSYSTEM".
            For Simulation Models use type: "ANSA_SIMULATION_MODEL"
            For Simulation Runs use type: "ANSA_SIMULATION_RUN"

    Returns
    -------
    object
            Returns a reference to the "ANSAPART" or "ANSAGROUP" with the specified Name.
            If such part does not exist None is returned.

            If the additional argument "type" has been used, this function returns
            an "ANSA_CONFIGURATION" or an "ANSA_SUBSYSTEM".

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromName("100")
                subsystem = base.GetPartFromName("100", type="ANSA_SUBSYSTEM")


    """


def Compare(
    parts: object,
    filename_in: str,
    file_type: str,
    input_deck: str,
    model1: object,
    model2: object,
    model1filenames: object,
    model1filetypes: object,
    model2filenames: object,
    model2filetypes: object,
    report_export_dir: str,
    meta_post_command: str,
    meta_post_script: str,
    ansa_post_script: str,
    c_state_export_dir: str,
    compare_action: str,
    matched_parts_map: object,
    report_filename: str,
    matched_diffs_list: object,
    dock_area: str,
) -> int:
    """

    Compares two models to identify the differences, based on the matching/diffing criteria specified in the
    ANSA.defaults.
    Three use cases are supported:
    -1st Use Case: Compare a list of parts of the current model with an incoming model. The incoming model can
     be an ANSA database, an Input file, or a Connection file.
    -2nd Use Case: Compare two models, which can be created through merge/input of ANSA databases/Input files.
    -3rd Use Case: Compare two models, where each model can consist of more than one files. The supported file
     types are ANSA database, Input file, and Connection file.

    Additionally, a series of optional actions are provided and the user can:

    - export a report with the identified differences in PDF, PPTX, XLSX, and CSV formats,
    - save the comparison results list for future use,
    - apply the made decisions (by default the entities of Model 2 are kept),
    - leave the comparison process open for further manual handling, and
    - cancel the comparison process.

    Parameters
    ----------
    parts : object, optional
            (1st Use Case) A list with the parts of the current model to be
            compared.

    filename_in : str, optional
            (1st Use Case) The full path of the incoming model.

    file_type : str, optional
            (1st Use Case) The type of the file of the incoming model. It can be
            'AnsaDB' for ANSA database, 'DeckFile' for Input file, and 'VIP', 'VIP2',
            'XML' for the respective Connection file.
            (Default: 'AnsaDB')

    input_deck : str, optional
            (1st Use Case) The type of the Input file if the incoming model e.g.
            'Nastran', 'LsDyna', 'PamCrash', 'Abaqus', 'Radioss', 'Ansys', etc.
            (If the file_type = 'DeckFile'). The default value is the current deck.

    model1 : object, optional
            (2nd Use Case) The 1st model to be compared (it can be created through
            the CreateNewAnsaModel script function).

    model2 : object, optional
            (2nd Use Case) The 2nd model to be compared (it can be created through
            the CreateNewAnsaModel script function).

    model1filenames : object, optional
            (3rd Use Case) A list with the full paths of the files which constitute
            Model 1.

    model1filetypes : object, optional
            (3rd Use Case) A list with the types of the files included in the
            model1filenames list. They can be 'ANSA_DB_TYPE' for ANSA database,
            'INPUT_FILE_TYPE' for Input file, and 'CONN_VIP_TYPE', 'CONN_VIP2_TYPE',
            'CONN_XML_TYPE' for the respective Connection files.

    model2filenames : object, optional
            (3rd Use Case) A list with the full paths of the files which constitute
            Model 2.

    model2filetypes : object, optional
            (3rd Use Case) A list with the types of the files included in the
            model2filenames list. They can be 'ANSA_DB_TYPE' for ANSA database,
            'INPUT_FILE_TYPE' for Input file, and 'CONN_VIP_TYPE', 'CONN_VIP2_TYPE',
            'CONN_XML_TYPE' for the respective Connection files.

    report_export_dir : str, optional
            The full path of the directory where all the data, which are needed
            for the generation of the report, are exported.

    meta_post_command : str, optional
            The full path of the META PostProcessor executable. META PostProcessor
            is used for the generation of the PDF and PPTX reports.

    meta_post_script : str, optional
            The full path of the script used for the generation of the PDF and
            PPTX reports.

    ansa_post_script : str, optional
            The full path of the script used for the generation of the CSV and
            XLSX reports.

    c_state_export_dir : str, optional
            The full path of the ".ansa_compare" file, where the comparison
            results list will be saved.

    compare_action : str, optional
            Defines the action taken once the comparison process is completed.
            It can be 'OK' to apply the made decisions (by default the entities of
            Model 2 are kept), 'SHOW_CARD' to keep the Compare Report window
            open, 'SHOW_COMPARE_OPTIONS_AND_CARD' to keep the Advanced
            View Options and the Compare Report windows open, and 'CANCEL' to
            cancel the comparison process.
            (Default: 'CANCEL)'

    matched_parts_map : object, optional
            A dictionary with the ANSA Ids of the matched parts. The Ids of Model 1
            are set as keys and the Ids of Model 2 are set as values. This argument is
            given by the user and it is filled in during the execution of the function.
            As a result the length of the dictionary is the number of the matched parts.
            The ANSA Ids refer to Model 1 and Model 2, and if these Models are merged,
            the returned Ids are invalid.

    report_filename : str, optional
            Defines the file name of the generated report.

    matched_diffs_list : object, optional
            A list in which two dictionaries are appended, one for each of the
            Compare Models (Model 1 and Model 2). Each of the dictionaries contain
            the Ids of the matched parts as keys and the percentage difference as
            value. This argument is given by the user and it is filled in during the
            execution of the function. As a result the length of the dictionaries is
            the number of the matched parts for each Model. The ANSA Ids refer to
            Model 1 and Model 2, and if these Models are merged, the returned Ids
            are invalid. The length of the input list is increased by 2.

    dock_area : str, optional
            Defines the location where the "Compare Report" window will be docked.
            The accepted values are "LeftDockArea".

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils
            from ansa import constants


            def Use_Case_01():
                part1 = base.GetPartFromModuleId("module_id_of_part_01")
                part2 = base.GetPartFromModuleId("module_id_of_part_02")
                selected_parts = [part1, part2]
                ret = base.Compare(
                    parts=selected_parts,
                    filename_in="/path/to/incoming/model/input_file.nas",
                    file_type="DeckFile",
                    input_deck="Nastran",
                    report_export_dir="/path/to/export/directory/",
                    meta_post_command="/path/to/mETA_Post/executable/meta_post64.sh",
                    meta_post_script="/path/to/script/CompareReport.pyb",
                    compare_action="CANCEL",
                )


            def Use_Case_02():
                model_01 = base.CreateNewAnsaModel()
                base.SetCurrentAnsaModel(model_01)
                utils.Merge("/path/to/ansa/database/of/model_01/ansa_file.ansa")

                model_02 = base.CreateNewAnsaModel()
                base.SetCurrentAnsaModel(model_02)
                base.InputNastran("/path/to/nastran/file/of/model_02/nastran_file.nas")

                base.SetCurrentDeck(constants.NASTRAN)
                base.Compare(model1=model_01, model2=model_02, compare_action="SHOW_CARD")


            def Use_Case_03():
                files_of_model_01 = ["/path/to/file_01/of/model_01/ansa_file.ansa"]
                types_of_model_01_files = ["ANSA_DB_TYPE"]
                files_of_model_02 = [
                    "/path/to/file_01/of/model_02/input_file.nas",
                    "/path/to/file_02/of/model_02/conn_file.xml",
                ]
                types_of_model_02_files = ["INPUT_FILE_TYPE", "CONN_XML_TYPE"]

                base.SetCurrentDeck(constants.NASTRAN)
                base.SetANSAdefaultsValues({"Geometry_Matching_Similarity": "95"})
                base.Compare(
                    model1filenames=files_of_model_01,
                    model1filetypes=types_of_model_01_files,
                    model2filenames=files_of_model_02,
                    model2filetypes=types_of_model_02_files,
                    c_state_export_dir="/path/to/comparison/results/file/comparison_results.ansa_compare",
                    compare_action="CANCEL",
                )


            # General Note: The created models remain in the ANSA session after the completion
            # of the comparison process. Please use the base.DestroyAnsaModel to remove a model.


    """


def LaminateRosetteInfo(
    deck: int, laminate: object, rosette: int, fields: object
) -> object:
    """

    Gets values from a Rosette for the specified laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH.

    laminate : object
            A reference to a laminate Property.

    rosette : int
            The id of the rosette to get its values.

    fields : object
            A list of the fields to retrieve info.

            Available fields are:

            name:       The name of the rosette.
            position:   A list with the coordinates of the position vector (x,y,z).
            direction:  A list with the coordinates of the direction vector (x, y, z).
            reference:  A list with the coordinates of the reference vector (x,y,z).
            coordinate: An object of the coordinate system if the rosette is defined on a coordinate,
                        or None if it isn't.

    Returns
    -------
    object
            Returns a dictionary with keys the 'fields' values.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.GetEntity(constants.ABAQUS, "LAMINATE", 1)
                ret = base.LaminateRosetteInfo(
                    constants.ABAQUS,
                    laminate,
                    1,
                    ("name", "position", "direction", "reference", "coordinate"),
                )
                print(ret["name"])
                print(ret["position"])
                print(ret["direction"])
                print(ret["reference"])
                print(ret["coordinate"]._id)


    """


def BlockRedraws(block: bool) -> int:
    """

    This function is used to block and unblock any drawing action in ANSA main GL area.
    It is used to block/unblock any drawing update actions, in case drawing while in the
    middle of some procedure is unwanted or time consuming.

    Parameters
    ----------
    block : bool
            Set this variable to 'True' to block all redraw actions or 'False' to enable drawing again.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.BlockRedraws(True)

                # Functionality which requires that drawing is blocked
                base.BlockRedraws(False)


    """


def SCTetraCreateRegionsForUnreferencedProperties() -> int:
    """

    This function automatically creates REGIONs in SC TETRA deck for every PSHELL and PSOLID that are
    not referenced by any REGION. It works on the whole model, and thus, it takes no arguments.

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SCTetraCreateRegionsForUnreferencedProperties()


    """


def CreateNewAnsaWindow(name: str) -> object:
    """

    Creates a new ANSA window with the given name.

    Parameters
    ----------
    name : str, optional
            The name of the window that will be created.

    Returns
    -------
    object
            Returns a reference to the newly created window object.

    See Also
    --------
    GetAnsaWindow, GetAnsaWindowName

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_window")
                print(window)


    """


def GetAnsaWindow(name: str) -> object:
    """

    Returns a reference to the ANSA window with the given name.

    Parameters
    ----------
    name : str
            The name of the requested ANSA window.

    Returns
    -------
    object
            Returns a reference to the ANSA window with the given name.

    See Also
    --------
    CreateNewAnsaWindow, GetAnsaWindowName

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_win")
                print(window)
                window1 = base.GetAnsaWindow("my_win")
                print(window1)


    """


def GetAnsaWindowName(window: object) -> str:
    """

    Returns the name of the given ANSA window.

    Parameters
    ----------
    window : object
            A reference to the ANSA Window to retrieve its name.

    Returns
    -------
    str
            Returns the name of the requested ANSA window.

    See Also
    --------
    CreateNewAnsaWindow, GetAnsaWindow

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_win")
                print(window)

                win_name = base.GetAnsaWindowName(window1)
                print(win_name)


    """


def LoadAnsaModelToAnsaWindow(model: Entity, window: object) -> None:
    """

    Loads a model to an ANSA window.

    Parameters
    ----------
    model : Entity
            A reference to the model.

    window : object
            A reference to the ANSA window.

    Returns
    -------
    None
            Always returns None.

    See Also
    --------
    LoadAllAnsaModelsToAnsaWindow

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_win")
                cur_model = base.GetCurrentAnsaModel()

                base.LoadAnsaModelToAnsaWindow(cur_model, window)


    """


def LoadAllAnsaModelsToAnsaWindow(window: object) -> None:
    """

    Loads all the existing models to the given ANSA window.

    Parameters
    ----------
    window : object
            A reference to the ansa window.

    Returns
    -------
    None
            Always returns None.

    See Also
    --------
    LoadAnsaModelToAnsaWindow

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_win")
                base.LoadAllAnsaModelsToAnsaWindow(window1)


    """


def SyncWindows(windows: object) -> object:
    """

    Syncronizes the views of listed ANSA windows.

    Parameters
    ----------
    windows : object, optional
            A list of the requested ANSA windows to be synchronized.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_win")
                window1 = base.GetAnsaWindow("Main Window")

                base.SyncWindows((window, window1))


    """


def CloseAnsaWindow(window: object) -> object:
    """

    Closes an existing Ansa window.

    Parameters
    ----------
    window : object
            A reference to the window to be closed.

    Returns
    -------
    object
            Always returns None.

    See Also
    --------
    GetAnsaWindow

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.GetAnsaWindow("Window 1")
                base.CloseAnsaWindow(window)


    """


def UnloadAnsaModelFromAnsaWindow(model: Entity, window: object) -> None:
    """

    Unloads a model from an ANSA window.

    Parameters
    ----------
    model : Entity
            The model to unload.

    window : object
            The respective ANSA window.

    Returns
    -------
    None
            Always returns None.

    See Also
    --------
    UnloadAllAnsaModelsFromAnsaWindow, LoadAnsaModelToAnsaWindow, LoadAllAnsaModelsToAnsaWindow

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_win")
                cur_model = base.GetCurrentAnsaModel()
                base.UnloadAnsaModelFromAnsaWindow(cur_model, window)


    """


def UnloadAllAnsaModelsFromAnsaWindow(window: object) -> None:
    """

    Unloads all models loaded in an ANSA window.

    Parameters
    ----------
    window : object
            The respective ANSA window.

    Returns
    -------
    None
            Always returns None.

    See Also
    --------
    UnloadAnsaModelFromAnsaWindow, LoadAnsaModelToAnsaWindow, LoadAllAnsaModelsToAnsaWindow

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.CreateNewAnsaWindow("my_win")
                base.UnloadAllAnsaModelsFromAnsaWindow(window)


    """


def SmoothResultFeatureBased(
    result: object,
    flatten_top: float,
    flatten_bottom: float,
    zero_abs_range: float,
    cutoff_curvature: float,
    cutoff_displacement: float,
) -> int:
    """

    Function for applying feature based smoothing on a created result.

    Parameters
    ----------
    result : object
            An OpenFoam result object.

    flatten_top : float, optional
            Values greater than the one defined will be flattened.

    flatten_bottom : float, optional
            Values smaller than the one defined will be flattened.

    zero_abs_range : float, optional
            Set to 0 to absolute values smaller than the one defined.

    cutoff_curvature : float, optional
            Mean curvature in each node is checked and if its ratio is below
            this value the node is omitted. Values should be in the 0-1 range.
            (Default: 0, Nothing is ommited)

    cutoff_displacement : float, optional
            It's the ratio of the vector measure, from which and below
            the vector will be omitted.

    Returns
    -------
    int
            Returnd 0 on success and 1 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                sens = base.GetEntity(constants.OPENFOAM, "RESULT", 1)
                base.SmoothResultFeatureBased(
                    sens,
                    flatten_top=10000.0,
                    flatten_bottom=-10000.0,
                    zero_abs_range=0.0,
                    cutoff_curvature=0.15,
                    cutoff_displacement=0.1,
                )
                base.OutputResult(sens, "sens1_python.txt", 0)


    """


def GetFacesOfHotPoints(hot_points: object) -> object:
    """

    Returns a list with the faces that the input hot points belong to.

    Parameters
    ----------
    hot_points : object
            A hot point entity, a hot point ID, a list of hot point entities,
            a list of hot point IDs, or a list of hot point entities and IDs.

    Returns
    -------
    object
            A list with the faces that the input hot points belong to.

    See Also
    --------
    GetFacesOfCons, GetMacrosOfCons, GetMacrosOfHotPoints, GetConsOfHotPoints, GetPerimetersOfHotPoints

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def GetFacesOfHotPointsFromListOfHotPointsEntitiesDemo():
                # collect all hot points of data-base
                hots_list = base.CollectEntities(constants.NASTRAN, None, "HOT POINT")
                # collect adjacent faces of hot points contained in list hots_list
                faces_list = base.GetFacesOfHotPoints(hots_list)
                # pick faces contained in list faces_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces_list)


            def GetFacesOfHotPointsFromSingleHotPointEntityDemo():
                # collect hot point with ID 2165 from data-base (## Change here to desired ID ##)
                hot_entity = base.GetEntity(constants.NASTRAN, "HOT POINT", 2165)
                # collect adjacent faces of hot point entity
                faces_list = base.GetFacesOfHotPoints(hot_entity)
                # pick faces contained in list faces_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces_list)


            def GetFacesOfHotPointsFromListOfHotPointIDsDemo():
                # Define a list of hot point IDs (## Change here to desired IDs ##)
                hots_ids_list = [2168, 2161, 1719]
                # collect adjacent faces of hot points contained in list hots_ids_list
                faces_list = base.GetFacesOfHotPoints(hots_ids_list)
                # pick faces contained in list faces_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces_list)


            def GetFacesOfHotPointFromSingleHotPointIDDemo():
                # collect adjacent faces of hot point with ID 2168 (## Change here to desired ID ##)
                faces_list = base.GetFacesOfHotPoints(2168)
                # pick faces contained in list faces_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces_list)


            def GetFacesOfHotPoinsFromListOfHotPointEntitiesAndIDsDemo():
                # Define a list of hot point entities/IDs (## Change here to desired IDs ##)
                hots_list = [2168, base.GetEntity(constants.NASTRAN, "HOT POINT", 2165), 1752]
                # collect adjacent faces of  hot points contained in list hots_list
                faces_list = base.GetFacesOfHotPoints(hots_list)
                # pick faces contained in list faces_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces_list)


    """


def GetMacrosOfHotPoints(hot_points: object) -> object:
    """

    Returns a list with the macros that the input hot points belong to.

    Parameters
    ----------
    hot_points : object
            A hot point entity, a hot point ID, a list of hot point entities, a list of hot point IDs,
            or a list of hot point entities and IDs.

    Returns
    -------
    object
            Returns a list with the macros that the input hot points belong to.

    See Also
    --------
    GetFacesOfCons, GetMacrosOfCons, GetFacesOfHotPoints, GetConsOfHotPoints, GetPerimetersOfHotPoints

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def GetMacrosOfHotPointsFromListOfHotPointsEntitiesDemo():
                # collect all hot points of data-base
                hots_list = base.CollectEntities(constants.NASTRAN, None, "HOT POINT")
                # collect adjacent macros of hot points contained in list hots_list
                macros_list = base.GetMacrosOfHotPoints(hots_list)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfHotPointsFromSingleHotPointEntityDemo():
                # collect hot point with ID 2165 from data-base (## Change here to desired ID ##)
                hot_entity = base.GetEntity(constants.NASTRAN, "HOT POINT", 2165)
                # collect adjacent macros of hot point entity
                macros_list = base.GetMacrosOfHotPoints(hot_entity)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfHotPointsFromListOfHotPointIDsDemo():
                # Define a list of hot point IDs (## Change here to desired IDs ##)
                hots_ids_list = [2168, 2161, 1719]
                # collect adjacent macros of hot points contained in list hots_ids_list
                macros_list = base.GetMacrosOfHotPoints(hots_ids_list)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfHotPointFromSingleHotPointIDDemo():
                # collect adjacent macros of hot point with ID 2168 (## Change here to desired ID ##)
                macros_list = base.GetFacesOfHotPoints(2168)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


            def GetMacrosOfHotPoinsFromListOfHotPointEntitiesAndIDsDemo():
                # Define a list of hot point entities/IDs (## Change here to desired IDs ##)
                hots_list = [2168, base.GetEntity(constants.NASTRAN, "HOT POINT", 2165), 1752]
                # collect adjacent macros of  hot points contained in list hots_list
                macros_list = base.GetFacesOfHotPoints(hots_list)
                # pick macros contained in list macros_list
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=macros_list)


    """


def GetConsOfHotPoints(hot_points: object) -> object:
    """

    Returns a list with the adjacent CONS of the input hot points.

    Parameters
    ----------
    hot_points : object
            A hot point entity, or a hot point ID, or a list of hot point entities,
            or a list of hot point IDs, or a list of hot point entities and IDs.

    Returns
    -------
    object
            A list with the adjacent CONS of the input hot points.

    See Also
    --------
    GetFacesOfCons, GetMacrosOfCons, GetMacrosOfHotPoints, GetPerimetersOfHotPoints

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def GetConsOfHotPointsFromListOfHotPointsEntitiesDemo():
                # collect all hot points of data-base
                hots_list = base.CollectEntities(constants.NASTRAN, None, "HOT POINT")
                # collect adjacent CONS of hot points contained in list hots_list
                cons_list = base.GetConsOfHotPoints(hots_list)
                # pick CONS contained in list cons_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=cons_list)


            def GetConsOfHotPointsFromSingleHotPointEntityDemo():
                # collect hot point with ID 2165 from data-base (## Change here to desired ID ##)
                hot_entity = base.GetEntity(constants.NASTRAN, "HOT POINT", 2165)
                # collect adjacent CONS of hot point entity
                cons_list = base.GetConsOfHotPoints(hot_entity)
                # pick CONS contained in list cons_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=cons_list)


            def GetConsOfHotPointsFromListOfHotPointIDsDemo():
                # Define a list of hot point IDs (## Change here to desired IDs ##)
                hots_ids_list = [2168, 2161, 1719]
                # collect adjacent CONS of hot points contained in list hots_ids_list
                cons_list = base.GetConsOfHotPoints(hots_ids_list)
                # pick CONS contained in list cons_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=cons_list)


            def GetConsOfHotPointFromSingleHotPointIDDemo():
                # collect adjacent CONS of hot point with ID 2161 (## Change here to desired ID ##)
                cons_list = base.GetConsOfHotPoints(hot_points=2161)
                # pick CONS contained in list cons_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=cons_list)


            def GetConsOfHotPoinsFromListOfHotPointEntitiesAndIDsDemo():
                # Define a list of hot point entities/IDs (## Change here to desired IDs ##)
                hots_list = [
                    2168,
                    base.GetEntity(constants.NASTRAN, "HOT POINT", element_id=2165),
                    1752,
                ]
                # collect adjacent CONS of  hot points contained in list hots_list
                cons_list = base.GetConsOfHotPoints(hots_list)
                # pick CONS contained in list cons_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=cons_list)


    """


def GetPerimetersOfHotPoints(hot_points: object) -> object:
    """

    Returns a list with the adjacent perimeters of the input hot points.

    Parameters
    ----------
    hot_points : object
            A hot point entity, a hot point ID, a list of hot point entities, a list of hot point IDs,
            or a list of hot point entities and IDs.

    Returns
    -------
    object
            A list with the adjacent perimeters of the input hot points.

    See Also
    --------
    GetFacesOfCons, GetMacrosOfCons, GetMacrosOfHotPoints, GetConsOfHotPoints

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def GetPerimetersOfHotPointsFromListOfHotPointsEntitiesDemo():
                # collect all hot points of data-base
                hots_list = base.CollectEntities(constants.NASTRAN, None, "HOT POINT")
                # collect adjacent perimeters of hot points contained in list hots_list
                perims_list = base.GetPerimetersOfHotPoints(hots_list)
                # pick perimeters contained in list perims_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=perims_list)


            def GetPerimetersOfHotPointsFromSingleHotPointEntityDemo():
                # collect hot point with ID 2165 from data-base (## Change here to desired ID ##)
                hot_entity = base.GetEntity(constants.NASTRAN, "HOT POINT", 2165)
                # collect adjacent perimeters of hot point entity
                perims_list = base.GetPerimetersOfHotPoints(hot_entity)
                # pick perimeters contained in list perims_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=perims_list)


            def GetPerimetersOfHotPointsFromListOfHotPointIDsDemo():
                # Define a list of hot point IDs (## Change here to desired IDs ##)
                hots_ids_list = [2168, 2161, 1719]
                # collect adjacent perimeters of hot points contained in list hots_ids_list
                perims_list = base.GetPerimetersOfHotPoints(hots_ids_list)
                # pick perimeters contained in list perims_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=perims_list)


            def GetPerimetersOfHotPointFromSingleHotPointIDDemo():
                # collect adjacent perimeters of hot point with ID 2161 (## Change here to desired ID ##)
                perims_list = base.GetPerimetersOfHotPoints(2161)
                # pick perimeters contained in list perims_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=perims_list)


            def GetPerimetersOfHotPoinsFromListOfHotPointEntitiesAndIDsDemo():
                # Define a list of hot point entities/IDs (## Change here to desired IDs ##)
                hots_list = [2168, base.GetEntity(constants.NASTRAN, "HOT POINT", 2165), 1752]
                # collect adjacent perimeters of  hot points contained in list hots_list
                perims_list = base.GetPerimetersOfHotPoints(hots_list)
                # pick perimeters contained in list perims_list
                base.PickEntities(constants.NASTRAN, "CONS", initial_entities=perims_list)


    """


def FacesCut(
    node1: object,
    node2: object,
    heal: bool,
    cut_option: object,
    auto_remesh_flg: object,
) -> object:
    """

    Applies a parametric cut between input hot points and returns created faces, or a plane cut defined by a normal vector.

    Parameters
    ----------
    node1 : object
            Either a hot point entity or a hot point ID.

    node2 : object
            Either a hot point entity or a hot point ID.

    heal : bool, optional
            True for heal-cut, False (default) otherwise.

    cut_option : object, optional
            A dictionary containing tuples of string values 'parametrical' or 'plane' -
            a triple of floats defining the normal vector of the cutting plane.
            Triple of floats may not be given, in case that the string value equals
            to 'parametrical'.
            If the dictionary is not given, parametrical cut is the default state.

    auto_remesh_flg : object, optional
            If True and macros are meshed, cut and macros (that are affected)
            remeshing will take place.

    Returns
    -------
    object
            Returns a list with the created faces.

    See Also
    --------
    PlaneCut

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def FacesCutEntityEntityDemo():
                # Get hot point with ID 2128 (## change to desired ID ##)
                hot1 = base.GetEntity(constants.NASTRAN, "HOT POINT", 2128)
                # Get hot point with ID 2215 (## change to desired ID ##)
                hot2 = base.GetEntity(constants.NASTRAN, "HOT POINT", 2215)
                # Apply parametric cut between hot1 and hot2
                faces = base.FacesCut(hot1, hot2)
                # Pick created faces
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces)


            def FacesCutIDIDDemo():
                # Apply parametric cut between hot point with ID 2128 and hot point with ID 2215 (## change to desired ID ##)
                faces = base.FacesCut(2128, 2215)
                # Pick created faces
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces)


            def FacesCutEntityIDDemo():
                # Get hot point with ID 2128 (## change to desired ID ##)
                hot = base.GetEntity(constants.NASTRAN, "HOT POINT", 2128)
                # Apply parametric cut between hot and hot point with ID 2215 (## change to desired ID ##)
                faces = base.FacesCut(hot, 2215)
                # Pick created faces
                base.PickEntities(constants.NASTRAN, "FACE", initial_entities=faces)


            def FacesCutParametrical_with_dict():
                arg1 = base.GetEntity(constants.NASTRAN, "HOT POINT", 740)
                arg2 = base.GetEntity(constants.NASTRAN, "HOT POINT", 484)
                arg4 = {}
                arg4["parametrical"] = ()
                base.FacesCut(node1=arg1, node2=arg2, cut_option=arg4, auto_remesh_flg=True)


            def FacesCutPlane_with_dict():
                arg1 = base.GetEntity(constants.NASTRAN, "HOT POINT", 481)
                arg2 = base.GetEntity(constants.NASTRAN, "HOT POINT", 223)
                arg4 = {}
                arg4["plane"] = (
                    -0.538766,
                    0.464963,
                    0.545686,
                )
                base.FacesCut(
                    node1=arg1, node2=arg2, heal=False, cut_option=arg4, auto_remesh_flg=False
                )


    """


def CadToAnsa(
    parts: object,
    file_type_priority: str,
    num_of_parallel_jobs: int,
    time_out_limit: int,
    dm_path: str,
    representation_name: str,
    check_for_other_representations: bool,
    script_per_part_file_name: str,
    script_per_part_function_name: str,
    script_all_parts_file_name: str,
    script_all_parts_function_name: str,
    reload_parts: bool,
    open_window: bool,
    report_dir: str,
    check_in_dm: bool,
    ansa_executable: str,
    check_in_dm_representation_priority: str,
    use_attached_ansa_files_instead_of_checking_in_dm: str,
    conflict_nodes: str,
    conflict_properties: str,
    conflict_materials: str,
    conflict_sets: str,
    conflict_coords: str,
    conflict_bc_sets: str,
    open_group_files: bool,
    use_always_the_ansa_feature: bool,
    check_in_dm_ignore_status: str,
    conflict_sections: str,
    conflict_hourglass: str,
    conflict_eos: str,
    conflict_functions: str,
    parallel_jobs_execution: str,
    connection_timeout: int,
) -> int:
    """

    This function calls the CAD to ANSA functionality.

    Parameters
    ----------
    parts : object, optional
            A list of parts for which CadToAnsa will run. If this
            argument is missing, all parts of the ANSA database
            will be sent to the function.

    file_type_priority : str, optional
            Set the suggested file type priority eg. 'jt, CATPart, igs'.
            Default value is undefined.

    num_of_parallel_jobs : int, optional
            Define how many processes will be launched to work in parallel.
            Use the number 0 to denote that no parallel processes should
            be launched.
            (Default: 0)

    time_out_limit : int, optional
            Maximum allowed time (in minutes) before a process
            is considered as blocked.
            Blocked processes will be forced to finish.
            (Default: 30)

    dm_path : str, optional
            The DM path in which the parts will be saved. Alternatively,
            the value "current" can be given to denote the usage of the
            current DM path or the value "temporary" to denote the usage
            of a temporary DM that will be deleted after usage.
            (Default: "temporary")

    representation_name : str, optional
            Representation name of the new translated parts that
            will be saved in DM.
            (Default: "translated_cad")

    check_for_other_representations : bool, optional
            In case the desired Representation does not exist in DM,
            reload any other existing Representation name.
            (Default: True)

    script_per_part_file_name : str, optional
            Script that will be called after translating every part file.
            This script will be called one time for every part.
            By default, no such script will be used.

    script_per_part_function_name : str, optional
            The function name to be called on the script specified
            by: "script_per_part_file_name".
            By default, no such function name will be used.

    script_all_parts_file_name : str, optional
            Script that will be called after opening all parts.
            This script will be called only one time at the end.
            By default, no such script will be used.

    script_all_parts_function_name : str, optional
            Script that will be called after opening all parts.
            This script will be called only one time at the end.
            By default, no such function name will be used.

    reload_parts : bool, optional
            Set to False if the parts should not reloaded from DM.
            (Default: True)

    open_window : bool, optional
            Set to True if the CAD to ANSA Settings window should
            open before execution.
            (Default: False)

    report_dir : str, optional
            The directory in which the report files should be placed.

    check_in_dm : bool, optional
            Set to False if you want to skip checking for available
            representations in DM.
            (Default: True)

    ansa_executable : str, optional
            Define a specific ANSA executable to be used when
            CAD to ANSA runs in parallel.

    check_in_dm_representation_priority : str, optional
            Define the priority of Representation names to be
            checked in DM, e.g. 'crash, nvh, dura'.

    use_attached_ansa_files_instead_of_checking_in_dm : str, optional
            Give priority to open the attached ANSA or Solver files instead of reloading the part form DM.

    conflict_nodes : str, optional
            Determine how to resolve conflicts on Nodes during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_properties : str, optional
            Determine how to resolve conflicts on Properties during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_materials : str, optional
            Determine how to resolve conflicts on Materials during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_sets : str, optional
            Determine how to resolve conflicts on Sets during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_coords : str, optional
            Determine how to resolve conflicts on Coords during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_bc_sets : str, optional
            Determine how to resolve conflicts on Bc Sets during merge.
            Accepted values: "Offset", "Keep old".
            Default value: "Offset".

    open_group_files : bool, optional
            Defines if the attached files of groups will be opened.
            Default value: False.

    use_always_the_ansa_feature : bool, optional
            Defines if the parallel workers will always use the ANSA BETA LM feature or if it will be chosen automatically depending on the CAD file type.
            Default value: False

    check_in_dm_ignore_status : str, optional
            When checking in DM, ignore parts with specific DM/Status value. Example: 'WIP, Draft, In progress'.

    conflict_sections : str, optional
            Determine how to resolve conflicts on Sections during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_hourglass : str, optional
            Determine how to resolve conflicts on Hourglass during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_eos : str, optional
            Determine how to resolve conflicts on Eos during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    conflict_functions : str, optional
            Determine how to resolve conflicts on Functions during merge.
            Accepted values: "Offset", "Keep old", "Keep new".
            Default value: "Offset".

    parallel_jobs_execution : str, optional
            Define if the parallel jobs will be executed locally or remotely from a SPDRM client. This option is available only when connected to a SPDRM with version > 1.6.0
            Accepted values: "Locally", "Remotely"
            Default value: "Locally"

    connection_timeout : int, optional
            Define how many minutes the ANSA workers will wait until they find an avaialable licence.
            Default value: 5 minutes

    Returns
    -------
    int
            Returns 0 if the CAD to ANSA procedure has been executed successfully and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Example 1:
                # Send all parts of the database to 'CAD to ANSA'
                # by using only the default values of arguments
                base.CadToAnsa()

                # Example 2
                # Send only two parts to 'CAD to ANSA'
                # with some arguments given.
                part1 = base.GetPartFromModuleId("A")
                part2 = base.GetPartFromModuleId("B")
                base.CadToAnsa(
                    parts=[part1, part2],  # specific parts
                    num_of_parallel_jobs=0,  # without parallel processes
                    dm_path="current",  # use the current dm_path
                )

                # Example 3
                # Send all parts of the database to 'CAD to ANSA'
                # with all arguments given.
                base.CadToAnsa(
                    file_type_priority="CATPart, jt",
                    num_of_parallel_jobs=3,
                    time_out_limit=40,
                    dm_path="C:/Users/TestUser/DM/",
                    representation_name="test_cad",
                    check_for_other_representations=True,
                    script_per_part_file_name="C:/Users/TestUser/PerPart.py",
                    script_per_part_function_name="mainPerPart",
                    script_all_parts_file_name="C:/Users/TestUser/AllParts.py",
                    script_all_parts_function_name="mainAllParts",
                    reload_parts=False,
                    open_window=True,
                    report_dir="C:/Users/TestUser/CadToAnsaReports/",
                    check_in_dm=True,
                    check_in_dm_representation_priority="crash, nvh, dura",
                )


    """


def SurfaceExtrudeExtrude(
    select_entities: object,
    dir_entities: object,
    direction_method: int,
    internal_face: bool,
    respect_user_selection: bool,
    point1: object,
    point2: object,
    distance: float,
    part: object,
    property: object,
    mirror: bool,
    volumes: bool,
    ret_ents: bool,
) -> int:
    """

    This function works in the same principle as the Sweep function of the same menu.
    It creates a surface out of an extruded profile.
    When a surface is created, the topological conditions are automatically generated.

    Parameters
    ----------
    select_entities : object
            Is a list of entities for the extrusion surface. It can be either
            Cons/Curves/ or Faces.

    dir_entities : object
            Is a list of entities which defines the directrix (a chain of CONS or
            3D-curve segments) of the extrusion.

    direction_method : int
            If 0, the extrusion performs by two points that defines the direction,
            else directrix is being activated.

    internal_face : bool
            If True, result forms a closed volume or volumes where the internal
            faces are created.

    respect_user_selection : bool
            If True, then the order of entries in entities will be respected and thus
            Faces will be created according to that order.

    point1 : object, optional
            Is a list with x, y, z double coordinates that indicates the start of the
            direction, in case that direction_method equals to 0.

    point2 : object, optional
            Is a list with x, y, z double coordinates that indicates the end of the
            direction, in case that direction_method equals to 0.

    distance : float, optional
            If direction_method equals to 0 and distance is given, the length of the
            created face(s) is equal to that input, otherwise the length is equal to the
            distance of the vector that define point1 and point2.

    part : object, optional
            Is the part for the created face(s).

    property : object, optional
            Is the property for the created faces(s).

    mirror : bool, optional
            If True bidirectionally extruded faces are being created , while direction_method equals to 0.
            Default value is False.

    volumes : bool, optional
            If True, in case select_entities named_argument contains face(s), Volume creation takes place.
            Default value is False.

    ret_ents : bool, optional
            If True returns created faces.
            Default value is False.

    Returns
    -------
    int
            It returns 1 if faces were created. Otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def SurfExtrudeExtrude_faces():
                dir_entities = []
                sel_entities = []
                sel_entities2 = []

                sel_entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 1))
                sel_entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 2))

                sel_entities2.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 19))
                sel_entities2.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 20))

                dir_entities.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 1))
                dir_entities.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 7))
                dir_entities.append(base.GetEntity(ansa.constants.NASTRAN, "CURVE", 2))

                point1 = []
                point2 = []

                point1.append(-100.0)
                point1.append(-100.0)
                point1.append(0.0)

                point2.append(-100.0)
                point2.append(50.0)
                point2.append(0.0)

                face1 = base.GetEntity(ansa.constants.NASTRAN, "FACE", 1)
                part = base.GetEntityPart(face1)
                pid = base.GetEntity(ansa.constants.NASTRAN, "PSHELL", 2)

                surf_extr_extr = base.SurfaceExtrudeExtrude(
                    select_entities=sel_entities,
                    dir_entities=dir_entities,
                    direction_method=0,
                    internal_face=False,
                    respect_user_selection=False,
                    point1=point1,
                    point2=point2,
                    distance=100.0,
                    part=part,
                    property=pid,
                )
                print("SURFACE_EXTRUDE_EXTRUDE = ", surf_extr_extr)


            def main():
                # ---------------------------------
                arg1 = []
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 513673))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CONS", 512173))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 105844))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 105821))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 105609))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 105581))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 105560))
                arg2 = []
                arg6 = []
                arg6.append(1360.55)
                arg6.append(688.339)
                arg6.append(385.535)
                arg7 = []
                arg7.append(1360.55)
                arg7.append(915.645)
                arg7.append(385.535)
                ret = ansa.base.SurfaceExtrudeExtrude(
                    select_entities=arg1,
                    dir_entities=arg2,
                    direction_method=0,
                    internal_face=False,
                    respect_user_selection=False,
                    point1=arg6,
                    point2=arg7,
                    distance=227.306,
                    mirror=False,
                    volumes=True,
                    ret_ents=True,
                )

                if not isinstance(ret, list):
                    print(ret)
                else:
                    print("Containers len = ", len(ret))
                    for i in ret:
                        print(
                            "------------------------------------------------------------------------------------------- Entities len = ",
                            len(i),
                        )
                        for j in i:
                            print(j)


            if __name__ == "__main__":
                main()


    """


def ApplyResult(result: object) -> int:
    """

    Script function for applying an OPENFOAM Result. Takes as input an unbuilt Result.

    Parameters
    ----------
    result : object
            An OPENFOAM result.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                sens = base.CreateResult("./results_map.dat")
                vals = {"Draw mode": "Vector", "Result type": "Custom", "Scale Factor": 1000}
                id = base.SetEntityCardValues(constants.OPENFOAM, sens, vals)
                base.ApplyResult(sens)


    """


def FacesMiddleSingle(
    face1: object, face2: object, part: object, property: object, hide_used_faces: bool
) -> object:
    """

    This function creates a middle Face between two Faces. The new Face will lie on a new
    Surface that is created between the Surfaces of the two Faces. The shape of the resulting
    middle Face is a combination of the perimeter shapes of the two ones.

    Parameters
    ----------
    face1 : object
            A face.

    face2 : object
            A face.

    part : object, optional
            The part for the created face.

    property : object, optional
            The property for the created faces

    hide_used_faces : bool, optional
            If set to False, initial input faces will not be hidden,
            in case of graphical interface.
            (Default: True)

    Returns
    -------
    object
            Returns the created face on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def faces_middle_single():
                face1 = base.GetEntity(constants.NASTRAN, "FACE", 4)
                face2 = base.GetEntity(constants.NASTRAN, "FACE", 1)

                part = base.GetEntityPart(face2)
                pid = base.GetEntity(constants.NASTRAN, "PSHELL", 3)

                solid_single = base.FacesMiddleSingle(face1, face2, part, pid, True)

                print("SOLID_SINGLE = ", solid_single)


    """


def ScaleResult(result: object, scale_value: float) -> int:
    """

    Function for scaling an OPENFOAM Result. Takes as input a Result and the scale value.

    Parameters
    ----------
    result : object
            An OPENFOAM result object.

    scale_value : float
            The scale factor.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                sens = base.CreateResult("./results_map.dat")
                vals = {"Draw mode": "Vector", "Result type": "Custom", "Scale Factor": 1000}
                id = base.SetEntityCardValues(constants.OPENFOAM, sens, vals)
                base.ScaleResult(sens, 0.001)


    """


def MoIsToPlotels() -> int:
    """

    The function takes into account the visible elements, counts their principal
    inertia axes and creates three pairs of auxiliary PLOTEL type elements according
    to the directions of the principal inertia axes. The three pairs of PLOTELs are
    named "Plotel for I1" and I2 and I3.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                iok = base.MoIsToPlotels()


    """


def GetEntitySubsystem(entity: object) -> object:
    """
    .. deprecated:: 17.1.3
            Use :py:func:`GetEntityCardValues` instead.


    The function returns all the subsystems that contain the specified entity.

    Parameters
    ----------
    entity : object
            This can be either a part or an include entity.
            The function will not work for any other entity type.

    Returns
    -------
    object
            Returns a list of subsystems. If the specified entity does not belong to any subsystem,
            then the function will return an empty list.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_ent = base.GetEntity(constants.NASTRAN, "SHELL", 53)
                p_part = base.GetEntityPart(ent)
                p_subsystem = base.GetEntitySubsystem(entity=p_part)
                vals = ("Name", "Module Id")
                ret = base.GetEntityCardValues(constants.NASTRAN, p_subsystem, vals)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.1.3. Use :py:func: GetEntityCardValues instead.",
        DeprecationWarning,
    )


def CurvesTangentCurve(
    entity: object,
    point_on_entity: object,
    point_direction: object,
    distance: float,
    part: object,
) -> object:
    """

    This function defines a 3D-curve as the tangential extension of a selected entity.
    The entity can be a 3D-curve, CONS or Cross Section segment.

    Parameters
    ----------
    entity : object
            A 3D-curve, CONS or Cross Section segment.

    point_on_entity : object
            A list with x, y, z double coordinates that indicates the start point
            of the tangent vector for the new 3D Curve.

    point_direction : object
            A list with x, y, z double coordinates that indicates the direction point,
            defining the end of the tangent vector for the new 3D Curve.

    distance : float, optional
            Defines the extend length value. If distance is not defined the length
            of the created segment equals to the distance between the start point
            of the tangent vector and the projection point of "point_direction"
            upon the tangent.

    part : object, optional
            The part for the created tangent curve.

    Returns
    -------
    object
            Returns the created tangent curve, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def curves_tan_cur():
                point_on_entity = []
                point_dir = []

                entity = base.GetEntity(constants.NASTRAN, "CURVE", 1)
                # entity = base.GetEntity(constants.NASTRAN, "CONS", 5)
                print(entity)

                point_on_entity = base.GetEntity(constants.NASTRAN, "POINT", 1)
                point_dir = base.GetEntity(constants.NASTRAN, "POINT", 2)

                print(point_on_entity)
                print(point_dir)

                diction1 = base.GetEntityCardValues(
                    constants.NASTRAN, point_on_entity, ("X", "Y", "Z")
                )
                diction2 = base.GetEntityCardValues(constants.NASTRAN, point_dir, ("X", "Y", "Z"))

                point_on_entity_coords = []
                point_on_entity_coords.append(diction1["X"])
                point_on_entity_coords.append(diction1["Y"])
                point_on_entity_coords.append(diction1["Z"])

                print("point_on_entity_coords = ", point_on_entity_coords)

                point_dir_coords = []
                point_dir_coords.append(diction2["X"])
                point_dir_coords.append(diction2["Y"])
                point_dir_coords.append(diction2["Z"])

                print("point_dir_coords = ", point_dir_coords)
                part = base.GetEntityPart(entity)
                curse = base.CurvesTangentCurve(
                    entity=entity,
                    point_on_entity=point_on_entity_coords,
                    point_direction=point_dir_coords,
                    part=part,
                )
                print("CURSE = ", curse)


            curves_tan_cur()


    """


def FacesProjectCut(node1: object, cons: object) -> object:
    """

    This function is used to cut (split) a Face by combining the Hot Points>Project and Faces>Cut functions.
    In other words, it splits a face between a selected hot point and its projection on a selected CONS parametrically.

    Parameters
    ----------
    node1 : object
            The selected hot point.

    cons : object
            The selected cons that projection will be held.

    Returns
    -------
    object
            Returns a list with the created faces on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def faces_prj_cut():
                hot1 = base.GetEntity(constants.NASTRAN, "HOT POINT", 87)
                cons = base.GetEntity(constants.NASTRAN, "CONS", 79)

                # Apply parametric cut between hot point with ID 87 and cons with ID 79 (## change to desired ID ##)
                created_faces = base.FacesProjectCut(hot1, cons)
                print(created_faces)


    """


def HotPointsRelease(hot_points: object) -> int:
    """

    This function releases Hot Points that lie on the limit of two or more faces. When a Hot Point is released, the adjacent CONS of the faces' limits are also released and become single CONS (marked in red). As a result, the local topology changes.

    Parameters
    ----------
    hot_points : object, optional
            Accepted values: a hot point, a list of hot points, a string with value 'visible' or
            a string with value 'all'.
            If it is called with 'visible', it works with all the visible hot points.
            If it is called with 'all', it works with all the hot points.

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def hot_pnts_rel():
                hot_list = []
                hot_list.append(base.GetEntity(ansa.constants.NASTRAN, "HOT POINT", 18))
                hot_list.append(base.GetEntity(ansa.constants.NASTRAN, "HOT POINT", 6))

                # hots = base.CollectEntities(ansa.constants.NASTRAN, None, "HOT POINT", filter_visible = True)

                release = base.HotPointsRelease(hot_list)
                # release = base.HotPointsRelease('visible')
                print(release)


    """


def HotPointsDelete(hot_points: object) -> int:
    """

    This function deletes Hot Points either lying on a CONS segment or on an FE perimeter. After deletion, the adjacent
    CONS segments or FE perimeters sharing the Hot Point become one.

    Parameters
    ----------
    hot_points : object
            A hot point, a list of hot points, a node, a list of nodes, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible hot points.
            If it is called with 'all', it works with all the hot points.

    Returns
    -------
    int
            Returns 1 if the deletion succeeded, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def delete_hot_pnt():
                hots = base.CollectEntities(constants.NASTRAN, None, "HOT POINT")

                hot_list = []
                hot_list.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 43))
                hot_list.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 47))
                hot_list.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 48))
                hot_list.append(base.GetEntity(constants.NASTRAN, "GRID", 104))

                delete_hot = base.HotPointsDelete(hot_list)
                # delete_hot = base.HotPointsDelete(hots)
                # delete_hot = base.HotPointsDelete("all")
                # delete_hot = base.HotPointsDelete("visible)

                print("DELETE_HOT_POINT = ", delete_hot)


    """


def IsolateRadius(radius: float) -> int:
    """

    This function isolates on the screen all the faces based on a given radius limit.

    Parameters
    ----------
    radius : float
            The radius limit to isolate the faces.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.IsolateRadius(10)


    """


def HotPointsParametrical(
    entities: object,
    points_dir: object,
    method: int,
    distance: float,
    produce3dpoint: bool,
    remesh: bool,
) -> int:
    """

    This function defines a new Node or Hot Point parametrically on a 3D-curve segment,
    on a CONS segment or on a linear element. The input parameter value may vary from 0 to 1,
    describing the percentage of the length of the 3D-curve or CONS, corresponding to method equals to 1.
    Alternatively, it can be an exact value of distance corresponding to method equals to 0.

    Parameters
    ----------
    entities : object
            A list of CURVES, CONS or LINEAR ELEMENTS, where the hot point will be
            defined parametrically.
            Alternatively, a dictionary containing tuples of entities (CURVES, CONS,
            LINEAR ELEMENTS) - a triple of floats defining the start point of the
            corresponding entity. If triple of floats is empty the start point of the entity
            will be taken into account by default. If argument is a dictionary, point_dir
            argument could not be given.

    points_dir : object, optional
            A list of x, y ,z coordinates defining the start point of the corresponding entity.
            If not given, x, y, z coordinates from entities dictionary will be taken into account,
            otherwise the start point of the entity.

    method : int, optional
            If 0, the input value can be the exact distance which may vary from 0 to the
            length of the entity, otherwise the input parameter value may vary from 0 to 1,
            describing the percentage of the length of the 3D-curve, cons or linear element.
            (Default: 0)

    distance : float, optional
            The input parameter value which may vary from 0 to 1, describing the percentage
            of the length of the 3D-curve, cons or linear element. Alternatively, it can be
            an exact value of distance.
            If not given, method value becomes 1 and distance 0.5.

    produce3dpoint : bool, optional
            If set to True, produces a 3d point instead of a hot point, else a hot point.

    remesh : bool, optional
            In case of CONS, if set to True, the Macro Area will be remeshed, else not.

    Returns
    -------
    int
            Returns the number of the valid insertions on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def hot_points_param():
                #######################################################################################
                # FIRST LIST ENTITIES
                #######################################################################################

                entity1 = base.GetEntity(constants.NASTRAN, "CBEAM", 593)
                entity2 = base.GetEntity(constants.NASTRAN, "CONS", 15)
                entity3 = base.GetEntity(constants.NASTRAN, "CURVE", 2)
                entity4 = base.GetEntity(constants.NASTRAN, "MORPHEDGE", 15)

                #######################################################################################
                # SECOND LIST COORDINATES
                #######################################################################################

                hot_point_on_entity = base.GetEntity(constants.NASTRAN, "HOT POINT", 43)
                point_entity = base.GetEntity(constants.NASTRAN, "POINT", 6)
                point_on_curve = base.GetEntity(constants.NASTRAN, "POINT", 3)
                point_on_moedge = base.GetEntity(constants.NASTRAN, "MORPHPOINT", 3)

                #######################################################################################
                # DICTIONAIRIES OF COORDINATES
                #######################################################################################

                diction1 = base.GetEntityCardValues(
                    constants.NASTRAN, point_entity, ("X", "Y", "Z")
                )
                diction2 = base.GetEntityCardValues(
                    constants.NASTRAN, hot_point_on_entity, ("X", "Y", "Z")
                )
                diction3 = base.GetEntityCardValues(
                    constants.NASTRAN, point_on_curve, ("X", "Y", "Z")
                )
                diction4 = base.GetEntityCardValues(
                    constants.NASTRAN, point_on_moedge, ("X", "Y", "Z")
                )

                #######################################################################################
                # APPEND X Y Z  TO POINT ARRAYS
                #######################################################################################

                point_XYZ_on_moedge = []  # 1.
                point_XYZ_on_moedge.append(diction4["X"])
                point_XYZ_on_moedge.append(diction4["Y"])
                point_XYZ_on_moedge.append(diction4["Z"])

                point_XYZ_on_curve = []  # 2.
                point_XYZ_on_curve.append(diction3["X"])
                point_XYZ_on_curve.append(diction3["Y"])
                point_XYZ_on_curve.append(diction3["Z"])

                point_on_entity = []  # 3.
                point_on_entity.append(diction1["X"])
                point_on_entity.append(diction1["Y"])
                point_on_entity.append(diction1["Z"])

                hot_array = []  # 4.
                hot_array.append(diction2["X"])
                hot_array.append(diction2["Y"])
                hot_array.append(diction2["Z"])

                #######################################################################################
                # APPEND POINT ARRAYS TO FINAL LIST AS SECOND ARGUMENT
                #######################################################################################

                points_array = []
                points_array.append(hot_array)
                points_array.append(point_on_entity)
                points_array.append(point_XYZ_on_curve)
                points_array.append(point_XYZ_on_moedge)
                print("POINTS_ARRAY = ", points_array)

                #######################################################################################
                # APPEND ENTITIES( CONS, CURVES, MOEDGES, LINEAR ELEMENTS) TO FINAL LIST AS FIRST ARGUMENT
                #######################################################################################

                entities_array = []
                entities_array.append(entity1)
                entities_array.append(entity2)
                entities_array.append(entity3)
                entities_array.append(entity4)

                #######################################################################################
                # A LIST OF X, Y, Z COORDINATES CAN BE PASSED AS SECOND ARGUMENT LIST ALTERNATIVELY

                # [[-404.8619361990236, -560.213643169021, 572.8472559036514], [34.012323496316796, -560.213643169021, 566.9704721356172]]
                #######################################################################################

                hot_param = base.HotPointsParametrical(
                    entities=entities_array,
                    points_dir=points_array,
                    method=1,
                    distance=0.12,
                    produce3dpoint=False,
                    remesh=False,
                )
                print("HOT_POINTS_PARAMETRICAL = ", hot_param)


            def main():
                # ---------------------------------
                arg1 = {}
                arg1[base.GetEntity(constants.NASTRAN, "CONS", 728)] = (-494.865, 511.972, 411.815)
                base.HotPointsParametrical(
                    entities=arg1, method=0, distance=23.45, produce3dpoint=False, remesh=True
                )

                # ---------------------------------
                arg1 = base.GetEntity(constants.NASTRAN, "CONS", 347)
                base.HotPointsParametrical(entities=arg1, method=1, distance=0.541318, remesh=True)


            def main2():
                # Function will insert a hot point in the mid distance of the entity
                arg1 = {}
                arg1[base.GetEntity(constants.NASTRAN, "CONS", 728)] = ()
                base.HotPointsParametrical(entities=arg1)


    """


def SurfaceContoured(
    entities: object,
    part: object,
    property: object,
    coordinates: object,
    additional_coordinates: object,
    direction: object,
    perpendicular_mode: object,
) -> object:
    """

    This function creates surfaces, passing through selected curves, which essentially become surfaces' profile curves.

    Parameters
    ----------
    entities : object
            A list of entities that will comprise the surface's cross sections. It
            can be either Cons/Curves/Morph edges/Linear Elements, a string with
            value 'visible' or a string with value 'all'. If it is called with
            'visible', it works with all the visible entities concerning the above
            types. If it is called with 'all', it works with all the entities.

    part : object, optional
            The part for the created face(s).

    property : object, optional
            The property for the created faces(s).

    coordinates : object, optional
            A list with lists of triple coordinates, that define the start of each profile curve.

    additional_coordinates : object, optional
            A list with lists of triple coordinates, that define the spots where
            additionals surfaces will be created. All profile curves should have
            the same number of spots and the spots that concern a profile should
            be given in order (in compliance with the direction). At closed
            profile curves, if no additional surfaces are requried the list should
            be empty. At opened profile curves the list should always contain the
            end of each profile curve, even if no additional surfaces are requried.

    direction : object, optional
            A list with lists of triple coordinates, that define points which are
            on profile curves and very close to the points of the coordinates list.
            That points mark the direction. If the list is empty the direction of
            each profile curve will be defined automatically. If the desired
            direction differs from the one that is calculated automatically ,
            the direction list should be used. The order of the given points for
            a cross section at additional_coordinates list should be in compliance
            with the given direction or with the direction that is calculated
            automatically (if no direction is given).

    perpendicular_mode : object, optional
            If it is 1 the created surfaces will be tanget to the planes that are
            defined by profile curves. (This option has effect only if all profile
            curves can define a plane). The default value is 0.

    Returns
    -------
    object
            Returns a list containing referenecs to the newly created entities on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = []
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 88))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 87))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 86))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 85))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 84))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 83))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 82))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 81))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 80))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 79))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 78))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "CURVE", 77))

                arg2 = []
                arg2.append([-8.14586, 44.0272, 207.762])  # ****** First Cross Section ******
                arg2.append([-7.83171, 60.6886, 208.734])  # ***** Second Cross Section ******
                arg2.append([-7.59199, 74.2371, 209.492])  # ****** Third Cross Section ******

                arg3 = []

                # ********************** First Cross Section  ********************
                arg3.append([-22.6098, 38.6471, 128.895])
                arg3.append([-23.8238, 37.9108, 129.379])
                arg3.append([-22.1868, 38.892, 143.766])
                arg3.append([-19.1231, 40.4859, 164.672])

                # ********************* Second Cross Section *********************
                arg3.append([-33.1988, 51.4039, 123.112])
                arg3.append([-34.335, 50.652, 123.74])
                arg3.append([-30.9167, 52.8086, 139.452])
                arg3.append([-25.1377, 55.7909, 162.233])

                # ********************** Third Cross Section *********************
                arg3.append([-42.1462, 61.584, 119.351])
                arg3.append([-43.2309, 60.8275, 120.087])
                arg3.append([-38.3215, 64.0346, 136.689])
                arg3.append([-30.2447, 68.2213, 160.736])

                arg4 = []

                arg4.append([-8.11634, 44.0326, 207.854])  # ****** First Cross Section ******
                arg4.append([-7.79217, 60.6937, 208.824])  # ***** Second Cross Section ******
                arg4.append([-7.54611, 74.2418, 209.577])  # ****** Third Cross Section ******

                ansa.base.SurfaceContoured(
                    entities=arg1,
                    coordinates=arg2,
                    additional_coordinates=arg3,
                    direction=arg4,
                    perpendicular_mode=0,
                )


                The above curves form three cross sections.

                The list arg2 contains the start of each chain.

                The list arg3 contains four spots for each chain. That means that, if the cross sections are closed, five surfaces will be created.
                Otherwise, if the cross sections are opened, the last spot of the arg3 list should be the end of the profile curves. So, four surfaces will be created.

                The list arg4 contains spots, very close to the spots of the arg2 list, that mark the direction. On each cross section the direction should be in compliance with the order of the given points for the specific profile.

                In the above example the lists could be in this form :


                arg2 = []
                arg2.append([-7.59199, 74.2371, 209.492])  # ****** Third Cross Section ******
                arg2.append([-7.83171, 60.6886, 208.734])  # ***** Second Cross Section ******
                arg2.append([-8.14586, 44.0272, 207.762])  # ****** First Cross Section ******

                arg3 = []

                # ********************** Third Cross Section *********************
                arg3.append([-42.1462, 61.584, 119.351])
                arg3.append([-43.2309, 60.8275, 120.087])
                arg3.append([-38.3215, 64.0346, 136.689])
                arg3.append([-30.2447, 68.2213, 160.736])

                # ********************* Second Cross Section *********************
                arg3.append([-33.1988, 51.4039, 123.112])
                arg3.append([-34.335, 50.652, 123.74])
                arg3.append([-30.9167, 52.8086, 139.452])
                arg3.append([-25.1377, 55.7909, 162.233])

                # ********************** First Cross Section  ********************
                arg3.append([-22.6098, 38.6471, 128.895])
                arg3.append([-23.8238, 37.9108, 129.379])
                arg3.append([-22.1868, 38.892, 143.766])
                arg3.append([-19.1231, 40.4859, 164.672])

                arg4 = []

                arg4.append([-7.54611, 74.2418, 209.577])  # ****** Third Cross Section *******
                arg4.append([-7.79217, 60.6937, 208.824])  # ***** Second Cross Section ******
                arg4.append([-8.11634, 44.0326, 207.854])  # ****** First Cross Section ********


    """


def DefineInterfaceBoundary(
    faces: object, part: bool, pid: bool, red: bool, blue: bool, subsystem: bool
) -> object:
    """

    This functions create Interface Boundary Entities from the given list of faces, cons or edges.

    Parameters
    ----------
    faces : object
            A list that contains faces, cons, edges or all of them.

    part : bool, optional
            If set to True, Interface Boundary Entities, between different parts will be created.

    pid : bool, optional
            If set to True, Interface Boundary Entities, between different pids will be created.

    red : bool, optional
            If set to True, Interface Boundary Entities, from red Cons will be created.

    blue : bool, optional
            If set to True, Interface Boundary Entities, from blue Cons will be created.

    subsystem : bool, optional
            If set to True, Interface Boundary Entities, between different subsystems will be created.

    Returns
    -------
    object
            Returns a list of the Interface Boundary Entities that have been created.
            If no Interface Boundary Entity has been created, the function returns None.

    See Also
    --------
    base.SmartPaste

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                all_faces = base.CollectEntities(0, None, "FACE")
                inter_bounds = base.DefineInterfaceBoundary(
                    faces=all_faces, part=False, pid=True, red=False, blue=True, subsystem=False
                )
                print(inter_bounds)


            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shells = base.CollectEntities(0, None, "SHELL")
                edges = []
                for shell in shells:
                    for i in [1, 2, 3]:
                        edge = base.Entity(constants.NASTRAN, shell._id, "SHELL", edge_index=i)
                        edges.append(edge)

                    shell_type = shell.get_entity_values(constants.NASTRAN, ["type"])["type"]
                    if shell_type == "CQUAD4":
                        edge = base.Entity(constants.NASTRAN, shell._id, "SHELL", edge_index=4)
                        edges.append(edge)

                print(edges)
                inter_bounds = base.DefineInterfaceBoundary(
                    faces=edges, part=False, pid=False, red=True, blue=False, subsystem=False
                )
                print(inter_bounds)


    """


def GetKeywordFieldLabels(deck: int, type: str) -> object:
    """

    Returns a list with the field labels of an entity card.

    Parameters
    ----------
    deck : int
            The deck of the entity card.

    type : str
            The name of the entity card.

    Returns
    -------
    object
            Returns a list with the field labels of the entity card.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                label_list = base.GetKeywordFieldLabels(ansa.constants.RADIOSS, "CONTROL")
                print(label_list)


    """


def SetPickMethod(pick_method: int):
    """

    This function sets the picking method(s) to be used by picking functions (e.g. PickEntities()), for line and area elements.
    It should be called before the picking function.

    Parameters
    ----------
    pick_method : int
            A combination of one or more of the following picking methods.
            NOTE: Although all the following methods can be combined, there is no point in that since
            all line methods, as well as all area methods, are mutually exclusive.
            You could, however set a combination of an area and a line method.

            -base.constants.ENT_SELECTION: Pick line or area elements with the Feature Selection>ENT
             method.
            -base.constants.LINE_ANGLE_SELECTION: Pick line elements with the Feature Selection>Feature
             Line method.
            -base.constants.LOOP_SELECTION: Pick line elements with the Feature Selection>Loop method.
            -base.constants.PID_NEIGHB_SELECTION: Pick line elements with the Feature Selection>PID
             Neighbs method.
            -base.constants.OPPOSITE_SELECTION: Pick line elements with the Feature Selection>Opposite method.
            -base.constants.LINE_PERIM_SELECTION: Pick edges with the Feature selection>Perimeter method.
            -base.constants.POLY_LINE_NODE_SELECTION: Pick line elements with the Feature Selection>Path method.
            -base.constants.POLY_LINE_OPPOSITE_SELECTION: Pick line elements with the
             Feature Selection>Opposite Path method.
            -base.constants.AREA_ANGLE_SELECTION: Pick area elements with the Feature Selection>Feature
             Area method.
            -base.constants.PID_SELECTION: Pick area elements with the Feature Selection>PID method.
            -base.constants.PID_REGION_SELECTION: Pick area elements with the Feature Selection>PID
             Region method.
            -base.constants.MID_SELECTION: Pick area elements with the Feature Selection>MID method.
            -base.constants.VOL_SELECTION: Pick area elements with the Feature Selection>VOL method.
            -base.constants.PART_SELECTION: Pick area elements with the Feature Selection>PART method.
            -base.constants.CFD_BC_SELECTION: Pick area elements with the Feature Selection>BC method.
            -base.constants.INCLUDE_SELECTION: Pick area elements with the Feature Selection>Include method.
            -base.constants.HBOX_FACE_SELECTION: Pick area elements with the Feature Selection>Hexa Box Face
             Area method.
            -base.constants.MACRO_SELECTION: Pick area elements with the Feature Selection>Macro method.
            -base.constants.POLY_AREA_AREA_SELECTION: Pick area elements with the Feature Selection>Poly
             Area method.
            -base.constants.POLY_LINE_AREA_SELECTION: Pick area elements with the Feature Selection>Poly
             Line method.
            -base.constants.FRONT_SELECTION: Pick entities which are only in the front view of the screen.
            -base.constants.NODES_SELECTION: Pick nodes with line elements tools. Mutually exclusive with base.constants.NODES_FROM_AREA.
            -base.constants.NODES_FROM_AREA: Pick nodes with area elements tools. Mutually exclusive with base.constants.NODES_SELECTION.

    See Also
    --------
    GetPickMethod, PickNodes, PickPointOnSurface, PickEntities

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = "SHELL"

                # Setting a single method
                base.SetPickMethod(base.constants.AREA_ANGLE_SELECTION)
                results = base.PickEntities(constants.NASTRAN, ents)

                for ent in results:
                    ret = base.GetEntityCardValues(constants.NASTRAN, ent, ("EID",))
                    print(ret["EID"])
                print(base.GetPickMethod())

                # Combining two methods
                base.SetPickMethod(
                    base.constants.AREA_ANGLE_SELECTION + base.constants.FRONT_SELECTION
                )
                results = base.PickEntities(constants.NASTRAN, ents)

                for ent in results:
                    ret = base.GetEntityCardValues(constants.NASTRAN, ent, ("EID",))
                    print(ret["EID"])
                print(base.GetPickMethod())


    """


def GetPickMethod() -> object:
    """

    This function returns the current picking method(s) that will be used the next time
    that the user calls a picking function (e.g. PickEntities()).
    Possible returned values are a combination of the following constants:

    base.constants.ENT_SELECTION: Pick line or area elements with the Feature Selection>ENT method

    base.constants.LINE_ANGLE_SELECTION: Pick line elements with the Feature Selection>Feature Line method
    base.constants.LOOP_SELECTION: Pick line elements with the Feature Selection>Loop method
    base.constants.PID_NEIGHB_SELECTION: Pick line elements with the Feature Selection>PID Neighbs method
    base.constants.OPPOSITE_SELECTION: Pick line elements with the Feature Selection>Opposite method
    base.constants.LINE_PERIM_SELECTION: Pick edges with the Feature selection>Perimeter method
    base.constants.POLY_LINE_NODE_SELECTION: Pick line elements with the Feature Selection>Path method
    base.constants.POLY_LINE_OPPOSITE_SELECTION: Pick line elements with the Feature Selection>Opposite Path method
    base.constants.NODES_SELECTION: Pick nodes with line elements tools. Mutually exclusive with base.constants.NODES_FROM_AREA.
    base.constants.NODES_FROM_AREA: Pick nodes with area elements tools. Mutually exclusive with base.constants.NODES_SELECTION.

    base.constants.AREA_ANGLE_SELECTION: Pick area elements with the Feature Selection>Feature Area method
    base.constants.PID_SELECTION: Pick area elements with the Feature Selection>PID method
    base.constants.PID_REGION_SELECTION: Pick area elements with the Feature Selection>PID Region method
    base.constants.MID_SELECTION: Pick area elements with the Feature Selection>MID method
    base.constants.VOL_SELECTION: Pick area elements with the Feature Selection>VOL method
    base.constants.PART_SELECTION: Pick area elements with the Feature Selection>PART method
    base.constants.CFD_BC_SELECTION: Pick area elements with the Feature Selection>BC method
    base.constants.INCLUDE_SELECTION: Pick area elements with the Feature Selection>Include method
    base.constants.HBOX_FACE_SELECTION: Pick area elements with the Feature Selection>Hexa Box Face Area method
    base.constants.MACRO_SELECTION: Pick area elements with the Feature Selection>Macro method
    base.constants.POLY_AREA_AREA_SELECTION: Pick area elements with the Feature Selection>Poly Area method
    base.constants.POLY_LINE_AREA_SELECTION: Pick area elements with the Feature Selection>Poly Line method
    base.constants.KINBODY_SELECTION: Pick area elements with the Feature Selection>KINBODY method

    Returns
    -------
    object
            Returns a combination of area and/or line mode picking methods, that will be used by picking functions.

    See Also
    --------
    SetPickMethod, PickNodes, PickPointOnSurface, PickEntities

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = "SHELL"
                base.SetPickMethod(base.constants.AREA_ANGLE_SELECTION)
                results = base.PickEntities(constants.NASTRAN, ents)

                for ent in results:
                    ret = base.GetEntityCardValues(constants.NASTRAN, ent, ("EID",))
                    print(ret["EID"])
                # If you have changed the picking method while picking,
                # the current picking method(s) will be printed (as integers)
                print(base.GetPickMethod())


    """


def BestView(ent1: object, ent2: object, ent3: object) -> object:
    """

    This function rotates the image automatically to align a view parallel to the screen.
    This function operates on Faces, Elements, Working Planes, Coordinate.

    Parameters
    ----------
    ent1 : object
            A referance to an entity, must be o a point reference if ent2 and ent3 arguments are used.

    ent2 : object, optional
            A reference to a point, ent1 must also be a point reference if used.

    ent3 : object, optional
            A reference to a point, ent1 must also be a point reference if used.

    Returns
    -------
    object
            Returns 1 on success and None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent1 = base.GetEntity(constants.NASTRAN, "SHELL", 2)
                base.BestView(ent1)


    """


def ConsOpenHole(
    entities: object,
    center: object,
    radius: float,
    normal: object,
    delete: bool,
    reconstruct: int,
    tube: bool,
    trim: bool,
    link: int,
    diameter: float,
) -> int:
    """

    This function opens holes on selected Faces or FE Shells, defining the center and the radius of the hole.

    Parameters
    ----------
    entities : object
            A list of entities, where the holes will be opened. They can be either Faces,
            FE Shells, a string with value 'visible' or a string with value 'all' . If it is called
            with 'visible', it works with all the visible entities concerning the above types.
            If it is called with 'all', it works with all the entities.

    center : object
            A list with x, y, z coordinates defining the center of the hole.

    radius : float, optional
            The radius of the hole. This argument can be used alternatively to argument 'diameter' but not in conjuction with it.

    normal : object, optional
            A list with dx, dy, dz values, defining the normal vector of the created tubes,
            in case that the tube flag is True.
            If the normal vector is not defined or is None, default value is given.

    delete : bool, optional
            If True the entities will be deleted.

    reconstruct : int, optional
            If FE Shells are given, reconstruct value defines the affected zones
            that the reconstruction will be held.
            If 0, no reconstruction takes place.

    tube : bool, optional
            If True, tube(s) can be generated.

    trim : bool, optional
            If True, deletes redundant/excessive part of tube(s) defined.

    link : int, optional
            When linked faces are involved on "delete" hole interior, then:
            -"0" means delete "All" linked faces.
            -"1" means delete "Child" linked faces.
            -"2" means "Convert" child linked faces.
            (Default: 0)

    diameter : float, optional
            The diameter of the hole. This argument can be used alternatively to argument 'radius' but not in conjuction with it.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def cons_open_hole():
                # defining SHELLS
                shell_entities = base.CollectEntities(ansa.constants.NASTRAN, None, "SHELL")

                # defining FACES
                entities = []
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 1))
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 2))
                entities.append(base.GetEntity(ansa.constants.NASTRAN, "FACE", 3))

                point_entity1 = base.GetEntity(ansa.constants.NASTRAN, "POINT", 1)
                point_entity2 = base.GetEntity(ansa.constants.NASTRAN, "POINT", 2)

                diction1 = base.GetEntityCardValues(
                    ansa.constants.NASTRAN, point_entity1, ("X", "Y", "Z")
                )
                diction2 = base.GetEntityCardValues(
                    ansa.constants.NASTRAN, point_entity2, ("X", "Y", "Z")
                )

                # defining CENTER
                center_array = []
                center_array.append(diction1["X"])
                center_array.append(diction1["Y"])
                center_array.append(diction1["Z"])
                center_array.append(diction2["X"])
                center_array.append(diction2["Y"])
                center_array.append(diction2["Z"])

                # defining NORMAL
                hot1 = [-69.006305, -57.455766, 0.000000]
                hot2 = [90.925790, 90.037066, 100.000000]
                normal = [hot67[0] - hot56[0], hot67[1] - hot56[1], hot67[2] - hot56[2]]

                open_hole = base.ConsOpenHole(
                    entities,
                    center_array[0:6],
                    normal=normal,
                    radius=20.234,
                    delete=True,
                    tube=True,
                    trim=True,
                    reconstruct=2,
                )
                # open_hole = base.ConsOpenHole(entities, center_array[0:6], radius=20.234)
                print(open_hole)


    """


def FacesExtendPairs(
    boundary_cons_1: object,
    boundary_cons_2: object,
    range: float,
    delete_hots_flag: bool,
    patch_flag: bool,
) -> int:
    """

    This script function extends Faces (source), defined in two groups, by adding new Faces
    as extensions to the source ones, according to a specified distance or until extension
    of the one group reaches Faces of the other group. The new Surfaces are extensions of
    the Surfaces of the sources. Topology will be applied automatically, only between Faces
    of different groups.

    Parameters
    ----------
    boundary_cons_1 : object
            A red cons or a list of red cons of the first group.

    boundary_cons_2 : object
            A red cons or a list of red cons of the second group.

    range : float
            The appropriate extension distance.

    delete_hots_flag : bool
            True or False, in cases that a selection of CONS could be replaced
            by one CONS or not (by removing their intermediate Hot Points).

    patch_flag : bool
            If set to True, the created extension faces lay on new surfaces.
            If set to False, the new face gives the surface to the original faces too.

    Returns
    -------
    int
            Returns 1 on success or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def extend_pairs():
                mase_array1 = []
                mase_array1.append(base.GetEntity(constants.NASTRAN, "CONS", 6))
                mase_array1.append(base.GetEntity(constants.NASTRAN, "CONS", 11))
                mase_array1.append(base.GetEntity(constants.NASTRAN, "CONS", 12))
                mase_array1.append(base.GetEntity(constants.NASTRAN, "CONS", 13))

                mase_array2 = []
                mase_array2.append(base.GetEntity(constants.NASTRAN, "CONS", 2))
                mase_array2.append(base.GetEntity(constants.NASTRAN, "CONS", 14))
                mase_array2.append(base.GetEntity(constants.NASTRAN, "CONS", 15))
                mase_array2.append(base.GetEntity(constants.NASTRAN, "CONS", 16))

                extend_pairs = base.FacesExtendPairs(mase_array1, mase_array2, 150.0, True, True)
                print("EXTEND_PAIRS = ", extend_pairs)


    """


def ControlNewListItem(
    deck: int, control: object, type: str, index: int, entity: object, part_type: int
) -> int:
    """

    Adds a new item in a Control list.

    Parameters
    ----------
    deck : int
            One of PAMCRASH, LSDYNA, RADIOSS.

    control : object
            A reference to the Control entity.

    type : str
            Keyword of the Control entity that has a list to be modified.

    index : int, optional
            The index that the item will be inserted.
            If not specified, item will be inserted at the end of the list .

    entity : object, optional
            A reference to the entity that will replace the existing one.

    part_type : int, optional
            The value of the TYPE field that will replace the existing one.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    See Also
    --------
    ControlDeleteListItem, ControlModifyListItem, ControlInfoListItem, ControlListItemsNum

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                control = base.GetGlobalControl(constants.LSDYNA)
                prop = base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 1)
                base.ControlNewListItem(
                    constants.LSDYNA,
                    control,
                    "MPP_DECOMPOSITION_ARRANGE_PARTS",
                    entity=prop,
                    part_type=0,
                )


    """


def ControlDeleteListItem(deck: int, control: object, type: str, index: int) -> int:
    """

    Deletes an item from a Control list.

    Parameters
    ----------
    deck : int
            One of PAMCRASH, LSDYNA, RADIOSS.

    control : object
            A reference to the Control entity.

    type : str
            Keyword of the Control entity that has a list that will be modified.

    index : int, optional
            The index of the item that will be deleted.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    See Also
    --------
    ControlNewListItem, ControlModifyListItem, ControlInfoListItem, ControlListItemsNum

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                control = base.GetGlobalControl(constants.LSDYNA)
                set = base.GetEntity(constants.LSDYNA, "SET", 1)
                prop = base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 1)
                base.ControlNewListItem(
                    constants.LSDYNA,
                    control,
                    "MPP_DECOMPOSITION_ARRANGE_PARTS",
                    entity=prop,
                    part_type=0,
                )
                base.ControlNewListItem(
                    constants.LSDYNA,
                    control,
                    "MPP_DECOMPOSITION_ARRANGE_PARTS",
                    entity=set,
                    part_type=1,
                )

                base.ControlDeleteListItem(
                    constants.LSDYNA, control, "MPP_DECOMPOSITION_ARRANGE_PARTS", 2
                )


    """


def ControlModifyListItem(
    deck: int, control: int, type: str, index: int, entity: object, part_type: int
) -> int:
    """

    Modifies the values of an item of a Control list.

    Parameters
    ----------
    deck : int
            One of PAMCRASH, LSDYNA, RADIOSS.

    control : int
            A reference to the Control entity.

    type : str
            Keyword of the Control entity that has a list that will be modified.

    index : int, optional
            The index of the item that will be modified.
            If not specified, all items of the list will be modified.

    entity : object, optional
            A reference to the entity that will replace the existing one.

    part_type : int, optional
            The value of the TYPE field that will replace the existing one.

    Returns
    -------
    int
            Returns 0 if invalid arguments are specified, 1 otherwise.

    See Also
    --------
    ControlNewListItem, ControlDeleteListItem, ControlInfoListItem, ControlListItemsNum

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                control = base.GetGlobalControl(constants.LSDYNA)
                set1 = base.GetEntity(constants.LSDYNA, "SET", 1)
                prop = base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 1)
                base.ControlNewListItem(
                    constants.LSDYNA,
                    control,
                    "MPP_DECOMPOSITION_ARRANGE_PARTS",
                    entity=prop,
                    part_type=0,
                )

                base.ControlModifyListItem(
                    constants.LSDYNA,
                    control,
                    "MPP_DECOMPOSITION_ARRANGE_PARTS",
                    index=1,
                    entity=set1,
                    part_type=11,
                )


    """


def ControlInfoListItem(deck: int, control: int, type: str, index: int) -> object:
    """

    Gets values from an item of a Control list.

    Parameters
    ----------
    deck : int
            One of PAMCRASH, LSDYNA, RADIOSS.

    control : int
            A reference to the Control entity.

    type : str
            Keyword of the Control entity that has a list to get values from.

    index : int, optional
            The index of the item to get values from.

    Returns
    -------
    object
            On success, it returns a dictionary with keys the labels of the fields and values their respective values.
            Otherwise, None is retuned.

    See Also
    --------
    ControlNewListItem, ControlDeleteListItem, ControlModifyListItem, ControlListItemsNum

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                control = base.GetGlobalControl(constants.LSDYNA)
                prop = base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 1)
                base.ControlNewListItem(
                    constants.LSDYNA,
                    control,
                    "MPP_DECOMPOSITION_ARRANGE_PARTS",
                    entity=prop,
                    part_type=0,
                )

                ret = base.ControlInfoListItem(
                    constants.LSDYNA, control, "MPP_DECOMPOSITION_ARRANGE_PARTS", 1
                )
                print("Item ID: " + str(ret["ID"]) + ", TYPE: " + str(ret["TYPE"]))


    """


def CurvesNew(
    coordinates: object, tangency: object, common: bool, new_part: bool
) -> object:
    """

    This function defines smooth 3D-curves by passing through a number of positions.

    Parameters
    ----------
    coordinates : object
            A list with lists of x, y, z coordinates defining the points that the
            created curve passes through.

    tangency : object, optional
            A dictionary defining vectors (vx, vy, vz), controlling the tangency
            at the start or at the end of the created curve.
            -'s' defines the starting vector (vx1, vy1, vz1).
            -'e' defines the ending vector (vx2, vy2, vz2).

    common : bool, optional
            If True, the tangency of the starting vector, will also be imposed
            on the ending vector and the curve will close.

    new_part : bool, optional
            If True, a new part is given to the created curve, otherwise a current part.

    Returns
    -------
    object
            Returns the created curve, otherwise None.

    See Also
    --------
    CreateCurve, CreateCurveWithBox, CurvesTangentCurve

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def curves_new():
                points = []
                points.append([502.059, -182.241, 29.3154])
                points.append([591.276, -177.278, 17.2144])
                points.append([694.487, -178.695, 29.3154])
                points.append([694.487, -54.6477, 24.202])
                points.append([591.276, -53.2301, 12.101])
                points.append([502.059, -58.1932, 24.202])
                vecs = {}
                vecs["s"] = (0, -0.988282, -0.152641)
                vecs["e"] = (0, -0.999404, 0.0345212)

                curve = base.CurvesNew(points, vecs, True, True)
                print(curve)


    """


def LaminateSplitToOnePropertyPerLayer(
    deck: int, laminate: object, create_simple_props: bool, skip_empty_layers: bool
) -> object:
    """

    Takes a laminate with different elements per layer and creates one laminate property per layer.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH.

    laminate : object
            A laminate property.

    create_simple_props : bool, optional
            If set to True, the laminate must not have woven layers and deck must be one of
            Nastran, LsDyna, Abaqus, Ansys and Permas (Nastran only for shells).

    skip_empty_layers : bool, optional
            If set to True, no properties are created for empty layers.
            (Default: False)

    Returns
    -------
    object
            Returns a list containing the created properties.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = base.CurrentDeck()
                solid_lam = base.GetEntity(deck, "SOLID_LAMINATE", 1)
                props = base.LaminateSplitToOnePropertyPerLayer(deck, solid_lam)

                for prop in props:
                    print(prop)


    """


def MatchCurvesAndCons(curves: object, cons: object) -> object:
    """

    Finds the identical input curves and cons (according to the "tolerance mode").

    Parameters
    ----------
    curves : object
            A list of curves to compare with cons.

    cons : object
            A list of cons to compare with curves.

    Returns
    -------
    object
            On success, it returns a list of matched curves and cons (two consecutive
            list items correspond to a pair). On error, it returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def compareDatabaseCurvesAndCons():
                curvesList = base.CollectEntities(constants.NASTRAN, None, "CURVE")
                consList = base.CollectEntities(constants.NASTRAN, None, "CONS")

                pairs = base.MatchCurvesAndCons(curvesList, consList)

                for i in range(0, len(pairs), 2):
                    print("Curve with name:", pairs[i]._name, "and id:", pairs[i]._id)
                    print("Cons with name:", pairs[i + 1]._name, "and id:", pairs[i + 1]._id)


    """


def SaveFileAsCGR(filename: str) -> int:
    """

    This function ouputs the visible entities with no hierarchy to a ".cgr" file.
    The units of the ".cgr" file are the same with the units of ansa at the time of the output.

    Parameters
    ----------
    filename : str
            The whole path to the file.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                for part in parts:
                    vals = base.GetEntityCardValues(constants.NASTRAN, part, ("Name",))
                    name = vals["Name"]
                    status = base.Or(part)  # make the part the only visible part
                    base.SaveFileAsCGR("/home/user/" + name + ".cgr")


    """


def SectionForceAssistant(
    entities: object,
    part: object,
    deck: int,
    section_type: str,
    name: str,
    multiple_planes: bool,
    mp_number: int,
    mp_distance: float,
    mp_path: object,
    origin: object,
    normal_vector: object,
    create_geb: bool,
    create_global: bool,
    create_local: bool,
    local_type: str,
    local_axis: str,
    circular: bool,
    create_ref_node: str,
    ref_node: object,
    step: object,
) -> object:
    """

    Creates a Section Force as the gui Assistant.

    Parameters
    ----------
    entities : object
            A list of elements to be cut.
            Can be Elements, Properties or Parts.

    part : object, optional
            The part of the created cross section force.

    deck : int, optional
            The deck according to which the Section Force will be created.

    section_type : str, optional
            The section type when needed (PLANE, SET, CONTACT, LINK).

    name : str, optional
            The name of the created cs,

    multiple_planes : bool, optional
            If set to True, multiple planes will be created.

    mp_number : int, optional
            The number of the created planes when multiple planes will be created.
            (Only when multiple_planes=True)

    mp_distance : float, optional
            The distance between the planes when multiple planes will be created.
            (Only when multiple_planes=True with no mp_number)

    mp_path : object, optional
            The path (array of curves) of the created multiple planes.
            (Only when multiple_planes=True)

    origin : object, optional
            Origin point when single plane.

    normal_vector : object, optional
            Normal Vector when single plane.

    create_geb : bool, optional
            If set to True, creates GEB_OR.

    create_global : bool, optional
            If set to True, global cord output result.

    create_local : bool, optional
            Local cord if create_local=True.

    local_type : str, optional
            "coord", "accelometer" of local.

    local_axis : str, optional
            Axis aligned with local. ( LX, LY, LZ, LI)

    circular : bool, optional
            If set to True, creates circular cs.

    create_ref_node : str, optional
            Creation of reference node in Abaqus. (auto, specify, no) (only in Abaqus)

    ref_node : object, optional
            Reference Node in Abaqus (when create_ref_node = 'specify')

    step : object, optional
            Abaqus Step.

    Returns
    -------
    object
            Returns a list containing references to the newly created Section Force objects.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.NASTRAN, "SHELL", 9)
                part = base.GetEntityPart(ent)
                property1 = base.GetEntity(constants.NASTRAN, "__PROPERTIES__", 1)
                entities = [part, property1]
                secfos = base.SectionForceAssistant(
                    entities=entities,
                    part=part,
                    deck=constants.LSDYNA,
                    section_type="PLANE",
                    name="ThisistheName",
                    origin=[0, 0, 0],
                    normal_vector=[1, 2, 3],
                    create_global=True,
                    create_local=True,
                    local_type="accelerometer",
                    local_axis="LX",
                )
                print(secfos)


    """


def SeatFieldGetCharacteristicPoints(field: object) -> object:
    """

    This function collects the positions of the seat adjustments' field characteristic points.

    Parameters
    ----------
    field : object
            The name or the PID of the seat adjustments' field.

    Returns
    -------
    object
            Returns a dictionary with the following keys:
                    A_SRP, B_MostFront, C_SRP, Cprime_SRP and D_MostRear.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Set field PID
                field_pid = 150209
                field_points = base.SeatFieldGetCharacteristicPoints(field_pid)

                for point in field_points:
                    print("{0: 15s}: {1}".format(point, field_points[point]))


    """


def SetGroupAsConfiguration(group: object) -> int:
    """
    .. deprecated:: 16.0.1
            Use :py:func:`NewConfiguration` instead.


    WARNING: This function is obsolete! Use the function
    "ansa.base.NewConfiguration" instead to create configurations.

    This function accepts a group and sets it to be a configuration.

    Parameters
    ----------
    group : object
            The group you wish to set as configuration.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def printAllConfigs():
                configs = base.GetAllConfigurations()
                for config in configs:
                    vals = ("Name", "Module Id")
                    ret = base.GetEntityCardValues(constants.NASTRAN, config, vals)
                    print(
                        "Found configuration named '"
                        + ret["Name"]
                        + "' with module id="
                        + ret["Module Id"]
                        + "."
                    )


            def main():
                printAllConfigs()
                new_conf = base.NewGroup("New_configuration")
                base.SetGroupAsConfiguration(new_conf)
                printAllConfigs()


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.0.1. Use :py:func: NewConfiguration instead.",
        DeprecationWarning,
    )


def RunParallelJobsOnParts(
    parts: object,
    num_of_parallel_jobs: int,
    per_part_script: str,
    per_part_script_function: str,
    per_part_script_data: object,
    time_out_limit: int,
    report_dir: str,
    ansa_executable: str,
) -> int:
    """

    This function will execute a Python "per part" script on each given part
    individually, in parallel. For each part, an ANSA process (Worker) is launched
    in the background and runs the given script for that part.

    Apart from the "per part" script, a function must be specified on that script
    file to run. The given function must accept one single argument. That argument
    will be a dict that contains two keys:

    - 'part_attributes': The running part attributes.
    - 'per_part_script_data': Optional user data that should be given upon calling
    the RunParallelJobsOnPart functions as an argument. If a lot of data should be
    passed to the per part script function, eg. separate info for each part, all
    this data could be written to a file and just the file path passed as per part
    script data to get the data re-evaluated inside the function.

    The return value of the per part script function will be stored in a report.xml
    file stored in the "report_dir". The function can also return a dict with
    special keys to denote an error or warning. The keys in the dict can be:
    "RETURN_ERROR", "RETURN_WARNING", "RETURN_VALUE".

    Parameters
    ----------
    parts : object
            A list of parts for which RunParallelJobsOnParts will run.
            If this argument is missing, all parts of the ANSA database
            will be sent to the function.

    num_of_parallel_jobs : int
            Define the maximum number of ANSA workers that will work
            in parallel at any given time.

    per_part_script : str
            The user per part script that will be called for each part.

    per_part_script_function : str
            The function name to be called on the per part script.
            See the function's description for more details.

    per_part_script_data : object, optional
            A dict which contains key-value string pairs of data which will be
            available to the per part script function.
            See the function's description for more details.

    time_out_limit : int, optional
            Maximum allowed time (in minutes) before a process is considered
            as blocked. Blocked processes will be forced to finish.
            (Default: 30)

    report_dir : str, optional
            A directory that will contain detailed report (and execution) files for
            reference purposes.

    ansa_executable : str, optional
            Define a specific ANSA executable to be used for parallel jobs.

    Returns
    -------
    int
            Returns 0 on success and 1 otherwise.

            WARNING: While the procedure may have been executed succesfully, the per part
            script function may have failed for one or all parts, therefore the report
            directory files should be checked for detailed information if something has not
            worked as expected.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                all_parts = base.CollectEntities(0, None, "ANSAPART")
                if all_parts:
                    ret_val = base.RunParallelJobsOnParts(
                        parts=all_parts,
                        num_of_parallel_jobs=5,
                        per_part_script="C:/Users/TestUser/PerPart.py",
                        per_part_script_function="PerPartScriptMain",
                        per_part_script_data={"dm_root": base.GetDMRoot()},
                        time_out_limit=40,
                        report_dir="C:/Users/TestUser/ParallelJobsReport/",
                    )

                    if ret_val:
                        print("ERROR: Could not run parallel jobs")


            # The PerPartScriptMain function in the PerPart.py file could begin like this:
            # def PerPartScriptMain(all_args):
            # \tpart_attributes = all_args['part_attributes']
            # \tper_part_script_data = all_args['per_part_script_data']

            # \tdm_root = per_part_script_data['dm_root']
            # \t...


    """


def CreateDMRoot(dm_root: str, dm_structure_xml: str) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`CreateRootFolder` instead.


    This function creates a new folder which can be then used as a DM Root.
    If a dm_structure.xml file is defined, it will be copied into that new folder.

    Parameters
    ----------
    dm_root : str
            The desired folder that will be used as a DM Root.

    dm_structure_xml : str, optional
            The source dm_structure.xml that will be copied to the new DM folder.

    Returns
    -------
    int
            Returns 1 if the function was successful and 0 on failure,
            in one of the following cases:
            -If the new folder exists but has no write access.
            -If the new folder can't be created.
            -If the dm_structure.xml can't be copied to the new folder.

    See Also
    --------
    SetDMRoot, RemoveDMRoot, GetDMRoot, GetDMRootsList

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def createANewDM():
                if base.CreateDMRoot("C:\\tmp\\DM1") == 1:
                    base.SetDMRoot("C:\\tmp\\DM1")
                if base.CreateDMRoot("C:\\tmp\\DM2", dm_structure_xml="C:\\tmp\\dm_structure.xml") == 1:
                    base.SetDMRoot("C:\\tmp\\DM2")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: CreateRootFolder instead.",
        DeprecationWarning,
    )


def GetEntityDMProperties(entity: object) -> object:
    """

    When connected to a DM, one may need to get an entity's DM Properties as a list.

    Parameters
    ----------
    entity : object
            The input entity whose properties will be returned.
            It may be one of the following:
            -ANSAPART
            -ANSA_SUBSYSTEM
            -ANSA_SIMULATION_MODEL
            -ANSA_CONFIGURATION
            -ANSA_SIMULATION_RUN
            -ANSA_LOADCASE
            -ANSA_LIBRARY_ITEM
            -INCLUDE

    Returns
    -------
    object
            Returns a list containing the DM Properties.
            Any properties that are ANSA Attributes, are returned with the "DM" prefix, e.g."DM/Discipline".

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromName("1_BIW_GROUP")
                print(base.GetEntityDMProperties(part))

                subsystem = base.GetPartFromName("MODULE_1", type="ANSA_SUBSYSTEM")
                print(base.GetEntityDMProperties(subsystem))


    """


def UnvolumizeSolidLaminate(
    deck: int, laminate: object, delete: bool, treat_initial_conditions: bool
) -> object:
    """

    Converts a Solid Laminate into a Shell Laminate.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH.

    laminate : object
            The solid laminate to unvolumize.

    delete : bool, optional
            Controls whether the original solid laminate will be deleted.
            (Default: True)

    treat_initial_conditions : bool, optional
            Controls whether the initial conditions will be transferred to the new
            shell element.
            (Default: True)

    Returns
    -------
    object
            Returns the created shell laminate or None in case of failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                psolid = base.GetEntity(constants.ABAQUS, "SOLID_LAMINATE", 1)
                pshell = base.UnvolumizeSolidLaminate(
                    constants.ABAQUS, psolid, delete=True, treat_initial_conditions=True
                )
                print(pshell)


    """


def ConvertUnits(units: str, scale: bool) -> int:
    """
    .. deprecated:: 18.0.0
            Use :py:func:`SetLengthUnits` instead.


    Changes the current units by determining the appropriate input.
    Note that as the current units change, the tolerances are automatically adjusted.

    Parameters
    ----------
    units : str
            A string determining the desired change, available from
            the below list:
            - "Kilometers (KM)"
            - "Meters (M)"
            - "Centimeters (CM)"
            - "Millimeters (MM)"
            - "Micrometers (UM)"
            - "Miles (MI)"
            - "Feet (FT)"
            - "Inches (IN)"
            - "Milliinches (MIL)"
            - "Microinches (UIN)"

    scale : bool, optional
            If set to True, both units and coordinates change, otherwise
            units are changed but the coordinates remain the same.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def change_units():
                unit = "Inches (IN)"

                ret = base.ConvertUnits(unit, True)
                print(ret)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 18.0.0. Use :py:func: SetLengthUnits instead.",
        DeprecationWarning,
    )


def GatherFaces(
    face: object, feature_angle: float, visibility: str, container: str
) -> object:
    """

    Function that gathers the desired faces from all faces of the model or from
    every visible one or from containers.
    This function works a script alternative for selecting faces. The user can gather
    any face he needs in a similar way as he would select faces from the screen.

    The script function works either in visible faces defining visibililty named argument
    as 'visible', or in the entire database defining visibililty named argument as 'all'.

    Besides the option to define feature angle, the user can obtain faces by defining container named argument as 'PID',
    gathering faces which have the same PID, by defining as 'PID_region', gathering faces which have the same PID and are
    topologically associated, by defining as 'PART', gathering faces which have the same part, taking into account the
    visibility mode.

    In case that user will define neither visibility nor container named arguments,
    function will return faces that are topologically associated according to given feature_angle, as in gui mode.
    Specifically, if feature_angle is not defined, it is initialized to 40 degrees.

    Parameters
    ----------
    face : object
            A face to define the feature angle selection, 'PID', 'PID_region', or 'PART'.

    feature_angle : float, optional
            Specify the 'feature_angle' value. All neighboring faces will be selected provided
            that the angle formed by the normals of neighboring entities is less than the
            specified value. This allows for fast and easy selection of specific regions of the
            model. Adjusting the 'feature angle' value controls the extent of the selection area
            of the entities. If not defined feature_angle is initialized to 40 degrees.

    visibility : str, optional
            If visibility = 'all', then the entire database is taken into account,
            if visibility = 'visible', only visible faces.
            In case that visibility is not defined visible faces are taken into account.

    container : str, optional
            Container can be one of the following strings:
            -'PID', gathering faces with same PID.
            -'PID_region', gathering faces that are topologically connected with same PID.
            -'PART', gathering faces with the same part.
            If not defined, feature_angle selection is taken into account.

    Returns
    -------
    object
            Returns a list with the gathered faces, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def gatherFaces():
                face = base.GetEntity(constants.NASTRAN, "FACE", 167)

                faces_list = base.GatherFaces(
                    face, feature_angle=2.0, visibility="all", container="PID_region"
                )
                print("Gatherd_Faces =", len(faces_list))

                container = base.CreateEntity(constants.NASTRAN, "HIGHLIGHT_CONTAINER")
                base.AddToHighlight(container, faces_list, "WHITE")

                base.RedrawAll()


    """


def SizeBoxByCurves(
    height_edges: object,
    top_bottom_edges: object,
    max_surface_length: float,
    max_volume_length: float,
) -> object:
    """

    Function for creating a size box by defining its four "height" edges and the "top", "bottom" edges (optionally).

    Parameters
    ----------
    height_edges : object
            A list that contains all the entities that define the four box "height" edges.

    top_bottom_edges : object, optional
            A list that contains all the entities that define the "top", "bottom" edges of
            the new box.

    max_surface_length : float, optional
            The max surface length of the created size box.

    max_volume_length : float, optional
            The max volume length of the created size box.

    Returns
    -------
    object
            Returns a reference to the newly crated box object on success, 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def sizeBoxByCurves():
                height_edges = []
                height_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 5))
                height_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 6))
                height_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 7))
                height_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 8))
                height_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 9))
                height_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 10))

                top_bottom_edges = []
                top_bottom_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 3))
                top_bottom_edges.append(base.GetEntity(constants.NASTRAN, "CURVE", 4))

                base.SizeBoxByCurves(
                    height_edges=height_edges,
                    top_bottom_edges=top_bottom_edges,
                    max_surface_length=0.01,
                    max_volume_length=0.05,
                )


    """


def SizeBoxSplitProject(box_edge: object, points: object) -> int:
    """

    Function for projecting points array on an edge to split size box(es).

    Parameters
    ----------
    box_edge : object
            A box edge that will be split (point will be projected on this edge).

    points : object
            The points (3D point, node, hot point, etc) to project on the box edge.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    See Also
    --------
    SizeBoxSplit

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = []
                ents.append(base.GetEntity(constants.NASTRAN, "GRID", 4030658))
                ents.append(base.GetEntity(constants.NASTRAN, "GRID", 4030659))
                ents.append(base.GetEntity(constants.NASTRAN, "GRID", 4030660))
                edg = base.GetEntity(constants.NASTRAN, "SIZEBOXEDGE", 239)
                base.SizeBoxSplitProject(edg, ents)


    """


def SizeBoxByPoints(
    points: object, solid_type: str, max_surface_length: float, max_volume_length: float
) -> object:
    """

    Function for creating a 3D size box from existing nodes or edges, shells.

    Parameters
    ----------
    points : object
            A list with entities from where 5,6,7 or 8 points will be taken to create
            a TETRA, PYRAMID, PENTA or HEXA box.

    solid_type : str, optional
            An argument that defines the solid type in case that the input points could
            be used for the creation of more than one solid types.
            It takes the values "hexa", "penta", "tetra" or "pyramid".

    max_surface_length : float, optional
            The max surface length of the created size box.

    max_volume_length : float, optional
            The max volume length of the created size box.

    Returns
    -------
    object
            Returns a reference to the newly created box object on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                points1 = []
                points1.append(base.GetEntity(constants.NASTRAN, "GRID", 266))
                points1.append(base.GetEntity(constants.NASTRAN, "GRID", 279))
                points1.append(base.GetEntity(constants.NASTRAN, "GRID", 258))
                points1.append(base.GetEntity(constants.NASTRAN, "GRID", 246))
                points1.append(base.GetEntity(constants.NASTRAN, "GRID", 280))
                points1.append(base.GetEntity(constants.NASTRAN, "GRID", 257))
                base.SizeBoxByPoints(
                    points=points1,
                    solid_type="penta",
                    max_surface_length=1.2,
                    max_volume_length=1.2,
                )

                points2 = []
                points2.append(base.GetEntity(constants.NASTRAN, "GRID", 271))
                points2.append(base.GetEntity(constants.NASTRAN, "GRID", 309))
                points2.append(base.GetEntity(constants.NASTRAN, "GRID", 308))
                points2.append(base.GetEntity(constants.NASTRAN, "GRID", 267))
                points2.append(base.GetEntity(constants.NASTRAN, "GRID", 285))
                points2.append(base.GetEntity(constants.NASTRAN, "GRID", 286))
                base.SizeBoxByPoints(
                    points=points2, solid_type="hexa", max_surface_length=3.4, max_volume_length=4.8
                )


    """


def FlangesCompatible(
    faces1: object, faces2: object, option: int, create_interface_pid: bool
) -> object:
    """

    Given two compatible sets of faces, it applies flanges compatible to them and returns
    1 on success, 2 on partial done, 0 on failure and all faces cut in the process.

    Parameters
    ----------
    faces1 : object
            A list of first set of faces either entities or face IDs.

    faces2 : object
            A list of second set of faces either entities or face IDs.

    option : int, optional
            An integer representing the flanges compatible option:
            0 - Link (default)
            1 - Topo
            2 - Fuse
            (suppliance of this argument is optional, default value = 0)

    create_interface_pid : bool, optional
            Set to True, if the user wants the flange compatible faces created
            (for options link and topo) to be assigned to new interface PID.
            False otherwise (suppliance of this argument is optional).
            (Default: False)

    Returns
    -------
    object
            Returns 1 on success, 2 on partial done, 0 on failure and a list with the faces
            that have been cut in case of success or partial done.

    See Also
    --------
    FlangesCompatibleLink, FlangesCompatibleTopo, FlangesCompatibleFuse

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # first example - with face IDs
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces = base.FlangesCompatible(
                    faces1=faces1IDs, faces2=faces2IDs, option=2, create_interface_pid=True
                )


            # second example - with face entities
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces1 = []
                for id in faces1IDs:
                    faces1.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces2 = []
                for id in faces2IDs:
                    faces2.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces = base.FlangesCompatible(
                    faces2=faces2, faces1=faces1, option=0, create_interface_pid=True
                )
                print(faces)


    """


def IsolateFlangesProximity(
    entities1: object,
    entities2: object,
    search_by: str,
    fact_or_dist: float,
    solid_thic: float,
    angle: float,
) -> object:
    """

    Detects flanges by proximity, just like the Isolate>Flanges>Proximity button.
    'entities1' and 'entities2' definitions are important.
    If none is defined, function will detect flanges on all visible entities.
    if only entities1 is defined, function will detect flanges on that container.
    If both entities1 and entities2 are defined, function will detect flanges between those containers,
    flanges between entities1 elements and flanges between entities2 elements will be ignored.
    The function does not alter the model visibility (as opposed to the ANSA button).
    If elements are detected as flanges, they will be returned in a list.

    Parameters
    ----------
    entities1 : object, optional
            The first container of entities (shells/faces/solids).

    entities2 : object, optional
            The second container of entities (shells/faces/solids).

    search_by : str, optional
            Search method: "factor" or "distance".
            (Default: "factor")

    fact_or_dist : float, optional
            The factor/distance value.
            (Default: 1.0)

    solid_thic : float, optional
            The 'thickness' that will be applied to solids for the check.
            (Default: 1.0)

    angle : float, optional
            The maximum allowed angle between two entities to be considered flanges.
            (Default: 10.0)

    Returns
    -------
    object
            Returns:
            -NULL if there is an input data error.
            -None if the function detects no flanges.
            -A list with all the detected flange elements.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # Will search on all visible entities using factor 1.5 , solid_thic=1(undeclared, default) and angle=20.
            def main():
                base.IsolateFlangesProximity(search_by="factor", fact_or_dist=1.5, angle=20)


            # Will search for flanges with factor=1 and angle=10 between faces of PID 1 and 50. Result will be isolated visible.
            def main():
                prop1 = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                prop2 = base.GetEntity(constants.NASTRAN, "PSHELL", 50)

                entities1 = base.CollectEntities(constants.NASTRAN, prop1, "FACE")
                entities2 = base.CollectEntities(constants.NASTRAN, prop2, "FACE")

                flanges = base.IsolateFlangesProximity(
                    entities1, entities2, search_by="factor", fact_or_dist=1, angle=10
                )
                isolate = base.Or(flanges)


    """


def MergeSets(
    sets: object, keep_sets_as_nested: bool, delete_merged_sets: bool
) -> object:
    """

    Merges two or more sets into a new one.

    Parameters
    ----------
    sets : object
            A list of the sets we need to Merge.

    keep_sets_as_nested : bool, optional
            Option to add the selected sets as nested into the new set, instead of
            only adding their contents.
            (Default: False)

    delete_merged_sets : bool, optional
            Option to delete the sets we merged.
            All the objects that refer to these sets will be changed to refer to the newly
            created set, that derives from the selected sets merge.
            Only effective if keep_sets_as_nested = False.
            (Default: False)

    Returns
    -------
    object
            Returns a reference to the newly created set that derives from the sets merge.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def test_merge_sets():
                sets = base.CollectEntities(0, None, "SET")

                new_set = base.MergeSets(sets, keep_sets_as_nested=False, delete_merged_sets=True)
                print(new_set)


    """


def ConsBreak(cons: object, tolerance: float, angle: float) -> int:
    """

    This function breaks the selected CONS, CURVES by inserting Hot Points on locations of discontinuity.
    In case a selected CONS-CURVE does not have any discontinuity, this CONS is not broken.

    Parameters
    ----------
    cons : object
            Can be a CONS, a list of CONS, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible CONS.
            If it is called with 'all', it works with all the CONS in database.

    tolerance : float, optional
            Discontinuity distance, the maximum gap between limits of two curves.
            (Default value : Nodes matching distance)

    angle : float, optional
            The angle formed between two consecutive curves in degrees.
            (Default : 45)

    Returns
    -------
    int
            Returns 1 on success and 0 on error.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                cons_list = []
                cons_list.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 720))
                cons_list.append(base.GetEntity(ansa.constants.NASTRAN, "CONS", 758))
                ret = ansa.base.ConsBreak(cons_list)
                # ret = ansa.base.ConsBreak('visible')
                print(ret)


    """


def InputOffForm(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function inputs an off format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputOffForm("C:/temp/users/folder/data.off", nodes_id="keep-old")


    """


def OutputOffForm(filename: str, mode: str) -> int:
    """

    This function outputs a model in OFF Format from ANSA.

    Parameters
    ----------
    filename : str
            The file system path.

    mode : str, optional
            Accepted values: "all", "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputOffForm("C:/temp/users/folder/data.off", "all")


    """


def AddToRdsSubset(subset: object, entities: object) -> object:
    """

    Adds an entity or a matrix containing entities, to a subset.
    The AddToRdssubset function performs significantly faster when
    entities are added in to the set massively, through a list.

    Parameters
    ----------
    subset : object
            The subset entity reference.

    entities : object
            A list of references or a single reference
            of the entities that will be added to the set.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                all_props = base.CollectEntities(constants.RADIOSS, search_types="__PROPERTIES__")

                p_subset = base.GetEntity(constants.RADIOSS, "SUBSET", 1)
                for prop in all_props:
                    base.AddToRdsSubset(p_subset, prop)
                # or you can use a list of entities (i.e. Properties or Subsets)
                base.AddToRdsSubset(p_subset, all_props)


    """


def InteractiveGroupingOfPartsBasedOnAttribute(
    attribute_name: str, group_name_color: object, group_names_order: object, type: str
) -> object:
    """

    This function can classify parts according to a given attribute name (argument
    'attribute_name') and after the user's interaction, pick parts from one group and
    push to another in order to change their value. Parts are colored according to
    their value for the given attribute name. If an attribute does not exist,
    it will be created.

    For Parts use "ANSAPART" for argument 'type' or nothing.
    The function works for Parts by default.

    The function also supports grouping of subsystems.
    For Subsystems use argument: type = "ANSA_SUBSYSTEM".

    Parameters
    ----------
    attribute_name : str
            The attribute name.

    group_name_color : object, optional
            The groups names to use and their respective colors.

    group_names_order : object, optional
            A list cointaining the order of the group names to be displayed in the gl area.

    type : str, optional
            The type of the entities that will be classified.

    Returns
    -------
    object
            Returns a dictionary with the entities (parts or subsystems) grouped according to
            their values (groups of entities per value).
            In case of QUITALL or ESCKEY (Cancel), None is returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def InteractiveGroupingOfPartsBasedOnAttribute():
                # for parts
                base.InteractiveGroupingOfPartsBasedOnAttribute(
                    attribute_name="User/MyStatus",
                    group_name_color={
                        "OK": [0, 255, 0, 100],
                        "WARNING": [255, 255, 0, 100],
                        "ERROR": [255, 0, 0, 100],
                        "N/A": [200, 200, 200],
                    },
                    group_names_order=["OK", "WARNING", "ERROR", "N/A"],
                )

                # for subsystems
                base.InteractiveGroupingOfPartsBasedOnAttribute(
                    attribute_name="User/IO_Index",
                    group_name_color={
                        "1": [0, 255, 0, 100],
                        "2": [255, 255, 0, 100],
                        "3": [255, 0, 0, 100],
                        "N/A": [200, 200, 200],
                    },
                    group_names_order=["1", "2", "3", "N/A"],
                    type="ANSA_SUBSYSTEM",
                )


    """


def DampingPatchLayerNew(
    dpatch: object, layer_pos: int, mat: object, t: float, theta: float, sout: str
) -> int:
    """

    Creates a new Damping Patch layer in the specified Damping Patch.

    Parameters
    ----------
    dpatch : object
            A Damping Patch object

    layer_pos : int
            The position of the new layer.

    mat : object, optional
            A Material object for the layer. If no Material is given,
            a default MAT1 Material will be created.

    t : float, optional
            The thickness of the layer.
            (Default: 1.0)

    theta : float, optional
            The angle of the layer.
            (Default: 0.0)

    sout : str, optional
            The sout of the layer. Accepted values: "", "yes" or "not".
            (Default: "")

    Returns
    -------
    int
            Always returns 0.

    See Also
    --------
    DampingPatchLayerDelete, DampingPatchLayerModify, DampingPatchLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                dpatch = base.GetEntity(constants.NASTRAN, "DAMPING_PATCH", 1)
                base.DampingPatchLayerNew(dpatch, 1)


    """


def DampingPatchLayerDelete(dpatch: object, layer_pos: int) -> int:
    """

    Deletes a Damping Patch layer in the specified Damping Patch.

    Parameters
    ----------
    dpatch : object
            A Damping Patch object.

    layer_pos : int
            The position of the layer to delete.

    Returns
    -------
    int
            Always returns 0.

    See Also
    --------
    DampingPatchLayerNew, DampingPatchLayerModify, DampingPatchLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                dpatch = base.GetEntity(constants.NASTRAN, "DAMPING_PATCH", 1)
                base.DampingPatchLayerDelete(dpatch, 1)


    """


def DampingPatchLayerModify(
    dpatch: object, layer_pos: int, mat: object, t: float, theta: float, sout: str
) -> int:
    """

    Modifies a Damping Patch layer in the specified Damping Patch.

    Parameters
    ----------
    dpatch : object
            A Damping Patch object.

    layer_pos : int
            The position of the new layer.

    mat : object, optional
            A Material object for the layer. If no Material is given,
            a default MAT1 Material will be created.

    t : float, optional
            The thickness of the layer.

    theta : float, optional
            The angle of the layer.

    sout : str, optional
            The sout of the layer.

    Returns
    -------
    int
            Always returns 0.

    See Also
    --------
    DampingPatchLayerNew, DampingPatchLayerDelete, DampingPatchLayerInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                dpatch = base.GetEntity(constants.NASTRAN, "DAMPING_PATCH", 1)

                mat = base.GetEntity(constants.NASTRAN, "MAT1", 4)
                base.DampingPatchLayerModify(dpatch, 1, mat, 0.1, 45, "YES")


    """


def DampingPatchLayerInfo(dpatch: object, layer_pos: int, fields: object) -> object:
    """

    Gets values from a Damping Patch Layer in the specified Damping Patch.

    Parameters
    ----------
    dpatch : object
            A Damping Patch object.

    layer_pos : int
            The position of the new layer.

    fields : object
            A list of the fields to retrieve info from.
            Available fields are:
            -MID: (object) The Material.
            -T: (float) The thickness.
            -THETA: (float) The angle.
            -SOUT: (string) The sout: "", "YES" or "NO".

    Returns
    -------
    object
            Returns a dictionary with key the 'fields' values. Otherwise None is returned.

    See Also
    --------
    DampingPatchLayerNew, DampingPatchLayerDelete, DampingPatchLayerModify

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                dpatch = base.GetEntity(constants.NASTRAN, "DAMPING_PATCH", 1)

                ret = base.DampingPatchLayerInfo(dpatch, 1, ("MID", "T", "THETA", "SOUT"))
                print(ret)


    """


def ControlListItemsNum(deck: int, control: int, type: str) -> object:
    """

    Gets the total number of the items of a Control list.

    Parameters
    ----------
    deck : int
            One of PAMCRASH, LSDYNA, RADIOSS.

    control : int
            A reference to the Control entity.

    type : str
            Keyword of the Control entity that has a list to get values from.

    Returns
    -------
    object
            Returns a dictionary with the total number of items, on success.
            Otherwise, None is retuned.

    See Also
    --------
    ControlNewListItem, ControlDeleteListItem, ControlModifyListItem, ControlInfoListItem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                control = base.GetGlobalControl(constants.LSDYNA)
                set = base.GetEntity(constants.LSDYNA, "SET", 1)
                prop = base.GetEntity(constants.LSDYNA, "SECTION_SHELL", 1)
                base.ControlNewListItem(
                    constants.LSDYNA,
                    control,
                    "MPP_DECOMPOSITION_ARRANGE_PARTS",
                    entity=prop,
                    part_type=0,
                )

                ret = base.ControlListItemsNum(
                    constants.LSDYNA, control, "MPP_DECOMPOSITION_ARRANGE_PARTS"
                )
                print("Items Num:", ret["Items"])


    """


def CanvasList() -> object:
    """

    Returns a list with all the Canvas objects.

    Returns
    -------
    object
            Returns a list with the Canvas names, or None if there are no Canvas objects.

    See Also
    --------
    Canvas

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                canvas = base.Canvas("MyCanvas")

                canvas.set_color(0xFF0000FF)
                canvas.point_size(10)
                canvas.point(0, 0, -1)
                canvas.show()

                names = base.CanvasList()
                for name in names:
                    print(name)
                    canvas = base.Canvas(name)
                    print(canvas._name)


    """


def DrawModeList() -> object:
    """

    Gets a list with all the DrawMode objects.

    Returns
    -------
    object
            Returns a list with all the DrawMode objects, or None if none of them exist.

    See Also
    --------
    DrawMode

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                draw_mode1 = base.DrawMode("MyDrawMode1")
                draw_mode1.enable()

                draw_mode2 = base.DrawMode("MyDrawMode2")
                draw_mode2.enable()

                draw_modes = base.DrawModeList()
                for draw_mode in draw_modes:
                    print(draw_mode._name)


    """


def CopyPartsToAnsaModel(parts: Entity | Iterable, model: Entity) -> int:
    """

    Copies one or more parts of the active model to another model.

    Parameters
    ----------
    parts : Entity | Iterable
            A list of part entities.

    model : Entity
            The model object where parts will be copied.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                model = base.GetEntity(constants.NASTRAN, "MODEL", 1)
                part = base.GetPartFromModuleId("1")
                base.CopyPartsToAnsaModel(part, model)


    """


def GetInterfaceNode(entity: object, create: bool) -> object:
    """

    The function returns the interface node of an element and optionally
    it can create it, if it does not exist, and return it.

    Parameters
    ----------
    entity : object
            The entity from which interface node will be returned.
            Warning: not all entities have interface node.

    create : bool, optional
            Force create an interface node if the entity does not have any.
            (Default: False)

    Returns
    -------
    object
            Returns the interface node or None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = base.CollectEntities(constants.NASTRAN, None, "LC_POINT")
                for ent in ents:
                    # node = base.GetInterfaceNode(ent)
                    node = base.GetInterfaceNode(ent, True)

                    if node == None:
                        print("Interface node not found")
                    else:
                        print("Interface node found")


    """


def ConsProject(
    entities: object,
    faces_array: object,
    range: float,
    project_type: object,
    min_length: float,
    split_original: bool,
    connect_with_faces: bool,
    paste: bool,
    produce_curves: bool,
    nearest_target: bool,
    delete_faces: bool,
    paste_sides: bool,
) -> object:
    """

    This function projects a number of selected 3D-curves, CONS, element edges or line elements
    on a number of selected Faces, in a direction that is normal, or the user defines to each Face.

    Parameters
    ----------
    entities : object
            The projected entity, a list with the projected entities, a string with
            value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible entities.
            If it is called with 'all', it works with all the entities.

    faces_array : object
            A face, a list of faces, a string with value 'visible' or a string
            with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    range : float, optional
            If given, projections are being created only in areas that the projection
            distance is not bigger than the specified value, else there is no limitation.

    project_type : object, optional
            A dictionary containing tuples of string values 'normal' or 'user' - a triple
            of floats defining the direction, in case that string value is 'user'.
            Triple of floats may not be given, in case that string value equals
            with 'normal'.

    min_length : float, optional
            If given, avoids projections in areas that would create CONs very
            close to the existing ones, provided that the defined value is not
            bigger than the critical length.

    split_original : bool, optional
            If True, the source curves will be split according to their
            projections' Hot Points.

    connect_with_faces : bool, optional
            If set to True, it results in the creation of Faces between the
            original CONS and their projections. The newly created Faces,
            will also be returned in a list.

    paste : bool, optional
            If True, source entities (CONS, 3D Curves, etc.) and target projections
            are pasted, if their distance is smaller than the "CONS matching
            distance" parameter in Windows>Settings>Settings>Tolerance.

    produce_curves : bool, optional
            If True, 3D Curves are produced instead of CONS as projections
            of the source curves.

    nearest_target : bool, optional
            If True, projection will take place on nearest faces within the range
            of maximum projection distance and avoid double projection on
            opposite positioned faces.
            (Default: False)

    delete_faces : bool, optional
            If True, if the trace of the projection forms a closed loop inside the target faces (not touching the outer perimeters), faces inside the loop will be deleted.
            (Default: False)

    paste_sides : bool, optional
            if True and "connect_with_faces" is True, projects and pastes the sides of the newly created faces to nearby geometry, within cons matching distance.
            (Default: False)

    Returns
    -------
    object
            Returns a list containing two lists. The first list contains the newly created CONS.
            The second list contains the newly created faces, if connect_with_faces flag is True,
            otherwise it is None.

    See Also
    --------
    ConsProjectNormal, ConsProjectUser, FacesProject, CurvesProjectOnPlane

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                arg1 = base.GetEntity(constants.NASTRAN, "CONS", 2)
                arg2 = base.GetEntity(constants.NASTRAN, "FACE", 7)
                arg3 = {"Normal": (0, 0, 0)}
                base.ConsProject(entities=arg1, faces_array=arg2, project_type=arg3, min_length=20)

                # ...or...

                arg1 = []
                arg1.append(base.GetEntity(constants.NASTRAN, "CONS", 2))
                arg1.append(base.GetEntity(constants.NASTRAN, "CONS", 10))
                arg4 = {"User": (0.86012, -0.295475, 0.415799)}
                base.ConsProject(
                    entities=arg1,
                    faces_array="visible",
                    range=150.26,
                    project_type=arg4,
                    min_length=20,
                    split_original=True,
                    connect_with_faces=True,
                    paste=True,
                )

                # ...or...

                arg1 = []
                arg1.append(base.GetEntity(constants.NASTRAN, "CONS", 2))
                arg1.append(base.GetEntity(constants.NASTRAN, "CONS", 10))
                arg2 = base.GetEntity(constants.NASTRAN, "FACE", 7)
                arg3 = {"User": (0.925859, -0.0637592, 0.372452)}
                ret_list = base.ConsProject(
                    entities=arg1,
                    faces_array=arg2,
                    project_type=arg3,
                    produce_curves=True,
                    nearest_target=True,
                )

                print(len(ret_list))
                print(len(ret_list[0]))
                print(len(ret_list[1]))


    """


def SurfacesReduce(faces: object, tolerance: float, shrink: bool, perface: bool) -> int:
    """

    Certain Surfaces may have a very detailed description. In some rare cases this may lead to problems
    like bad projections and offsetting or slightly distorted mesh. This function addresses these problems
    by automatically applying one of two procedures. It firstly attempts to simplify the selected surfaces
    or, if this fails, to reduce them. More specifically:

    Simplify: It replaces an existing surface with a planar or one of the primitive shapes (sphere, torus, cone, cylinder)
    approximation, provided that its roughness falls within the Tolerance value.
    It will also shrink Surfaces to the minimum size required to accommodate the Faces sharing these Surfaces,
    by activating the relevant option.

    Reduce: It reduces the data of surfaces. Data reduction is achieved by means of the mathematical description
    and the number of patches of the surface.

    Parameters
    ----------
    faces : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    tolerance : float
            Can be any positive value, corresponding to the 'Tolerance' line edit.

    shrink : bool, optional
            Can be True or False, corresponding to the activation or not of the flag 'Shrink'.

    perface : bool, optional
            Can be True or False, corresponding to the activation or not of the flag 'Per face'.
            In case it becomes True, shrink value becomes True too.
            (Default: False)

    Returns
    -------
    int
            Returns the number of reduces and/or shrinked surfaces or 0 on failure.

    See Also
    --------
    Simplify

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = []
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 82))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 83))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 84))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 85))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 86))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 87))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 88))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 89))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 90))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 97))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 105))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 140))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 141))

                base.SurfacesReduce(faces=faces, tolerance=0.05, shrink=True, perface=True)


    """


def PlaneCutMulti(
    auxiliary_entities: object,
    defined_wrkplanes: str,
    entities: object,
    produce_plane_faces: bool,
    perform_topology: bool,
) -> int:
    """

    This function cuts a number of selected Faces, FE elements, CONS or Curves with a number of planes which are defined perpendicularly along a chain of CONS or 3D curves. At least one cutting plane can be used, which corresponds in the middle of the input named argument "auxiliary_entities".

    Parameters
    ----------
    auxiliary_entities : object
            Input entities, Curves or CONS normally to which cut planes will be defined.

    defined_wrkplanes : str
            Input string to specify the number of equidistant cut planes,
            or the absolute step distance between them.
            In the latter case, type "~" and the desired distance and the fitting
            number of planes between the end-points of the chain will be created.

    entities : object
            A list of entities where the cut will be applied, a string with value 'visible'
            or a string with value 'all' . If it is called with 'visible', it works with all
            the visible entities. If it is called with 'all', it works with all the entities.

    produce_plane_faces : bool, optional
            If True, new planar face(s) will be created lying on the plane(s) that
            will intersect with the face(s)/shell(s).

    perform_topology : bool, optional
            If False, the performed plane-cut will get released into red bounds.
            If True, all cuts will be pasted.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def plane_cut_multi():
                deck = base.CurrentDeck()
                aux_ents = []
                aux_ents.append(base.GetEntity(deck, "CONS", 7))

                def_wrk_planes = "~10"
                # def_wrk_planes = '3'

                entities = []
                entities.append(base.GetEntity(deck, "FACE", 7))
                entities.append(base.GetEntity(deck, "FACE", 4))
                entities.append(base.GetEntity(deck, "FACE", 2))

                plncutMulti = base.PlaneCutMulti(aux_ents, def_wrk_planes, entities, False, True)
                print(plncutMulti)


    """


def CircleTangentToCurves(first_entity: object, second_entity: object) -> object:
    """

    This script function defines an arc using two 3d Curves or Cons.

    Parameters
    ----------
    first_entity : object
            A dictionary containing tuples of entities (CURVES, CONS) - a triple of floats
            defining the start point of the corresponding entity.

    second_entity : object
            A dictionary containing tuples of entities (CURVES, CONS) - a triple of floats
            defining the start point of the corresponding entity.

    Returns
    -------
    object
            Returns the created CURVE, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = {}
                arg1[base.GetEntity(ansa.constants.NASTRAN, "CURVE", 9)] = (0, 50, -80)
                arg2 = {}
                arg2[base.GetEntity(ansa.constants.NASTRAN, "CURVE", 10)] = (0, -70, 40)
                ansa.base.CircleTangentToCurves(arg1, arg2)


    """


def CurvesCircleConcentric(curve: object, distance: float) -> object:
    """

    This function defines a 3D curve, as an arc of a circle concentric to a selected 3D curve circle definition.

    Parameters
    ----------
    curve : object
            A 3D curve object, which is an arc of a circle (3D curve).

    distance : float
            The distance, specifying the difference between the radius of
            the input circle and the new concentric circle.

    Returns
    -------
    object
            Returns the created 3d curve, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                arg1 = base.GetEntity(constants.NASTRAN, "CURVE", 11)
                created_curve = base.CurvesCircleConcentric(curve=arg1, distance=10)
                print(created_curve)


    """


def FlangesCornerMark(faces: object) -> int:
    """

    This function inserts two Hot Points to mark free round-shaped edges (corners),
    identifying them automatically by the input faces.

    Parameters
    ----------
    faces : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    Returns
    -------
    int
            Returns 1 in all cases.

    See Also
    --------
    FillCorner

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = []
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 124))
                base.FlangesCornerMark(faces)


    """


def FlangesSimplify(cons: object) -> int:
    """

    This function simplifies the flanges shape, by creating faces using the already existing surface.

    Parameters
    ----------
    cons : object
            A cons or a list of cons.

    Returns
    -------
    int
            Returns 1 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cons = []
                cons.append(base.GetEntity(constants.NASTRAN, "CONS", 137))
                base.FlangesSimplify(cons)


    """


def CreateGEB(entities: object, type: str) -> object:
    """

    This function takes as input a collection of nodes, and creates a Generic Entity
    Builder (GEB). The nodes are grouped into elements, edges and nodes.

    Parameters
    ----------
    entities : object
            A collection of nodes.

    type : str
            The type of the GEB that will be created (i.e. ENTITY_NAME_SB, ENTITY_NAME_BC etc).

    Returns
    -------
    object
            Returns the created GEB on successs, or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                s = base.GetEntity(constants.NASTRAN, "SET", 13)
                grids_of_set = base.CollectEntities(constants.NASTRAN, s, "GRID")
                geb_ent = base.CreateGEB(grids_of_set, "GEB_SB")


    """


def SizeBoxCornerPoints(boxes: object) -> object:
    """

    Script function for acquiring the corner points of a size-box.

    Parameters
    ----------
    boxes : object
            A list with size-box entities.

    Returns
    -------
    object
            Returns a list containing the acquired corner points on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                m = []
                m.append(base.GetEntity(constants.NASTRAN, "SIZE_BOX", 1))
                m.append(base.GetEntity(constants.NASTRAN, "SIZE_BOX", 2))

                corner = base.SizeBoxCornerPoints(m)
                for ent in corner:
                    print("Corner point = ", ent._id)


    """


def DeleteSubsystem(subsystem: object) -> bool:
    """
    .. deprecated:: 17.1.0
            Use :py:func:`DeleteEntity` instead.


    Deletes a subsystem from the ANSA database.

    Parameters
    ----------
    subsystem : object
            The subsystem entity that should be deleted.

    Returns
    -------
    bool
            Returns True on success, False otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ent = base.GetPartFromName("Subsystem_1", "ANSA_SUBSYSTEM")
                print(base.DeleteSubsystem(ent))


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.1.0. Use :py:func: DeleteEntity instead.",
        DeprecationWarning,
    )


def AddToSubsystem(subsystem: object, ents: object, force_move: bool) -> bool:
    """

    Adds entities to a subsystem.

    Parameters
    ----------
    subsystem : object
            The subsystem entity to which we need to add entities to.

    ents : object
            A list that contains the entities that should be added to the subsystem.

    force_move : bool, optional
            If true, parts or groups are converted to Top Items in hierarchy
            to be eligible for dropping in the user-specified subsystem.

    Returns
    -------
    bool
            Returns true on success, false otherwise.

    See Also
    --------
    RemoveFromSubsystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromName("Part_1")
                subsystem = base.GetPartFromName("Subsystem_1", "ANSA_SUBSYSTEM")
                print(base.AddToSubsystem(subsystem, [part]))


    """


def RemoveFromSubsystem(subsystem: object, ents: object) -> bool:
    """
    .. deprecated:: 20.0.0
            Use :py:func:`RemoveFromModelContainer` instead.


    Removes entities from a subsystem.

    Parameters
    ----------
    subsystem : object
            The subsystem entity, which we need to remove entities from.

    ents : object, optional
            A list that contains the entities that should be removed from the subsystem.

    Returns
    -------
    bool
            Returns True on success, False otherwise.

    See Also
    --------
    AddToSubsystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromName("Part_1")
                subsystem = base.GetPartFromName("Subsystem_1", "ANSA_SUBSYSTEM")
                print(base.RemoveFromSubsystem(subsystem, [part]))


    """

    import warnings

    warnings.warn(
        "Deprecated since version 20.0.0. Use :py:func: RemoveFromModelContainer instead.",
        DeprecationWarning,
    )


def PopulateSubsystemWithInclude(subsystem: object) -> bool:
    """

    This function takes all the contained entities of a subsystem, creates an include
    to contain them and attaches that include to the subsystem.

    Parameters
    ----------
    subsystem : object
            The subsystem entity.

    Returns
    -------
    bool
            Returns True if the command was executed successfully, False otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                ent = base.GetPartFromName("Subsystem_1", "ANSA_SUBSYSTEM")
                print(base.PopulateSubsystemWithInclude(ent))


    """


def Clear() -> int:
    """

    The function clears all the drawing area of ANSA.
    It functions similar to pressing the "ALL" and then the "INVERT" button inside Focus Toolbar.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Clear()


    """


def WritePamstampFabric(
    filename: str, mode: str, write_thickness: bool, title: str
) -> int:
    """

    Writes a Pamstamp Fabric file, i.e. a M01 file containing thickness (THCK) and fiber direction (FIB1/FIB2) data.

    Parameters
    ----------
    filename : str
            The full path name for the Pamstamp file.

    mode : str, optional
            "all" or "visible".
            (Default: "all")

    write_thickness : bool, optional
            If set to True, write the thickness.
            (Default: True)

    title : str, optional
            The title of the file.
            (Default: "")

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    See Also
    --------
    ReadPamstampFabric

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.WritePamstampFabric("/home/user/file")


    """


def ReadPamstampFabric(filename: str) -> int:
    """

    Reads a Pamstamp Fabric file, i.e. an M01 file containing thickness (THCK) and fiber direction (FIB1/FIB2) data.

    Parameters
    ----------
    filename : str
            The full path name for the Pamstamp file.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    See Also
    --------
    WritePamstampFabric

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ReadPamstampFabric("/home/user/file")


    """


def GetReferenceLibraryEntity(deck: int, name: str, type: str) -> object:
    """

    Transfers an entity from the Reference Library to the current ANSA model, given its name and type.

    Parameters
    ----------
    deck : int
            The deck constant.

    name : str
            The name of the entity that will be transferred from the Reference Library.

    type : str
            A string that describes the type of element.
            It can be retrieved from the title of the element's edit card,
            where it is displayed within brackets.
            To get a reference to a property or a material, the types
            "__PROPERTIES__" and  "__MATERIALS__" can be used
            instead of the exact entity type.

    Returns
    -------
    object
            Returns None when the entity is not found, and a class object on success.

            The returned class has two members:
            entity:         The transferred entity.
            referentials:   A list containing all the referentials of the main transferred entity.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ref_entity = base.GetReferenceLibraryEntity(
                    constants.RADIOSS, "property name", "PROP/SHELL"
                )
                print(ref_entity.entity)
                print(ref_entity.referentials)


    """


def HotPointsMarkUnmark(hot_point: object, unmark: bool) -> int:
    """

    This function is used to define Welding Spots on existent Hot Points or to remove selected Welding Spots.

    Parameters
    ----------
    hot_point : object, optional
            A hot point, a list of hot points, a string with value 'visible' or a string
            with value 'all'. If it is called with 'visible', it works with all the visible hot points.
            If it is called with 'all', it works with all the hot points.
            If the hot_point argument is not given, it works with all the visible hot points.

    unmark : bool, optional
            If set to True, functionality unmarks the already marked welding spots,
            else it marks the selected hot_point/s.
            (Default: False)

    Returns
    -------
    int
            Returns 1 in all cases.

    See Also
    --------
    HotPointsWeldSpot

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # base.HotPointsMarkUnmark(hot_point='visible', unmark=False)
                # base.HotPointsMarkUnmark()

                hots = []
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 287865))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 287866))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 68315))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 68567))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 68489))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 68853))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 290497))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 287872))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 69318))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 68136))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 67756))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 66704))
                hots.append(base.GetEntity(constants.NASTRAN, "HOT POINT", 69234))

                base.HotPointsMarkUnmark(hot_point=hots, unmark=False)
                # base.HotPointsMarkUnmark(hot_point='all', unmark=True)


    """


def HotPointsWeldSpot(
    face: object, coordinates: object, produce3dpoint: bool, ret_ents: bool
) -> object:
    """

    This function defines Welding Spots (magenta circle with cross) or 3D points (cyan squares) at the indicated position on a selected Face.

    Parameters
    ----------
    face : object
            The face that weld spots will be created.

    coordinates : object
            A list containing lists with triples of x, y, z, defining the set of points
            that will be projected on the input face, in order to create weld spots.
            [[x1, y1, z1], [x2, y2, z2], ..., [xn, yn, zn]]

    produce3dpoint : bool, optional
            Produce 3d points instead of weld spots.

    ret_ents : bool, optional
            If set to True, returns the created entities, otherwise the number of the
            successful projections.
            (Default: False)

    Returns
    -------
    object
            Returns the number of the successful projections, otherwise 0.
            If ret_ents=True returns the created entities, otherwise None.

    See Also
    --------
    HotPointsMarkUnmark

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                face = base.GetEntity(base.CurrentDeck(), "FACE", 63046)
                coords = []
                coords.append([2688.54, -353.579, 13.3602])
                coords.append([2724.17, -331.047, 13.1536])
                coords.append([2779.36, -313.861, 12.4984])
                coords.append([2833.71, -323.72, 11.4548])
                coords.append([2851.94, -338.252, 11.0163])
                coords.append([2861.41, -347.123, 10.7709])
                ret = base.HotPointsWeldSpot(face, coords, False, True)
                print(ret)


    """


def CreatePropertiesFromShellsThickness(
    shells: object,
    thickness_step: float,
    base_value: float,
    cut_mesh: bool,
    expand_level: int,
    always_create_new_pids: bool,
    start_pid: int,
    create_fe_perimeters: bool,
    apply_pid_per_macro: bool,
) -> object:
    """

    This function will create new properties according to the average shell's nodal
    thickness and to the given thickness step. These properties will be assigned
    correctly to all the given shells correspondingly .

    Parameters
    ----------
    shells : object
            A list that holds the shells we want to process .

    thickness_step : float
            The step that we will use to bundle thicknesses.

    base_value : float, optional
            The base value will be included in the discretization of nodal to property thickness.

    cut_mesh : bool, optional
            Option for cutting mesh at thickness changes.
            (DEPRECATED ARGUMENT)

    expand_level : int, optional
            The number of expand levels to improve the mesh around the edges where mesh will be cut.
            (DEPRECATED ARGUMENT)

    always_create_new_pids : bool, optional
            Option to create always new properties or using existing properties every time the function is called.

    start_pid : int, optional
            The starting PID of the created properties. Used in case of option 'always_create_new_pids' is true.

    create_fe_perimeters : bool, optional
            Option for creating FE perimeters at PID bounds.

    apply_pid_per_macro : bool, optional
            Option for applying PID per macro. In order for this to work, 'cut_mesh' and 'create_fe_perimeters' should be False. It is also not working for shells belonging to 'Not Recognized' parts.

    Returns
    -------
    object
            Returns a list with the created properties, on success.
            On failure returns None.

    See Also
    --------
    CreateIsoperimeters

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shells = base.CollectEntities(constants.ABAQUS, None, "SHELL")
                new_props = base.CreatePropertiesFromShellsThickness(shells, 0.5)
                print(new_props)


    """


def SetPamstampFabricAngles(shells: object, b2_offset: float) -> int:
    """

    Sets the Fabric Angles b1 and b2 for PAM-CRASH. THETA must be defined on Shell elements for this function to work.
    Angle b1 is calculated based on shell's THETA. Angle b2 is defined as b1+b2_offset.

    Parameters
    ----------
    shells : object
            A list with Shell elements.

    b2_offset : float
            Add this value to angle b1 in order to produce a value for angle b2.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    See Also
    --------
    WritePamstampFabric, ReadPamstampFabric

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                base.SetPamstampFabricAngles(shells, 90.0)


    """


def LoadDMEntities(entities: object, load: bool) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`LoadEntities` instead.


    This functions loads/unloads Model Browser entities from DM. When in Load mode all specified
    entities will first be cleared of their contents and then be loaded(downloaded) from DM. When
    in Unload mode, entities will be cleared and left empty.

    Parameters
    ----------
    entities : object
            A list of Model Browser entities which can be loaded/unloaded.
            These can be Subsystems, Simulation Models, Simulation Runs or
            Library Items, or any combination of them.

    load : bool
            Set this argument to True to load the specified entities from DM or False to unload them.
            (Default: False)

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                subsystems = base.CollectEntities(0, None, "ANSA_SUBSYSTEM")
                base.LoadDMEntities(entities=subsystems, load=True)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: LoadEntities instead.",
        DeprecationWarning,
    )


def FacesFuseProximities(
    faces1: object, faces2: object, method: object, part: object, property: object
) -> object:
    """

    This function closes the narrow gap between two groups of faces and connects them along a wide area.

    Parameters
    ----------
    faces1 : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    faces2 : object
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.

    method : object
            A dictionary containing tuples of string values 'Translate' or 'Offset' - four floats
            defining the direction (the first triple-dx, dy,dz) and the distance, in case that the
            string value is 'Translate', a float defining the offset distance, in case that the
            string value is 'Offset'.

    part : object, optional
            The part for the created face(s).

    property : object, optional
            The property for the created faces(s).

    Returns
    -------
    object
            Returns a list with the created face(s), otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                arg1 = []
                arg1.append(base.GetEntity(constants.NASTRAN, "FACE", 5))
                arg1.append(base.GetEntity(constants.NASTRAN, "FACE", 6))
                arg1.append(base.GetEntity(constants.NASTRAN, "FACE", 8))
                arg2 = []
                arg2.append(base.GetEntity(constants.NASTRAN, "FACE", 1))
                arg2.append(base.GetEntity(constants.NASTRAN, "FACE", 2))
                arg2.append(base.GetEntity(constants.NASTRAN, "FACE", 3))
                arg3 = {}
                arg3["Translate"] = (5.68434e-015, -6.15804e-015, -1, 30.50)
                arg4 = base.GetEntity(constants.NASTRAN, "ANSAPART", 2)
                arg5 = base.GetEntity(constants.NASTRAN, "PSHELL", 3)
                created_faces = base.FacesFuseProximities(
                    faces1=arg1, faces2=arg2, method=arg3, part=arg4, property=arg5
                )
                print(created_faces)


            def main2():
                arg1 = []
                arg1.append(base.GetEntity(constants.NASTRAN, "FACE", 5))
                arg1.append(base.GetEntity(constants.NASTRAN, "FACE", 6))
                arg2 = []
                arg2.append(base.GetEntity(constants.NASTRAN, "FACE", 1))
                arg2.append(base.GetEntity(constants.NASTRAN, "FACE", 2))
                arg3 = {}
                arg3["Offset"] = 25.32
                arg4 = base.GetEntity(constants.NASTRAN, "ANSAPART", 2)
                arg5 = base.GetEntity(constants.NASTRAN, "PSHELL", 1)
                created_faces = base.FacesFuseProximities(
                    faces1=arg1, faces2=arg2, method=arg3, part=arg4, property=arg5
                )
                print(created_faces)


    """


def FacesFusePipes(cons1: object, cons2: object) -> int:
    """

    This function closes the narrow gap between two solid description pipes that lie one inside the other.

    Parameters
    ----------
    cons1 : object
            A CONS that lies on the inner perimeter of the outer pipe.

    cons2 : object
            A CONS that lies on the outer perimeter of the inside pipe.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                arg1 = base.GetEntity(constants.NASTRAN, "CONS", 28)
                arg2 = base.GetEntity(constants.NASTRAN, "CONS", 44)
                base.FacesFusePipes(cons1=arg1, cons2=arg2)


    """


def FacesFuseProject() -> object:
    """

    Ths function projects and connects every visible single (red) CONS to the visible neighboring faces.

    Returns
    -------
    object
            Returns a list of the created CONS on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                cons_list = ansa.base.FacesFuseProject()
                print(cons_list)


    """


def PointsRemoveDouble(entities: object, tolerance: float) -> int:
    """

    This function deletes duplicate 3D Points within a user specified tolerance.

    Parameters
    ----------
    entities : object
            A point, a list of points, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible points.
            If it is called with 'all', it works with all the points.

    tolerance : float
            A search value that describes the distance where possible collision
            may occur between input 3D Points.

    Returns
    -------
    int
            Returns the number of the deleted 3D Points on success, else 0.

    See Also
    --------
    RemoveDoubleConnections

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = []
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2499))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2501))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2502))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2503))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2504))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2505))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2506))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2507))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2508))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2509))
                arg1.append(base.GetEntity(base.CurrentDeck(), "POINT", 2510))
                ret = base.PointsRemoveDouble(entities=arg1, tolerance=33)
                # base.PointsRemoveDouble(entities='visible', tolerance=33)
                # base.PointsRemoveDouble(entities='all', tolerance=33)
                print(ret)


    """


def InputOptistruct(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    header: str = "overwrite",
    ignore_enddata: str = "off",
    read_only: str = "wp",
    sets_type_definition: str = None,
    read_hmcomments: str = "off",
    bc_sets_offset: str = "offset",
    create_parameters: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    read_replication_lines: str = "off",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    advanced_options: str = "",
    coords_id: str = "offset",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    paste_nodes_by_id: str = "off",
    comment_input_laminates: str = "on",
    convert_stack_to_laminate: str = "off",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    The InputOptistruct function imports an Optistruct model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old" or
            "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge", "skip" or "new".
            (Default: "overwrite")

    ignore_enddata : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    sets_type_definition : str, optional
            Pairs of ids and type of imported sets. Ranges of sets can be
            specified a pair of lower and upper ids separated by ":".
            The whole range of imported sets can be represented by "ALL".
            Set type can be assigned option "NODE", "ELEMENT", "DESVAR", "RANDOM", "FATIGUE", "UNDEFINED" or "TRIM".

    read_hmcomments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    bc_sets_offset : str, optional
            Accepted values: "offset" or "keep-old".
            (Default: "offset")

    create_parameters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    read_replication_lines : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    advanced_options : str, optional
            Defines the entity types to be read:
            dr, Header, Nodes, Elements, Properties, Materials, Sets,
            Contacts. When this argument is defined only the provided
            types will be read. When dr exists in the beginning of the
            string the provided types will not be read
            If left blank everything will be read.

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    convert_stack_to_laminate : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure.
            If the "new_include" argument is enabled, it returns a reference to a new INCLUDE
            containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputOptistruct(filename="C:/temp/users/folder/data.fem", elements_id="offset")


    """


def OutputOptistruct(
    filename: str,
    mode: str,
    write_comments: str,
    format: str,
    continuation_lines: str,
    enddata: str,
    split_pyramid: str,
    disregard_includes: str,
    output_element_thickness: str,
    thickness: float,
    second_as_first: str,
    first_as_r: str,
    cweld_el_as_grid: str,
    apply_subcontainer_rules: str,
    lf_mode: str,
    beginbulk: str,
    output_numbering_rules: str,
    version: str,
    include_output_mode: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    update_include_fname: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    output_parameter_keywords: str,
    output_pcompg_as_pcomp: str,
    comment_output_name_comment,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_safety: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    comment_output_as_hypermesh,
    comment_output_lock_views: str,
    advanced_options: str,
    include: object,
    configuration: object,
    comment_output_annotations: str,
    comment_output_names_as_plain_comment: str,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_fe_perimeters: str,
    comment_output_features: str,
    comment_output_laminates: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs an Optistruct format file.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model, include or MBContainer that is being output)

    mode : str, optional
            "all", "model" or "visible".
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "as_v_11_2_4", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    format : str, optional
            "short" or "long".
            (Default: what set at the last execution)

    continuation_lines : str, optional
            "on" or "off".
            (Default: "off")

    enddata : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    split_pyramid : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_element_thickness : str, optional
            "off", "at_element_card" or "at_property_card".
            (Default: what set at the last execution)

    thickness : float, optional
            The thickness of the element.
            (Default: "0.0")

    second_as_first : str, optional
            "on" or "off".
            (Default: "off")

    first_as_r : str, optional
            "on" or "off".
            (Default: "off")

    cweld_el_as_grid : str, optional
            "on" or "off".
            (Default: "off")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    lf_mode : str, optional
            "system native", "unix" or "dos".
            (Default: what set at the last execution)

    beginbulk : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    version : str, optional
            Optistruct version. One of "2017", "2018".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    update_include_fname : str, optional
            "on" or "off".
            Corresponds to the "Update Include ReferenceFile"
            option of the Output Parameters of the GUI function.
            (Default: "off")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: "off")

    output_parameter_keywords : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_pcompg_as_pcomp : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_name_comment : , optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_safety : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_as_hypermesh : , optional
            "on" or "off".
            (Default: "off")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of dw, wo, followed by Header, UHeader, Nodes, UNodes, Elements,
            UElements, Properties, UProperties, Materials,
            UMaterials, Sets, USets, Contacts, Ucontacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    include : object, optional
            The reference to the include entity.

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include" argument.
            Outputs either an inactive configuration when no other
            actives, or the active one.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_names_as_plain_comment : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be written
            "alc_points", "lc_points" or "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def get_include_by_name(name):
                ents = base.NameToEnts(name)
                for ent in ents:
                    if base.GetEntityType(constants.NASTRAN, ent) == "INCLUDE":
                        return ent
                return False


            def main():
                base.OutputOptistruct(
                    filename="C:/temp/users/folder/data.fem", disregard_includes="on"
                )
                include_entity = get_include_by_name("data.fem")
                if include_entity:
                    base.OutputOptistruct(include=include_entity)


    """


def FacesPlaneCut(
    working_plane: object,
    entities: object,
    produce_plane_faces: bool,
    perform_topology: bool,
    part: object,
    property: object,
) -> int:
    """

    This function cuts a number of input Faces, FE elements, CONS or Curves with a Working Plane.
    This plane can be either an existing Working Plane or a newly created Working Plane, defined by a list of coordinates.

    Parameters
    ----------
    working_plane : object
            Can be one of the following:
            -A WPLANE.
            -A list containing two lists - [[x,y,z], [dx,dy,dz]].
            The first list contains a triplet of x, y, z coordinates defining the origin
            of the desired plane.
            The second list contains a triplet of dx, dy, dz (vector), defining the
            normal vector of the desired plane,
            -A list containing three lists of triplets [ [x1, y1, z1], [x2, y2, z2], [x3, y3, z3] ] defining three points that determine the desired working plane.

    entities : object
            A list of entities where the cut will be applied, a string with value
            'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible entities.
            If it is called with 'all', it works with all the entities.

    produce_plane_faces : bool, optional
            If set to True, the new planar face will be created lying on the plane
            that will intersect with the face(s)/shell(s).

    perform_topology : bool, optional
            If set to False, the performed plane-cut will get released into red bounds.
            If set to True, all cuts will be pasted.

    part : object, optional
            The part for the requested planar face.

    property : object, optional
            The property for the requested planar face.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main1():
                arg1 = []
                arg1.append([-104.657, -6.23047e-006, 0])  # origin
                arg1.append([0.639822, 0.768523, -1.2492e-007])  # normal vector
                arg2 = []
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 1))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 4))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 7))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 18))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 19))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 20))
                arg5 = base.GetEntity(base.CurrentDeck(), "ANSAPART", 3)
                arg6 = base.GetEntity(base.CurrentDeck(), "PSHELL", 1)
                base.FacesPlaneCut(
                    working_plane=arg1,
                    entities=arg2,
                    produce_plane_faces=True,
                    perform_topology=True,
                    part=arg5,
                    property=arg6,
                )


            def main2():
                arg1 = []
                arg1.append([-104.657, -6.23047e-006, 0])  # first point
                arg1.append([-82.0941, -92.3368, 50])  # second point
                arg1.append([-82.8806, -93.0893, 50.9028])  # third point
                arg2 = []
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 1))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 4))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 7))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 18))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 19))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 20))
                arg5 = base.GetEntity(base.CurrentDeck(), "ANSAPART", 3)
                arg6 = base.GetEntity(base.CurrentDeck(), "PSHELL", 1)
                base.FacesPlaneCut(
                    working_plane=arg1,
                    entities=arg2,
                    produce_plane_faces=True,
                    perform_topology=True,
                    part=arg5,
                    property=arg6,
                )


            def main3():
                arg1 = base.GetEntity(base.CurrentDeck(), "WPLANE", 1)
                arg2 = []
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 1))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 4))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 7))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 18))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 19))
                arg2.append(base.GetEntity(base.CurrentDeck(), "FACE", 20))
                arg5 = base.GetEntity(base.CurrentDeck(), "ANSAPART", 3)
                arg6 = base.GetEntity(base.CurrentDeck(), "PSHELL", 1)
                base.FacesPlaneCut(
                    working_plane=arg1,
                    entities=arg2,
                    produce_plane_faces=True,
                    perform_topology=True,
                    part=arg5,
                    property=arg6,
                )


    """


def ResultsMapperManualPosition(mapper: object, user_transformations: object) -> int:
    """

    The user can run directly the Manual Position Tool for a Results Mapper entity without opening its card.

    Parameters
    ----------
    mapper : object
            A RESULTS_MAPPER entity.

    user_transformations : object, optional
            One or more transformations matrices which will be applied after the
            transformation matrix of the Results Mapper.

    Returns
    -------
    int
            Returns 0 if OK was pressed.
            Returns 1 if Cancel was pressed or if another failure occured.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                resmap = base.GetEntity(constants.ABAQUS, "RESULTS_MAPPER", 1)
                m1 = [
                    [1.0, 0.0, 0.0, 0.0],
                    [0.0, 1.0, 0.0, 0.0],
                    [0.0, 0.0, 1.0, 0.0],
                    [2000.0, 0.0, 0.0, 1.0],
                ]

                m2 = [
                    [1.0, 0.0, 0.0, 0.0],
                    [0.0, 1.0, 0.0, 0.0],
                    [0.0, 0.0, 1.0, 0.0],
                    [1000.0, 0.0, 0.0, 1.0],
                ]

                base.ResultsMapperManualPosition(resmap, [m1, m2])


    """


def UpdateModelSetupEntities(entities: object, clear_first: bool) -> int:
    """
    .. deprecated:: 18.1.0
            Use :py:func:`OrganizeModelContainerEntities` instead.


    Accepts a list of entities (Subsystems, Simulation Models, Simulation Runs) and
    runs Action Update Model Setup Entities for them.

    Parameters
    ----------
    entities : object
            A list containing the entities on which the action Update
            Model Setup Entities will be executed for.
            Bear in mind that this action is not defined for the
            GEOMETRY_OUT_OF_SUBSYSTEMS subsystem.

    clear_first : bool, optional
            This argument is deprecated. The function's behaviour has been thoroughly updated
            and the Model Setup Entities are cleared and recalculated in all cases.

    Returns
    -------
    int
            Returns the number of entities that ran the Update Model Setup Entities action.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def updateMSEScriptFunc(all_subsystems):
                subs_to_update = []
                for subsystem in all_subsystems:
                    if subsystem._name != "GEOMETRY_OUT_OF_SUBSYSTEMS":
                        subs_to_update.append(subsystem)
                base.UpdateModelSetupEntities(subs_to_update, True)


            def main():
                base.SetCurrentDeck(
                    constants.RADIOSS
                )  # to make sure all will happen with compliant rules
                all_subsystems = base.CollectEntities(constants.RADIOSS, None, "ANSA_SUBSYSTEM")

                if len(all_subsystems):
                    updateMSEScriptFunc(all_subsystems)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 18.1.0. Use :py:func: OrganizeModelContainerEntities instead.",
        DeprecationWarning,
    )


def PointsRelative(relative: object, project_on_plane: object, ret_ents: bool) -> int:
    """

    This function defines new 3D-points that lie on a given relative position from a number
    of node entities, 3D-points, Hot Points, Weld Points, Grids etc, or by passing a list with
    lists of triple coordinates, that define the desired position of the created 3d-points.
    i.e. [[x1, y1, z1], [x2, y2, z2], ..., [xn, yn, zn]].

    Parameters
    ----------
    relative : object
            A list with node entities or a list with lists of triple coordinates, that define
            the desired position of the created 3d-points.
            i.e. [[x1, y1, z1], [x2,y2,z2], ..., [xn,yn,zn]].

    project_on_plane : object, optional
            A WPLANE or a CROSS_SECTION where the created 3d points will be projected.

    ret_ents : bool, optional
            If True, returns a list with the create 3d points in success, otherwise an empty list.

    Returns
    -------
    int
            Returns the number of the created 3d POINTS, otherwise 0.
            If ret_ents is True, returns a list with the created 3d points in success, otherwise an empty list.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = []
                arg1.append(base.GetEntity(base.CurrentDeck(), "MORPHPOINT", 1152))
                arg1.append(base.GetEntity(base.CurrentDeck(), "GRID", 4838))
                arg1.append(base.GetEntity(base.CurrentDeck(), "HOT POINT", 7366))
                base.PointsRelative(relative=arg1)


            # ...or...


            def main2():
                arg1 = []
                arg1.append([2489.68, -345.014, 32.45])
                arg1.append([2493.72, -337.113, 32.45])
                arg1.append([2500.76, -325.646, 32.45])
                arg1.append([2503.84, -317.167, 32.45])
                arg1.append([2503.94, -303.388, 32.45])
                base.PointsRelative(relative=arg1)


            # ...or...


            def main3():
                arg1 = []
                arg1.append(base.GetEntity(base.CurrentDeck(), "MORPHPOINT", 1152))
                arg1.append(base.GetEntity(base.CurrentDeck(), "GRID", 4838))
                arg1.append(base.GetEntity(base.CurrentDeck(), "HOT POINT", 7366))
                arg2 = base.GetEntity(base.CurrentDeck(), "WPLANE", 1)  # or CROSS_SECTION
                base.PointsRelative(relative=arg1, project_on_plane=arg2)


    """


def GetNastranHeaderInfo(header: object) -> object:
    """

    This function returns all the information from a nastran header.

    Parameters
    ----------
    header : object
            The nastran header where the information will be extracted from.

    Returns
    -------
    object
            Returns an object on success, or None on failure.

            This object header_info has the following members:
            header_info.solution:                   the solution
            header_info.nastran_statements:         a list of nastran statements
            header_info.file_management_statements: a list of file management statements
            header_info.executive_control:          a list of executive control statements
            header_info.case_control:               a list of objects for each subcase

            Each subcase object has the following members:
            subcase.subcase_id:             the subcase id (0: for common case)
            subcase.subcase_commands:       a list of objects for each statement in subcase

            Each subcase_command object has the following members:
            subcase_command.name:           the command name
            subcase_command.value:          the command value
            subcase_command.entity:         the referenced entity (if exists)
            subcase_command.line:           the command line

            header_info.parameters:         a list of objects for each parameter

            Each parameter object has the following members:
            parameter.name:                 the name of parameter
            parameter.value:                the value of parameter
            parameter.line:                 the command line

            header_info.unsupported_lines:  a list of lines that are not included in the
                                            above sections

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.NASTRAN
                header = base.CreateEntity(deck, "Nastran Header")
                text = "nastran system(151)=1\\nnastran system(189)=0.99\\n"
                text += "SOL   103\\nTIME  = 3.15E7\\nCEND\\nECHO =none\\nTITLE       = a_title\\nLABEL       =  a_label\\n"
                text += "METHOD      (STRUCT) = 99\\nMETHOD      (FLUID)  = 100\\n"
                text += "SUBCASE 1\\nSTRESS = ALL\\nDISPLACEMENT(RPUNCH, PLOT,PRINT) =  ALL\\n"
                text += "BEGIN BULK\\nPARAM,      COUPMASS ,          1"

                base.SetNastranHeaderText(header, text)
                header_data = base.GetNastranHeaderInfo(header)

                # solution
                solution = header_data.solution
                print("---SOLUTION---")
                print(solution)
                print("\\n")

                # nastran statements
                print("---NASTRAN STATEMENTS---")
                nastran_statements_list = header_data.nastran_statements
                for nastran_statement in nastran_statements_list:
                    print(nastran_statement)
                print("\\n")

                # file management
                print("---FILE MANAGEMENT---")
                fm_statements_list = header_data.file_management_statements
                for fm_statement in fm_statements_list:
                    print(fm_statement)
                print("\\n")

                # executive control
                print("---EXECUTIVE CONTROL---")
                exec_statements_list = header_data.executive_control
                for exec_statement in exec_statements_list:
                    print(exec_statement)
                print("\\n")

                # case control
                print("---CASE CONTROL---")
                case_control_list = header_data.case_control
                for subcase in case_control_list:
                    subcase_id = subcase.subcase_id
                    print("\\tSubcase:", str(subcase_id))

                    subcase_commands = subcase.subcase_commands
                    for command in subcase_commands:
                        command_name = command.name
                        print("\\t\\tcommand_name = ", command_name)
                        command_value = command.value
                        print("\\t\\tcommand_value = ", command_value)
                        command_entity = command.entity
                        print("\\t\\tcommand_entity = ", repr(command_entity))
                        command_line = command.line
                        print("\\t\\tcommand_line = ", command_line)
                        print("\\n")
                print("\\n")

                # parameters
                print("---PARAMETERS---")
                parameters_list = header_data.parameters
                for parameter in parameters_list:
                    parameter_name = parameter.name
                    print("parameter name = ", parameter_name)
                    parameter_value = parameter.value
                    print("parameter value = ", parameter_value)
                    parameter_line = parameter.line
                    print("parameter line = ", parameter_line)
                    print("\\n")
                print("\\n")

                # unsupported
                unsupported_list = header_data.unsupported_lines
                print("---UNSUPPORTED LINES---")
                for unsupported in unsupported_list:
                    print(unsupported)


    """


def SetNastranOutputRequestToGeb(geb: object, output_request: str) -> int:
    """

    Given a nastran output request line, sets the appropriate values in GEB_OR.

    Parameters
    ----------
    geb : object
            A GEB_OR entity.

    output_request : str
            A nastran output request line.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                output_request_line = "DISPLACEMENT (SORT1, PRINT) = ALL"
                geb_or = base.CreateEntity(constants.NASTRAN, "GEB_OR")

                base.SetEntityCardValues(constants.NASTRAN, geb_or, {"Name": "DISPLACEMENT"})
                base.SetNastranOutputRequestToGeb(geb_or, output_request_line)


    """


def SgraphMapAction(
    group_1: object, group_2: object, matching_threshold: float, map_type: str
) -> object:
    """

    This function maps Parts or Pids of provided groups, using Separation graph (SGRAPH).

    Parameters
    ----------
    group_1 : object
            A list that contains elements like volumes, shells
            and solids and containers like group, parts, sets. These
            entities are going to be loaded in SGRAPH group1.

    group_2 : object
            A list that contains elements like volumes, shells
            and solids and containers like group, parts, sets. These
            entities are going to be loaded in SGRAPH group2.

    matching_threshold : float, optional
            Is the matched area percentage above which parts/pids is concidered unmatched.
            (Default: 0.1)

    map_type : str, optional
            The basic grouping unit, meaning "part" o "pid".
            (Default: "part")

    Returns
    -------
    object
            Returns a dictionary.
            The key is a Part/Pid of group_2 and the data is another dictionary, with key a Part/Pid of group_1 and
            data the matching area percentage between the respective Part/Pid of group_2 and Part/Pid of group_1.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                group1 = base.GetPartFromName("FE")
                group2 = base.GetPartFromName("GEOM")
                base.SetANSAdefaultsValues({"sgraph_search_range": 5})
                ret = base.SgraphMapAction(
                    group_1=group1, group_2=group2, matching_threshold=0.1, map_type="part"
                )

                for target, source_data in ret.items():
                    for source, perc in source_data.items():
                        print(
                            "Taget item:",
                            target,
                            "is matched with source item:",
                            source,
                            "with percentage:",
                            perc,
                            "\\n",
                        )


    """


def PointsDelete(entities: object) -> int:
    """

    This function deletes a number of selected 3D-points (cyan squares), circle centers (cyan circles), point-sets, Spots (red circles) or TARGET_POINTS.

    Parameters
    ----------
    entities : object, optional
            A point, a list of points, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible points.
            If it is called with 'all', it works with all the points.
            If no input is given, the function will delete the visible entities.

    Returns
    -------
    int
            Returns the number of deleted 3D Points on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                points = []
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 14))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 13))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 12))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 11))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 10))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 9))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 8))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 7))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 6))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 5))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 4))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 3))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 2))
                points.append(base.GetEntity(base.CurrentDeck(), "POINT", 1))
                base.PointsDelete(points)  #'all', 'visible'


    """


def ReleaseVolumes(faces: object) -> int:
    """

    This function disconnects geometrical volumes that have been topologically pasted.
    The volumes are released and the triple (cyan) CONS become double (yellow).

    Parameters
    ----------
    faces : object, optional
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.
            If no input is given, release performs on visible faces.

    Returns
    -------
    int
            Returns 1 in all cases.

    See Also
    --------
    ReleaseCons

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                faces = []
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 1))
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 4))
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 5))
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 7))
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 9))
                base.ReleaseVolumes(faces)


            # ...or...


            def main2():
                base.ReleaseVolumes()  # release volumes in visible faces


    """


def LaminateSplit(deck: int, laminate: object, elements: object) -> object:
    """

    Splits the specified laminate property into two laminate properties; one that contains
    the specified elements and one that contains the rest of the initial property's elements.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH.

    laminate : object
            A reference to a laminate property.

    elements : object
            A list with elements that belong to the laminate property,
            which will form a new laminate property.

    Returns
    -------
    object
            Returns a reference to the newly created laminate part object, containing the specified list of elements.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import session


            def main():
                session.New("discard")
                base.InputNastran("/home/user/laminates.nas")
                laminates = base.CollectEntities(constants.NASTRAN, None, "LAMINATE")
                elements = base.CollectEntities(constants.NASTRAN, laminates[0], "__ELEMENTS__")

                ret = base.LaminateSplit(constants.NASTRAN, laminates[0], elements[0:10])
                print(ret)


    """


def LaminateReportWindow(laminates: object) -> int:
    """

    Opens a Laminate tool's Generate Report window for the given Laminates.

    Parameters
    ----------
    laminates : object
            A list with laminate properties.

    Returns
    -------
    int
            Returns 0 if OK was pressed, or 1 if Cancel was pressed or if another failure occured.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import session


            def main():
                session.New("discard")
                base.InputNastran("/home/user/laminates.nas")
                deck = base.CurrentDeck()

                laminates = base.CollectEntities(deck, None, "LAMINATE")
                ret = base.LaminateReportWindow(laminates)
                print(ret)

                laminates = base.CollectEntities(deck, None, "SOLID_LAMINATE")
                ret = base.LaminateReportWindow(laminates)
                print(ret)


    """


def AddToModelContainer(
    container: object, entities: object, force_move: bool, return_failed: bool
) -> object:
    """

    Adds entities to a model container.

    Model container types are:
    "ANSAPART", "ANSAGROUP", "ANSA_SUBSYSTEM", "ANSA_CONFIGURATION",
    "ANSA_SIMULATION_MODEL", "ANSA_SIMULATION_RUN", ANSA_LOADCASE".
    Entities types to be added are:
    All ANSA entity types(including Model container types).

    The model container and "entities" must have compatible types to interact.
    Compatibility examples:
    Adding "ANSAPART" to "ANSA_SUBSYSTEM".
    Adding "ANSAPART" to "ANSA_CONFIGURATION".
    Adding "ANSA_SUBSYSTEM" to "ANSA_SIMULATION_MODEL".
    Adding "ANSA_LIBRARY_ITEM" / "INCLUDE" to "ANSA_LOADCASE".
    Adding "ANSA_LOADCASE" / "ANSA_SIMULATION_MODEL" to "ANSA_SIMULATION_RUN".
    Adding any other ANSA entity to ANSAPART/ ANSA_SUBSYSTEM/ ANSA_SIMULATION_MODEL/ LOADCASE

    The compatibility between the Model Containers and the entities to be added
    can be checked in the Model Browser by dragging and drop operation.

    Parameters
    ----------
    container : object
            The Model Container to add entities to.
            For supported container types, check the function description.

    entities : object
            The entities to add to the model container.
            For container-entities type compatibility examples, check the function description.

    force_move : bool, optional
            If true, parts or groups are converted to Top Items in hierarchy
            to be eligible for dropping in the user-specified subsystem.

    return_failed : bool, optional
            Controls the return value. If set to True, a list of entities which
            failed to be added to the specified container is returned.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base

            NASTRAN = ansa.constants.NASTRAN


            # Example 1
            def main():
                subsystem = base.GetPartFromName("My_Subsystem", "ANSA_SUBSYSTEM")
                if not subsystem:
                    subsystem = base.CreateEntity(
                        NASTRAN, "ANSA_SUBSYSTEM", {"Name": "My_Subsystem"}
                    )
                part = base.GetPartFromName("My_Part")
                if not part:
                    part = base.CreateEntity(NASTRAN, "ANSAPART", {"Name": "My_Part"})
                base.AddToModelContainer(container=subsystem, entities=part)


            # Example 2
            def main():
                sim_run = base.GetPartFromName("My_Sim_Run", "ANSA_SIMULATION_RUN")
                if not sim_run:
                    sim_run = base.CreateEntity(
                        NASTRAN, "ANSA_SIMULATION_RUN", {"Name": "My_Sim_Run"}
                    )
                ent_types = ["ANSA_SIMULATION_MODEL", "ANSA_LOADCASE"]
                entities = []
                for ent_type in ent_types:
                    ent = base.GetPartFromName(ent_type, ent_type)
                    if not ent:
                        ent = base.CreateEntity(NASTRAN, ent_type, {"Name": ent_type})
                    entities.append(ent)
                base.AddToModelContainer(container=sim_run, entities=entities)


    """


def RemoveFromModelContainer(container: object, entities: object) -> object:
    """

    Removes entities from a model container.

    Model container types are:
    "ANSAPART", "ANSAGROUP", "ANSA_SUBSYSTEM", "ANSA_CONFIGURATION",
    "ANSA_SIMULATION_MODEL", "ANSA_SIMULATION_RUN", ANSA_LOADCASE".

    Entity types to be removed are:
    All ANSA entity types(including Model Container types).

    The model container and "entities" must have compatible types to interact.
    Compatibility examples:
    Removing "ANSAPART" from "ANSA_SUBSYSTEM".
    Removing "ANSAPART" from "ANSA_CONFIGURATION".
    Removing "ANSA_SUBSYSTEM" from "ANSA_SIMULATION_MODEL".
    Removing "ANSA_LIBRARY_ITEM" / "INCLUDE" from "ANSA_LOADCASE".
    Removing "ANSA_LOADCASE" / "ANSA_SIMULATION_MODEL" from "ANSA_SIMULATION_RUN".
    Removing any other ANSA entity from ANSA_SUBSYSTEM/ ANSA_SIMULATION_MODEL/ ANSA_LOADCASE.
    Removing the following ANSA entities from ANSAPART: GEBs, RESULTs_MAPPERs,
            INVERSE FORMINGs, SPCs, AIRBAGs, MOTIONs, DEFINE_HEX_SPOTWELD_ASSEMBLY, DISPLAY MODELs,
            Nastran PEM entities (TRMCPLs, ACPEMCPLs), Nastran Thermal BCs (QVECT etc).

    Parameters
    ----------
    container : object
            The Model Container to remove entities from.
            For supported container types, check the function description.

    entities : object
            The entities to remove from the model container.
            For container-entities type compatibility examples, check the function description.

    Returns
    -------
    object
            Always returns None.

    See Also
    --------
    base.AddToModelContainer

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            NASTRAN = constants.NASTRAN


            # Example 1
            def main():
                subsystem = base.CreateEntity(NASTRAN, "ANSA_SUBSYSTEM", {"Name": "My_Subsystem"})
                if not subsystem:
                    subsystem = base.CreateEntity(NASTRAN, "ANSAPART", {"Name": "My_Subsystem"})
                part = base.GetPartFromName("My_Part")
                if not part:
                    part = base.CreateEntity(NASTRAN, "ANSAPART", {"Name": "My_Part"})
                # Add and immediately remove the entity. If RemoveFromModelContainer was
                # not called, "My_Part" would have stayed inside "My_Subsystem"
                base.AddToModelContainer(container=subsystem, entities=part)
                base.RemoveFromModelContainer(container=subsystem, entities=part)


            # Example 2
            def main():
                sim_run = base.GetPartFromName("My_Sim_Run", "ANSA_SIMULATION_RUN")
                if not sim_run:
                    sim_run = base.CreateEntity(
                        NASTRAN, "ANSA_SIMULATION_RUN", {"Name": "My_Sim_Run"}
                    )
                ent_types = ["ANSA_SIMULATION_MODEL", "ANSA_LOADCASE"]
                entities = []
                for ent_type in ent_types:
                    ent = base.GetPartFromName(ent_type, ent_type)
                    if not ent:
                        ent = base.CreateEntity(NASTRAN, ent_type, {"Name": ent_type})
                    entities.append(ent)
                # Add and immediately remove the entities. If RemoveFromModelContainer was
                # not called, the entities would have stayed inside "My_Sim_Run"
                base.AddToModelContainer(container=sim_run, entities=entities)
                base.RemoveFromModelContainer(container=sim_run, entities=entities)


    """


def AutodetectGEBConnectivity(
    geb: object, type: str, search_area: str, search_distance: float
) -> object:
    """

    This function automatically detects the connectivity of Generic Entity Builders (GEBs) that
    have one of the following search patterns: UserDefinedArea, MappedArea, MappedAreaBox.

    Parameters
    ----------
    geb : object
            The GEB entity whose connectivity will be automatically detected.

    type : str
            The type of the connected entities. Can be one of the following:
            i) Part
            ii) Property
            iii) Subsystem

    search_area : str, optional
            Specify whether the function will search among "All" or "Visible" entities.
            (Default: "All")

    search_distance : float, optional
            Specify the search distance for the detection of connected entities.

    Returns
    -------
    object
            Returns a list with the detected entities.
            If the function fails to detect any entity, it will return None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                gebs = base.CollectEntities(0, None, "GEB_BC")
                base.AutodetectGEBConnectivity(
                    gebs[0], type="Part", search_area="All", search_distance=1
                )


    """


def SetCrossSectionPid(cross_section: object, property: object) -> int:
    """

    Set a PID to a cross section.

    Parameters
    ----------
    cross_section : object
            A cross section or a list of cross section entities.

    property : object
            A reference to a property.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.LSDYNA, "CROSS_SECTION", 2)
                prop = base.GetEntity(constants.LSDYNA, "__PROPERTIES__", 1)
                base.SetCrossSectionPid(cross, prop)


    """


def SetCurvePid(curve: object, property: object) -> int:
    """

    Sets a PID to a curve.

    Parameters
    ----------
    curve : object
            A reference to the curve to be set the property.

    property : object
            A reference to a property.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curve = base.GetEntity(constants.LSDYNA, "CROSS_CURVE", 1)
                prop = base.GetEntity(constants.LSDYNA, "__PROPERTIES__", 2)
                base.SetCurvePid(curve, prop)


    """


def PointsOnCurve(
    entities: object,
    total_points: str,
    create_curves: bool,
    create_pset: bool,
    ret_ents: bool,
) -> int:
    """

    This function distributes 3D-points (cyan squares) along selected 3D curves, CONS or element edges.
    At least one 3d Point can be defined, which corresponds in the middle of the input named argument "total_points".

    Parameters
    ----------
    entities : object
            A list with valid CONS, CURVE, MORPHEDGE or linear elements.

    total_points : str
            An input string to specify the number of equidistant 3d Points, or the
            absolute step distance between them. In the latter case, type "~" and
            the desired distance and the fitting number of 3d Points between the
            end-points of the chain will be created.

    create_curves : bool, optional
            If set to True, apart from the 3D Points, 3D Curves will also be created
            to fill the gaps between the selected Curves.
            (Default: False)

    create_pset : bool, optional
            If set to True, Point Sets will be created instead of 3D Points in a similar fashion.
            (Default: False)

    ret_ents : bool, optional
            If set to True, returns created 3d Points, in case create_pset equals to False.
            (Default: False)

    Returns
    -------
    int
            Returns the number of the created 3d Points, otherwise 0.
            In case that create_pset is True, the function returns the number of the created point sets, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = []
                arg1.append(base.GetEntity(base.CurrentDeck(), "CURVE", 409))
                arg1.append(base.GetEntity(base.CurrentDeck(), "MORPHEDGE", 395))
                ret = base.PointsOnCurve(
                    entities=arg1, total_points="123", create_curves=False, create_pset=False
                )
                print(ret)


    """


def PointsInLine(coordinates: object, total_points: str) -> int:
    """

    This function defines new 3D-points in a straight line between two input points.
    The user should pass as an input a list with two lists of triple doubles, defining the input points.

    Parameters
    ----------
    coordinates : object
            A list with two lists of x, y, z coordinates are given as first input, defining the positions.
            i.e. [[x1, y1, z1] , [x2, y2, z2]].

    total_points : str
            An input string to specify the number of equidistant 3d points, or the absolute
            step distance between them. In the latter case, type "~" and the desired distance
            and the fitting number of 3d points between the input end-points will be created.

    Returns
    -------
    int
            Returns the number of the created 3d Points on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                coords = []
                coords.append([2375.65, -270, 24.2841])
                coords.append([2467.72, -256, 28.85])
                ret = base.PointsInLine(coords, "231")
                print(ret)


    """


def FacesFreezeUnFreeze(faces: object, unfreeze: bool) -> int:
    """

    This function locks / unlocks the selected Faces and their boundary CONS segments.
    In this way, the Faces' condition is "function locked" and no participation to
    functions that might alter their topology or meshing (if any) is permitted!
    The input Macro Areas become frozen (locked) and the segments that compose their boundaries too.

    Parameters
    ----------
    faces : object, optional
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.
            If nothing is passed then functionality will freeze the visible faces.

    unfreeze : bool, optional
            If True input faces will be unfreezed in case that are frozen.
            (Default: False)

    Returns
    -------
    int
            Returns the number of the faces that have been freezed or unfreezed on success, otherwise 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                faces = []
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 63369))
                ret = base.FacesFreezeUnFreeze(faces=faces, unfreeze=True)
                print(ret)

                # ret = base.FacesFreezeUnFreeze(faces='visible', unfreeze=True)
                # ret = base.FacesFreezeUnFreeze(faces='all', unfreeze=False)
                # ret = base.FacesFreezeUnFreeze() ### it works with the visible faces


    """


def FlangesCompatibleLink(
    faces1: object, faces2: object, assign_property: int, assign_part: int
) -> object:
    """

    Given two compatible sets of faces, it apples flanges compatible with option link on them and
    returns 1 on success, 2 on partial done, 0 on failure and all faces cut in the process.

    Parameters
    ----------
    faces1 : object
            A list of first set of faces either entities or face IDs (Master faces).

    faces2 : object
            A list of second set of faces either entities or face IDs (Slave faces).

    assign_property : int, optional
            An integer representing the available options for assigning the property
            of newly created faces.
            0 - Assign property of master (default).
            1 - Assign property of slave.
            2 - Assign interface property.
            3 - No assignment (i.e., master/slave).

    assign_part : int, optional
            An integer representing the available options for assigning the part
            of newly created faces.
            0 - Assign part of master (default).
            1 - Assign part of slave.
            2 - Assign interface part.
            3 - No assignment (i.e., master/slave).

    Returns
    -------
    object
            A list containing 1 on success, 2 on partial done, 0 nfailure and a list with the faces
            that have been cut in case of success or partial done.

    See Also
    --------
    FlangesCompatibleTopo, FlangesCompatibleFuse

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # first example - with face IDs
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces = base.FlangesCompatibleLink(
                    faces1=faces1IDs, faces2=faces2IDs, assign_property=2, assign_part=1
                )


            # second example - with face entities
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces1 = []
                for id in faces1IDs:
                    faces1.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces2 = []
                for id in faces2IDs:
                    faces2.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces = base.FlangesCompatibleLink(
                    faces2=faces2, faces1=faces1, assign_property=1, assign_part=2
                )
                print(faces)


    """


def FlangesCompatibleTopo(
    faces1: object, faces2: object, assign_property: int, assign_part: int
) -> object:
    """

    Given two compatible sets of faces, it apples flanges compatible with option topo on them and
    returns 1 on success, 2 on partial done, 0 on failure and all faces cut in the process.

    Parameters
    ----------
    faces1 : object
            A list of first set of faces either entities or face IDs (Master faces).

    faces2 : object
            A list of second set of faces either entities or face IDs (Slave faces).

    assign_property : int, optional
            An integer representing the available options for assigning the property
            of newly created faces.
            0 - Assign property of master (default).
            1 - Assign property of slave.
            2 - Assign interface property.
            3 - Assign double property.

    assign_part : int, optional
            An integer representing the available options for assigning the part
            of newly created faces.
            0 - Assign part of master (default).
            1 - Assign part of slave.
            2 - Assign interface part.

    Returns
    -------
    object
            A list containing 1 on success, 2 on partial done, 0 on failure and a list with the faces
            that have been cut in case of success or partial done.

    See Also
    --------
    FlangesCompatibleLink, FlangesCompatibleFuse

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # first example - with face IDs
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces = base.FlangesCompatibleTopo(
                    faces1=faces1IDs, faces2=faces2IDs, assign_property=2, assign_part=1
                )


            # second example - with face entities
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces1 = []
                for id in faces1IDs:
                    faces1.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces2 = []
                for id in faces2IDs:
                    faces2.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces = base.FlangesCompatibleTopo(
                    faces2=faces2, faces1=faces1, assign_property=1, assign_part=2
                )
                print(faces)


    """


def FlangesCompatibleFuse(
    faces1: object,
    faces2: object,
    assign_property: int,
    assign_part: object,
    keep_faces: int,
) -> object:
    """

    Given two compatible sets of faces, it apples flanges compatible with option fuse on them and
    returns 1 on success, 2 on partial done, 0 on failure and all faces cut in the process.

    Parameters
    ----------
    faces1 : object
            A list of first set of faces either entities or face IDs (Master faces).

    faces2 : object
            A list of second set of faces either entities or face IDs (Slave faces).

    assign_property : int, optional
            An integer representing the available options for assigning the
            property of newly created faces.
            0 - Assign property of master (default).
            1 - Assign property of slave.
            2 - Assign interface property.

    assign_part : object, optional
            An integer representing the available options for assigning the
            part of newly created faces.
            0 - Assign part of master (default).
            1 - Assign part of slave.
            2 - Assign interface part.

    keep_faces : int, optional
            An integer representing the available options for keeping or deleting face caps.
            0 - Delete caps (default).
            1 - Keep master caps.
            2 - Keep slave caps.
            3 - Keep both master and slave caps.

    Returns
    -------
    object
            Returns a list containing 1 on success, 2 on partial done, 0 on failure and a list with the faces
            that have been cut in case of success or partial done.

    See Also
    --------
    FlangesCompatibleLink, FlangesCompatibleTopo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # first example - with face IDs
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces = base.FlangesCompatibleFuse(
                    faces1=faces1IDs,
                    faces2=faces2IDs,
                    assign_property=2,
                    assign_part=1,
                    keep_faces=2,
                )


            # second example - with face entities
            def main():
                faces1IDs = [1522, 1523]
                faces2IDs = [4107]

                faces1 = []
                for id in faces1IDs:
                    faces1.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces2 = []
                for id in faces2IDs:
                    faces2.append(base.GetEntity(constants.NASTRAN, "FACE", id))
                faces = base.FlangesCompatibleFuse(
                    faces2=faces2, faces1=faces1, assign_property=1, assign_part=2, keep_faces=0
                )
                print(faces)


    """


def GetGeometryOutOfSubsystems() -> object:
    """
    .. deprecated:: 21.1.0
            Use :py:func:`CollectEntities` instead.


    The function will return the GEOMETRY_OUT_OF_SUBSYSTEMS subsystem,
    or None in case the model does not have any subsystems.

    Returns
    -------
    object
            Returns a reference to the entity GEOMETRY_OUT_OF_SUBSYSTEMS,
            or None if it does not exist (when there are no subsystems in the model).

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def getAllSubsystems():
                ret_vals = base.CollectEntities(0, None, "ANSA_SUBSYSTEM")
                print("In total they are ", len(ret_vals))
                for entity in ret_vals:
                    print("I got ", entity._name)


            def getVisibleSubsystems():
                ret_vals = base.CollectEntities(0, None, "ANSA_SUBSYSTEM", filter_visible=True)
                print("In total they are ", len(ret_vals))
                for entity in ret_vals:
                    print("I got ", entity._name)


            def getGeomOutOfSubs():
                out_of_subs = base.GetGeometryOutOfSubsystems()
                print("Geometry ot of subsystems is ", out_of_subs)


            def getEntitiesOutOfMBContainers():
                entities = base.CollectEntities(
                    deck=0, containers=None, search_types="__OUT_OF_MBCONTAINERS__"
                )


            def main():
                print(
                    "-----------------------ALL SUBSYSTEMS-------------------------------------------------"
                )
                getAllSubsystems()
                print(" ")
                print(
                    "------------------------VISIBLE SUBSYSTEMS-------------------------------------------------"
                )
                getVisibleSubsystems()
                print(" ")
                print(
                    "------------------------GEOMETRY OUT OF SUBSYSTEMS-------------------------------------------------"
                )
                getGeomOutOfSubs()
                print(" ")
                print(
                    "-----------------------CONTENTS OUT OF MBCONTAINERS-----------------------------------------"
                )
                getEntitiesOuOfMBContainers()


    """

    import warnings

    warnings.warn(
        "Deprecated since version 21.1.0. Use :py:func: CollectEntities instead.",
        DeprecationWarning,
    )


def CreateConfigurations(source: str, names: str, variant_values: object) -> object:
    """

    This function will create new configurations as a given source/functionality would do.

    Parameters
    ----------
    source : str
            "variant_conditions": Create the configurations based on the
            "Variant Conditions" functionality.

    names : str, optional
            - "overwrite": If conflicting names occur with existing configurations' ones,
               ovewrite the configurations.
            - "offset": If conflicting names occur with existing configurations' ones,
               offset the new names.

    variant_values : object, optional
            A dictionary of configuration names to a dictionary of accepted variant name-value. If no value is specified for a variant name then a new configuration is created for all possible combinations for this variant

    Returns
    -------
    object
            Returns a list that contains the created configurations.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dict1 = {}
                dict1["variant_name1"] = "value1"
                dict1["variant_name2"] = "value2"
                dict1["variant_name3"] = "value3"

                dict2 = {}
                dict2["variant_name1"] = "value4"
                dict2["variant_name2"] = "value5"

                dictionary = {}
                dictionary["configuration_name1"] = dict1
                dictionary["configuration_name2"] = dict2

                created_configurations = base.CreateConfigurations(
                    "variant_conditions", names="overwrite", variant_values=dictionary
                )
                print(created_configurations)


    """


def ImportVariantValues(vechicle_id: str, variant_values: object) -> object:
    """

    This function imports the variant values that define a specific vehicle, so that they
    can be used by the "Variant Conditions" functionality.

    Parameters
    ----------
    vechicle_id : str
            An identifier for the vehicle (eg it's name).

    variant_values : object
            A dictionary, containing the variant values that define this vehicle.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vehicle_values = {"Right_Left_Steering": "Right", "Roof": "Open"}
                base.ImportVariantValues("right_open", vehicle_values)


    """


def ClearVariantValues() -> object:
    """

    This function clears all the imported vehicle variant values that got imported
    by the ImportVariantValues function.

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ClearVariantValues()


    """


def OutputSonate(filename: str, mode: str, source_unit_system: object) -> int:
    """

    This function ouputs a Sonate format file like the FILE>OUTPUT>SONATE functionality.

    Parameters
    ----------
    filename : str
            The name of the output file. Must reference the full path to the file.

    mode : str, optional
            Selection of output entities. Valid options are: 'all', 'model' or 'visible'.
            (Default: what set at the last execution)

    source_unit_system : object, optional
            A UnitSystem object. Dictates the unit system from which the output will be converted to SI.

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.NASTRAN
                loadcase = base.Loadcase(deck)
                base.SetEntityCardValues(deck, loadcase.nastran_header, {"Solver": "Sonate"})
                base.SetActiveNastranHeader(loadcase.nastran_header)
                base.OutputSonate("C:/temp/users/folder/sonate_file", "all")


    """


def OutOfIncludes(deck: int, search_types: object, filter_visible: bool) -> object:
    """

    Collects massively the entities of a particular type that are listed in the OUT OF INCLUDES container.

    Parameters
    ----------
    deck : int
            The deck for which the collection will take place.

    search_types : object
            A string or list of strings with "ansa keywords" of the types to be
            collected. Such types can be SHELL, SOLID, GRID etc.
            Additionally, the following keywords can be used:
            "__PROPERTIES__": returns all properties in the "OUT OF INCLUDES" container.
            "__MATERIALS__": returns all materials in the "OUT OF INCLUDES" container.
            "__ELEMENTS__": returns all standard elements in the "OUT OF INCLUDES" container.
            "__ALL_ENTITIES__": returns all entities in the "OUT OF INCLUDES" container.
            "__CONNECTIONS__":returns all connections in the "OUT OF INCLUDES" container.

    filter_visible : bool, optional
            Return only the entities that satisfy all collection criteria, have visibility
            status, and the status is active. In all other cases the parameter is ignored.
            (Default: False)

    Returns
    -------
    object
            Rreturns a list with references to the collected entities.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = []
                ents = base.OutOfIncludes(constants.NASTRAN, "__MATERIALS__")
                for ent in ents:
                    base.SetEntityCardValues(
                        constants.NASTRAN, ent, {"Name": "OUT OF INCLUDES MATERIAL"}
                    )


    """


def LaminateLayerTemplateNew(
    deck: int,
    laminate: object,
    id: int,
    name: str,
    color: object,
    add_elements: object,
    remove_elements: object,
    mat: object,
    ply: object,
    t: object,
    theta: object,
    nip: object,
    sout: object,
    type: object,
    tmanuf: float,
    dvpreln: object,
    mapped_data: str,
    mapped_thickness: object,
    mapped_orientation: object,
    rosette: object,
    a: float,
    sync_name: bool,
    layer_type: str,
    mat_thermal: object,
) -> int:
    """

    Creates a new laminate layer template in the specified laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH or OPTISTRUCT.

    laminate : object
            A laminate property.

    id : int, optional
            The id of the layer template.

    name : str, optional
            The name of the layer template.

    color : object, optional
            The color of the layer template. A list with 3 integers (rgb).

    add_elements : object, optional
            A list of elements to be added to the layer template.

    remove_elements : object, optional
            A list of elements to be removed from the layer template.

    mat : object, optional
            The material of the layer template. None to disable it.

    ply : object, optional
            The PLY of the layer template. None to disable it. (PAMCRASH)

    t : object, optional
            The thickness of the layer template. None to disable it.

    theta : object, optional
            The orientation angle of the layer template. None to disable it.

    nip : object, optional
            The number of integration points, NIP. None to disable it. (ABAQUS, ANSYS)

    sout : object, optional
            One of: "", "YES" or "NO". None to disable it. (NASTRAN)

    type : object, optional
            One of: "SHELL", "PLANE" or "CORE". None to disable it. (PERMAS)

    tmanuf : float, optional
            The thickness of one manufacturable ply, TMANUF of Optistruct. (NASTRAN)

    dvpreln : object, optional
            A list of DVPRELn. (NASTRAN)

    mapped_data : str, optional
            "Thick, Orient", "Thickness", "Orientation" or "".

    mapped_thickness : object, optional
            A list of the mapped thicknesses of the elements in "add_elements" matrix.

    mapped_orientation : object, optional
            A list or a list with lists of the mapped orientations of the elements
            in "add_elements" matrix.

    rosette : object, optional
            A rosette id.

    a : float, optional
            The angle between first and second material direction (Radioss).

    sync_name : bool, optional
            Synchronize Template Name with Layer Name

    layer_type : str, optional
            One of: "Draped", "Projected".

    mat_thermal : object, optional
            The thermal material of the layer template. None to disable it. (LSDYNA)

    Returns
    -------
    int
            Returns the id of the new layer template.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)
                elems = base.CollectEntities(deck, None, "SHELL")

                for i in range(1, 5):
                    base.LaminateLayerTemplateNew(
                        deck=deck, laminate=prop, id=i, name="Template" + str(i), add_elements=elems
                    )


    """


def LaminateLayerTemplateModify(
    deck: int,
    laminate: object,
    id: int,
    new_id: str,
    name: object,
    color: object,
    add_elements: object,
    remove_elements: object,
    mat: object,
    ply: object,
    t: object,
    theta: object,
    nip: object,
    sout: object,
    type: object,
    tmanuf: float,
    dvpreln: object,
    mapped_data: str,
    mapped_thickness: object,
    mapped_orientation: object,
    rosette: object,
    regenerate_mapped_data: bool,
    a: float,
    sync_name: bool,
    layer_type: str,
    mat_thermal: object,
) -> object:
    """

    Modifies a laminate layer template in the specified laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH or
            OPTISTRUCT.

    laminate : object
            A laminate property.

    id : int
            The id of the layer template.

    new_id : str, optional
            The new id of the layer template.

    name : object, optional
            The name of the layer template.

    color : object, optional
            The color of the layer template. A list with 3 integers (rgb).

    add_elements : object, optional
            A list of elements to be added to the layer template.

    remove_elements : object, optional
            A list of elements to be removed from the layer template.

    mat : object, optional
            The material of the layer template. None to disable it.

    ply : object, optional
            The PLY of the layer template. None to disable it. (PAMCRASH)

    t : object, optional
            The thickness of the layer template. None to disable it.

    theta : object, optional
            The orientation angle of the layer template. None to disable it.

    nip : object, optional
            The number of integration points, NIP. None to disable it. (ABAQUS, ANSYS)

    sout : object, optional
            One of: "", "YES" or "NO". None to disable it. (NASTRAN)

    type : object, optional
            One of: "SHELL", "PLANE" or "CORE". None to disable it. (PERMAS)

    tmanuf : float, optional
            The thickness of one manufacturable ply, TMANUF of Optistruct. (NASTRAN)

    dvpreln : object, optional
            List of DVPRELn. (NASTRAN)

    mapped_data : str, optional
            "Thick, Orient", "Thickness", "Orientation" or "".

    mapped_thickness : object, optional
            A list of the mapped thicknesses of the elements in "add_elements" matrix.

    mapped_orientation : object, optional
            A list or a list with lists of the mapped orientations of the elements
            in "add_elements" matrix.

    rosette : object, optional
            A rosette id, or None to clear rosette.

    regenerate_mapped_data : bool, optional
            If the mapped data of the layer will be regenerated when there are elements to be added to it. If it was already draped by ANSA, draping will be reapplied. Otherwise, any existing mapped data will be extrapolated to the newly added elements.

    a : float, optional
            The angle between first and second material direction (Radioss).

    sync_name : bool, optional
            Synchronize Template Name with Layer Name

    layer_type : str, optional
            One of: "Draped", "Projected".

    mat_thermal : object, optional
            The thermal material of the layer template. None to disable it. (LSDYNA)

    Returns
    -------
    object
            Returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)

                base.LaminateLayerTemplateModify(deck=deck, laminate=prop, id=1, t=0.02, theta=None)


    """


def LaminateLayerTemplateDelete(
    deck: int, laminate: object, id: int, delete_instances: bool
):
    """

    Deletes a laminate layer template from the specified laminate.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A laminate property.

    id : int
            The id of the layer template.

    delete_instances : bool, optional
            If True all layer instances will be deleted. (default = False)

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)

                ids = base.LaminateLayerTemplateIds(deck, prop)

                for id in ids:
                    base.LaminateLayerTemplateDelete(deck, prop, id)


    """


def LaminateLayerTemplateCopy(deck: int, laminate: object, id: int) -> int:
    """

    Copies a layer template of a laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A laminate property.

    id : int
            The id of the layer template.

    Returns
    -------
    int
            Returns the id of the newly created layer template.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)

                new_id = base.LaminateLayerTemplateCopy(deck=deck, laminate=prop, id=1)


    """


def LaminateLayerTemplateIds(deck: int, laminate: object) -> object:
    """

    Gets a list of ids of all the layer templates of a laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A laminate property.

    Returns
    -------
    object
            A list of ids of all the layer templates of a laminate property.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)

                ids = base.LaminateLayerTemplateIds(deck, prop)

                for id in ids:
                    base.LaminateLayerTemplateDelete(deck, prop, id)


    """


def LaminateLayerTemplateReferences(deck: int, laminate: object, id: int) -> object:
    """

    Gets a list of layers using the specified layer template.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS or PAMCRASH.

    laminate : object
            A laminate property.

    id : int
            The id of a layer template.

    Returns
    -------
    object
            Returns a list of tuples (sequence, layer).

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)

                ids = base.LaminateLayerTemplateIds(deck, prop)
                for id in ids:
                    print(
                        "template =",
                        id,
                        "-> layers =",
                        base.LaminateLayerTemplateReferences(deck, prop, id),
                    )


    """


def LaminateLayerTemplateInfo(
    deck: int, laminate: object, id: int, fields: object
) -> object:
    """

    Gets values from a layer template of the specified laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH or OPTISTRUCT.

    laminate : object
            A laminate property.

    id : int
            The id of the layer template.

    fields : object
            A list with the options that the user wants to extract the values from.
            Available options:
            "name"
            "color"
            "elements"
            "PLY"
            "MID"
            "T"
            "THETA"
            "NIP"
            "mapped_data"
            "mapped_thickness"
            "mapped_orientation"
            "SOUT"
            "type"
            "TMANUF"
            "DVPRELn"
            "rosette"
            "A"
            "sync_name"
            "layer_type"
            "TMID"

    Returns
    -------
    object
            Returns a dictionary with the requested options as keys and the retrieved values as the dictionary's values.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)

                ret = base.LaminateLayerTemplateInfo(
                    deck=deck, laminate=prop, id=1, fields=("name", "T")
                )
                print(ret)


    """


def OutputAtfx(filename: str, mode: str) -> int:
    """

    This function outputs a model in ATFX format.

    Parameters
    ----------
    filename : str
            The name of the output file.

    mode : str, optional
            "all", "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputAtfx("C:/temp/users/folder/data.wrl", "all")


    """


def InputIdeasMseries(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    merge_sets_by_name: str = "off",
    input_pyramids: str = "off",
    model_action: str = "merge_model",
    new_include: str = "off",
) -> int | Entity:
    """

    This function inputs an I-DEAS M-Series format file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    input_pyramids : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 0 on success and 1 on failure.
            If the "new_include" argument is enabled, it returns a reference to a new INCLUDE
            containing all the newly imported entities, or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputIdeasMseries(
                    filename="c:/temp/users/folder/data.mse", model_action="merge_model"
                )


    """


def InputIdeasV(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    new_include: str = "off",
) -> int | Entity:
    """

    This function inputs a '.unv' format file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 0 on success and 1 on failure.
            If the "new_include" argument is enabled, it returns a reference to a new INCLUDE
            containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputIdeasV(
                    filename="c:/temp/users/folder/data.unv", model_action="merge_model"
                )


    """


def InputMSeries(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    merge_sets_by_name: str = "off",
    input_pyramids: str = "off",
    model_action: str = "merge_model",
) -> int:
    """

    This function inputs an M-Series format file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    input_pyramids : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputMSeries(
                    filename="c:/temp/users/folder/data.mse", model_action="merge_model"
                )


    """


def InputSonate(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    target_unit_system: utils.UnitSystem = None,
) -> int:
    """

    This function inputs a Sonate format file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    target_unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the unit system to which the input will be
            converted from SI.
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputSonate("C:/temp/users/folder/data.xml", elements_id="offset")


    """


def InputUniversal(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    new_include: str = "off",
) -> int | Entity:
    """

    This function inputs a .unv format file.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 0 on success and 1 on failure.
            If the "new_include" argument is enabled, it returns a reference to a new INCLUDE
            containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputUniversal(
                    filename="C:/temp/users/folder/data.unv", model_action="merge_model"
                )


    """


def SurfacesFit(entities: object, part: object, prop: object, ret_ents: bool) -> object:
    """

    The function can be used to create a new Face, so that it fits input edges or point entities.
    Edges refer to Curves, CONS or even shell element edges, whereas point entities can be 3D Points,
    Hot Points or FE-Model nodes.
    Alternatively, the function accepts a list with lists of triple coordinates, that define the desired
    position that the new face fits.
    [[x1, y1, z1] [x2, y2, z2], ..., [xn, yn, zn]]

    Parameters
    ----------
    entities : object
            A list containing edges (CONS, CURVE, MORPH EDGES, CONNECTION EDGES, LINEAR ELEMENTS etc)
            and points (3D Points, Hot Points or FE-Model node) simultaneously.
            Alternatively, a list with lists of triple coordinates, that define the desired
            position that the new face fits.
            [[x1, y1, z1], [x2, y2, z2], ..., [xn, yn, zn]]

    part : object, optional
            The part for the created face.

    prop : object, optional
            The property for the created face.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.

    Returns
    -------
    object
            Returns True on success, otherwise False.
            If ret_ents=True it will return a list with the created entities,
            or None if no entities are created.

    See Also
    --------
    FacesNewFitted

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def surfsFit_1():
                cons = base.PickEntities(constants.NASTRAN, "CONS")
                nodes = base.CollectEntities(constants.NASTRAN, None, "POINT", filter_visible=True)

                arg1 = []
                for i in cons:
                    arg1.append(i)
                if nodes:
                    for i in nodes:
                        arg1.append(i)
                # CONFIGURE PART & PROPERTY - START
                ent_part = base.GetEntity(constants.NASTRAN, "CONS", 1433)
                part = base.GetEntityPart(ent_part)
                pid = base.GetEntity(constants.NASTRAN, "PSHELL", 24)
                # CONFIGURE PART & PROPERTY - END

                print(base.SurfacesFit(entities=arg1, part=part, prop=pid, ret_ents=True))


            def surfsFit_2():
                ents = []
                ents.append([2596.5, -10.5678, 213.519])
                ents.append([2598.28, -30.9169, 214.698])
                ents.append([2596.27, -8.73785, 212.412])
                ents.append([2594.79, -38.9747, 219.62])
                ents.append([2610.02, 12.6055, 211.382])
                ents.append([2611.53, -7.40267, 212.515])
                ents.append([2611.73, -9.23575, 213.521])
                ents.append([2613.51, -29.5849, 214.67])
                ents.append([2597.77, -37.4535, 217.754])
                ents.append([2613.14, -36.1107, 217.432])
                ents.append([2598.67, -56.001, 219.666])
                ents.append([2558.35, -11.1371, 250.722])
                ents.append([2560.27, -45.726, 248.741])
                ents.append([2513.13, -17.6892, 264.976])
                ents.append([2496.61, -27.8691, 262.948])
                ents.append([2515.55, -68.2739, 253.141])
                ents.append([2448.58, -71.6729, 249.49])
                ents.append([2447.74, -83.7495, 249.381])
                print(base.SurfacesFit(ents))


    """


def CurvesTangentPointToCurve(point: object, entity: object, part: object) -> object:
    """

    The function defines a 3D-curve between a selected point and the tangent of a selected 3D curve or CONS.
    Point entity can be 3D Point, Hot Point or FE-Model node.
    Alternatively, point can be represented by passing a list with xyz coordinates, [x, y, z].

    Parameters
    ----------
    point : object
            A point entity can be 3D Point, Hot Point or FE-Model node.
            Alternatively, point can be represented by passing a list
            with xyz coordinates, [x, y, z].

    entity : object
            Can be a CURVE or a CONS.

    part : object, optional
            The part for the created curve. If it is not defined, the part
            of the input entity will be taken into consideration.

    Returns
    -------
    object
            Returns the created curve on success, otherwise None.

    See Also
    --------
    CurvesTangentCurve

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                arg2 = base.PickEntities(constants.NASTRAN, "CURVE")
                # arg2 = base.GetEntity(constants.NASTRAN, 'CONS', 2317)

                arg1 = []
                arg1.append(2394.33)
                arg1.append(658.88)
                arg1.append(544.724)

                # arg1 = base.GetEntity(ansa.constants.NASTRAN, 'HOT POINT', 2327)

                cons2317 = base.GetEntity(ansa.constants.NASTRAN, "CONS", 2317)
                part = base.GetEntityPart(cons2317)

                print(base.CurvesTangentPointToCurve(point=arg1, entity=arg2, part=part))


    """


def FringeDrawModeList() -> object:
    """

    Gets a list with all the FringeDrawMode objects.

    Returns
    -------
    object
            Returns a list containing the FrineDrawMode objects, or None if none of them exist.

    See Also
    --------
    FringeDrawMode, DrawMode, DrawModeList, Canvas

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                draw_modes = base.FringeDrawModeList()
                for draw_mode in draw_modes:
                    print(draw_mode._name)
                    draw_mode.delete()


    """


def ExportPLMXMLTree(
    filename: str,
    parts: object,
    structure_info: str,
    representation_info: str,
    flatten_files: bool,
    export_jt: bool,
    export_png: bool,
    export_attachments: bool,
    file_handling: object,
    engine_settings: object,
) -> int:
    """

    This function exports model related information into a PLMXML package. This
    package consists of a PLMXML file, plus an optional directory which holds all
    file references from the XML file. The name of this directory is the same as the
    XML file minus the extension.

    The way files are referenced from the XML file depends on the configured File
    Handling information. If no explicit File Handling information is provided (see
    argument file_handling), then 3 kinds of files are handled by default. The
    values of the type / role attributes in the Dataset / AssociatedDataset elements
    respectively are described for the default handling below:

    - ANSA files: type = "T4T_ANSA", role = "IMAN_specification"
    - JT files: type = "DirectModel", role = "IMAN_Rendering"
    - PNG files: type = "Image", role = "IMAN_specification"

    Parameters
    ----------
    filename : str
            Name of the PLMXML output file.
            This argument may also hold a pathname, if the
            output file is to be stored in a directory
            different that the current working one.

    parts : object, optional
            A list of parts entities to be exported in the
            PLMXML package. Note that the parts that will
            eventually be described in the PLMXML package
            depend also on the value of the structure_info
            argument: if set to "hierarchy" or "flat" then the
            children of the selected parts will recursively be
            visited and will be output to the PLMXML package.
            (Default value: Root parts)

    structure_info : str, optional
            Describes what structural information should be
            output to the PLMXML file. Allowed values are:
            "hierarchy": information about all selected parts
            and their (recursive) children will be exported,
            together with assembly relationship.
            "flat": information about all selected parts and
            their (recursive) children will be exported, but
            the assembly relationships not.
            "monolithic": selected parts are exported with a
            monolithic representation file that aggregates all
            respective contained parts.
            (Default value: "hierarchy")

    representation_info : str, optional
            Describes what representation info should be
            output to the PLMXML file. Allowed values are:
            "current": the currently active representation
            for each part will be packaged and referenced
            from the PLMXML file.
            "all": for each part the currently active one,
            plus all others found in DM will be packaged and
            referenced from the PLMXML file.
            "none": no representation related files will be
            packaged.
            (Default value: "current")

    flatten_files : bool, optional
            Defines whether the referenced files directory
            (accompanying the PLMXML file) will contain the
            packaged files in a nested or flattened directory
            structure.
            (Default value: False)

    export_jt : bool, optional
            Defines whether a JT image should be included in
            the PLMXML package for each part.
            (Default value: False)

    export_png : bool, optional
            Defines whether a PNG image should be included in
            the PLMXML package for each part.
            (Default value: False)

    export_attachments : bool, optional
            Defines whether the various attached files should
            be included in the PLMXML package for each part.
            (Default value: False)

    file_handling : object, optional
            List or tuple of PLMXMLFileHandlingInfo objects.
            Defines how the different kinds of packaged files
            should be described in the PLMXML file. When this
            argument is provided, it describes exclusively the
            file handling (i.e. it is not applied over the
            default handling).
            (Default value: See function description)

    engine_settings : object, optional
            Object of type PLMXMLEngineSettings, describing
            various configuration options of the PLMXML export
            engine.
            (Default value: Default created PLMXMLEngineSettings
            object)

    Returns
    -------
    int
            This function returns an integer, which encodes the below Result Codes:
            0 - Success.
            1 - No license available (ANSA_JT_OPEN).
            2 - Unable to create packaging directory.
            3 - Unable to create PLMXML file.
            4 - File packaging failed.
            5 - Invalid hierarchy detected.
            6 - PLMXML SDK error.

    See Also
    --------
    PLMXMLFileHandlingInfo, PLMXMLEngineSettings

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                file_export_info = []

                info = base.PLMXMLFileHandlingInfo(
                    "jt", dataset_type="DirectModel", assoc_dataset_role="IMAN_rendering"
                )
                file_export_info.append(info)

                info = base.PLMXMLFileHandlingInfo(
                    "ansa", dataset_type="T4T_ANSA", assoc_dataset_role="IMAN_Specification"
                )
                file_export_info.append(info)

                settings = base.PLMXMLEngineSettings()
                settings.export_user_attributes = False

                base.ExportPLMXMLTree(
                    "output.plmxml",
                    structure_info="hierarchy",
                    representation_info="all",
                    flatten_files=True,
                    export_jt=True,
                    file_handling=file_export_info,
                    engine_settings=settings,
                )


    """


def GetLengthUnits() -> str:
    """

    The function returns the current ANSA units label from
    Tools>Settings>Settings>Resolution/Tolerances/Units>Current Units.

    Returns
    -------
    str
            Returns a string that contains the label of the current ANSA length units.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def get_length_units():
                units = base.GetLengthUnits()
                print(units)


            # "millimeter"
            # "kilometer"
            # "meter"
            # "centimeter"
            # "micron"
            # "mile"
            # "feet"
            # "inch"
            # "mil"
            # "microinch"


    """


def SetLengthUnits(units: str, scale: bool) -> str:
    """

    The user can change the current length units by determining the appropriate input, available from the list below:
       "millimeter",
       "kilometer",
       "meter",
       "centimeter",
       "micron",
       "mile",
       "feet",
       "inch",
       "mil",
       "microinch".
    Note that as the current units change the tolerances are adjusted automatically.

    Parameters
    ----------
    units : str
            A string determining the desired change, available from the below list:

            -"millimeter",
            -"kilometer",
            -"meter",
            -"centimeter",
            -"micron",
            -"mile",
            -"feet",
            -"inch",
            -"mil",
            -"microinch".

    scale : bool, optional
            If True, the model coordinates change too, otherwise they remain the same.
            (Default: True)

    Returns
    -------
    str
            Returns a string containing the previous length units setting on success, otherwise NULL.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def change_units():
                ## "millimeter"
                ## "kilometer"
                ## "meter"
                ## "centimeter"
                ## "micron"
                ## "mile"
                ## "feet"
                ## "inch"
                ## "mil"
                ## "microinch"

                units = "inch"
                prev_units = base.SetLengthUnits(units, True)
                print(prev_units)


    """


def OpenIdsManager(container: str, ids_from: str) -> int:
    """

    This function opens the "Ids Manager" tool.

    Parameters
    ----------
    container : str
            The container that the "Ids Manager" window will refer to.
            The container can be either "Includes", or "Properties".

    ids_from : str, optional
            The name of the group of entities from which the ids will be shown
            in the "Ids Manager" tool.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OpenIdsManager("Includes", "ELEMENT")
                base.OpenIdsManager("Properties", "MATERIAL")


    """


def TransformCompress(deck: int, entity: object) -> int:
    """

    Compresses a transformation with multiple sub-transformations.

    Parameters
    ----------
    deck : int
            The deck in which the transform will take place.

    entity : object
            The transform that is going to be compressed.
            Should contain two or more sub-transformations.

    Returns
    -------
    int
            Returns 0 on success or 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                transforms = base.CollectEntities(constants.PAMCRASH, None, "TRSFM")
                for tr in transforms:
                    ret = base.TransformCompress(constants.PAMCRASH, tr)
                    print(ret)


    """


def SetIncludePathAlias(alias: str, path: str, force_use_alias: bool) -> object:
    """

    Sets a path alias and adds it in Include Paths.

    Parameters
    ----------
    alias : str
            The alias to be used for a specific path.

    path : str
            The path to be replaced by the alias.

    force_use_alias : bool, optional
            If force_use_alias = True, the alias given as argument will be used in the
            corresponding Includes' RefereneFile.
            If force_use_alias = False, the alias given as argument will not be used in the
            corresponding Includes ReferenceFile.
            (Default: True)
            (See Remarks for a detailed description of the possible issues that may occur and
            how to handle this argument)

    Returns
    -------
    object
            On failure, 0 is returned.
            On success, it returns either 1 or (in case of force_use_alias = False -see case 2 and 3 of the remarks-)
            a list of includes that had their Reference File reverted to a previous analiased filename.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            # EXAMPLE 1
            def main():
                base.SetIncludePathAlias(
                    alias="DIR1", path="/home/IncludesDir", force_use_alias=True
                )
                # Includes with "/home/IncludesDir" in their Reference File will replace it with "DIR1:/"
                # e.g. Include with Reference File "/home/IncludesDir/INCL1" now will have "DIR1:/INCL1" as Reference File

                base.SetIncludePathAlias(
                    alias="DIR1", path="/home/NewIncludesDir", force_use_alias=False
                )
                # if INCL1 does not exist inside "/home/NewIncludesDir", the new Reference File will be the previously
                # valid analiased filename, "/home/IncludesDir/INCL1". Returns the Include that failed to use alias.


            # EXAMPLE 2
            def main():
                base.SetIncludePathAlias(
                    alias="DIR1", path="/home/IncludesDir"
                )  # force_use_alias defaults to True.
                # e.g. Include with Reference File "/home/IncludesDir/INCL1" now will have "DIR1:/INCL1" as Reference File

                base.SetIncludePathAlias(
                    alias="DIR1", path="/home/NewIncludesDir", force_use_alias=True
                )
                # even if INCL1 does not exist inside "/home/NewIncludesDir", alias will be used and the new Reference File
                # will be "DIR2:/INCL1". Returns 0 on failure, 1 on success.


    """


def RemoveIncludePathAlias(alias: str) -> int:
    """

    Removes an existing alias from Include Paths.

    Parameters
    ----------
    alias : str
            The alias to be removed from Include Paths.

    Returns
    -------
    int
            Returns 0 on failure, 1 on success.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetIncludePathAlias(alias="DIR1", path="/home/IncludesDir")
                base.SetIncludePathAlias(alias="DIR2", path="/home/NewIncludesDir")
                # 2 aliases have been set to Include Paths

                base.RemoveIncludePathAlias("DIR1")
                # Returns 1. The Reference files of the Includes using that alias will be expanded.
                base.RemoveIncludePathAlias("DIR3")
                # Returns 0, DIR3 does not exist in Include Paths.


    """


def GetIncludePathAlias() -> object:
    """

    Gets all the pairs alias-path, defined in Include Paths.

    Returns
    -------
    object
            Returns a dictionary with key: Alias and value: Path.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SetIncludePathAlias("DIR1", "/home/IncludeDir")

                base.GetIncludePathAlias()
                # Returns dictionary {'DIR1': '/home/IncludeDir'}


    """


def ImportAP242Tree(filename: str, open_tree_editor: bool) -> int:
    """

    Imports an AP242 tree into ANSA with or without launching the product tree editor.

    Parameters
    ----------
    filename : str
            The full path of the AP242 file.

    open_tree_editor : bool, optional
            If set to True, the tree editor is launched.
            (Default: False)

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ImportAP242Tree("C:/AP242/ap242file.xml", True)


    """


def NearestGeometry(
    coordinates: object,
    tolerance: float,
    search_types: str,
    entities: object,
    all_nearest: bool,
) -> object:
    """

    This function finds the nearest geometrical entity to a set of coordinates.
    A list with lists of the x, y, z coordinates are given as input and for each point the nearest(s)
    geometrical entity is found.

    Parameters
    ----------
    coordinates : object
            A list with lists of triple x, y, z coordinates are given as input
            and for each triple, the nearest(s) geometrical entity is found.

    tolerance : float
            The search tolerance.

    search_types : str
            A string defining the search geometrical type.
            Valid inputs can be: 'FACE', 'CONS', 'CURVE', 'CONNECTION_CURVE',
            'CROSS_CURVE', 'POINT' or 'HOT POINT', 'CORD_NODES_R'.

    entities : object, optional
            A list of entities where the search will take place.
            A string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.
            If nothing is passed, it works with the visible entities, concerning the
            'search_types' named argument.

    all_nearest : bool, optional
            If set to True, the function returns all the nearest entities per triple coordinate,
            otherwise the closest entity found within the given tolerance.

    Returns
    -------
    object
            Returns a list containing lists with the references to the closest geometrical entities
            per triple given coordinate. The first list is a reference to the nearest entity in correspondence
            to the first point as it is determined by the x, y, z coordinates of the first triple in the coordinates list.
            If nothing is found within the tolerance, None is returned.

    See Also
    --------
    NearestNode, NearestShell

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def _NearestEntities(highlight):
                faces = []
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 67))
                faces.append(base.GetEntity(constants.NASTRAN, "FACE", 92))

                cons = base.GetEntity(constants.NASTRAN, "CONS", 249)
                cons_list = base.CollectEntities(
                    constants.NASTRAN, None, "CONS", filter_visible=True
                )

                coords = [
                    [2311.279400, -542.560600, 562.026280],
                    [2409.510700, -669.300200, 579.501300],
                    [2299.951530, -571.789933, 545.037993],
                    [2320.594136, -555.529855, 476.317144],
                    [2431.940000, -493.396000, 560.458000],
                ]

                results = base.NearestGeometry(coords, 120, "CONS", "visible", True)
                # results = base.NearestGeometry(coords, 54, 'CONS', 'all', True)
                # results = base.NearestGeometry(coords, 13.34, 'CONS', cons_list, False) #returns the closest CONS within tolerance
                # results = base.NearestGeometry(coords, 120.45, 'FACE', faces, True)
                # results = base.NearestGeometry(coords, 256, 'CORD_NODES_R')

                if results is not None:
                    print(len(results))
                    for i in range(0, len(results)):
                        print("list_len = ", len(results[i]))
                        for j in range(0, len(results[i])):
                            print(results[i][j])
                # draw_print
                if highlight:
                    container = base.CreateEntity(constants.NASTRAN, "HIGHLIGHT_CONTAINER")
                    base.AddToHighlight(container, results[0], "WHITE")

                    base.RedrawAll()
                return results


            if __name__ == "__main__":
                _NearestEntities(True)


    """


def UnitConversion(
    source_unit_system: object, target_unit_system: object, include: object
) -> object:
    """

    This function performs a unit conversion of the current model from source to target unit systems.
    Additionaly, the 'include' parameter can be specified to perform a unit conversion on an include.

    Parameters
    ----------
    source_unit_system : object
            The source unit system, defined by a UnitSystem object.

    target_unit_system : object
            The target unit system, defined by a UnitSystem object.

    include : object, optional
            The include that will be converted.
            If left blank, the current model will be converted.

    Returns
    -------
    object
            Always returns None.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                unit_system1 = utils.UnitSystem(length="centimeter")
                unit_system2 = utils.UnitSystem(length="meter")

                # convert current model
                base.UnitConversion(
                    source_unit_system=unit_system1, target_unit_system=unit_system2
                )

                # convert an include
                my_include = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)
                base.UnitConversion(
                    source_unit_system=unit_system1,
                    target_unit_system=unit_system2,
                    include=my_include,
                )

                del unit_system1
                del unit_system2


    """


def GetShellThickness(deck: int, shell: object, nodal_thicknesses: bool) -> object:
    """

    This function returns the effective thickness of the shell.

    Parameters
    ----------
    deck : int
            The selected deck.

    shell : object
            The shell entity.

    nodal_thicknesses : bool, optional
            If True, return a tuple with the nodal thicknesses. In case a contact thickness
            has been defined, return a tuple with the contact thickness value (LSDYNA, PAMCRASH).

    Returns
    -------
    object
            Returns a double if nodal_thicknesses=False.
            Returns a tuple of the nodal thicknesses or the contact thickness if nodal_thicknesses=True.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shell = base.GetEntity(constants.ABAQUS, "SHELL", 1)

                t = base.GetShellThickness(constants.ABAQUS, shell)
                print(t)

                thicks = base.GetShellThickness(constants.ABAQUS, shell, True)
                print(thicks)


    """


def LeadingEdge(faces: object, radius: float, create_curves: bool) -> object:
    """

    Detects leading edges on supplied faces, with respect to a supplied radius which defines the maximum radius in consideration.
    Retuns a SET, named "Leading Edge Curves" or "Leading Edge CONS", containing the curves or CONS created respectively.

    Parameters
    ----------
    faces : object, optional
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.
            If nothing is passed, all the visible faces are taken into consideration.

    radius : float, optional
            A float defining the radius curvature of the input faces where leading edge will be detected.

    create_curves : bool, optional
            True if only create curves, False (default) if create only CONS (i.e., Cut).

    Returns
    -------
    object
            Returns a list of the created CURVES on success, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                faces = []
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 90))
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 92))
                faces.append(base.GetEntity(base.CurrentDeck(), "FACE", 93))

                # ret = base.LeadingEdge(faces = 'visible', radius = 20., create_curves = True)
                # ret = base.LeadingEdge(faces = 'all')
                ret = base.LeadingEdge(faces=faces)
                print(ret)


    """


def FacesDach(faces: object, auto_identify: object, parameters: object) -> int:
    """

    This function replaces a single fillet (or chamfer) or a series of fillets (or chamfers) with
    the corresponding tangent Faces creating a sharp corner.

    Parameters
    ----------
    faces : object, optional
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.
            In case a list is passed, result will simulate selection of faces in GUI mode.
            In case 'visible' or 'all' is passed, named argument auto_identify must be specified,
            in order to simulate automatic identification of entities to be sharped.
            If auto_identify will not passed default values will be taken into consideration.
            If nothing is passed function will auto identify visible faces to be sharped.

    auto_identify : object, optional
            A list with three lists. First sublist consists two floats , min radius, max radius.
            Second sublist consists two floats, min corner angle, max corner angle.
            Third sublist consists two floats, min width, max width.
            If no list is passed default operation will search for entities with min radius = 0,
            max radius = 20 and min width = 0, max width = 10.
            (Default: [[0., 20.], [0., 0.], [0., 10.]])

    parameters : object, optional
            A list with five boolean parameters.
            The first defining deletion of identified fillet (or chamfer).
            The second defining release of CONS.
            The third defining Join of Macros.
            The fourth defining Produce Curves.
            The fifth defining tangency calculation of Dach's faces.

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    See Also
    --------
    FacesDivide

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = []
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 27))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 28))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 29))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 30))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 31))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 32))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 34))
                arg1.append(base.GetEntity(ansa.base.CurrentDeck(), "FACE", 35))
                arg2 = []
                arg2.append(True)
                arg2.append(True)
                arg2.append(False)
                arg2.append(False)
                arg2.append(True)
                ansa.base.FacesDach(
                    faces=arg1, auto_identify=[[0, 20], [0, 90], [0, 10]], parameters=arg2
                )

                # ansa.base.FacesDach()
                # ansa.base.FacesDach(faces='visible')
                # ansa.base.FacesDach(faces='all')


    """


def FacesDivide(faces: object, auto_identify: object, parameters: object) -> int:
    """

    This function splits a string of Faces (fillets or chamfers) in half iso-parametrically.

    Parameters
    ----------
    faces : object, optional
            A face, a list of faces, a string with value 'visible' or a string with value 'all'.
            If it is called with 'visible', it works with all the visible faces.
            If it is called with 'all', it works with all the faces.
            In case a list is passed, result will simulate selection of faces in GUI mode.
            In case 'visible' or 'all' is passed, named argument auto_identify  must be specified,
            in order to simulate automatic identification of entities to be sharped.
            If auto_identify will not passed default values will be taken into consideration.
            If nothing is passed function will auto identify visible faces to be sharped.

    auto_identify : object, optional
            A list with three lists. First sublist consists two floats , min radius, max radius.
            Second sublist consists two floats, min corner angle, max corner angle.
            Third sublist consists two floats, min width, max width.
            If no list is passed default operation will search for entities with min radius = 0,
            max radius = 20, min width = 0, max width = 10.
            (Default: [[0., 20.], [0., 0.], [0., 10.]])

    parameters : object, optional
            A list with two boolean parameters.
            The first defining Join of Macros.
            The second defining Keep PIDs for the created faces to maintain their Pid.
            (Default: [False, False])

    Returns
    -------
    int
            Returns 1 on success, otherwise 0.

    See Also
    --------
    FacesDach

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                arg1 = []
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 27))
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 28))
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 29))
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 30))
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 31))
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 32))
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 34))
                arg1.append(base.GetEntity(base.CurrentDeck(), "FACE", 35))
                arg2 = []
                arg2.append(True)
                arg2.append(True)
                base.FacesDivide(
                    faces=arg1, auto_identify=[[0, 20], [0, 90], [0, 10]], parameters=arg2
                )

                # base.FacesDivide()
                # base.FacesDivide(faces='visible')
                # base.FacesDivide(faces='all')


    """


def OrientSolidFacets(solids: object, facet: object) -> object:
    """

    Just like its GUI counterpart (Elements->SOLID->"Orient Facets") this function will change
    the selected solids in order to use as base facet, facet with index = 1, the facet that has
    the same orientation as the given one.

    The facet, that is provided as argument, must belong to a solid element that is connected to the selected solids.

    Parameters
    ----------
    solids : object
            A list of solids. These solids will be oriented by the function.

    facet : object
            A facet that will be used to orient the given solids.

    Returns
    -------
    object
            Returns a list containing references to the solids that were unable to be oriented according to the given facet.
            If no solids have failed, it returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def orient_facets():
                facet = base.Entity(0, 17277, "SOLID", facet=2)
                print(facet)
                solids = base.CollectEntities(constants.NASTRAN, None, "SOLID")

                failed_solids = base.OrientSolidFacets(solids, facet)
                print("failed solids are {}".format(len(failed_solids)))


    """


def GetCurvePid(curve: object) -> object:
    """

    Gets the property of a cross curve.

    Parameters
    ----------
    curve : object
            A reference to a cross curve.

    Returns
    -------
    object
            Returns the property of the cross curve or None if the curve has no property.

    See Also
    --------
    SetCurvePid

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross_curve = base.GetEntity(constants.NASTRAN, "CROSS_CURVE", 1)
                prop = base.GetCurvePid(cross_curve)


    """


def GetDatabaseTypesInInclude(deck: int, include: object, recursive: bool) -> object:
    """

    Returns all the different ansa types contained in an include, as seen in given deck database.
    Helpful to answer questions like "does include has this type entities?"

    Parameters
    ----------
    deck : int
            The deck for which the collection will take place.

    include : object
            A reference to an INCLUDE ANSA entity.

    recursive : bool
            Recursively search any containers contained in a higher level INCLUDE.
            Available options: True or False.

    Returns
    -------
    object
            Returns a list with the types of entities that are contained in the selected INCLUDE.
            In case that the selected INCLUDE is empty the function returns an empty list.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create two includes, 1 top level and 1 as child of the top level include.
                vals = {"Name": "top_include"}
                top_include = base.CreateEntity(constants.NASTRAN, "INCLUDE", vals)
                vals = {"Name": "child_include"}
                child_include = base.CreateEntity(constants.NASTRAN, "INCLUDE", vals)
                base.AddToInclude(top_include, child_include)

                # Create a GRID and add it to the child include.
                vals = {"X1": 0, "X2": 0, "X3": 0}
                grid = base.CreateEntity(constants.NASTRAN, "GRID", vals)
                base.AddToInclude(child_include, grid)

                # top_include contains ['INCLUDE', GRID']
                print(
                    base.GetDatabaseTypesInInclude(constants.NASTRAN, top_include, recursive=True)
                )

                # child_include contains [GRID']
                print(
                    base.GetDatabaseTypesInInclude(
                        constants.NASTRAN, child_include, recursive=False
                    )
                )

                # in LSDYNA, child_include contains ['NODE']
                print(
                    base.GetDatabaseTypesInInclude(constants.LSDYNA, child_include, recursive=False)
                )


    """


def CopyEntitiesFromAnsaModel(
    model: Entity, deck: int, types: str | Iterable, names: str | Iterable
) -> List[Entity]:
    """

    Copies entities from an Ansa model to current model given
    their names and types.

    Parameters
    ----------
    model : Entity
            The Ansa model object from which the requested entities will be copied to the current Ansa model.

    deck : int
            the deck

    types : str | Iterable
            A python list holding the requested entity types, which will be copied from the source Ansa model. This list should be created in correspondence with the next argument 'names' (i.e. should have the same size).

    names : str | Iterable
            A python list holding the requested entity names, which will be copied from the source Ansa model. This list should be created in correspondence with the previous argument 'types' (i.e. should have the same size).

    Returns
    -------
    List[Entity]
            CopyEntitiesFromAnsaModel() function returns a python list (having the same size
            as the 'types' and 'names' lists) whose entries hold a reference to the copied
            entity. Any entry of the returned list could be 'None' in case an error occurs
            or if the requested entity can not be found.

    See Also
    --------
    GetCurrentAnsaModel, SetCurrentAnsaModel, CreateNewAnsaModel, DestroyAnsaModel, CopyPartsToAnsaModel

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                for i in range(8):
                    base.CreateEntity(constants.ABAQUS, "NODE", {"Name": str(i + 1)})
                model_src = base.GetEntity(constants.ABAQUS, "MODEL", 0)

                model = base.CreateEntity(constants.ABAQUS, "MODEL")
                base.SetCurrentAnsaModel(model)

                types = ["NODE"] * 8
                names = [str(i + 1) for i in range(8)]
                ret = base.CopyEntitiesFromAnsaModel(model_src, constants.ABAQUS, types, names)
                print(ret)


    """


def GetAnsaModelSourceFileNames(model: Entity) -> List[str]:
    """

    Returns a list of the file names (ansa databases and neutral files) that were read to form the given Ansa Model.

    Parameters
    ----------
    model : Entity
            The Ansa model object.

    Returns
    -------
    List[str]
            Returns a list whose entries hold the file names of the merged files that form the given Ansa Model.

    See Also
    --------
    GetCurrentAnsaModel

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                cur_model = base.GetCurrentAnsaModel()
                print(base.GetAnsaModelSourceFileNames(cur_model))


    """


def SetCurrentAnsaWindow(window: object) -> object:
    """

    Sets as Current an existing-docked Ansa window.

    Parameters
    ----------
    window : object
            A reference to the window to become current.

    Returns
    -------
    object
            Always returns None.

    See Also
    --------
    GetAnsaWindow

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window = base.GetAnsaWindow("Window 2")
                base.SetCurrentAnsaWindow(window)


    """


def InputAdamsSolver(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function imports an '.adm' (Adams/Solver) format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputAdamsSolver("/home/users/model.adm", "keep-old", "keep-old", "offset")


    """


def LaminateChangeStackingToPerPly(
    deck: int,
    property: object,
    fill_ply_drop_offs: bool,
    merge_method: str,
    merge_t_tol: float,
    merge_theta_tol: float,
    disconnect_layers: object,
    gap: object,
    ret_node_pairs: bool,
    ret_node_bricks: bool,
    ret_facet_pairs: bool,
    drop_off_prop: object,
    force_split_woven_layers: bool,
    avoid_hanging_edges: bool,
    paste_same_angle_layers: bool,
    create: object,
    rows_num: object,
) -> object:
    """

    This function changes the stacking of a Laminate property to "per ply".

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, PAMCRASH, ABAQUS, RADIOSS, ANSYS, PERMAS.

    property : object
            A laminate property or a list of laminate properties.

    fill_ply_drop_offs : bool, optional
            Flag for filling ply drop-offs.
            (Default: False)

    merge_method : str, optional
            Method by which the layers of different properties will be merged.
            One of "by_tolerances", "by_gplyid", "by_layer_name".
            Required only for multiple properties.

    merge_t_tol : float, optional
            Thickness tolerance by which the layers of different properties
            will be merged. Required for merge_method = "by_tolerances".

    merge_theta_tol : float, optional
            Theta tolerance by which the layers of different properties
            will be merged. Required for merge_method = "by_tolerances".

    disconnect_layers : object, optional
            A boolean value which if set to True all the layers are disconnected,
            or a dictionary with key a tuple (property, sequence_pos, layer_pos),
            and value a boolean which if set to True the layer key is disconnected
            from all adjacent layers above.
            (Default: False)

    gap : object, optional
            A float value which is the gap between all the disconnected layers,
            or a dictionary with key a tuple (property, sequence_pos, layer_pos),
            and value a float which is the gap between the layer key
            and all adjacent layers above. Gap should be 0 or greater.
            (Default: 0)

    ret_node_pairs : bool, optional
            If set to True, layer_data.node_pairs is a list of tuples with 2 nodes.
            If set to False, layer_data.node_pairs is None.
            (Default: False)

    ret_node_bricks : bool, optional
            If set to True, layer_data.node_bricks is a list of tuples with 6 or 8 nodes.
            If set to False, layer_data.node_bricks is None.
            (Default: False)

    ret_facet_pairs : bool, optional
            If set to True, layer_data.facet_pairs is a list of tuples
            with 2 facets or shells.
            If set to False, layer_data.facet_pairs is None.
            (Default: False)

    drop_off_prop : object, optional
            Simple solid property of the ply drop-offs. If not given
            and fill_ply_drop_offs is True, then a default solid property is created.

    force_split_woven_layers : bool, optional
            If set to True, woven layers are split.
            If set to False, woven layers are not split, except for SOLID_LAMINATE
            in LSDYNA, PAMCRASH, RADIOSS and PERMAS
            (Default: False)

    avoid_hanging_edges : bool, optional
            When fill_ply_drop_offs is True,
            avoid hanging edges by creating pyramids (drop-off elements)
            and by splitting hexas to pentas (layer elements).
            (Default: False)

    paste_same_angle_layers : bool, optional
            If set to True, consequent layers with the same nominal angle
            are not disconnected, even if disconnect_layers = True.
            (Default: False)

    create : object, optional
            A string value which is element type which will be created,
            or a dictionary with key a tuple (property, sequence_pos, layer_pos),
            and value a string which is element type which will be created.
            This string must be one of 'shells', 'thick shells', 'solids'.
            (Default: same as the property type)

    rows_num : object, optional
            An integer which is the number of rows per layer that will be created,
            or a dictionary with key a tuple (property, sequence_pos, layer_pos),
            and value an integer which is the number of rows per layer that will be created.
            (Default: 1)

    Returns
    -------
    object
            Returns None on failure.

            An object 'ret' on success with the following members:
            ret.layers_data: a list of layer_data objects, one object per layer
            with data about the interface between a layer and all adjacent layers above.

            This object layer_data has the following members:
            layer_data.laminate: the final laminate property
            layer_data.sequence_pos: the final sequence index
            layer_data.layer_pos: the final layer index
            layer_data.node_pairs: a list of tuples with 2 nodes (bottom and top). These may be used to create beams.
            layer_data.node_bricks: a list of tuples with 6 or 8 nodes (penta or hexa). These may be used to create cohesives.
            layer_data.facet_pairs: a list of tuples with 2 facets or shells (bottom and top). These may be used to create contacts.
            layer_data.init_laminate: the initial laminate property
            layer_data.init_sequence_pos: the initial sequence index
            layer_data.init_layer_pos: the initial layer index

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "SOLID_LAMINATE", 1)

                ret = base.LaminateChangeStackingToPerPly(
                    deck=deck, property=prop, disconnect_layers=True, gap=0.02, ret_node_bricks=True
                )
                if ret is None:
                    print("LaminateChangeStackingToPerPly failed!")
                    return
                pcohesive = base.CreateEntity(deck, "COHESIVE_SECTION")

                for layer_data in ret.layers_data:
                    for nodes in layer_data.node_bricks:
                        vals = {}
                        vals["PID"] = pcohesive._id
                        for i in range(len(nodes)):
                            vals["N" + str(i + 1)] = nodes[i]._id
                        base.CreateEntity(deck, "COHESIVE", vals)


    """


def LaminateChangeStackingToSingleElement(
    deck: int, property: object, vertical_limit: float
) -> object:
    """

    This function changes the stacking of a tshell/solid laminate property to "single element".

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, PAMCRASH, ABAQUS, RADIOSS, ANSYS, PERMAS.

    property : object
            One tshell/solid laminate property or a list of tshell/solid laminate properties.

    vertical_limit : float, optional
            The vertical limit (angle in degrees) for the projection which is made,
            so that different material orientations of the solids are transferred
            to the created solid as mapped orientations.
            Failed elements are stored in ret.failed_elems.
            (Default: 0)

    Returns
    -------
    object
            Returns None on failure.

            Returns an object 'ret' on success with the following members:
            ret.failed_elems: a list of failed elements due to vertical_limit.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "SOLID_LAMINATE", 1)

                ret = base.LaminateChangeStackingToSingleElement(
                    deck=deck, property=prop, vertical_limit=80
                )
                if ret is None:
                    print("LaminateChangeStackingToSingleElement failed!")
                    return
                if len(ret.failed_elems) > 0:
                    new_set = base.CreateEntity(deck, "SET")
                    base.AddToSet(new_set, ret.failed_elems)


    """


def GenerateReducedRepresentation(
    source: object,
    type: str,
    output_path: str,
    method: object,
    dm_option: str,
    dm: object,
    freqset: object,
    damping: object,
    frf_parameters: object,
    interface: object,
    displacement_all: bool,
    solution: str,
    include_wetted_nodes: bool,
    create_reduced_coupling: bool,
    epilysis_in_ansa: bool,
    additional_header_commands: object,
) -> int:
    """

    This function generates a reduced representation from a source container (include or subsystem).

    Parameters
    ----------
    source : object
            A Subsystem, Include or Set.

    type : str
            The representation type.
            Accepted values:
            -"DMIGOP2": NASTRAN Superelement with .op2 results file
            -"DMIGPCH": NASTRAN Superelement with .pch results file
            -"FRF": FRF Representation
            -"MODAL": Modal Model
            -"RIGIDBODY": RigidBody Representation

    output_path : str
            The path where the representation files will be output.
            The file to be solved (TS) as well as display files, where applicable.

    method : object, optional
            The EIGRL that is needed for the representation definition.
            The argument should not be defined for Static reduction (SOL 101)
            and RigidBody representation.

    dm_option : str, optional
            Display Model option.
            Accepted values:
            -"NO" (default): Use no Display Model
            -"NEW": Create new display model from source
            -"EXISTING": Use existing Display Model entity
            -"ALL": Use entire source as display
            -"SKIN": Create new display model containing the
                     solids shell skin (only for modal reduction of fluid container).

    dm : object, optional
            A Display Model entity.
            If dm_option is "EXISTING", the dm must be defined.

    freqset : object, optional
            A FREQSET entity.
            If type is "FRF", the freqset must be defined.

    damping : object, optional
            A TABDMP1 or TABLED entity that defines the damping.

    frf_parameters : object, optional
            A dictionary with FRF specific parameters:
                - sol (integer or string) : Valid values are 108, 111, "From Modal".
                - output_type (string): Valid values are "op2" and "pch"
                - coordinate_system (string): Valid values are "local" and "global"
                - excitation_dofs (dictionary): A dictionary with an LC POINT name as
                  key and dof as value (12345)
                - response_dofs (dictionary): A dictionary with an LC POINT name as
                  key and dof as value (12345)
                - modal_container (object): A Subsystem (Representation : Modal Model)
                  or a Reduced Model entity (TYPE : Modal Model) containing modal results.

    interface : object, optional
            Interface Nodes option.
            Accepted values:
            -"ALL" (default): All Assembly Points and Loadcase Points of Display Model.
            -"A_POINTS": All Assembly Points of Display Model.
            - A Set entity.

    displacement_all : bool, optional
            Request Displacement for all (not only Display Model) nodes.

    solution : str, optional
            Select reduction type for Nastran Superelements.
            Accepted values:
            -"101" for static reduction (SOL 101)
            -"103" (default) for dynamic reduction (SOL 103)

    include_wetted_nodes : bool, optional
            Request results for wetted nodes as well.
            Use for Representation "MODAL MODEL" of a Structural Subsystem connected
            with a Fluid Subsystem through an FSCOUPLING entity.
            (Default = True)

    create_reduced_coupling : bool, optional
            Use for Representation "MODAL MODEL" of a Structural Subsystem connected
            with a Fluid Subsystem through an FSCOUPLING entity.
            (Default = False)

    epilysis_in_ansa : bool, optional
            Runs Epilysis(IN ANSA) in order to solve the Reduced Representation.
            (Default = False)

    additional_header_commands : object, optional
            A string or list of strings with header commands to be added to the header section of the produced solver file.

    Returns
    -------
    int
            Returns 1 on success, or 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                src = base.GetPartFromName("MySubsystem", "ANSA_SUBSYSTEM")
                eigrl = base.GetEntity(constants.NASTRAN, "EIGRL", 1)
                base.GenerateReducedRepresentation(src, "DMIGOP2", "~/output/", eigrl, "NEW")


    """


def LaminateLayerTemplateChangeOrientation(
    deck: int,
    laminate: object,
    id: int,
    orientation_type: str,
    elements: object,
    vertical_limit: float,
    orientation_vector: object,
    orientation_element: object,
    orientation_curves: object,
) -> object:
    """

    Changes the mapped orientation of a laminate layer template.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH.

    laminate : object
            A laminate property.

    id : int
            The id of the layer template.

    orientation_type : str
            One of "by_vector", "by_theta", "by_edges".

    elements : object, optional
            A list of elements of the layer to change orientation.
            If not given all elements of the layer are used.

    vertical_limit : float, optional
            The angle in degrees. The orientation change fails if the angle between
            the normal vector and the vector which gives the orientation is greater
            than the vertical_limit.

    orientation_vector : object, optional
            A list with three double values. Needed for "by_vector", "by_theta".

    orientation_element : object, optional
            An element needed for "by_theta".

    orientation_curves : object, optional
            A list of curves. Needed for "by_curves".

    Returns
    -------
    object
            Returns None on success and a list of failed elements if any of the given elements fails to orient.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS

                laminate = base.GetFirstEntity(deck, "LAMINATE")
                elem = base.GetEntity(deck, "SHELL", 1148)
                curves = base.GetFirstEntity(deck, "CURVE")
                set = base.GetFirstEntity(deck, "SET")
                elems = base.CollectEntities(deck, set, "SHELL")

                base.LaminateLayerTemplateChangeOrientation(
                    deck, laminate, 1, "by_curves", orientation_curves=curves, elements=elems
                )
                base.LaminateLayerTemplateChangeOrientation(
                    deck,
                    laminate,
                    2,
                    "by_theta",
                    orientation_vector=(1, 0, -1),
                    orientation_element=elem,
                )
                base.LaminateLayerTemplateChangeOrientation(
                    deck, laminate, 3, "by_vector", orientation_vector=(1, 0, 1)
                )


    """


def RenumberIncludes(includes: object) -> int:
    """

    This function applies the numbering rules of the includes that are given as input.

    Parameters
    ----------
    includes : object
            A list containing the includes whose numbering rules will be applied.

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def main():
                base.CreateNumberingRule(
                    constants.NASTRAN,
                    "INCLUDE",
                    "include_1",
                    "0",
                    "PER_GROUP",
                    1000001,
                    2000000,
                    "General rule for include_1",
                )
                base.CreateNumberingRule(
                    constants.NASTRAN,
                    "INCLUDE",
                    "include_2",
                    "ELEMENT",
                    "PER_GROUP",
                    2000001,
                    3000000,
                    "ELEMENT rule for include_2",
                )
                base.CreateNumberingRule(
                    constants.NASTRAN,
                    "INCLUDE",
                    "include_2",
                    "GRID",
                    "PER_GROUP",
                    3000001,
                    4000000,
                    "GRID rule for include_2",
                )
                include_1 = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)
                include_2 = base.GetEntity(constants.NASTRAN, "INCLUDE", 2)
                base.RenumberIncludes([include_1, include_2])


    """


def IncludeHasDatabaseType(
    deck: int, include: object, search_type: str, recursive: bool
) -> bool:
    """

    Checks if include contains the given database type, given by "search_type" in form of string.

    Parameters
    ----------
    deck : int
            The deck for which the collection will take place.

    include : object
            A reference to an INCLUDE ANSA entity.

    search_type : str
            A string that describes the type of the entity.
            It can be retrieved from the title of the element's edit card,
            where it is displayed within brackets.
            Additionally, a Database container (e.g. "ELEMENT", "MATERIAL", "PROPERTY")
            can given as search_type.

    recursive : bool
            Recursively search any containers contained in a higher level INCLUDE.
            Available options: True or False.

    Returns
    -------
    bool
            Returns True if include contains search_type, False otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.CreateEntity(constants.NASTRAN, "INCLUDE")
                grid = base.CreateEntity(constants.NASTRAN, "GRID")

                base.AddToInclude(include, grid)
                ret = base.IncludeHasDatabaseType(
                    constants.NASTRAN, include, "GRID", recursive=False
                )


            def main():
                include = base.CreateEntity(constants.NASTRAN, "INCLUDE")
                mat1 = base.CreateEntity(constants.NASTRAN, "MAT1")

                base.AddToInclude(include, mat1)
                ret = base.IncludeHasDatabaseType(
                    constants.NASTRAN, include, "MATERIAL", recursive=False
                )


    """


def SetWorkingModelContainer(container: object, check: bool, unload: bool) -> bool:
    """

    Sets a Simulation Model, Loadcase or Simulation Run as working or non working.

    Parameters
    ----------
    container : object
            The Model Container to be set. Supported types are:
            a) ANSA_SIMULATION_MODEL type,
            b) ANSA_SIMULATION_RUN type,
            c) ANSA_LOADCASE type.

    check : bool, optional
            If set to False, the MB container is set as not working.
            (Default: True)

    unload : bool, optional
            If True, setting a container as Working will result to unload
            of entities which are not under this container.
            (Default: True)

    Returns
    -------
    bool
            Returns True or False, whether the operation was succesful or not.

    See Also
    --------
    GetWorkingModelContainer

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def setWorking():
                # create a sim run
                run = base.CreateEntity(constants.NASTRAN, "ANSA_SIMULATION_RUN")

                # create a bunch of sim models
                model1 = base.CreateEntity(constants.NASTRAN, "ANSA_SIMULATION_MODEL")
                model2 = base.CreateEntity(constants.NASTRAN, "ANSA_SIMULATION_MODEL")
                base.AddToModelContainer(run, model2)

                # create a loadcase
                lc1 = base.CreateEntity(constants.NASTRAN, "ANSA_LOADCASE")
                base.AddToModelContainer(run, lc1)

                base.SetWorkingModelContainer(run)


            # example which sets a container as non working
            def setNonWorking():
                # create a sim run
                run = base.CreateEntity(constants.NASTRAN, "ANSA_SIMULATION_RUN")
                lc1 = base.CreateEntity(constants.NASTRAN, "ANSA_LOADCASE")
                lc2 = base.CreateEntity(constants.NASTRAN, "ANSA_LOADCASE")
                base.AddToModelContainer(run, lc1)
                base.SetWorkingModelContainer(run)

                # In order to set lc2 as working, run must be set as non working
                base.SetWorkingModelContainer(run, False, False)
                base.SetWorkingModelContainer(lc2)


    """


def GetWorkingModelContainer(element_type: str) -> object:
    """

    Returns the working Model Browser container as specified at input arguments.

    Parameters
    ----------
    element_type : str
            The type of ANSA Model Browser Container.
            Supported types:
            -"ANSA_SIMULATION_MODEL"
            -"ANSA_SIMULATION_RUN"
            -"ANSA_LOADCASE"

    Returns
    -------
    object
            Returns the working Model Browser Container on success, or None on failure.

    See Also
    --------
    SetWorkingModelContainer

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # create a bunch of sim models
                model1 = base.CreateEntity(constants.NASTRAN, "ANSA_SIMULATION_MODEL")
                model2 = base.CreateEntity(constants.NASTRAN, "ANSA_SIMULATION_MODEL")
                model3 = base.CreateEntity(constants.NASTRAN, "ANSA_SIMULATION_MODEL")

                base.SetWorkingModelContainer(model2)

                # get the working
                working = base.GetWorkingModelContainer("ANSA_SIMULATION_MODEL")


    """


def ChangeCoordType(
    deck: int,
    coords: List[Entity] | Entity,
    target_type_name: str,
    update_names: bool = False,
) -> List[Entity | None]:
    """

    Changes a given goordinate system or a list of coordinate systems to the selected coordinate system type of the selected deck.

    Parameters
    ----------
    deck : int
            The deck of the target coordinate system type

    coords : List[Entity]|Entity
            A coordinate system entity or a list of coordinate system entities

    target_type_name : str
            The target coordinate system keyword on the selected deck

    update_names : bool, optional
            If set to True the changed coordinate systems are renamed based on the new type. False by default.

    Returns
    -------
    List[Entity|None]
            Returns a list with the changed coordinate system entities. The new list has 'None' values at the positions of the entities that failed to be converted so that they can be retrieved from the original list.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # collect coordinate systems
                coord_sys_list = base.CollectEntities(constants.NASTRAN, None, "CORD_C")

                # change to spherical
                changed_coord_sys_list = base.ChangeCoordType(
                    constants.NASTRAN, coord_sys_list, "CORD_S"
                )

                # report failed
                print("Failed to process the following:")
                for old_ent, changed_ent in zip(coord_sys_list, changed_coord_sys_list):
                    if changed_ent == None:
                        # handle coordinate system that was not changed
                        print(old_ent)


    """


def InverseFormingImportFlc(inv_forming: object, filename: str):
    """

    Imports only the crack forming limit curve to an INVERSE FORMING entity from a *.csv file. The csv file should have two columns that correspond to minor/major strain values, seperated with commas:

    minor_strain_1, major_strain_1
    minor_strain_1, major_strain_1
    ...
    minor_strain_n, major_strain_n

    Parameters
    ----------
    inv_forming : object
            A reference to an INVERSE FORMING object.

    filename : str
            The filename to import.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                inv_forming = base.GetEntity(ansa.constants.NASTRAN, "INVERSE FORMING", 1)
                base.InverseFormingImportFlc(inv_forming, "filename.txt")


            if __name__ == "__main__":
                main()


    """


def InverseFormingExportFldPoints(inv_forming: object, filename: str):
    """

    Exports the forming limit diagram points of a builded INVERSE FORMING entity to a *.csv file.

    Parameters
    ----------
    inv_forming : object
            A reference to an INVERSE FORMING object.

    filename : str
            The filename to output.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.SetCurrentDeck(constants.LSDYNA)
                target_pid = "11100121"
                dict = {"Connectivity": "#" + target_pid}
                dict["Hardening K"] = 580.5
                dict["Fill holes"] = "YES"
                dict["Create Initial Eps"] = "YES"
                inv_forming = base.CreateEntity(constants.LSDYNA, "INVERSE FORMING", dict)
                base.InverseFormingSetDirection(inv_forming)
                base.InverseFormingApply(inv_forming)
                base.InverseFormingExportFldPoints(inv_forming, "./filename.txt")
                base.SetViewButton({"VIEWMODE": "EL.EPS"})


            if __name__ == "__main__":
                main()


    """


def InverseFormingApply(inv_formings: object) -> int:
    """

    Builds the selected INVERSE FORMING objects.

    Parameters
    ----------
    inv_formings : object
            A list of INVERSE FORMING objects.

    Returns
    -------
    int
            Return 0 on success 1 on failure

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.SetCurrentDeck(constants.LSDYNA)
                target_pid = "11100121"
                dict = {"Connectivity": "#" + target_pid}
                dict["Hardening K"] = 580.5
                dict["Fill holes"] = "YES"
                dict["Create Initial Eps"] = "YES"
                inv_forming = base.CreateEntity(constants.LSDYNA, "INVERSE FORMING", dict)
                base.InverseFormingSetDirection(inv_forming)
                base.InverseFormingApply(inv_forming)
                base.InverseFormingExportFldPoints(inv_forming, "./filename.txt")
                base.SetViewButton({"VIEWMODE": "EL.EPS"})


            if __name__ == "__main__":
                main()


    """


def InverseFormingSetDirection(inv_formings: object):
    """

    Defines stamp directions for INVERSE FORMING objects.

    Parameters
    ----------
    inv_formings : object
            A list of INVERSE FORMING objects.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.SetCurrentDeck(constants.LSDYNA)
                target_pid = "11100121"
                dict = {"Connectivity": "#" + target_pid}
                dict["Hardening K"] = 580.5
                dict["Fill holes"] = "YES"
                dict["Create Initial Eps"] = "YES"
                inv_forming = base.CreateEntity(constants.LSDYNA, "INVERSE FORMING", dict)
                base.InverseFormingSetDirection(inv_forming)
                base.InverseFormingApply(inv_forming)
                base.InverseFormingExportFldPoints(inv_forming, "./filename.txt")
                base.SetViewButton({"VIEWMODE": "EL.EPS"})


            if __name__ == "__main__":
                main()


    """


def InverseFormingReleaseResults(inv_formings: object) -> object:
    """

    Releases created entities from INVERSE FORMING entities.

    Parameters
    ----------
    inv_formings : object
            A list of INVERSE FORMING objects.

    Returns
    -------
    object
            Always returns none.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(ansa.constants.NASTRAN, "INVERSE FORMING", 1)
                base.InverseFormingApply(entity)
                base.InverseFormingReleaseResults(entity)


    """


def OrganizeModelContainerEntities(entities: object):
    """

    Accepts a list of entities ( Subsystems, Simulation Models ) and runs action Organize Subsystem/Simulation Model Entities respectively.

    Parameters
    ----------
    entities : object
            A list containing the entities on which the action Organize Model Container Entities will be executed for.
            Bear in mind that this action is not defined for the GEOMETRY_OUT_OF_SUBSYSTEMS subsystem.

    Examples
    --------
    ::

            import ansa
            from ansa import constants
            from ansa import base


            def updateMSEScriptFunc(all_subsystems):
                base.SetCurrentDeck(
                    constants.RADIOSS
                )  # to make sure all will happen with compliant rules
                all_subsystems = base.CollectEntities(constants.RADIOSS, None, "ANSA_SUBSYSTEM")
                base.OrganizeModelContainerEntities(all_subsystems)


    """


def AddSimulationRunToDM() -> object:
    """
    .. deprecated:: 17.1.0
            Use :py:func:`AddSimulationRun` instead.


    Adds a Simulation Run to the DM. If the Simulation Run file contains a hierarchy
    of Includes, they will be added as well to the DM.

    Returns
    -------
    object
            Returns the server id of the newly added Simulation Run, unless the addition
            fails or the overwrite flag is False and the Simulation Run already exists in
            the DM (then it returns None).

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                names_values = {}
                names_values["Name"] = []
                names_values["Simulation_Model"] = "2"
                names_values["LoadCase"] = "3"
                names_values["Main_File"] = "..."
                server_id = base.AddSimulationRunToDM(names_values, file_type="LSDYNA", link=True)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.1.0. Use :py:func: AddSimulationRun instead.",
        DeprecationWarning,
    )


def CheckAdjacentFacesOrientation(cons: object) -> bool:
    """

    This script function checks orientation between two adjacent faces, by accepting a valid double( yellow ) cons.

    Parameters
    ----------
    cons : object
            A double ( yellow ) cons.

    Returns
    -------
    bool
            Returns True in case orientation between adjacent faces is the same, otherwise False.

    Examples
    --------
    ::

            import ansa
            from ansa import *


            def main():
                cons = base.CollectEntities(ansa.constants.NASTRAN, None, "CONS")
                if len(cons):
                    set = base.CreateEntity(constants.NASTRAN, "SET", {"Name": "Diff Orientation"})
                    for i in cons:
                        if not base.CheckAdjacentFacesOrientation(i):
                            base.AddToSet(set, i)


            def main2():
                cons = base.GetEntity(ansa.constants.NASTRAN, "CONS", 512534)
                print(base.CheckAdjacentFacesOrientation(cons))


            main()
            # main2()


    """


def ResultsMapperGetResults(mappers: object) -> object:
    """

    Returns a list of entities that are created by the mapper upon 'Apply'.

    Parameters
    ----------
    mappers : object
            A Results Mapper entity

    Returns
    -------
    object
            Upon success, returns a list of entities created by the Results Mapper. Returns none otherwise

    Examples
    --------
    ::

            import ansa
            import base


            def main():
                mappers = base.CollectEntities(
                    deck=ansa.constants.ABAQUS, search_types="RESULTS_MAPPER"
                )
                created_ents = base.ResultsMapperGetResults(mappers)


    """


def CollectAssemblyAdapter(container: object, content: object) -> object:
    """
    .. deprecated:: 20.0.0
            Use :py:func:`GetModelContainerAdapter` instead.


    Returns the Adapter entity that adapts Content to Container, if exists.

    Parameters
    ----------
    container : object
            A reference to the container entity.

    content : object
            A reference to the content entity.

    Returns
    -------
    object
            Returns the Adapter ANSA entity, in case the Content ANSA entity is adapted in
            the Container ANSA entity, or None otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                all_sim_runs = base.CollectEntities(
                    constants.NASTRAN, containers=None, search_types="ANSA_SIMULATION_RUN"
                )
                all_loadcases = base.CollectEntities(
                    constants.NASTRAN, containers=None, search_types="ANSA_LOADCASE"
                )
                for sim_run in all_sim_runs:
                    for loadcase in all_loadcases:
                        adapter = base.CollectAssemblyAdapter(container=sim_run, content=loadcase)
                        if adapter != None:
                            print("Loadcase '", loadcase._name, "' uses adapter ", adapter)
                            print("            to get adapted in the '", sim_run._name, "' Sim.Run")
                        else:
                            print("Loadcase '", loadcase._name, "' is not found ")
                            print(
                                "            as a child of '",
                                sim_run._name,
                                "' Sim.Run in this database",
                            )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 20.0.0. Use :py:func: GetModelContainerAdapter instead.",
        DeprecationWarning,
    )


def CrossSectionOrientLocal(
    cross_section: object,
    x: float,
    y: float,
    angle: float,
    translate_to_shear: bool,
    translate_to_mass: bool,
    transform_to_mass: bool,
) -> int:
    """

    Orients the local coordinate system of a cross section.

    Parameters
    ----------
    cross_section : object
            A cross section or a list of cross section entities, whose coordinate system(s)
            will be oriented.

    x : float, optional
            The translation value parallel to the cross section's X-axis.
            Default value: 0

    y : float, optional
            The translation value parallel to the cross section's Y-axis.
            Default value: 0

    angle : float, optional
            The angle of rotation of the local coordinate system (degrees).
            Default value: 0

    translate_to_shear : bool, optional
            Translate the local coordinate system to the cross section's shear center.
            Default value: False
            (Note: If translate_to_shear is True, none of the other optional arguments should
            be provided.)

    translate_to_mass : bool, optional
            Translate the local coordinate system to the cross section's mass center.
            Default value: False
            (Note: If translate_to_mass is True, none of the other optional arguments should
            be provided.)

    transform_to_mass : bool, optional
            Translate the local coordinate system to the cross section's mass center and
            rotate it at the angle of principal axis.
            (Note: If transform_to_mass is True, none of the other optional arguments should
            be provided.)

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.NASTRAN, "CROSS_SECTION", 1)
                base.CrossSectionOrientLocal(cross, transform_to_mass=True)


            if __name__ == "__main__":
                main()


    """


def ConvertSubsystems(subsystems: object, subtype: str) -> object:
    """

    Converts a list of Subsystem to the subtype the user specified, if such conversion is possible.

    Parameters
    ----------
    subsystems : object
            A list of subsytems.

    subtype : str
            The subtype that the subsystems will be converted to. Can be "Regular" or "Connecting"

    Returns
    -------
    object
            Return value is a list of subsystems which failed to be converted to the requested subtype.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                base.NewSubsystem()
                subsystems = base.CollectEntities(0, None, "ANSA_SUBSYSTEM")

                base.ConvertSubsystems(subsystems, "Connecting")


            if __name__ == "__main__":
                main()


    """


def ViewsExportMetaFormat(view_name: str, file_path: str):
    """

    Exports a saved view to a meta format file.

    Parameters
    ----------
    view_name : str
            The name of the saved view, there must be a view in Views Manager List with the corresponding name.

    file_path : str
            The file path of the exported view.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.ViewsExportMetaFormat("Custom View", "/path/to/custom_view.view")


            if __name__ == "__main__":
                main()


    """


def SmartPaste(
    source: object,
    target: object,
    prefer_change_source_than_join_perimeters: bool,
    treat_source_as_frozen: bool,
) -> object:
    """

    This function pastes the CONS associated with the source and target given Interface Boundaries, without erasing the mesh. If the mesh around the source and target Boundaries is not compatible, then the target is reconstructed.

    Parameters
    ----------
    source : object
            A list or single Interface Boundary entity that contains the source cons to paste. The mesh of the source entities will not be altered (unless prefer_change_source_than_join_perimeters is set to True).

    target : object
            A list or single Interface Boundary entity that contains the target cons or faces to paste with. If the mesh around the target entities is incompatible with the source, it will be altered to fit the source.

    prefer_change_source_than_join_perimeters : bool, optional
            If this option is set to True, altering the source mesh is preferred if perimeters need to be joined in the target. The default value is False.

    treat_source_as_frozen : bool, optional
            If this option is set to True, source perimeter considered as frozen. The default value is False.

    Returns
    -------
    object
            If some of the Interface Boundaries fail to be pasted, The function returns a list with dictionaries. Each dictionary contains a) a list with the source failed cons with key "failed_source" b) a list with the target failed cons with key "failed_target" c) a list with all the alive source cons with key "source" d) a list with all the alive target cons with key "target". If paste succeeds completely, the function returns 0. If no valid input is provided and no paste is performed at all, the function returns 1.

    See Also
    --------
    base.DefineInterfaceBoundary

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants

            # paste the red cons between 2 parts


            def demoWithFacesBoundaryInterfaces():
                # Need some documentation? Run this with F5
                base.SetANSAdefaultsValues({"tolerance_mode": "middle"})

                p1 = base.GetPartFromName("p1")
                p2 = base.GetPartFromName("p2")

                faces_of_p1 = base.CollectEntities(constants.NASTRAN, p1, "FACE")
                faces_of_p2 = base.CollectEntities(constants.NASTRAN, p2, "FACE")

                boundaries_of_p1 = base.DefineInterfaceBoundary(faces_of_p1, red=True)
                boundaries_of_p2 = base.DefineInterfaceBoundary(faces_of_p2, red=True)

                base.SmartPaste(boundaries_of_p1, boundaries_of_p2)


            def demoWithConsBoundaryInterfaces():
                # Need some documentation? Run this with F5
                base.SetANSAdefaultsValues({"tolerance_mode": "middle"})

                p1 = base.GetPartFromName("p1")
                p2 = base.GetPartFromName("p2")

                cons_of_p1 = base.PerimetersOfFace(p1, "active")
                cons_of_p2 = base.PerimetersOfFace(p2, "active")

                boundaries_of_p1 = base.DefineInterfaceBoundary(cons_of_p1, red=True)
                boundaries_of_p2 = base.DefineInterfaceBoundary(cons_of_p2, red=True)

                base.SmartPaste(boundaries_of_p1, boundaries_of_p2)


    """


def SetUserDefinedGeometrySearch(entity: object, settings: Any) -> int:
    """

    The function assigns UserDefinedGeometry as search method to entity, if it is not already assigned, and the area must be defined from a list of nodes. The area must always be defined.
    Also the function assigns UserDefinedArea as search method to Gebs, A_POINTs LC_POINTs and DOMAIN_FINDERs

    Parameters
    ----------
    entity : object
            A single entity or a sequence of entities to assign UserDefinedGeometry search. Valid entities are Connectors, GEBs, A_POINTs, LC_POINTs and DOMAIN_FINDERs.

    settings : Any
            Depending on the entity type, the settings might be given in a different format.

            For Connector:
            A sequence of Dictionaries, one for each entity, where the key is the search Card fields where UserDefinedGeometry will be assigned. These fields are 'search1' to 'search4'. The data of each key might be another dictionary with settings or just a list with nodes to define the area.
            The settings dictionary accepts the following options:
            key: 'area'
            data: list of nodes

            key: 'sdist'
            data: a value larger than 0.
            Default value is 1. This option is optional.

            For Gebs, A_POINTs LC_POINTs and DOMAIN_FINDERs:
            A sequence of dictionaries or node lists, to define the area, for each entity.
            The dictionary accepts the following options:
            key: 'area'
            data: list of nodes

            key: 'sdist'
            data: a value larger than 0.
            Default value is 1. This option is optional.

    Returns
    -------
    int
            The number of entities where the UserDefinedGeometrySearch was successfully applied.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            # ways to set user defined geometry search
            def example1():
                connector = base.GetEntity(constants.NASTRAN, "CONNECTOR_ENTITY", 2)

                part = base.GetPartFromModuleId("Part1")
                grids_group1 = base.CollectEntities(constants.NASTRAN, part, "GRID", recursive=True)

                part = base.GetPartFromModuleId("Part2")
                grids_group2 = base.CollectEntities(constants.NASTRAN, part, "GRID", recursive=True)

                # DIFFERENT WAYS TO EXECUTE  CORRECTLY SetUserDefinedGeometrySearch
                correct_options1 = {"area": grids_group2, "sdist": 5.0}
                correct_options2 = {"area": grids_group2, "sdist": 4}
                correct_options3 = {"area": grids_group2}
                valid_settings1 = {"search1": grids_group1}
                valid_settings2 = {"search1": grids_group1, "search2": correct_options1}
                valid_settings3 = {"search1": grids_group1, "search2": correct_options2}
                valid_settings4 = {"search1": grids_group1, "search2": correct_options3}

                base.SetUserDefinedGeometrySearch(connector, valid_settings1)
                base.SetUserDefinedGeometrySearch(connector, valid_settings2)
                base.SetUserDefinedGeometrySearch(connector, valid_settings3)
                base.SetUserDefinedGeometrySearch(connector, valid_settings4)


            # set user defined area to multiple connectors
            def example2():
                # collect connectors to set user defined geometry search
                connector1 = base.GetEntity(constants.NASTRAN, "CONNECTOR_ENTITY", 2)
                connector2 = base.GetEntity(constants.NASTRAN, "CONNECTOR_ENTITY", 3)

                # settings for connector 1
                part1 = base.GetPartFromModuleId("Part1")
                grids_connector1 = base.CollectEntities(
                    constants.NASTRAN, part1, "GRID", recursive=True
                )
                settings1 = {"search1": grids_connector1}

                # settings for connector 2
                part2 = base.GetPartFromModuleId("Part2")
                grids_connector2 = base.CollectEntities(
                    constants.NASTRAN, part2, "GRID", recursive=True
                )
                settings2 = {"search1": grids_connector2}

                all_connectors = [connector1, connector2]
                all_settings = [settings1, settings2]

                num_succeeded = base.SetUserDefinedGeometrySearch(all_connectors, all_settings)


            def example3():
                apoint1 = base.GetEntity(constants.NASTRAN, "A_POINT", 1)
                apoint2 = base.GetEntity(constants.NASTRAN, "A_POINT", 2)
                apoints = [apoint1, apoint2]

                # settings for A_POINT 1
                part1 = base.GetPartFromModuleId("Part1")
                grids_connector1 = base.CollectEntities(
                    constants.NASTRAN, part1, "GRID", recursive=True
                )

                part2 = base.GetPartFromModuleId("Part2")
                grids_connector2 = base.CollectEntities(
                    constants.NASTRAN, part2, "GRID", recursive=True
                )

                base.SetUserDefinedGeometrySearch(apoint1, grids_group2)
                base.SetUserDefinedGeometrySearch(apoint1, {"area": grids_group2, "sdist": 10.0})
                base.SetUserDefinedGeometrySearch(
                    apoints, [{"area": grids_group2, "sdist": 10.0}, grids_group1]
                )


            def example4():
                connector = base.GetEntity(constants.NASTRAN, "CONNECTOR_ENTITY", 2)
                apoint1 = base.GetEntity(constants.NASTRAN, "A_POINT", 1)
                apoint2 = base.GetEntity(constants.NASTRAN, "A_POINT", 2)
                all_ents = [apoint1, connector, apoint2]

                part = base.GetPartFromModuleId("Part1")
                grids_group1 = base.CollectEntities(constants.NASTRAN, part, "GRID", recursive=True)

                part = base.GetPartFromModuleId("Part2")
                grids_group2 = base.CollectEntities(constants.NASTRAN, part, "GRID", recursive=True)

                correct_options = {"area": grids_group2, "sdist": 4}
                settings = [
                    {
                        "area": grids_group2,
                        "sdist": 10.0,
                    },  # 1st entity(A_POINT) settings in all_ents
                    {
                        "search1": grids_group1,
                        "search2": correct_options,
                    },  # 2nd entity(Connector) settings
                    grids_group1,  # 3rd entity(A_POINT) settings
                ]

                num_succeeded = base.SetUserDefinedGeometrySearch(all_ents, settings)


    """


def GetEntityCheckInDMValue(entity: object) -> str:
    """
    .. deprecated:: 19.1.0
            Use :py:func:`GetEntityDMUpdateStatus` instead.


    Returns the value of 'Check in DM' flag of the given entity.

    Parameters
    ----------
    entity : object
            The entity to get the 'Check in DM' flag value

    Returns
    -------
    str
            Returns the value of the 'Check in DM' flag.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                all_parts = base.CollectEntities(0, containers=None, search_types="ANSAPART")

                print("Results for parts")
                print("---------------------")
                for run_part in all_parts:
                    print(base.GetEntityCheckInDMValue(run_part))
                all_subsystems = base.CollectEntities(
                    0, containers=None, search_types="ANSA_SUBSYSTEM"
                )

                print("\\n\\nResults for subsystems")
                print("-----------------------------")
                for run_subsystem in all_subsystems:
                    print(base.GetEntityCheckInDMValue(run_subsystem))
                all_sim_models = base.CollectEntities(
                    0, containers=None, search_types="ANSA_SIMULATION_MODEL"
                )

                print("\\n\\nResults for simulation models")
                print("---------------------------------------")
                for run_sim_model in all_sim_models:
                    print(base.GetEntityCheckInDMValue(run_sim_model))


    """

    import warnings

    warnings.warn(
        "Deprecated since version 19.1.0. Use :py:func: GetEntityDMUpdateStatus instead.",
        DeprecationWarning,
    )


def OutputCGNS2D(
    filename: str,
    mode: str,
    unit_system: object,
    scale: float,
    filetype: str,
    unstructured_options: str,
    version: str,
    format: str,
    write_families: str,
) -> int:
    """

    Outputs a CGNS 2D file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include
            the full path to the file.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: "all")

    unit_system : object, optional
            A UnitSystem object.
            Dictates the length unit to which the
            output will be scaled from the existing
            ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments
            are defined, the latter will override the first.

    filetype : str, optional
            Select the type of the output file.
            Can be "HDF5" or "ADF", in
            both upper- and lower-case.
            (Default: "ADF")

    unstructured_options : str, optional
            "mixed" or "separated".
            It controls the format of unstructured meshes.
            "mixed" - output all elements in a common section.
            "separated" - output elements in different sections
            based on their types.
            (Default: "mixed")

    version : str, optional
            "v3.2.0" or "v4.2.0"
            It controls the CGNS library version of the output file.
            (Default: the value of the keyword "Output CGNS Library Version" in ANSA defaults)

    format : str, optional
            "structured" or "unstructured".
            (Default: "unstructured")

    write_families : str, optional
            "yes" or "no".
            It controls whether to group boundary conditions under Famliy_t nodes and write them with FamilySpecified type or not.
            (Default: "no")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputCGNS2D(
                    "C:/users/data.cgns",
                    mode="visible",
                    filetype="HDF5",
                    unstructured_options="mixed",
                )


    """


def CrossSectionResults(
    cross_section: object, mode: str, kind: str, system: str, result_flags: object
) -> object:
    """

    Returns stress values of a calculated cross section on its local coordinate system X-Y.

    Parameters
    ----------
    cross_section : object
            The calculated cross section.

    mode : str
            Mode of results.
            Accepted values: "Any", Section", "Centroid", "Shear C"

    kind : str
            Kind of results.
            Accepted values: "V.Misses", "Normal", "Shear", "Warping"

    system : str
            System to which results are expressed.
            Accepted values: "X-Y", "1-2"

    result_flags : object, optional
            A list with strings that correspond to flags of various stresses.
            Accepted list values: "Nz", "Qx", "Q1", "Qy", "Q2", "Mz", "Mx", "M1", "My", "M2"

            Note: If this argument omitted, current values of these flags will be assumed,
                      otherwise only the referenced flags will be activated.

    Returns
    -------
    object
            Return a list of class objects in success or None otherwise.

            The class objects in the returned list has three members:
            x:       The local x-coordinate of stress value
            y:       The local y-coordinate of stress value
            stress:  The stress value at point (x,y)

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(ansa.constants.NASTRAN, "CROSS_SECTION", 1)

                results = base.CrossSectionResults(
                    cross, mode="Any", kind="Normal", system="1-2", result_flags=["M1", "M2"]
                )

                for v in results:
                    print("x=", v.x, "y=", v.y, "stress=", v.stress)


    """


def AddToAnnotation(annotation: object, entity: object) -> object:
    """

    Adds an entity to an Annotation.
    The Annotation will be attached to the entity.

    Parameters
    ----------
    annotation : object
            The Annotation entity

    entity : object
            The entity that will be added to the Annotation

    Returns
    -------
    object
            The function returns always None

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import constants, base


            def main():
                ent = base.Entity(constants.NASTRAN, 1, "GRID")
                set_vals = {
                    "Name": "An annotation",
                    "Text": "My annotation on Grid",
                    "Background_R": 255,
                    "Background_G": 255,
                    "Background_B": 0,
                    "Follow anchor": "YES",
                    "OffsetX": 30,
                    "Anchor type": "Triangular",
                }

                annot = base.CreateEntity(constants.NASTRAN, "ANNOTATION", set_vals)
                base.AddToAnnotation(annot, ent)


    """


def SaveLogFile(filename: str, log_type: str, format: str) -> int:
    """

    This function saves last input or merge analytics

    Parameters
    ----------
    filename : str
            The name of the file

    log_type : str, optional
            if value "merge_analytics" is provided the merge
            analytics will be saved instead of input analytics

    format : str, optional
            accepted values "csv", "html"
            by default the log file is saved in html format

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                base.InputNastran(filename="C:/temp/users/folder/data.nas")
                base.SaveLogFile(filename="C:/temp/users/folder/data_analytics.html")


            if __name__ == "__main__":
                main()


    """


def RelocateReducedRepresentationPaths(subsystem: object, target_path: str) -> int:
    """

    Relocate to a target path, all paths related with a Reduced Representation.

    Parameters
    ----------
    subsystem : object
            A reference to a subsystem object.

    target_path : str
            The path where all Reduced Representation related paths will be relocated to.

    Returns
    -------
    int
            Returns 0 if relocation fails, 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                subsystem = base.GetEntity(ansa.constants.NASTRAN, "ANSA_SUBSYSTEM", 1)

                if subsystem:
                    ret = base.RelocateReducedRepresentationPaths(subsystem, "C:/tmp/Users/")


    """


def InputPlot3D(
    filename: str,
    nodes_id: str = "offset",
    elements_id: str = "offset",
    properties_id: str = "offset",
    model_action: str = "merge_model",
    file_format: str = "ascii",
    dimension: str = "3d",
    grid_type: str = "multi-block",
    endianness: str = "little-endian",
    precision: str = "double",
    contains_iblanking: str = "no",
    data_layout: str = "whole",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    The InputPlot3D function imports a Plot3D model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted value: "offset".

    elements_id : str, optional
            Accepted value: "offset".

    properties_id : str, optional
            Accepted value: "offset".

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    file_format : str, optional
            Accepted values: "ascii", "c-binary"  or "fortran-binary".
            (Default: "ascii")

    dimension : str, optional
            Accepted values: "2d" or "3d".
            (Default: "3d")

    grid_type : str, optional
            Accepted values: "single-block" or "multi-block".
            (Default: "multi-block")

    endianness : str, optional
            Accepted values: "big-endian" or "little-endian".
            (Default: "little-endian")

    precision : str, optional
            Accepted values: "single" or "double".
            (Default: "double")

    contains_iblanking : str, optional
            Accepted values: "yes" or "no".
            (Default: "no")

    data_layout : str, optional
            Accepted values: "whole" or "planar".
            (Default: "whole")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA will use the light volume representation,
            which is more suitable for CFD meshes.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputPlot3D(
                    "C:/temp/users/folder/data.xyz",
                    model_action="overwrite_model",
                    file_format="fortran-binary",
                    dimension="3d",
                    grid_type="multi-block",
                    endianness="little-endian",
                    precision="double",
                )


    """


def OutputPlot3D(
    filename: str,
    mode: str,
    file_format: str,
    grid_type: str,
    precision: str,
    data_layout: str,
    unit_system: object,
    scale: float,
) -> int:
    """

    This function outputs a Plot3D format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: "all")

    file_format : str, optional
            Accepted values: "ascii" or "c-binary".
            (Default: "ascii")

    grid_type : str, optional
            Accepted values: "single-block" or "multi-block".
            (Default: "multi-block")

    precision : str, optional
            Accepted values: "single" or "double".
            (Default: "double")

    data_layout : str, optional
            Accepted values: "whole" or "planar".
            (Default: "whole")

    unit_system : object, optional
            A UnitSystem object.
            Dictates the length unit to which the
            output will be scaled from the existing
            ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments
            are defined, the latter will override the first.

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputPlot3D(
                    filename="C:/users/dat/data.xyz",
                    mode="visible",
                    file_format="ascii",
                    grid_type="multi-block",
                    data_layout="whole",
                )


    """


def InputSestra(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    coords_id: str = "offset",
    model_action: str = "merge_model",
    read_comments: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_lock_views: str = "on",
    comment_input_misc: str = "on",
    comment_input_annotations: str = "on",
    comment_input_attributes: str = "on",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
) -> int:
    """

    The InputSestra function imports an Sestra model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputSestra(
                    "C:/temp/users/folder/dataT1.FEM",
                    model_action="overwrite_model",
                    elements_id="offset",
                )


    """


def OutputSestra(
    filename: str,
    mode: str,
    write_comments: str,
    model_check: str,
    model_check_template: str,
    cancel_output_if_model_check_error: str,
    write_analysis_control_data: str,
):
    """

    This function outputs a Sestra format file like the FILE>OUTPUT>SESTRA functionality.

    Parameters
    ----------
    filename : str
            The name of the output file. must reference the full path
            to the file.

    mode : str, optional
            "all", "model" or "visible".
            (Default: what set at the last execution)

    write_comments : str, optional
            "none" or "at_eof".
            (Default: what set at the last execution)

    model_check : str, optional
            Run a check template before output.
            Accepted values: "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The check template to execute during output.
            This argument is valid only if 'model_check' is "on".

    cancel_output_if_model_check_error : str, optional
            Cancel output if model checking fails. Model checking
            will fail if at least one error or warning was encountered.
            Accepted values: "on", "off".
            This argument is valid only if 'model_check' is "on".
            (Default: "off")

    write_analysis_control_data : str, optional
            Write Analysis Control Data file on output.
            Accepted values: "on", "off".
            (Default: what set at the last execution)

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputSestra(
                    "C:/temp/dataT1.FEM", write_comments="at_eof", write_analysis_control_data="on"
                )


    """


def OutputMetaFrfAssembly(filename: str, mode: str) -> int:
    """

    This function ouputs a Meta Frf Assembly format file like the FILE>OUTPUT>META FRF ASSEMBLY functionality.

    Parameters
    ----------
    filename : str
            The name of the output file. Must reference the full path to the file.

    mode : str, optional
            Selection of output entities. Valid options are: 'all', 'model' or 'visible'.
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 0 on success, 1 otherwise.

    Examples
    --------
    ::

            base.OutputMetaFrfAssembly("C:/temp/users/folder/frf_assembly.ses", "all")


    """


def CreateView(
    name: str,
    euler_x: float,
    euler_y: float,
    euler_z: float,
    left: float,
    bottom: float,
    near: float,
    right: float,
    top: float,
    far: float,
    rotpoint_x: float,
    rotpoint_y: float,
    rotpoint_z: float,
):
    """

    Creates a new view at Views Manager List.

    Parameters
    ----------
    name : str
            The view's name.

    euler_x : float
            X axis euler angle.

    euler_y : float
            Y axis euler angle.

    euler_z : float
            Z axis euler angle.

    left : float
            View's bouding box left coordinate.

    bottom : float
            View's bouding box bottom coordinate.

    near : float
            View's bouding box near coordinate.

    right : float
            View's bouding box right coordinate.

    top : float
            View's bouding box top coordinate.

    far : float
            View's bouding box far coordinate.

    rotpoint_x : float
            Rotation center's X coordinate.

    rotpoint_y : float
            Rotation center's Y coordinate.

    rotpoint_z : float
            Rotation center's Z coordinate.

    See Also
    --------
    base.ViewsExportMetaFormat

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.CreateView("Custom View 1", 45, 0, 0, -100, -100, -1, 100, 100, 1, 0, 0, 0)


            if __name__ == "__main__":
                main()


    """


def InvertPart(part: object) -> object:
    """

    This function collects all parts that
    1) are not in the incoming matrix and
    2) are not a parent group (all levels up till the top root) of any incoming part

    Parameters
    ----------
    part : object
            A part entity or a list of part entities.

    Returns
    -------
    object
            A matrix with the collected parts.

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa


            def main():
                part = ansa.base.GetPartFromModuleId("Left_Middle")
                print(ansa.base.InvertPart(part))


    """


def ActivateSimulationRun(simulation_run: object, activate: bool) -> int:
    """

    This function will set/unset the input Simulation Run as the Working Model
    Browser Container.

    Parameters
    ----------
    simulation_run : object
            a Simulation Run entity.

    activate : bool
            set or unset as Working

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa


            def main():
                simulation_run = ansa.base.GetPartFromName("Run1", type="ANSA_SIMULATION_RUN")
                print(ansa.base.ActivateSimulationRun(simulation_run, True))


    """


def ReplaceSegmentsWithinContactSets(contacts: object) -> object:
    """

    The function takes a list of CONTACTs as argument and tries to replace the SEGMENTs existing within the referenced SETs, by filling them with entities which describe the same area/volume, such as SHELLs/SOLIDs, Properties or EDGEs.

    Parameters
    ----------
    contacts : object
            A single contact, a list of contacts or "all" to modify all the contacts of the model.

    Returns
    -------
    object
            None

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Need some documentation? Run this with F5
                contact = base.GetEntity(constants.RADIOSS, "INTER", 1)
                ReplaceSegmentsWithinContactSets(contact)

                ReplaceSegmentsWithinContactSets("all")  # Replace SEGMENTs of all contacts


    """


def OptimizeSetContents(sets: object, solid_skin_mode: bool) -> object:
    """

    The function takes a list of SETs as argument and tries to optimize their contents by replacing lower level entities to higher level entities which describe the same Area/Volume. The hierarchy of the entities has as follows:

    NODEs -> ELEMENTs -> PROPERTIES -> (optional) Skin of Solid PROPERTIES

    Parameters
    ----------
    sets : object
            A single SET, a list of SETs or "all" to optimize all the SETs of the model.

    solid_skin_mode : bool, optional
            If this flag is True, then the solid Properties will be replaced with their
            respective skin (default is False)

    Returns
    -------
    object
            None

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                set = base.GetEntity(constants.NASTRAN, "SET", 1)
                base.OptimizeSetContents(set)

                # or
                base.OptimizeSetContents("all")  # Optimize all the SETs of the model

                # or
                base.OptimizeSetContents("all", True)  # Optimize all the SETs of the model

                # or
                base.OptimizeSetContents(
                    sets="all", solid_skin_mode=True
                )  # Optimize all the SETs of the model


    """


def CompareContentsOfContainers(
    deck: int,
    model1: object,
    model2: object,
    type: str,
    check_first_level: bool,
    check_geometry: bool,
    match_containers_by_name: bool,
) -> object:
    """

    This function takes two ANSA models as arguments and tries to find differences between the contents of
    the given container type(e.g. SET), by comparing the type and the id of every contained entity. Also,
    there is an option to perform geometric check by inspecting the C.O.G. of each child entity alongside
    with the C.O.G. of the container itself.
    To be noted that the function matches the containers of the two Models by using their Id.

    Parameters
    ----------
    deck : int
            The deck

    model1 : object
            The first ANSA Model for which the check will be held.

    model2 : object
            The second ANSA Model for which the check will be held.

    type : str
            The type of the container for which the check will be held. it can be:
            Sets, (i.e. "SET", "GROUP")
            "INCLUDE",
            "ANSAPART"
            "__PROPERTIES__"
            "__MATERIALS__"

    check_first_level : bool, optional
            If True, the check will be held only for the first level
            children of the container (default is False).

    check_geometry : bool, optional
            If True, geometric check will be held as well, based on the C.O.G.
            of the contained entities (default is False).

    match_containers_by_name : bool, optional
            If True, the matching of containers is performed my name.

    Returns
    -------
    object
            Returns a list of tuples, each of which contains information about the containers, which found different.
            The tuple has the form (container_of_model1, container_of_model2, str_difference)
            The str_difference describes what kind of difference the containers have.

    Examples
    --------
    ::

            import os
            import ansa


            def main():
                p0 = ansa.base.GetEntity(0, "MODEL", 0)
                p1 = ansa.base.GetEntity(0, "MODEL", 1)
                list = ansa.base.CompareContentsOfContainers(1, p0, p1, "SET", True, True)
                print(list)


            if __name__ == "__main__":
                main()


    """


def GetIncludeReferenceFileText(include: object) -> str:
    """

    Gets the text of an include's reference file.

    Parameters
    ----------
    include : object
            A reference to an include element.

    Returns
    -------
    str
            Returns the text of the given include's reference file.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                include = base.GetEntity(constants.NASTRAN, "INCLUDE", 1)
                text = base.GetIncludeReferenceFileText(include)


    """


def InputMotionSolve(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    This function imports a '.xml' (MotionSolve) format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset" or "nooffset" or "keep-old" or "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model", "new_model_in_active_window",
            "new_model_in_new_window" or "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputMotionSolve("/home/users/model.xml", "keep-old", "keep-old", "offset")


    """


def RemoveFromAnnotation(annotation: object, entity: object) -> bool:
    """

    Removes an entity from an Annotation.
    The Annotation will be detached from the entity.

    Parameters
    ----------
    annotation : object
            The Annotation entity

    entity : object
            The entity that will be removed from the Annotation

    Returns
    -------
    bool
            The function returns true if the entity is removed and false otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import constants, base


            def main():
                ent = base.Entity(constants.NASTRAN, 1, "GRID")
                set_vals = {"Name": "An annotation", "Text": "My annotation on Grid"}
                annot = base.CreateEntity(constants.NASTRAN, "ANNOTATION", set_vals)

                base.AddToAnnotation(annot, ent)
                base.RemoveFromAnnotation(annot, ent)


    """


def DefineReducedRepresentation(
    type: str,
    display_file: str,
    asm_file: str,
    pch_file: str,
    results_file: str,
    convert_to_dmigpch: bool,
    source: object,
) -> object:
    """

    This function defines a reduced representation from the necessary solver files.

    Parameters
    ----------
    type : str
            The representation type.
            Accepted values:
            -"DMIGOP2": NASTRAN Superelement with .op2 results file
            -"DMIGPCH": NASTRAN Superelement with .pch results file
            -"DMIG". Reduced Model with DMIG matrices as results.
            -"FRF": FRF Representation
            -"MODAL": Modal Model

    display_file : str, optional
            File with geometry used for display of the Reduced Model.

    asm_file : str, optional
            Assembly file (.asm) produced by the solver.
            If type is "DMIGOP2" or "DMIGPCH" asm_file must be defined.

    pch_file : str, optional
            Punch file (.pch) produced by the solver.
            If type is "DMIGPCH" or "DMIG" pch_file must be defined.

    results_file : str, optional
            Results file (.op2) produced by the solver.
            If type is "DMIGOP2" or "FRF" or "MODAL" results_file must be defined.

    convert_to_dmigpch : bool, optional
            This option can be used if type is "DMIG" and converts the DMIG Reduced Model
            to DMIGPCH Reduced Model.
            Default is True.

    source : object, optional
            A Subsystem.

    Returns
    -------
    object
            Returns the defined Reduced Model.

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import base


            def main():
                asm = "~/tmp/superelement_1.asm"
                pch = "~/tmp/superelement_1.pch"
                results = "~/tmp/superelement_1.op2"

                ret_ent = base.DefineReducedRepresentation(
                    "DMIGOP2", asm_file=asm, pch_file=pch, results_file=results
                )
                print(ret_ent)


            if __name__ == "__main__":
                main()


    """


def OutputMotionSolve(filename: str, mode: str) -> int:
    """

    This function outputs a MotionSolve file.

    Parameters
    ----------
    filename : str
            The path to the directory to export.

    mode : str, optional
            "all", "model" or "visible".
            (Default: "visible")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                dir = utils.SelectSaveDir("/home/user/")
                base.OutputMotionSolve(dir, "all")


    """


def GetEntityDMUpdateStatus(entity: object) -> int:
    """

    Get the "DM Update Status" of the specified entity.

    Parameters
    ----------
    entity : object
            The entity to get the "DM Update Status".

    Returns
    -------
    int
            Returns a constant value according to the "DM Update Status" as follows:
            constants.DM_STATUS_UP_TO_DATE      for "Up to date"
            constants.DM_STATUS_NOT_UP_TO_DATE  for "Not up to date"
            constants.DM_STATUS_MODIFIED        for "Modified"
            constants.DM_STATUS_ALTERNATIVE     for "Alternative"
            constants.DM_STATUS_NOT_FOUND       for "Not Found"
            constants.DM_STATUS_ERROR           when no "DM Root" was specified.

    Examples
    --------
    ::

            import ansa
            from ansa import base, constants


            def getDMUpdateStatus():
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")

                print("DM Update Status of Parts:")
                for part in parts:
                    dm_update_status = base.GetEntityDMUpdateStatus(part)
                    if dm_update_status == constants.DM_STATUS_ERROR:
                        print("Please add/connect to a DM Root")
                        break
                    if dm_update_status == constants.DM_STATUS_UP_TO_DATE:
                        print('The "' + part._name + '" part is updated')
                    elif dm_update_status == constants.DM_STATUS_NOT_FOUND:
                        print('The "' + part._name + '" part was not found in DM')
                    else:
                        print('The "' + part._name + '" part is not updated')


            getDMUpdateStatus()


    """


def CrossSectionAutoSpotAll(
    cross_section: object,
    tolerance_t_fac: float,
    parallel_limit: float,
    diameter: float,
    along_step: float,
    widthwise_step: float,
    young_modulus: float,
    poisson_ratio: float,
    curves: object,
) -> int:
    """

    Connect cross section flanges with spot elements.

    Parameters
    ----------
    cross_section : object
            A cross section or a list of cross section entities, calculated as thin,
            whose flanges will be connected with spot elements.

    tolerance_t_fac : float, optional
            Two segments with thickness t1 and t2 will be spot connected if the distance between
            them is less or equal to tolerance_t_fac*(t1+t2)/2.
            (Default value: 1.2)

    parallel_limit : float, optional
            Any pair of segments that form angle up to this value (in degrees) will be treated
            as parallel. Accepted values 0 ~ 60.
            (Default value: 10.)

    diameter : float, optional
            Diameter of the created spot entity. If no value is provided, then the mean diameter
            ,of the spots that already exist in the cross section, is extracted and applied. If
            the cross section does not have spot elements, the default value is applied.
            (Default value: 5.)

    along_step : float, optional
            Distance between the created spot elements along the cross section's normal axis.
            If no value is provided, then the mean distance, of the spots that already exist in
            the cross section, is extracted and applied. If the cross section does not have spot
            elements, the default value is applied.
            (Default value: 35.)

    widthwise_step : float, optional
            Distance between the created spot elements along the cross section segment.
            (Default value: 0.)

    young_modulus : float, optional
            The young modulus of elasticity of the created spot elements. If no value is
            provided, then the mean modulus of elasticity, of the spots that already exist
            in the cross section, is extracted and applied. If the cross section does not
            have spot elements, the default value is applied.
            (Default value: 210000)

    poisson_ratio : float, optional
            The poisson ratio of the created spot elements. If no value is provided, then the
            mean poisson ratio, of the spots that already exist in the cross section, is
            extracted and applied. If the cross section does not have spot elements,
            the default value is applied.
            (Default value: 0.3)

    curves : object, optional
            A list of CROSS_CURVE entities. If defined, then AutoSpot is performed only on the
            CROSS_CURVEs of the list and not on all cross section's CROSS_CURVEs.
            The entities of the list should belong to the provided cross_section.
            Note: This argument should not be used when a list of cross section entities is
            provided.

    Returns
    -------
    int
            Returns 1 upon successfull creation of at least one spot element and 0 otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.NASTRAN, "CROSS_SECTION", 1)
                base.CrossSectionAutoSpotAll(cross, tolerance_t_fac=1.3)


            if __name__ == "__main__":
                main()


    """


def GetCrossSpotConnectedCurves(cross_spot: object) -> object:
    """

    Creates a list with the cross curve entities that are connected through a cross spot.

    Parameters
    ----------
    cross_spot : object
            A cross spot entity. The curves which are connected through this entity will be extracted and
            retrieved.

    Returns
    -------
    object
            Returns a list with the spot connected cross curve entities.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                cross_spot = base.GetEntity(constants.NASTRAN, "CROSS_SPOT", 1)
                curves = base.GetCrossSpotConnectedCurves(cross_spot)
                print(curves)


            if __name__ == "__main__":
                main()


    """


def MergeAnsaModels(
    master_model: Entity,
    slave_model: Entity,
    target_model: str = "master_model",
    offset_option: str = "offset_slave_ids",
    delete_source_models: bool = False,
    merge_parts: bool = False,
    autoposition_parts: bool = False,
    create_instances: bool = False,
    custom_offset_options: Iterable = None,
) -> None:
    """

    This function merges two ansa models to the master model or to a new one, based on a series of user defined arguments.

    Parameters
    ----------
    master_model : Entity
            Master model object.

    slave_model : Entity
            Slave model object.

    target_model : str, optional
            Determines whether slave model will be merged to master one, or master
            and slave will be merged to a new one.
            Accepted values:"master_model", "new_model"
            (Default "master_model")

    offset_option : str, optional
            Determines the action to be taken for ids during the merge.
            Accepted values: "offset_slave_ids"
                             "offset_slave_ids_only_conflicts"
                             "custom_offset" : define offset option per entity group
                                               through "custom_offsets" parameter.
            (Default "offset_slave_ids")

    delete_source_models : bool, optional
            Determines whether merged_models are going to be deleted or not.
            Only applicable when "target_model" = "new_model".
            It won't have any effect otherwise.
            (Default: False)

    merge_parts : bool, optional
            Determines whether conflicting parts are going to be merged or not.
            (Default: False)

    autoposition_parts : bool, optional
            Determines whether multi-instantiated parts will be auto positioned or not.
            (Default: False)

    create_instances : bool, optional
            Determines whether two parts with the same Id or name will be merged
            or a new instance of the part will be created.
            (Default: False)

    custom_offset_options : Iterable, optional
            Used in combination with "offset_option" = "custom_offset"
            A python list holding pairs of the requested entity group type,
            and one of the following offset options:
                          "offset_all_slave_ids",
                          "offset_all_slave_ids_with_value", "offset_value", <value>
                          "offset_only_conflicts",
                          "offset_only_conflicts_with_value", "offset_value", <value>
                          "keep_master"(only for NODE, PROPERTY, MATERIAL, SET, COORDINATE,  SECTION PROPERTY, LOADSET, HOURGLASS, EOS)
                          "keep_slave"(only for NODE, PROPERTY, MATERIAL, SET, COORDINATE,  SECTION PROPERTY, LOADSET, HOURGLASS, EOS

            or
                     "all"  along with the already afforementioned supported offset_options, if user wants all the existing entity groups to be merged according to offset_option.  If a group needs to be excluded the latter needs to be defined with the desired option as last argument
                      e.g. to merge all existing groups of entities with option "offset_all_slave_ids" and only NODE with "keep_master": custom_offset_options=("all", "offset_all_slave_ids", "NODE", "keep_master")

    Returns
    -------
    None
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                model_master = base.GetEntity(constants.ABAQUS, "MODEL", 0)
                model_slave = base.GetEntity(constants.ABAQUS, "MODEL", 1)

                base.MergeAnsaModels(
                    master_model=model_master,
                    slave_model=model_slave,
                    target_model="new_model",
                    delete_source_models=True,
                    offset_option="custom_offset",
                    merge_parts=True,
                    autoposition_parts=False,
                    custom_offset_options=(
                        "ELEMENT",
                        "offset_all_slave_ids",
                        "NODE",
                        "keep_master",
                        "PROPERTY",
                        "offset_only_conflicts_with_value",
                        "offset_value",
                        9000000,
                    ),
                )


    """


def MeanFieldHomogenization(filename: str) -> object:
    """

    Performs material homogenization of a microstructure with properties of each
    constituent given in a xml file.

    Parameters
    ----------
    filename : str
            The filename of the xml with microstructure data.

    Returns
    -------
    object
            Returns an object with the homogenization results(Engineering properties
            assigned according to homogenized material type (isotropic, transversely isotropic
            orthotropic, anisotropic))
            -ret.E1
            -ret.E2
            -ret.E3
            -ret.N12
            -ret.N13
            -ret.N23
            -ret.G12
            -ret.G13
            -ret.G23
            -ret.RHO   (Homogenized Density)
            -ret.Stiff (Full stiffness matrix 6x6 in case of anisotropic materials)
            -ret.CTEs  (Full coefficients of thermal expansion matrix)
            -ret.SpecHeat (Specific Heat of composite in case of thermal conductivity analysis)
            -ret.ThermConduct (Full thermal conductivity tensor 3x3 in case of thermal conductivity analysis)

    See Also
    --------
    MeanFieldHomogenizationMakeMaterial

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                hm_rs = base.MeanFieldHomogenization("filename.xml")
                print(hm_rs.Stiff)


            if __name__ == "__main__":
                main()


    """


def MeanFieldHomogenizationMakeMaterial(
    deck: int,
    filename: str,
    stress_index_for_plast_curve: str,
    strain_index_for_plast_curve: str,
) -> object:
    """

    Performs material homogenization of a microstructure with properties of each
    constituent given in a xml file, and creates the appropriate homogeneous material
    for the given deck.

    Parameters
    ----------
    deck : int
            The deck for the material to be generated

    filename : str
            The filename of the xml with microstructure data.

    stress_index_for_plast_curve : str, optional
            In case of non linear homogenization analysis the
            stress index of the plastic curve to assign to
            material.E.g. "Stress11", "Stress22", "Stress33",
            "Stress12", "Stress13", "Stress23", "VonMises".
            If omitted von mises stress type is considered.

    strain_index_for_plast_curve : str, optional
            In case of non linear homogenization analysis the
            strain index of the plastic curve to assign to
            material.E.g. "Strain11", "Strain22", "Strain33",
            "Strain12", "Strain13", "Strain23", "VonMises".
            If omitted, von mises strain type is considered

    Returns
    -------
    object
            Returns the created homogeneous material

    See Also
    --------
    MeanFieldHomogenization

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                material = base.MeanFieldHomogenizationMakeMaterial(
                    constants.NASTRAN, "filename.xml", "VonMises", "Stress11"
                )
                print(material)


            if __name__ == "__main__":
                main()


    """


def ConnectPartInstances(master_part: object, slave_parts: object) -> bool:
    """

    This function makes the 'slave_parts' instances of the 'master_part'.
    All instances of the 'slave_parts' will have the same Module Id and Version with
    the 'master_part".

    Parameters
    ----------
    master_part : object
            The master part.

    slave_parts : object
            The list of parts that will become instances of the 'master_part'.

    Returns
    -------
    bool
            Returns True on success, False on failure.

    See Also
    --------
    base.BreakPartInstances, base.GetPartInstances

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                master = base.GetPartFromModuleId("101")
                print("master is: ")
                print(master)
                slave = base.GetPartFromModuleId("102")
                print("slave is: ")
                print(slave)

                part_instances = base.GetPartInstances(master)
                print("part_instances are:")
                print(part_instances)

                result = base.ConnectPartInstances(master, slave)
                print(result)

                part_instances = base.GetPartInstances(master)
                print("part_instances are:")
                print(part_instances)

                result = base.BreakPartInstances(part_instances)
                print(result)


    """


def BreakPartInstances(parts: object) -> bool:
    """

    This function takes as input a list of multi-instance parts and makes them single-instances.
    The single-instances will have empty Module Ids and their Names will be uniquified by
    appending '@' and a number.

    Parameters
    ----------
    parts : object
            The list of parts.

    Returns
    -------
    bool
            Returns True on success, False on failure.

    See Also
    --------
    base.ConnectPartInstances, base.GetPartInstances

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                master = base.GetPartFromModuleId("101")
                print("master is: ")
                print(master)
                slave = base.GetPartFromModuleId("102")
                print("slave is: ")
                print(slave)

                part_instances = base.GetPartInstances(master)
                print("part_instances are:")
                print(part_instances)

                result = base.ConnectPartInstances(master, slave)
                print(result)

                part_instances = base.GetPartInstances(master)
                print("part_instances are:")
                print(part_instances)

                result = base.BreakPartInstances(part_instances)
                print(result)


    """


def GetPartInstances(part: object, same_version_instances: bool) -> object:
    """

    This runction returns all instances of a part. If the flag 'same_version_instances'
    is True then the function returns only the part instances with the same version
    as the input part.

    Parameters
    ----------
    part : object
            The input part.

    same_version_instances : bool, optional
            This flag determines whether to return all part instances or only the ones
            with the same version as the input part.
            Default value: False.

    Returns
    -------
    object
            Returns the list with all instance of the part.

    See Also
    --------
    base.GetPartInstancesFromModuleId, base.ConnectPartInstances, base.BreakPartInstances, base.SetPartVersion

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                master = base.GetPartFromModuleId("101")
                print("master is: ")
                print(master)
                slave = base.GetPartFromModuleId("102")
                print("slave is: ")
                print(slave)

                part_instances = base.GetPartInstances(master)
                print("part_instances are:")
                print(part_instances)

                result = base.ConnectPartInstances(master, slave)
                print(result)

                part_instances = base.GetPartInstances(master)
                print("part_instances are:")
                print(part_instances)

                result = base.BreakPartInstances(part_instances)
                print(result)


    """


def GetPartLinks(part: object) -> object:
    """

    This function returns all link parts of a part.

    Parameters
    ----------
    part : object
            The input part.

    Returns
    -------
    object
            Returns a list with all links of the input part.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromModuleId("101")
                part_links = base.GetPartLinks(part)

                print(part_links)


    """


def CalculateHardeningParameters(
    deck: int, material_or_curve: object, filename: str, convert_nominal_to_true: bool
) -> object:
    """

    Calculates hardening modulus and hardening exponent from stress/strain data curve.

    Parameters
    ----------
    deck : int
            The deck to perform the calculations

    material_or_curve : object, optional
            For ABAQUS, LSDYNA and RADIOSS a material or a curve with
            stress strain data or a *.csv file with first column having
            the stresses and the second column the strains. If data
            table with more than one curve is assigned to the material,
            the calculations are performed with the first curve.
            Compatible materials:
            ABAQUS MATERIAL, RADIOSS LAW36, LSDYNA MAT24

    filename : str, optional
            A *.csv file with first column having the stresses and the
            second column, the strains.

    convert_nominal_to_true : bool, optional
            A flag for conversion of the stress and strain values
            from nominal to true. Default value is False

    Returns
    -------
    object
            Returns an object with the hardening parameters.
            -ret.K
            -ret.n

    See Also
    --------
    GetAllCurvesFromMaterial

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                material = base.GetEntity(
                    constants.LSDYNA, "MAT24 MAT_PIECEWISE_LINEAR_PLASTICITY", 1
                )
                ret = base.CalculateHardeningParameters(
                    constants.LSDYNA, material, convert_nominal_to_true=False
                )
                print(ret.K, ret.n)


            if __name__ == "__main__":
                main()


    """


def GetAllCurvesFromMaterial(deck: int, material: object) -> object:
    """

    GetAllCurvesFromMaterial - returns a list with all the curves of a data table assigned to material

    Parameters
    ----------
    deck : int
            The deck of the corresponding material
            Compatible decks: ABAQUS, LSDYNA, RADIOSS

    material : object
            A material with the given data table with curves
            Compatible materials:
            ABAQUS MATERIAL, LSDYNA MAT24, RADIOSS LAW36

    Returns
    -------
    object
            Returns a list with the curves of the data table assigned to the material

    See Also
    --------
    CalculateHardeningParameters

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                material = base.GetEntity(
                    constants.LSDYNA, "MAT24 MAT_PIECEWISE_LINEAR_PLASTICITY", 1
                )
                curves_list = base.GetAllCurvesFromMaterial(constants.LSDYNA, material)

                ret = base.CalculateHardeningParameters(constants.LSDYNA, curves_list[0])
                print(ret.K, ret.n)


            if __name__ == "__main__":
                main()


    """


def TransformResolve(entities: object) -> object:
    """

    Disconnects transformation entities from their affected entities keeping them at their current position.
    The transformation entities are kept but will no longer be applied on any entity.

    Parameters
    ----------
    entities : object
            A reference or a list of references of transformation entities.

    Returns
    -------
    object
            None

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                trmtrxs = base.CollectEntities(constants.LSDYNA, None, "DEFINE_TRANSFORMATION")
                base.TransformResolve(trmtrxs)


    """


def CrossSectionDeleteFreeEdges(
    cross_section: object,
    apply_max_length: bool,
    max_length: float,
    handle: str,
    free_on: str,
    spot_neighbor: bool,
    paste_neighbor: bool,
    curve_neighbor: bool,
) -> int:
    """

    Delete the free edges of thin cross sections.

    Parameters
    ----------
    cross_section : object
            A cross section, or a list of cross section entities, calculated as thin.

    apply_max_length : bool, optional
            Defines whether the value of max_length should be taken into account or not.
            (Default value: False)

    max_length : float, optional
            Defines an upper limit to the length of the free edges that should be included.
            Free edges, whose length is bigger than this value are ignored.
            Used only when apply_max_length = True.
            (Default value: 0)

    handle : str, optional
            Defines whether two neighbor segments will be treated as a continuous edge or not.
            Accepted values: "Independently", "As chain"
            (Default value: "Independently")

    free_on : str, optional
            Defines that an edge should be included if it is free on one or both sides.
            Accepted values: "One side", "Both sides"
            (Default value: "One side")

    spot_neighbor : bool, optional
            Defines whether free edges that neighbor with Cross Spot elements should be
            included or not.
            Used only when free_on = "One side"
            (Default value: False)

    paste_neighbor : bool, optional
            Defines whether free edges that neighbor with Cross Paste elements should be
            included or not.
            Used only when free_on = "One side"
            (Default value: False)

    curve_neighbor : bool, optional
            Defines whether free edges that neighbor with Cross Curve elements should be
            included or not.
            Used only when free_on = "One side"
            (Default value: False)

    Returns
    -------
    int
            Always returns 1.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cross = base.GetEntity(constants.NASTRAN, "CROSS_SECTION", 1)
                base.CrossSectionDeleteFreeEdges(cross, spot_neighbor=True)


            if __name__ == "__main__":
                main()


    """


def GetFacesOfMacros(macros: object) -> object:
    """

    Returns the faces that input macros contain.

    Parameters
    ----------
    macros : object
            A Face entity, Face ID, a list of Face entities, a list of Face IDs, or a list of Face entities and IDs.

    Returns
    -------
    object
            Returns a list with the faces that the input macros contain.

    See Also
    --------
    GetFaceMacro, GetMacrosOfCons, GetMacrosOfHotPoints

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base, constants


            def main():
                id = 1
                macro = base.GetEntity(constants.NASTRAN, "FACE", id)
                faces_list = base.GetFacesOfMacros(macro)
                print(len(faces_list))


    """


def SplitVolumeMesh(properties: object, create_cfd_interfaces: bool) -> int:
    """

    The SplitVolumeMesh function duplicates the selected shell properties and disconnects the volume mesh.

    Parameters
    ----------
    properties : object
            A list of shell properties where the mesh will be
            splitted.

    create_cfd_interfaces : bool, optional
            Flag that indicates if a CFD_INTERFACE will be created
            for each property in the list. (Default: True)

    Returns
    -------
    int
            Returns 0 on success, non zero on error, where:

            0: Sucess
            1: Failure: Invalid properties list. Only shell properties are accepted.
            2: Failure: Empty properties list.
            3: Failure: Shell properties are not internal.
            4: Failure: Shell properties are intersecting.
            5: Failure: Shell properties contain or connect with frozen faces.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                pshell = base.GetEntity(ansa.constants.OPENFOAM, "SHELL_PROPERTY", 12)
                ret = base.SplitVolumeMesh(pshell, 1)


            if __name__ == "__main__":
                main()


    """


def UpdateContactClearance(deck: int, contacts: object) -> object:
    """

    Calculates the clearance values of given contacts.

    Parameters
    ----------
    deck : int
            The deck constant.

    contacts : object
            A list with the desired contacts.

    Returns
    -------
    object
            For the contacts that was able to make the calculations a dictionary is returned with keys the contacts and values the clearance of each contact.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                contacts = base.CollectEntities(constants.ABAQUS, None, "CONTACT_PAIR")
                results = base.UpdateContactClearance(constants.ABAQUS, contacts)
                print(results)


            def main():
                contacts = base.CollectEntities(constants.NASTRAN, None, "CONTACT")
                results = base.UpdateContactClearance(constants.NASTRAN, contacts)
                print(results)


    """


def DeleteModelContainer(
    containers: object,
    geometry: bool,
    connections: bool,
    model_setup_entities: bool,
    interfaces: bool,
    inner_containers: bool,
    display_model: bool,
    superelement: bool,
    loadcase: bool,
    definition: bool,
    protect_main_include: bool,
) -> int:
    """

    This function deletes one or more Model Browser Containers(Subsystems, Simulation Models, Simulation Runs, Loadcases, Library Items) contained in a list, according to a series of arguments.

    Parameters
    ----------
    containers : object
            A list of Model Browser containers(Subsystems, Simulation Models, Simulation Runs, Loadcases, Library Items).

    geometry : bool, optional
            Determines whether the Model Browsers' geometry should be deleted or not.
            (Default: False)

    connections : bool, optional
            Determines whether the Model Browsers' connections should be deleted or not.
            (Default: False)

    model_setup_entities : bool, optional
            Determines whether the Model Browsers' model setup entities should be deleted or not.
            (Default: False)

    interfaces : bool, optional
            Determines whether the Model Browsers' interfaces(Apoints, LCPoints) should be deleted or not.
            (Default: False)

    inner_containers : bool, optional
            Determines whether the Model Browsers' inner containers should be deleted or not.
            Use this when you need to delete the Subsystems/Manually dropped Includes that are children of a Simulation Model,  or the Loadcase and Simulation Model that are children of a Simulation Run.
            (Default: False)

    display_model : bool, optional
            Determines whether the Model Browser containers' corresponding Display Model should be deleted or not.
            Is applicable only to Display Model subsystems.
            (Default:False)

    superelement : bool, optional
            Determines whether the Model Browser containers' corresponding Superelement should be deleted or not.
            Is applicable only to Superlement subsystems.
            (Default : False)

    loadcase : bool, optional
            Determines whether the Model Browser containers' corresponding Loadcase should be deleted or not.
            Is applicable only to Loadcase Model Browser Containers related to a Loadcase entity.
            (Default:False)

    definition : bool, optional
            Determines whether the Model Browser containers' definition should be deleted or not.
            (Default:False)

    protect_main_include : bool, optional
            Determines whether the Model Browser containers' main includes should be deleted or not.
            (Default: False)

    Returns
    -------
    int
            Returns 1 when at least one of the Model Browser Containers which was sent for deletion attempted to delete its definition but instead it was turned Hidden, because it is in use - probably by a Connection as connectivity.
            Returns 0 in all other cases.

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import base


            def main():
                all_subsystems = base.CollectEntities(
                    0, containers=None, search_types="ANSA_SUBSYSTEM"
                )
                print(all_subsystems)
                ans = base.DeleteModelContainer(containers=all_subsystems, connections=True)
                print(ans)


            if __name__ == "__main__":
                main()


    """


def AddListAction(
    deck: int,
    action_name: str,
    keyword: str,
    filename: str,
    function_name: str,
    parent_name: str,
    separator: bool,
    group: int,
    icon_name: str,
    parent_icon_name: str,
) -> bool:
    """

    Creates a user defined action in an entity's list based on the entity type.
    A callback script is set to run when the action runs.

    Parameters
    ----------
    deck : int
            The deck on which the action will be created. A tuple of decks or constants.decks can also be used to create an action in more than one deck.

    action_name : str
            The action name as it will appear in the right click pop up menu.

    keyword : str
            The ANSA keyword of the entity for which the action will be created.

    filename : str
            The filename of the script file where the callback function is located.

    function_name : str
            The callback function that will run when the action is pressed. The prototype of the callback function is:
            def action(deck, entities, alist, *args)

            deck is the deck on which the action runs.
            entities is an iterable of the selected entities, or all the entities of the list if no entity is selected.
            alist is a named tuple with members alist.selected and alist.total.
            alist.selected is an integer of the number of the selected entities when the action was called.
            alist.total is an integer of the number of the total entities in the list.
            *args is reserved for future use.

    parent_name : str, optional
            The name of the parent action. Use the ':' character to create an hierarchy of actions.

    separator : bool, optional
            Add a separator in the pop up menu before the action.

    group : int, optional
            Add the action in the entity's group. Available constants are:

            constants.LIST_ACTION_NO_GROUP (default)
            constants.LIST_ACTION_IN_GROUP Add action in all entity types of a group
            constants.LIST_ACTION_IN_GROUP_ONLY Add action only in the entity's group
            constants.LIST_ACTION_IN_GROUP_ELEMENT Add action in all element types of a group
            constants.LIST_ACTION_IN_GROUP_ELEMENT_ONLY Add action only in the element's group

    icon_name : str, optional
            The icon to be displayed next to the action's name in the right click pop up menu.

    parent_icon_name : str, optional
            The icon to be displayed next to the action's parent name in the right click pop up menu. Use the ':' character to create an hierarchy of action icons.

    Returns
    -------
    bool
            Returns true if the action was created, false otherwise.

    Examples
    --------
    ::

            # main file, where the actions are created

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                actions_callback_file = "/path/to/action_callbacks.py"

                # Add action in PROPERTY list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action",
                    deck=constants.ABAQUS,
                    keyword="PROPERTY",
                    filename=actions_callback_file,
                    function_name="action",
                    separator=True,
                )

                # Add action in LAMINATE list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 1",
                    deck=constants.ABAQUS,
                    keyword="LAMINATE",
                    filename=actions_callback_file,
                    function_name="action",
                )

                # Add action in LAMINATE list in all decks
                base.AddListAction(
                    action_name="User Action 2",
                    deck=constants.decks,
                    keyword="LAMINATE",
                    filename=actions_callback_file,
                    function_name="action",
                )

                # Add action in DISLOADS TEMPFILM (subtype) in PERMAS deck and FILM in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 3",
                    deck=(constants.PERMAS, constants.ABAQUS),
                    keyword="DISLOADS TEMPFILM",
                    filename=actions_callback_file,
                    function_name="action",
                )

                # Add actions in LAMINATE list in ABAQUS deck under Parent Action
                base.AddListAction(
                    action_name="User Action 4",
                    deck=constants.ABAQUS,
                    keyword="LAMINATE",
                    filename=actions_callback_file,
                    function_name="action",
                    parent_name="Parent Action",
                )

                # Add actions in LAMINATE list in ABAQUS deck under Parent Action:Child Action
                base.AddListAction(
                    action_name="User Action 4.1",
                    deck=constants.ABAQUS,
                    keyword="LAMINATE",
                    filename=actions_callback_file,
                    function_name="action",
                    parent_name="Parent Action:Child Action",
                    icon_name="/path/action_icon.png",
                    parent_icon_name="/path/parent_icon.png:/path/child_icon.png",
                )

                base.AddListAction(
                    action_name="User Action 4.2",
                    deck=constants.ABAQUS,
                    keyword="LAMINATE",
                    filename=actions_callback_file,
                    function_name="action",
                    parent_name="Parent Action:Child Action",
                )

                # Add actions in LAMINATE list in ABAQUS deck under Parent Action
                base.AddListAction(
                    action_name="User Action 5",
                    deck=constants.ABAQUS,
                    keyword="LAMINATE",
                    filename=actions_callback_file,
                    function_name="action",
                    parent_name="Parent Action",
                )

                # Add action in SHELL_SECTION list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 6",
                    deck=constants.ABAQUS,
                    keyword="SHELL_SECTION",
                    filename=actions_callback_file,
                    function_name="action",
                )

                # Add action in all property types in PROPERTIES list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 7",
                    deck=constants.ABAQUS,
                    keyword="PROPERTY",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP,
                )

                # Add action in PROPERTIES list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 8",
                    deck=constants.ABAQUS,
                    keyword="PROPERTY",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP_ONLY,
                )

                # Add action in all initial conditions in INITIAL CONDITION list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 9",
                    deck=constants.ABAQUS,
                    keyword="INITIAL CONDITION",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP,
                )

                # Add action in INITIAL CONDITION list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 10",
                    deck=constants.ABAQUS,
                    keyword="INITIAL CONDITION",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP_ONLY,
                )

                # Add action in SHELL and QUAD list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 11",
                    deck=constants.ABAQUS,
                    keyword="SHELL",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP,
                )

                # Add action in SHELL list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 12",
                    deck=constants.ABAQUS,
                    keyword="SHELL",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP_ONLY,
                )

                # Add action in ELEMENT and QUAD list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 13",
                    deck=constants.ABAQUS,
                    keyword="ELEMENT",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP_ELEMENT,
                )

                # Add action in ELEMENT list in ABAQUS deck
                base.AddListAction(
                    action_name="User Action 14",
                    deck=constants.ABAQUS,
                    keyword="ELEMENT",
                    filename=actions_callback_file,
                    function_name="action",
                    group=constants.LIST_ACTION_IN_GROUP_ELEMENT_ONLY,
                )

                # Add action in LAMINATE list in ABAQUS deck which raises a window
                base.AddListAction(
                    action_name="User Action 15",
                    deck=constants.ABAQUS,
                    keyword="LAMINATE",
                    filename=actions_callback_file,
                    function_name="window",
                    separator=True,
                )


            if __name__ == "__main__":
                main()
            # action_callbacks.py file, where the callbacks are located
            import ansa
            from ansa import guitk


            def action(deck, entities, alist, *args):
                print("Deck:", deck)
                print("Number of selected entities:", alist.selected)
                print("Number of total entities in list:", alist.total)

                # Print the ids of the selected entities
                for ent in entities:
                    print(ent._id)


            def window(deck, entities, alist, *args):
                win = guitk.BCWindowCreate("BCWindow Example", guitk.constants.BCOnExitDestroy)
                guitk.BCWindowShowTitleBarButtons(
                    win, guitk.constants.BCMinimizeButton | guitk.constants.BCMaximizeButton
                )

                guitk.BCPushButtonCreate(win, "Flash", flashWindowFunc, win)
                dbb = guitk.BCDialogButtonBoxCreate(win)

                guitk.BCWindowSetInitSize(win, 240, 160)
                guitk.BCWindowSetSaveSettings(win, False)

                guitk.BCWindowSetAcceptFunction(win, acceptFunc, None)
                guitk.BCWindowSetRejectFunction(win, rejectFunc, None)

                guitk.BCShow(win)


            def flashWindowFunc(b, win):
                guitk.BCWindowFlash(win)
                return 0


            def acceptFunc(win, data):
                print("Accept")
                return 1


            def rejectFunc(win, data):
                print("Reject")
                return 1


    """


def OutputClarity(filename: str, mode: str) -> int:
    """

    OutputClarity outputs a the mesh as a file formatted for Clarity solver.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path to
            the file.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputClarity("C:/temp/users/folder/data.w3d", "all")


    """


def GetCurrentInputProductTreeSettings() -> object:
    """

    Returns an object of type "base.InputProductTreeSettings" initialized from the ANSA defaults.

    Returns
    -------
    object
            Returns an object of type "base.InputProductTreeSettings".

    See Also
    --------
    base.InputProductTreeSettings, base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                my_settings = base.GetCurrentInputProductTreeSettings()
                my_settings.should_open_window = True
                filename = "//home/file.xml"
                base.InputModelDefinition(
                    file_name=filename, file_type="PLMXML", settings=my_settings
                )


    """


def VolumeFractionAssistant(
    solids: object,
    shells: object,
    fill_internal: bool,
    accuracy: str,
    create_inivol_fraction: bool,
    material: object,
) -> object:
    """

    Calculates the volume fraction values for the input solids intersected by the input shells.

    Parameters
    ----------
    solids : object
            A list of solids for which the volume fraction will be computed.

    shells : object
            A list of shells (or solids) that intersect the solids.

    fill_internal : bool, optional
            Option for the location of the volume fraction (default = True).

    accuracy : str, optional
            The accuracy of the calculation: 'low', 'medium', 'high' or 'highest' (default = 'medium').

    create_inivol_fraction : bool, optional
            Option to create initial conditions, type = volume fraction (default = True).

    material : object, optional
            The material to be used by volume fraction entities (required if create_inivol_fraction = True).

    Returns
    -------
    object
            If create_inivol_fraction = True, the function will return a list of the created volume fraction entities.
            If create_inivol_fraction = False, the return value will be a dictionary with the solids as keys and the calculated volume fraction values as data.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                pid = base.GetEntity(0, "SHELL_SECTION", 1)
                shells = base.CollectEntities(0, pid, "SHELL", True)

                pid = base.GetEntity(0, "EULERIAN_SECTION", 6)
                solids = base.CollectEntities(0, pid, "SOLID")

                mat = base.GetEntity(0, "MATERIAL", 7)

                ret = base.VolumeFractionAssistant(
                    solids=solids,
                    shells=shells,
                    fill_internal=True,
                    accuracy="low",
                    create_inivol_fraction=True,
                    material=mat,
                )
                for i in ret:
                    print(i)
                ret = base.VolumeFractionAssistant(
                    solids=solids, shells=shells, fill_internal=True, create_inivol_fraction=False
                )
                for i in ret:
                    if ret[i] != 0.0:
                        print(
                            i._id, ret[i]
                        )  # will print the solid id and the volume fraction value of it


            if __name__ == "__main__":
                main()


    """


def SetPerspectiveCamera(aspect_ratio: float, fov: float, near: float, far: float):
    """

    Creates a new perspective ANSA camera

    Parameters
    ----------
    aspect_ratio : float
            The ratio width/height of the screen

    fov : float
            The field of view in degrees

    near : float
            The near plane

    far : float
            The far plane

    See Also
    --------
    SetParallelCamera

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Clear()
                base.Open("test_file.ansa")
                base.SetPerspectiveCamera(4.0 / 3.0, 45.0, 0.1, 100)


    """


def CameraLookAt(eye: object, focus: object, up: object):
    """

    Creates a new view of the current camera

    Parameters
    ----------
    eye : object
            a 3d vector for location of the camera

    focus : object
            a 3d vector for the focus point

    up : object
            the up 3d vector

    See Also
    --------
    SetParallelCamera

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Clear()
                base.Open("model.ansa")
                base.CameraLookAt((0.0, 0.0, 0.0), (168.0, -804.0, 307.0), (0.0, 0.1, 0.0))


    """


def SetParallelCamera(zoom_factor: float, z_size: float):
    """

    Creates a new parallel ANSA camera

    Parameters
    ----------
    zoom_factor : float
            The zoom of camera

    z_size : float
            The depth of camera frustum

    See Also
    --------
    SetPerspectiveCamera

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Clear()
                base.Open("model.ansa")

                base.SetParallelCamera(100.0, 500.0)
                base.CameraLookAt((0.0, 0.0, 0.0), (168.0, -804.0, 307.0), (0.0, 0.1, 0.0))


    """


def GetModelContainerAdapter(container: object, content: object) -> object:
    """

    Returns the Adapter entity that adapts Content to Container, if exists.

    Parameters
    ----------
    container : object
            A reference to the Model Browser Container entity.

    content : object
            A reference to the content entity that is adapted in the container entity

    Returns
    -------
    object
            Returns the Adapter ANSA entity, in case the Content ANSA entity is adapted in
            the Container ANSA entity, or None otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                all_sim_runs = base.CollectEntities(
                    constants.NASTRAN, containers=None, search_types="ANSA_SIMULATION_RUN"
                )
                all_loadcases = base.CollectEntities(
                    constants.NASTRAN, containers=None, search_types="ANSA_LOADCASE"
                )
                for sim_run in all_sim_runs:
                    for loadcase in all_loadcases:
                        adapter = base.GetModelContainerAdapter(container=sim_run, content=loadcase)
                        if adapter != None:
                            print("Loadcase '", loadcase._name, "' uses adapter ", adapter)
                            print("            to get adapted in the '", sim_run._name, "' Sim.Run")
                        else:
                            print("Loadcase '", loadcase._name, "' is not found ")
                            print(
                                "            as a child of '",
                                sim_run._name,
                                "' Sim.Run in this database",
                            )


    """


def CameraZoom(x: int, y: int, factor: float):
    """

    Zooming in/out of a given point

    Parameters
    ----------
    x : int
            the x pixel

    y : int
            the y pixel

    factor : float
            for parallel camera: a value in (0, 1) causes zoom in,
                                 a value in (-1, 0) causes zoom out,
                                 0 has no effect
            for perspective camera : positive for zoom in,
                                     negative for zoom out
                                     (the value has no effect)

    See Also
    --------
    SetPerspectiveCamera, SetParallelCamera, CameraLookAt

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Clear()

                base.SetEntityVisibilityValues(constants.NASTRAN, {"SHELL": "off"})
                base.Open("model.ansa")

                base.SetViewAngles("F10")
                base.CameraZoom(400, 100, 0.6)


    """


def RunReducedRepresentation(
    reduced_model: object, solver: str, custom_solver_command: str
) -> bool:
    """

    This function runs a specified solver executable in order to solve the generated file of the reduced representation.

    Parameters
    ----------
    reduced_model : object
            The reduced_model whose generated file will be solved.

    solver : str, optional
            Specified solver to run the reduced representation.
            Accepted values:
            - "epilysis_out_of_ansa"
            - "nastran"
            - "meta_as_solver"
            - "custom"
            Default "epilysis_out_of_ansa"

    custom_solver_command : str, optional
            Specifies the custom solver executable.
            Must be defined if solver is "custom".

    Returns
    -------
    bool
            Returns True on success, or False on failure.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base, constants


            def main():
                p_se = base.GetEntity(constants.NASTRAN, "REDUCED_MODEL", 1)
                ret = base.RunReducedRepresentation(p_se, "epilysis_out_of_ansa")


    """


def ConvertAbaqusStepmanagerToLoadcase(
    stepmanager: object, include_model_data: bool = True
) -> None:
    """

    This function converts a Step Manager to a Loadcase Setup Assistant.

    Parameters
    ----------
    stepmanager : object
            A Step Manager entity

    include_model_data : bool, optional
            True to include all model data. False otherwise.

    Returns
    -------
    None

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                stepman = base.GetEntity(deck, "STEP MANAGER", 1)
                base.ConvertAbaqusStepmanagerToLoadcase(stepman)


    """


def ViewsSaveViews(path: str):
    """

    Exports ANSA views to file.

    Parameters
    ----------
    path : str
            The file path of the exported views

    See Also
    --------
    ViewsLoadViews

    """


def ViewsLoadViews(path: str):
    """

    Imports ANSA views from file.

    Parameters
    ----------
    path : str
            The views file.

    """


def ViewsApplyView(name: str):
    """

    Apply an already create view with the same name as the parameter

    Parameters
    ----------
    name : str
            The name of the view

    """


def CreateCouplingFile(
    fs_coupling: object,
    coupling_file: str,
    algorithm: str,
    outward_dist: float,
    proj_dist: float,
    executable: str,
    inward_dist: float,
    srchunit: str,
    in_ansa: bool,
) -> bool:
    """

    This function creates a coupling file (.pch) for an FS COUPLING entity.

    Parameters
    ----------
    fs_coupling : object
            An FS COUPLING entity.

    coupling_file : str
            The path where the coupling file will be created.

    algorithm : str, optional
            Specified algorithm to create the coupling file. Accepted values:
            - "default"
            - "press_equilibrium"
            - "custom"
            Default: "default"

    outward_dist : float, optional
            Determines the height of the search box in the outward normal direction of
            the fluid surface as a percentage to the minimum fluid element's edge length,
            if srchunit argument is "rel", or as an absolute value, if srchunit is "abs".
            Default: 100%

    proj_dist : float, optional
            In case algorithm is "press_equilibrium", determines the approximate projection
            distance of a structural node to the fluid elements as a percentage between
            minimum, average and maximum potential distance values calculated with the
            search boxes algorithm in first step.
            Default: 50%

    executable : str, optional
            In case algorithm is "custom", determines the custom executable to be used for
            coupling file creation.

    inward_dist : float, optional
            Determines the height of the search box in the inward normal direction of
            the fluid surface as a percentage to the minimum fluid element's edge length,
            if srchunit argument is "rel", or as an absolute value, if srchunit is "abs".
            Default: 50%

    srchunit : str, optional
            Determines search units of the outward and inward search distance factors.
            Accepted values:
            - "abs" for absolute model units
            - "rel" for relative model units based on element's size
            Default: "rel"

    in_ansa : bool, optional
            Determines whether execution is performed in ANSA (main window freezes until
            calculation is finished) or out of ANSA (calculation is executed independently
            in the background).
            Default: True

    Returns
    -------
    bool
            Returns True on success, or False on failure.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base, constants


            def main():
                fs_coupling = base.GetEntity(constants.NASTRAN, "FS COUPLING", 1)
                coupling_file = "~/tmp/coupling.pch"

                ret = base.CreateCouplingFile(fs_coupling, coupling_file, "default")


    """


def MeanFieldHomogenizationCondCal(
    filename: str,
    kxx_target: float,
    kyy_target: float,
    kzz_target: float,
    enable_aspect_ratio: bool,
    enable_max_weight: bool,
    enable_max_cost: bool,
    enable_max_spec_heat: bool,
) -> object:
    """

    Performs microstructure calibration with respect to the inclusions volume fraction and/or aspect ratio to achieve target thermal conductivity properties

    Parameters
    ----------
    filename : str
            The filename of the xml with the microstructure data

    kxx_target : float
            The target thermal conductivity at x-direction

    kyy_target : float
            The target thermal conductivity at y-direction

    kzz_target : float
            The target thermal conductivity at z-direction

    enable_aspect_ratio : bool, optional
            Use aspect ratio as design variables

    enable_max_weight : bool, optional
            Use maximum weight as constraint of the optimization

    enable_max_cost : bool, optional
            Use maximum cost as constraint of the optimization

    enable_max_spec_heat : bool, optional
            Use maximum specific heat as constraint of the optimization

    Returns
    -------
    object
            Returns an object with the optimization results(List with volume fractions,
            list with aspect ratios, optimization status, error between achieved and target properties)
            -ret.OptVf
            -ret.OptAR
            -ret.OptStatus
            -ret.OptError

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ret = base.MeanFieldHomogenizationCondCal("filename.xml", 850, 700, 700)
                print(ret.OptVf)
                print(ret.OptAR)
                print(ret.OptError)
                print(ret.OptStatus)


            if __name__ == "__main__":
                main()


    """


def ConvertRBE3RefGridToIndependent(
    entities: object, ignore_dp_check: bool, handle_existing_um: str
) -> object:
    """

    Converts reference grids of an RBE3 entity or a list of RBE3 entities to independent by selecting
    specific grids and their components and setting the UM fields of these entities accordingly.

    Parameters
    ----------
    entities : object
            An object or a list of objects of RBE3 entities whose
            reference grids are to be converted to independent.

    ignore_dp_check : bool, optional
            Defines whether the selection process of the RBE3 UM values
            includes all components of grids or only the independent ones.
            Default: False

    handle_existing_um : str, optional
            Defines handling of RBE3s that already have UM values. Supported
            options:
            -"ignore": RBE3s with existing UM are ignored, listed directly in
            "not converted" container.
            -"check_fix": RBE3s with existing UM are checked and those with
            correct UM values are listed in "converted" container with no
            modifications performed. RBE3s with poor UM selection will be fixed,
            new UM values will be calculated and their old values are going to be
            overwritten.
            -"overwrite": RBE3s with existing UM are included in process, new
            UM values will be calculated and their old values are going to be
            overwritten.
            Default: "ignore"

    Returns
    -------
    object
            Returns a dictionary containing the keys 'converted' and 'not converted'. Each of these keys has as
            value a list with objects of RBE3 entities which converted successfully or not respectively.

    Examples
    --------
    ::

            import ansa
            from ansa import base, constants


            def main():
                ents = base.CollectEntities(constants.NASTRAN, None, "RBE3")

                rbe3s = base.ConvertRBE3RefGridToIndependent(entities=ents)

                print(rbe3s["converted"])
                print(rbe3s["not converted"])


    """


def Extrude2DTo3D(num_layers: int, element_length: float, delete_bcs: bool) -> int:
    """

    The Extrude2DTo3D function will extrude rows of volume elements from a planar shell mesh and automatically create shell PIDs that correspond to the 2D boundary conditions.

    Parameters
    ----------
    num_layers : int
            Number of layers to be generated.

    element_length : float
            The height of the elements in every layer.

    delete_bcs : bool, optional
            Flag that indicates if the initial 2D boundary conditions
            will be deleted. (Default: True)

    Returns
    -------
    int
            Returns 0 on success, non zero on error, where:

            0: Sucess
            1: Failure: The mesh can not be extruded if solid elements exist!
            2: Failure: No shell elements found!
            3: Failure: Mesh nodes are not co-planar!
            4: Failure: The mesh can not be extruded if polygons exist!
            5: Failure: The mesh can not be extruded if incomplete elements exist!

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.Extrude2DTo3D(num_layers=1, element_length=10.0)


            if __name__ == "__main__":
                main()


    """


def RemoveMaterialDatabase(deck: object, path: str) -> int:
    """

    Remove paths from ANSA.defaults Material Database

    Parameters
    ----------
    deck : object
            The  deck to remove paths from. Use 'all' if the removal should implemented in all decks.

    path : str
            The path that will be removed from the deck (or all decks if 'all' is used in deck). 'all' to remove all paths in selected deck (or all decks)

    Returns
    -------
    int
            Always return 0.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                base.RemoveMaterialDatabase(ansa.constants.NASTRAN, "all")


            if __name__ == "__main__":
                main()


    """


def InputSU2(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    The InputSU2 function imports an SU2 model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA will use the light volume representation,
            which is more suitable for CFD meshes.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputSU2("C:/temp/users/folder/data.su2", elements_id="offset")


    """


def OutputSU2(filename: str, mode: str, unit_system: object, scale: float) -> int:
    """

    The OutputSU2 function outputs an SU2 format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: "all")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the output
            will be scaled from the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: "1.0")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputSU2("C:/temp/users/folder/data.su2", mode="all")


    """


def DeleteViolatingVolumeElements(zones_number: int) -> object:
    """

    Calculates the off volume elements of the database according to the active quality criteria and deletes them.
    In addition, it automatically creates shell mesh to cover the remaining free facets.

    Parameters
    ----------
    zones_number : int, optional
            Number of neighboring zones around violating elements.
            (Default: zones_number=0)

    Returns
    -------
    object
            Returns a list containing the created shell properties.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                props = base.DeleteViolatingVolumeElements()

                for prop in props:
                    print(prop)


    """


def FreezeElements(deck: int, entity: str, selection: object) -> bool:
    """

    Freezes elements

    Parameters
    ----------
    deck : int
            The deck constant.

    entity : str
            A string that describes the type of the entity.
            "0" if a list of entities of different types has been selected.

    selection : object
            -"all" if user selects to freeze all elements of defined entity type
            -"visible" if user selects to freeze only visible elements of defined entity type
            - a list of all the elements to be frozen

    Returns
    -------
    bool
            Always returns True.

    See Also
    --------
    UnFreezeElements

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                base.FreezeElements(constants.NASTRAN, "0", ents)


    """


def UnFreezeElements(deck: int, entity: str, selection: object) -> bool:
    """

    Unfreezes elements

    Parameters
    ----------
    deck : int
            The deck constant.

    entity : str
            A string that describes the type of the entity.
            "0" if a list of entities of different types has been selected.

    selection : object
            -"all" if user selects to unfreeze all elements of defined entity type
            -"visible" if user selects to unfreeze only visible elements of defined entity type
            - a list of all the elements to be unfrozen

    Returns
    -------
    bool
            Always returns True.

    See Also
    --------
    FreezeElements

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.UnFreezeElements(constants.NASTRAN, "SHELL", "visible")


    """


def ConvertIncludeToModule(include: object) -> bool:
    """

    Converts an Include entity to a MODULE.

    Parameters
    ----------
    include : object
            The include entity to be converted.

    Returns
    -------
    bool
            If the function returns True, the given INCLUDE was either already a MODULE or was
            converted successfully to one. If the function returns False, an error was
            encountered.

    Examples
    --------
    ::

            import ansa
            from ansa.base import *


            def main():
                incl = GetEntity(ansa.constants.PAMCRASH, "INCLUDE", 1)
                ret = ConvertIncludeToModule(incl)
                print(ret)  # ret should be equal to True if incl was converted to a module


    """


def CurvesCreateFillet(curve1: object, curve2: object, input_value: object) -> object:
    """

    This script function creates a tangential circle arc curve, between two
    input curve segments or CONS, by defining willing radius.

    Parameters
    ----------
    curve1 : object
            A curve, the first Curve or CONS that the arc trace will pass through.

    curve2 : object
            A curve, the second Curve or CONS that the arc trace will pass through.

    input_value : object
            Either a dictionary or a float.
            If passed dictionary, key defines a list of doubles of size 3, corresponding to the start of the second curve segment, value a float corresponding to the willing fillet parameter in [0., 1.] domain of the second curve segment.
            If passed float, the radius of the created arc trace among input curve segments.

    Returns
    -------
    object
            Returns a list containing the resulted circle arc curve and the input curve segments in case of success, otherwise None.

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import *

            nas = constants.NASTRAN


            def main():
                curves = base.CollectEntities(nas, None, "CURVE")
                ret = base.CurvesCreateFillet(curves[0], curves[1], 50)
                print(ret)


            if __name__ == "__main__":
                main()


    """


def CompressUserDefinedAttributes() -> int:
    """

    This function performs the compression of user attributes according to the compression rules that are currently defined as ANSA.defaults parameters.

    Returns
    -------
    int
            Returns the number of deleted attributes.

    See Also
    --------
    CreateUserDefinedAttribute, GetUserDefinedAttribute, GetUserDefinedAttributes

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                file = "$HOME/my_rules.txt"
                base.SetANSAdefaultsValues({"compress_attribute_rules_file": file})
                total_deleted = base.CompressUserDefinedAttributes()
                print("total_deleted: " + str(total_deleted))


            main()


    """


def GroupAdjacentCurveChains(
    curves: object,
    angle: float,
    clear: bool,
    produce_middle_curves: bool,
    connect_middle_curves: object,
    produce_cross_curves: bool,
) -> object:
    """

    This script function identifies closed group curve chains, taking into consideration angle threshold. The resulted curve chain pairs may be used to define 3D-curves along its middle distance.

    Parameters
    ----------
    curves : object, optional
            This is a list with 3d-Curves, Connection lines, Cross Section Curves.
            Also accepts a string with value 'visible' or a string with value 'all' .
            If it is called with 'visible', it works with all the visible entities concerning the
            above types . If it is called with 'all', it works with all the entities.
            If nothing is passed it works with the visible.

    angle : float, optional
            The angle threshold defining consecutive 3d-curve segments. Above this value
            algorithm defines a chain so that may be used fo middle curve creation.
            If nothing passed, default value is 45. degrees.

    clear : bool, optional
            If True can be used to delete identical curves in order to be left with unique ones.
            Default value is True If nothing passed .

    produce_middle_curves : bool, optional
            If True creates curve chain along identified middle pair chains.
            If nothing is passed default value is True.

    connect_middle_curves : object, optional
            A list with two float variables defining nodes matching distance in the first place
            and angle in the second respectively. If list is given, then script function will
            merge the created curves, according to the input values, else curves per
            segment will be created.

    produce_cross_curves : bool, optional
            If True automatically identifies curves may belong to Cross Section and creates cross section entities with the respective cross curve chain pairs.
            If nothing passed default value is False.

    Returns
    -------
    object
            If produce_middle_curves named argument equals to True, returns a list of tuples, containing average thick value distance in the first place and a list with the created middle curves, else if produce_middle_curves equals to False returns a list of tuples, containing average thick value distance in the first place and a list with two lists containing the pair curve chains.
            If produce_cross_curves named argument equals to True, returns a dictionary, which len equals to the number of identified Cross Sections. Key equals to the created Cross Section, while value contains a list with tuples, where each tuple contains average thick value distance in the first place and a list containing identified curve chain pair, with lists, which len varying from 1 to 3, containing identified chains. First list equals to first chain, second list to second chain and if produce_middle_curves is True third list equals with the created middle curves.
            Returns None if nothing can be identified.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                ret = base.GroupAdjacentCurveChains(
                    curves="visible", angle=45.0, produce_middle_curves=True
                )
                print(len(ret))

                for item in ret:
                    s = base.CreateEntity(0, "SET")
                    for i in item[1]:
                        base.AddToSet(s, i)

                    ret = ansa.base.GroupAdjacentCurveChains(angle = 45., clear = True, produce_middle_curves = True, produce_cross_curves = True)
            \tfor key, value in ret.items():
            \t\tprint('Cross len = ', len(value))
            \t\tfor thic in value:
            \t\t\tprint('Cross Data = ', repr(thic))
            \t\t\tfor j in thic:
            \t\t\t\tprint('Chain = ', repr(j))



            if __name__ == "__main__":
                main()


    """


def CreateUserDefinedAction(
    entity_type: str,
    name: str,
    script: str,
    function: str,
    restriction_function: str,
    icon: str,
    overloads: str,
    comment: str,
) -> bool:
    """

    This function creates a user action in Model Browser for a specific Model Browser Container.

    Parameters
    ----------
    entity_type : str
            The ANSA keyword of the entities the user action affects.
            Currently only Model Browser container entities are supported.

    name : str
            The user action name.

    script : str
            The path to the python script the user action will execute.

    function : str
            The function name in the python script the user action will execute.

    restriction_function : str, optional
            The script function that will run to determine if the action should be available for an ANSA entity.

    icon : str, optional
            The icon to use for the user action.

    overloads : str, optional
            The hard coded action that this user action overloads, e.g. 'Save in DM', 'Reload', 'Output', 'Load', 'Unload'.

    comment : str, optional
            The comment of the user action.

    Returns
    -------
    bool
            Returns 'True' on success, 'False' on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base, utils


            def main():
                ua_name = "My Action"
                ua_script_path = "C:/my_user_action_script.py"
                ua_function = "my_function_name"
                ua_icon = "C:/action_icon.png"
                # ua_restriction = "my_restriction_function_name"
                # ua_overload = "Save in DM"
                # ua_comment = "This is my comment..."

                # Create the user action
                ret = base.CreateUserDefinedAction(
                    entity_type="ANSAPART",
                    name=ua_name,
                    script=ua_script_path,
                    function=ua_function,
                    icon=ua_icon,
                )
                print(ret)

                # Open the parts tab in order to see the new user action in gui (context menu & toolbar)
                utils.OpenModelBrowser(entity_type="Parts")


    """


def CrossSectionInfo(cross_section: object, filename: str, text_format: str) -> int:
    """

    This function saves a cross-sections info report in a file.

    Parameters
    ----------
    cross_section : object
            Accepted values: A cross section, or a list of cross section entities, "all", "visible", 0.
            If set to 0 or "all", runs for all cross sections of the database.
            If set to "visible," runs for visible cross sections.

    filename : str
            The path and the filename to be saved.

    text_format : str
            Accepted values: 'HTML', 'TEXT', 'CSV' or 'PDF'.

    Returns
    -------
    int
            Returns 0 on success, or 1 on failure.

    Examples
    --------
    ::

            import ansa


            def main():
                cross_section1 = ansa.base.GetEntity(1, "CROSS_SECTION", 1)
                ansa.base.CrossSectionInfo(
                    [cross_section1], "/home/users/cross_section_report.html", "html"
                )


            if __name__ == "__main__":
                main()


    """


def LaminateConvertToSandwich(
    deck: int,
    property: object,
    core_layers: object,
    core_rows_num: int,
    paste_shells: bool,
    merge_method: str,
    merge_t_tol: float,
    merge_theta_tol: float,
    ret_node_pairs: bool,
    ret_node_bricks: bool,
    ret_facet_pairs: bool,
    force_split_woven_layers: object,
) -> object:
    """

    This function changes laminate properties to sandwich structures.
    The result is a shell laminate at the bottom, a solid laminate in the middle (solid core)
    and a shell laminate at the top.

    Parameters
    ----------
    deck : int
            NASTRAN, LSDYNA, PAMCRASH, ABAQUS, RADIOSS, ANSYS, PERMAS or OPTISTRUCT

    property : object
            A laminate property or a list of laminate properties.

    core_layers : object
            A layer or a list of layers which will be the solid core of the sandwich structure.
            A layer is a tuple (property, sequence_pos, layer_pos).

    core_rows_num : int, optional
            An integer which is the number of rows per core layer that will be created,
            or a dictionary with key a tuple (property, sequence_pos, layer_pos),
            and value an integer which is the number of rows per core layer that will be created.
            (Default: 1)

    paste_shells : bool, optional
            A boolean value which if set to True all the shells will be pasted on the solid core.

    merge_method : str, optional
            Method by which the layers of different properties will be merged.
            One of "by_tolerances", "by_gplyid", "by_layer_name".
            Required only for multiple properties.

    merge_t_tol : float, optional
            Thickness tolerance by which the layers of different properties
            will be merged. Required for merge_method = "by_tolerances".

    merge_theta_tol : float, optional
            Theta tolerance by which the layers of different properties
            will be merged. Required for merge_method = "by_tolerances".

    ret_node_pairs : bool, optional
            If set to True, interface.node_pairs is a list of tuples with 2 nodes.
            If set to False, interface.node_pairs is None.
            (Default: False)

    ret_node_bricks : bool, optional
            If set to True, interface.node_bricks is a list of tuples with 6 or 8 nodes.
            If set to False, interface.node_bricks is None.
            (Default: False)

    ret_facet_pairs : bool, optional
            If set to True, interface.facet_pairs is a list of tuples with 2 facets or shells.
            If set to False, interface.facet_pairs is None.
            (Default: False)

    force_split_woven_layers : object, optional
            A dictionary with key a tuple (property, sequence_pos, layer_pos),
            and value a boolean which if set to True the woven layer would be split.

    Returns
    -------
    object
            Returns None on failure.

            An object on success with the following members:
            layers_data: A list of layer_data objects with data about the initial and final layer.
            bottom_interface: An object with data about the interface between the bottom shell laminate and the solid laminate.
            top_interface: An object with data about the interface between the top shell laminate and the solid laminate.

            The object layer_data has the following members:
            laminate: the final laminate property
            sequence_pos: the final sequence index
            layer_pos: the final layer index
            init_laminate: the initial laminate property
            init_sequence_pos: the initial sequence index
            init_layer_pos: the initial layer index

            The objects bottom_interface and top_interface have the following members:
            node_pairs: A list of tuples with 2 nodes (bottom and top). These may be used to create beams.
            node_bricks: A list of tuples with 6 or 8 nodes (penta or hexa). These may be used to create cohesives.
            facet_pairs: A list of tuples with 2 facets or shells (bottom and top). These may be used to create contacts.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                prop = base.GetEntity(deck, "LAMINATE", 1)

                ret = base.LaminateConvertToSandwich(
                    deck=deck,
                    property=prop,
                    core_layers=(prop, 1, 4),
                    core_rows_num=2,
                    paste_shells=False,
                )


    """


def GetConfigurationsFromParts(parts: object) -> object:
    """

    Get all configurations that a part("ANSAPART") belongs to.

    Parameters
    ----------
    parts : object
            A list of "ANSAPART"

    Returns
    -------
    object
            Returns a dictionary with part to a list of Configurations that part belongs to.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromName("XXXX", type="ANSAPART")
                dict = base.GetConfigurationsFromParts(part)


    """


def CreateModule(deck: int, solver_id: int, is_global: bool) -> object:
    """

    Creates a new MODULE entity.

    Parameters
    ----------
    deck : int
            A deck constant. Accepted values are ansa.constants.NASTRAN and ansa.constants.PAMCRASH.

    solver_id : int, optional
            The MODULE's solver id.

    is_global : bool, optional
            Defines whether the created MODULE will be a GLOBAL MODULE. Valid only if deck is ansa.constants.PAMCRASH.

    Returns
    -------
    object
            The created MODULE.

    See Also
    --------
    ansa.base.ConvertIncludeToModule

    Examples
    --------
    ::

            mod = ansa.base.CreateModule(ansa.constants.NASTRAN)
            mod_20 = ansa.base.CreateModule(ansa.constants.NASTRAN, solver_id=20)


    """


def AddToModule(module: object, entities: object) -> int:
    """

    Adds a collection of entities to a MODULE.

    Parameters
    ----------
    module : object
            The MODULE where the collection of entities will be added.

    entities : object
            The collection of entities to add to the MODULE.

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise.

    See Also
    --------
    ansa.base.CreateModule, ansa.base.ConvertIncludeToModule

    Examples
    --------
    ::

            elem = GetEntity(ansa.constants.PAMCRASH, "SHELL", 5)
            g1 = GetEntity(ansa.constants.PAMCRASH, "NODE", 1)
            g2 = GetEntity(ansa.constants.PAMCRASH, "NODE", 2)

            mod = CreateModule(ansa.constants.PAMCRASH)
            AddToModule(mod, elem)  # add a single entity
            AddToModule(mod, [g1, g2])  # add a collection of entities


    """


def BoundaryPrescribedFinalGeometryFill(deck: int, boundary: object, nodes: object):
    """

    Fills a BOUNDARY_PRESCRIBED_FINAL_GEOMETRY entity with nodes of the final geometry.

    Parameters
    ----------
    deck : int
            LSDYNA

    boundary : object
            The BOUNDARY_PRESCRIBED_FINAL_GEOMETRY entity that will be filled with nodes.

    nodes : object
            A list with the nodes.

    Examples
    --------
    ::

            import ansa
            from ansa import *


            def main():
                nodes = base.CollectEntities(constants.LSDYNA, None, "NODE")
                bpfg_nodes = []
                for n in nodes:
                    fields = {
                        "NID": n._id,
                        "X": n.position[0] * 2.0,
                        "Y": n.position[1] * 2.0,
                        "Z": n.position[2] * 2.0,
                    }
                    bpfg_nodes.append(
                        base.CreateEntity(2, "BOUNDARY_PRESCRIBED_FINAL_GEOMETRY_NODE", fields)
                    )
                boundary = base.CreateEntity(constants.LSDYNA, "BOUNDARY_PRESCRIBED_FINAL_GEOMETRY")

                for n in bpfg_nodes:
                    base.BoundaryPrescribedFinalGeometryFill(constants.LSDYNA, boundary, n)


            if __name__ == "__main__":
                main()


    """


def SetPartVersion(parts: object, version: str, apply_to_all_instances: bool) -> bool:
    """

    This function sets the version value to an ANSAPART or a list of ANSAPARTs.
    For the case of multi-instanciated parts, if the option 'apply_to_all_instances'
    is False, the new version will be applied only to the input parts and not to
    their instances. This way, multi-version instances can be created.

    Parameters
    ----------
    parts : object
            A single part or a list of parts.

    version : str
            The version value.

    apply_to_all_instances : bool, optional
            For the case of multi-instanciated parts, this flag determines whether the
            new version value will be applied to all part instances with the same version or not.
            Default value: True

    Returns
    -------
    bool
            Returns always True.

    See Also
    --------
    base.GetPartInstances

    """


def OpenEntityCard(deck: int, entity: object):
    """

    Opens the GUI card of the given entity

    Parameters
    ----------
    deck : int
            The entity's deck

    entity : object
            The entity for which to open the card

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constant


            def main():
                ent = base.GetEntity(constants.LSDYNA, "NODE", 1)
                base.OpenEntityCard(constants.LSDYNA, ent)


    """


def SaveTranslatorsSettings(filepath: str) -> bool:
    """

    Writes a defaults file of the translators settings at filepath. If filepath is not
    given, the defaults file will be written in .BETA directory according to which
    layout ANSA was launched (e.g. translators.defaults, CFD_translators.defaults).
    If the file already exists, it will be overwritten.
    This function is not supported under VR mode.

    Parameters
    ----------
    filepath : str, optional
            The full path of the defaults file to be saved.

    Returns
    -------
    bool
            1 if save was succesfull, 0 otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                if not base.SaveTranslatorsSettings():
                    print("Failed to save translators defaults.")
                base.SetANSAdefaultsValues({"TRANSL_LOG": "false"})
                if not base.SaveTranslatorsSettings("$HOME/translators_edited.defaults"):
                    print("Failed to save $HOME/translators_edited.defaults.")


            if __name__ == "__main__":
                main()


    """


def ModifyInitialEntitiesDefinition(deck: int, entity: object, fields: object) -> int:
    """

    The ModifyInitialEntitiesDefinition function modifies definition fields of Initial Stress and Initial Strain entities.
    Such fields are the following:
    deck: LS_DYNA:
            entity type: INITIAL_STRESS_SHELL:
                    fields: "NTHICK", "NHISV", "NTENSR"
            entity type: INITIAL_STRESS_TSHELL:
                    fields: "NTHICK", "NHISV"
            entity type: INITIAL_STRESS_BEAM:
                    fields: "NPTS", "NHISV"
            entity type: INITIAL_STRESS_SOLID:
                    fields: "NHISV"
            entity type: INITIAL_STRAIN_SHELL:
                    fields: "NTHICK"
    deck: RADIOSS:
            entity type: INITIAL_EPSP_F_SHELL:
                    fields: "NTHICK"
            entity type: INITIAL_STRAIN_SHELL:
                    fields: "NTHICK"
            entity type: INITIAL_STRESS_SHELL:
                    fields: "NTHICK", "NVARS"





    Parameters
    ----------
    deck : int
            The deck

    entity : object
            The "Initial Stress" or "Initial Strain" entity of which the fields will be modified

    fields : object
            Can be a list, tuple or dictionary.
            In case of dictionary, it must contain pairs of 'field name' - 'value'.
            In case of list or tuple, it must contain consecutive entry pairs of 'field name' - 'value'.

            As 'field name', there can be any of the fields specified above, depending on the type of the "Initial" entity and the deck.

    Returns
    -------
    int
            Returns the number of the given fields that were not modified.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # have an INITIAL_STRESS_SHELL entity with ID = 1 that was created with NHISV = 5

                inistr = base.GetEntity(constants.LSDYNA, "INITIAL_STRESS_SHELL", 1)
                values = base.GetEntityCardValues(constants.LSDYNA, inistr, ["NHISV"])
                print(values["NHISV"])
                # prints 5

                base.ModifyInitialEntitiesDefinition(constants.LSDYNA, inistr, {"NHISV": 10})

                values = base.GetEntityCardValues(constants.LSDYNA, inistr, ["NHISV"])
                print(values["NHISV"])
                # prints 10


    """


def Extreme() -> int:
    """

    Leaves visible only the elements that violate the quality criteria that are set in the Quality Criteria - Presentation Parameters window.

    Returns
    -------
    int
            The function always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import mesh


            def main():
                status = mesh.ReadQualityCriteria("/home/user/my_criteria.ansa_qual")
                base.Extreme()


    """


def ConvertEpilysisH5ToVMAP(h5_filename: str, filename: str):
    """

    Converts epilysis hdf5 results to VMAP file with specified filename

    Parameters
    ----------
    h5_filename : str
            The filename with Epilysis results in h5 format

    filename : str
            The filename of the VMAP file to be created

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                base.ConvertEpilysisH5ToVMAP("filename_epilysis.h5", "filename_VMAP.h5")


            if __name__ == "__main__":
                main()


    """


def SaveMaterialDatabase(deck: int, path: str, output_format: str) -> int:
    """

    Save Material Database to a file for the specified deck.

    Parameters
    ----------
    deck : int
            The deck for which you want to save the material database.

    path : str
            The name of the output file.

    output_format : str, optional
            The output format for the deck specified. Accepts the exact values of the graphic equivalent output format during save of the material database if it exists.

    Returns
    -------
    int
            Always returns 0.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                mat = base.CreateEntity(constants.LSDYNA, "MAT1 MAT_ELASTIC")
                base.CopyMatToMdb(mat)
                base.SaveMaterialDatabase(
                    constants.LSDYNA, "/home/material_data/dyna_mat_db.key", "971R10"
                )


    """


def RemoveFromBCSet(bcset: Entity, entities: Entity | list) -> int:
    """

    Removes an entity or a list containing entities, from a BCSet

    Parameters
    ----------
    bcset : Entity
            A reference to a bcset

    entities : Entity | list
            A reference or a list of references of ansa entities

    Returns
    -------
    int
            Returns 0 if invalid arguments were specified, 1 otherwise

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                loadsets = []

                loadsets.append(base.GetEntity(constants.NASTRAN, "LOAD_SET", 100))
                loadsets.append(base.GetEntity(constants.NASTRAN, "LOAD_SET", 200))

                load = base.GetEntity(constants.NASTRAN, "LOAD", 400)

                base.RemoveFromBCSet(load, loadsets)


    """


def MaterialCalibrationSet(fields: object, deck: int) -> int:
    """

    Sets the values for the material calibration, as a dictionary with key the labels as shown in
    Material calibration window.

    Parameters
    ----------
    fields : object
            A dictionary with keys the labels of the fields as shown in material calibration window

    deck : int
            The deck where the calibration will be performed

    Returns
    -------
    int
            Always returns zero

    See Also
    --------
    MaterialCalibration, MaterialCalibrationMakeMaterial

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import *


            def main():
                error = 1
                MooneyRivlin = 6
                cntr = 0
                fields = {
                    "Curve": 19,
                    "Material type": MooneyRivlin,
                    "C01": 0.01,
                    "C01_check": 1,
                    "C01_Min": 0.0000001,
                    "C01_Max": 1000,
                }
                base.MaterialCalibrationSet(fields, constants.LSDYNA)

                while error > 0.001 and cntr < 10:
                    error = base.MaterialCalibration()
                    cntr += 1
                print(error)
                if error < 0.01:
                    base.MaterialCalibrationMakeMaterial(constants.LSDYNA)


            if __name__ == "__main__":
                main()


    """


def MaterialCalibration() -> float:
    """

    Calibrates the material parameters according to given experimental curve

    Returns
    -------
    float
            Returns the error between the experimental curve and the calibrated material

    See Also
    --------
    MaterialCalibrationSet, MaterialCalibrationMakeMaterial

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import *


            def main():
                error = 1
                MooneyRivlin = 6
                cntr = 0
                fields = {
                    "Curve": 19,
                    "Material type": MooneyRivlin,
                    "C01": 0.01,
                    "C01_check": 1,
                    "C01_Min": 0.0000001,
                    "C01_Max": 1000,
                }
                base.MaterialCalibrationSet(fields, constants.LSDYNA)

                while error > 0.001 and cntr < 10:
                    error = base.MaterialCalibration()
                    cntr += 1
                print(error)
                if error < 0.01:
                    base.MaterialCalibrationMakeMaterial(constants.LSDYNA)


            if __name__ == "__main__":
                main()


    """


def MaterialCalibrationMakeMaterial(deck: int) -> object:
    """

    Generates the material entity for the specified deck according to the calibrated values

    Parameters
    ----------
    deck : int
            The deck to generate the material

    Returns
    -------
    object
            The generated material entity

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import *


            def main():
                error = 1
                MooneyRivlin = 6
                cntr = 0
                fields = {
                    "Curve": 19,
                    "Material type": MooneyRivlin,
                    "C01": 0.01,
                    "C01_check": 1,
                    "C01_Min": 0.0000001,
                    "C01_Max": 1000,
                }
                base.MaterialCalibrationSet(fields, constants.LSDYNA)

                while error > 0.001 and cntr < 10:
                    error = base.MaterialCalibration()
                    cntr += 1
                print(error)
                if error < 0.01:
                    base.MaterialCalibrationMakeMaterial(constants.LSDYNA)


            if __name__ == "__main__":
                main()


    """


def AbqStepGetOutputRequestIdentifyingKeys(output_request: object) -> object:
    """

    Returns a list of the identifying keys of the requested Output Request.

    Parameters
    ----------
    output_request : object
            A reference to the output request.

    Returns
    -------
    object
            It returns a list containing all the identifying keys of the selected output request.

    See Also
    --------
    AbqStepCollectOutputRequests, AbqStepInsertOutputRequest, AbqStepDeleteOutputRequest, AbqStepCopyOutputRequest, AbqStepUpdateOutputRequest, AbqStepGetOutputRequestName, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                requests = base.AbqStepCollectOutputRequests(p_step)
                for request in requests:
                    print(base.AbqStepGetOutputRequestName(request))
                    print(base.AbqStepGetOutputRequestIdentifyingKeys(request))


    """


def RenumberMBContainers(mbcontainers: object) -> bool:
    """

    This function applies the numbering rules of the model browser containers that are given as input.

    Parameters
    ----------
    mbcontainers : object
            A list containing the Model Browser Containers whose numbering rules will be applied.

    Returns
    -------
    bool
            Returns "True" if all entities of the Model Browser Container are correctly renumbered. Returns "False" if some entities do not belong to the numbering rule's range.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                subsystem = base.GetEntity(constants.NASTRAN, "ANSA_SUBSYSTEM", 713)
                rule1 = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "ANSA_SUBSYSTEM",
                    subsystem,
                    "0",
                    "PER_GROUP",
                    8000001,
                    9000000,
                    "subsystem_rule",
                    preserve_ids=True,
                )
                simulation_model = base.GetEntity(constants.NASTRAN, "ANSA_SIMULATION_MODEL", 897)
                rules2 = base.CreateNumberingRule(
                    constants.NASTRAN,
                    "ANSA_SIMULATION_MODEL",
                    simulation_model,
                    "0",
                    "PER_GROUP",
                    9000001,
                    10000000,
                    "simulation_model_rule",
                    preserve_ids=True,
                )
                base.SetStatusOfNumberingRules(True, True)
                base.RenumberMBContainers([subsystem, simulation_model])


    """


def AutoCreateAlignEntities(
    shells: list,
    faces: list,
    distance_limit: float = 5,
    distance_limit_as_percentage: bool = True,
    thickness_limit: float = 10,
    thickness_limit_as_percentage: bool = True,
) -> None:
    """

    Creates align entities on shells using the input faces.
    It needs a list of (argument name, argument value) pairs.

    Parameters
    ----------
    shells : list
            Shells where the align entities are created

    faces : list
            Faces used to create align entities

    distance_limit : float, optional
            The distance tolerance for nodes to be valid in an align entity. Default value is 5%.

    distance_limit_as_percentage : bool, optional
            If set to true the distance limit is used a percentage of thickness. Default value is True.

    thickness_limit : float, optional
            A thickness tolerance for nodes to be valid in an align entity. Default value is 10%.

    thickness_limit_as_percentage : bool, optional
            If set to True the thickness limit is used as a percentage. Default value is True.

    Returns
    -------
    None
            Returns nothing.

    Examples
    --------
    ::

            from ansa import base


            def main():
                search_face = ("FACE",)
                faces = base.CollectEntities(0, None, search_face, False)

                search_face = ("SHELL",)
                shells = base.CollectEntities(0, None, search_shell, False)

                base.AutoCreateAlignEntities(
                    shells=shells, faces=faces, distance_limit=5, thickness_limit=10
                )


    """


def AirbagXrefFill(airbag: object, nodes: object):
    """

    Fills an AIRBAG_XREF entity with XREF_NODES.
    In case that there are XREF_NODES that applied on the same node, call MarkDuplicateXref

    Parameters
    ----------
    airbag : object
            The AIRBAG_XREF entity that will be filled with nodes

    nodes : object
            A list with nodes

    See Also
    --------
    MarkDuplicateXref

    Examples
    --------
    ::

            import ansa
            from ansa import *


            def main():
                nodes = base.CollectEntities(constants.RADIOSS, None, "NODE")
                xref_nodes = []
                for n in nodes:
                    fields = {
                        "NID": n._id,
                        "X": n.position[0] * 2.0,
                        "Y": n.position[1] * 2.0,
                        "Z": n.position[2] * 2.0,
                    }
                    xref_nodes.append(base.CreateEntity(constants.RADIOSS, "XREF_NODE", fields))
                base.MarkDuplicateXref()
                airbag = base.CreateEntity(constants.RADIOSS, "AIRBAG_XREF")

                base.AirbagXrefFill(airbag, xref_nodes)


            if __name__ == "__main__":
                main()


    """


def InputMarc(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    merge_parts: str = "on",
    header: str = "merge",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_fe_perimeters: str = "on",
    paste_nodes_by_id: str = "off",
    new_include: str = "off",
    read_only: str = "wp",
    comment_input_inline_include: str = "on",
    store_unsupported_keywords_to_include: str = "off",
) -> int | Entity:
    """

    The InputMarc function imports a Marc model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "skip", "merge", "new"
            (Default: "merge")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            "on" or "off". If left blank, the current ANSA defaults value is assumed.

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is enabled, it returns a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                # Read Marc file with the default options.
                files = utils.SelectOpenFile(0)
                if len(files) > 0:
                    base.InputMarc(filename="C:/temp/users/folder/file.dat")


    """


def OutputMarc(
    filename: str,
    mode: str,
    write_comments: str,
    output_element_thickness: str,
    output_numbering_rules: str,
    output_parts_in_xml: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_colors: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_misc: str,
    comment_output_lock_views: str,
    model_check: str,
    comment_output_annotations: str,
    comment_output_attributes: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_fe_perimeters: str,
    advanced_options: str,
    comment_output_inline_include: str,
    include_output_mode: str,
    output_only_main_file: str,
    disregard_includes: str,
    update_include_fname: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    create_include_output_directory: str,
    version: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs a Marc format file like the FILE>OUTPUT>MARC functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file.

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            mode="custom_mbcontainer" can be used only
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "as_v_11_2_4", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    output_element_thickness : str, optional
            "on" or "off"
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_misc : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    model_check : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_fe_perimeters : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of dw, wo, followed by Header, UHeader, Nodes, UNodes,
            Elements, UElement, Properties, UProperties,
            Materials, UMaterials, Sets, USets, Contacts, UContacts.
            Separate the needed keywords with blanks, e.g "dw Properties Materials".

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "on")

    disregard_includes : str, optional
            "on" or "off".
            (Default: "on")

    update_include_fname : str, optional
            "on" or "off".
            (Default: "on")

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "on")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: "on")

    create_include_output_directory : str, optional
            "on" or "off".
            (Default: "on")

    version : str, optional
            Marc output version. Available: "13", "15".
            (Default: what set at the last execution)

    entities : object, optional
            The reference to a list of entities to be output.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputMarc(filename="C:/users/folder/file.dat")


    """


def FlangesCompatibleIdentify(
    faces: object,
    distance: float,
    angle_tolerance: float,
    minimum_overlap: float,
    allow_same_property: bool,
) -> object:
    """

    Function FlangesCompatibleIdentify() given a number of input faces it identitfies pairs of face areas that are flanges.

    Parameters
    ----------
    faces : object, optional
            A list with ANSA FACE entities (suppliance of this
            argument is optional, default = visible faces).

    distance : float, optional
            Maximum search distance (suppliance
            of this argument is optional, default value = 1.0).

    angle_tolerance : float, optional
            Maximum angle between angles (suppliance
            of this argument is optional, default value = 10.0).

    minimum_overlap : float, optional
            Minimum overlap (%) between faces in flange (suppliance
            of this argument is optional, minimum_overlap = 5.0).

    allow_same_property : bool, optional
            A boolean (i.e., 'True' or 'False') which
            signifies whether search should take into account faces of the property ID (suppliance of this argument is optional,
            default value = 'False').

    Returns
    -------
    object
            A dictionary where in each element the key represents the flange's ID and the value consists of two lists that represent the two face areas of the flange.

    See Also
    --------
    FlangesCompatibleLink, FlangesCompatibleTopo, FlangesCompatibleFuse

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                flanges = base.FlangesCompatibleIdentify()
                print(flanges)
                if flanges == None:
                    return
                for flg in flanges:
                    ret = base.FlangesCompatibleLink(
                        faces1=flg["master_faces"], faces2=flg["slave_faces"]
                    )
                    print("FlangesCompatibleLink = ", ret)


            if __name__ == "__main__":
                main()


    """


def InputVMAP(filename: str, model_action: str = "merge_model") -> int:
    """

    The InputVMAP function imports a VMAP model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                # Read VMAP file with the default options.
                base.InputVMAP(filename="C:/temp/users/folder/file.h5")


    """


def OutputVMAP(filename: str, mode: str) -> int:
    """

    This function outputs a VMAP format file like the FILE>OUTPUT>VMAP functionality.

    Parameters
    ----------
    filename : str
            The name of the output file.

    mode : str, optional
            "all", "model", "visible"

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputVMAP(filename="C:/users/folder/file.h5")


    """


def InjectionMoldingApply(injection_moldings: object) -> int:
    """

    Runs the analysis of the specified injection molding entity or entities.

    Parameters
    ----------
    injection_moldings : object
            A reference or a list of references to injection molding entities.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    InjectionMoldingGetResults, InjectionMoldingApplyOrientation

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                vals = {
                    "Name": "InjMold1",
                    "connectivity": "#1",
                    "search": "PassThrough",
                    "Gate node set": "1",
                    "Flow rate": 1.0,
                }
                inj_mold1 = base.CreateEntity(deck, "INJECTION MOLDING", vals)
                vals = {
                    "Name": "InjMold2",
                    "connectivity": "#1",
                    "search": "PassThrough",
                    "Gate node set": "2",
                    "Flow rate": 1.0,
                }
                inj_mold2 = base.CreateEntity(deck, "INJECTION MOLDING", vals)

                molds = [inj_mold1, inj_mold2]
                ret = base.InjectionMoldingApply(injection_moldings=molds)


    """


def SavePreviewImage(entity: object, filename: str, width: int, height: int) -> bool:
    """

    Saves the preview image of a MB Container or a Feature Entity as a png image.

    Parameters
    ----------
    entity : object
            The entity to save the preview image.

    filename : str
            The file path of the created png image.

    width : int, optional
            The width of the created image.

    height : int, optional
            The height of the created image.

    Returns
    -------
    bool
            Returns True if the image is saved successfully, False otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                fastener = base.GetEntity(0, "FASTENER FEATURE", 8)
                base.SavePreviewImage(fastener, "/home/user/fastener_image.png", 150, 150)

                part = base.GetPartFromName("Part_Name")
                base.SavePreviewImage(part, "/home/user/part_image.png", 150, 150)


            if __name__ == "__main__":
                main()


    """


def InjectionMoldingGetResults(
    injection_molding: object,
    fields: object,
    use_inn: bool,
    use_global_coordinates: bool,
) -> object:
    """

    Get the results of an already applied injection molding entity.

    Parameters
    ----------
    injection_molding : object
            A reference to an injection molding entity.

    fields : object
            A list of the fields to retrieve results.

            Available fields are:

            orientation_tensor (dictionary): A dictionary with the shells as keys and the respective orientation tensors as values.
            weld_line_nodes (dictionary): A dictionary with values a list of the nodes which form the weld lines.
            weld_line_nodes_and_meeting_angle (dictionary): A dictionary with dictionaries the nodes which form the weld lines as keys and the respective flow front meeting angle as values.
            fill_time (dictionary): A dictionary with dictionaries the nodes of the model as keys and the respective molding fill time as values.

    use_inn : bool, optional
            If set to True, Invariant Node Numbering will be used to compute the shells' orientation tensor. (Default: False)

    use_global_coordinates : bool, optional
            If set to True, the shells' orientation tensor will be transformed to the global coordinate system. (Default: False)

    Returns
    -------
    object
            On success, returns a dictionary with the 'fields' values as keys.
            Otherwise, None is returned.

    See Also
    --------
    InjectionMoldingApply, InjectionMoldingApplyOrientation

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                mold = base.GetEntity(deck, "INJECTION MOLDING", 1)

                ret = base.InjectionMoldingGetResults(
                    mold, {"orientation_tensor", "weld_line_nodes"}, use_global_coordinates=True
                )

                tensors_dict = ret["orientation_tensor"]
                weld_lines = ret["weld_line_nodes"]

                # Print the id of each shell and the in-plane components of its orienation tensor
                print("Orientation tensors:")
                print("ID A11 A22 A12")
                for shell, tensor in tensors_dict.items():
                    print(
                        shell._id,
                        tensor.a11,
                        tensor.a22,
                        tensor.a33,
                        tensor.a12,
                        tensor.a23,
                        tensor.a13,
                    )
                # Print all weld line nodes ids
                print("Weld line nodes:")
                print("ID")
                for node in weld_lines:
                    print(node._id)


    """


def SplitMultiBodyPart(part: object, check_in_dm: bool, dm_path: str) -> bool:
    """

    Converts a part marked as 'Is Multi Body' into a group with children single body parts

    Parameters
    ----------
    part : object
            The part to split.

    check_in_dm : bool, optional
            If true, check in DM for carry over single body parts and reload the latest found version if the geometric similarity is over 95%. Default value: False.

    dm_path : str, optional
            The DM path to search for carry over single body parts. If not defined, search in the current DM.

    Returns
    -------
    bool
            Returns True on success, False on failure.

    See Also
    --------
    MergeMultiBodyPart

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromModuleId("1000")
                part.set_entity_values(0, {"Is Multi Body": "YES"})

                base.SplitMultiBodyPart(part=part, check_in_dm=True, dm_path="/home/user/DM/")

                base.MergeMultiBodyPart(group=part)


            if __name__ == "__main__":
                main()


    """


def AbqStepInsertModelChangeParam(
    step: object, param: str, add: str, type: str, element: object, contact: object
) -> object:
    """

    Inserts a new parameter into a STEP's *MODEL CHANGE History Data.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be acquired by a previous call to GetEntity.

    param : str, optional
            "ACTIVATE", "ADD" or "REMOVE". (Default: "ACTIVATE")

    add : str, optional
            "", "STRAIN FREE" or "WITH STRAIN". (Default: "")

    type : str, optional
            "ELEMENT" or "CONTACT". (Default: "ELEMENT")

    element : object, optional
            A list containing the sets of elements to be added to the model change.
            Required if param is not "ACTIVATE" and type is "ELEMENT".

    contact : object, optional
            A list containing the contact pairs to be added to the model change.
            Required if param is not "ACTIVATE" and type is "CONTACT".

    Returns
    -------
    object
            Returns a reference to the created model change parameter on success and None on failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepUpdateModelChangeParam, AbqStepDeleteModelChangeParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                p_step = base.GetEntity(deck, "STEP", 1)
                elset = base.GetEntity(deck, "SET", 1)
                con1 = base.GetEntity(deck, "CONTACT_PAIR", 1)

                if p_step == None:
                    return
                param1 = base.AbqStepInsertModelChangeParam(
                    p_step, param="ADD", add="WITH STRAIN", element=[elset, 2]
                )
                param2 = base.AbqStepInsertModelChangeParam(
                    p_step, param="REMOVE", type="CONTACT", contact=con1
                )


    """


def AbqStepDeleteModelChangeParam(step: object, model_change_parameter: object) -> int:
    """

    Deletes a parameter from a STEP's *MODEL CHANGE History Data.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be acquired by a previous call to GetEntity.

    model_change_parameter : object
            Either a reference to a model change parameter, acquired by a previous
            call to AbqStepInsertModelChangeParam, or the index of the parameter
            in the *MODEL CHANGE parameter list.

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModelChangeParam, AbqStepUpdateModelChangeParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                p_step = base.GetEntity(deck, "STEP", 1)
                elset = base.GetEntity(deck, "SET", 1)
                con1 = base.GetEntity(deck, "CONTACT_PAIR", 1)

                if p_step == None:
                    return
                param1 = base.AbqStepInsertModelChangeParam(
                    p_step, param="ADD", add="WITH STRAIN", element=[elset, 2]
                )
                param2 = base.AbqStepInsertModelChangeParam(
                    p_step, param="REMOVE", type="CONTACT", contact=con1
                )

                base.AbqStepDeleteModelChangeParam(p_step, param2)
                base.AbqStepDeleteModelChangeParam(p_step, 0)


    """


def AbqStepUpdateModelChangeParam(
    step: object,
    model_change_parameter: object,
    param: str,
    add: str,
    type: str,
    element: object,
    contact: object,
) -> int:
    """

    Updates a parameter of a STEP's *MODEL CHANGE History Data.

    Parameters
    ----------
    step : object
            A reference to a STEP that can be acquired by a previous call to GetEntity.

    model_change_parameter : object
            Either a reference to a model change parameter, acquired by a previous
            call to AbqStepInsertModelChangeParam, or the index of the parameter
            in the *MODEL CHANGE parameter list.

    param : str, optional
            "ACTIVATE", "ADD" or "REMOVE". (Default: "ACTIVATE")

    add : str, optional
            "", "STRAIN FREE" or "WITH STRAIN". (Default: "")

    type : str, optional
            "ELEMENT" or "CONTACT". (Default: "ELEMENT")

    element : object, optional
            A list containing the sets of elements to be added to the model change.
            Required if param is not "ACTIVATE" and type is "ELEMENT".

    contact : object, optional
            A list containing the contact pairs to be added to the model change.
            Required if param is not "ACTIVATE" and type is "CONTACT".

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    See Also
    --------
    AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModelChangeParam, AbqStepDeleteModelChangeParam

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                p_step = base.GetEntity(deck, "STEP", 1)
                elset = base.GetEntity(deck, "SET", 1)
                con1 = base.GetEntity(deck, "CONTACT_PAIR", 1)

                if p_step == None:
                    return
                param1 = base.AbqStepInsertModelChangeParam(
                    p_step, param="ADD", add="WITH STRAIN", element=[elset, 2]
                )
                param2 = base.AbqStepInsertModelChangeParam(
                    p_step, param="REMOVE", type="CONTACT", contact=con1
                )

                base.AbqStepUpdateModelChangeParam(p_step, 0, param="ACTIVATE")
                base.AbqStepUpdateModelChangeParam(p_step, param2, param="ADD", contact=2)


    """


def QGraphDrawModeResults(method: str, method_argument: float):
    """

    This function returns the non zero results of a user selected QGraph draw mode. The user selects the QGraph method and provides the method arguments ( if any ) and the non-zero results are returned in a dictionary with the element as the key and the result as the value. Please notice that this function applies on visible elements.

    Parameters
    ----------
    method : str
            The QCheck to be executed as displayed in the QGRAPH pulldown in GUI mode.

    method_argument : float
            Any additional argument required by the QCheck. For the moment, only 'Curvature Radius' QCheck requires such an argument.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dict = base.QGraphDrawModeResults(method="curvature radius", method_argument=1000.0)


    """


def MergeMultiBodyPart(group: object) -> bool:
    """

    Converts a group marked as 'Is Multi Body' that has been created from SplitMultiBodyPart back into a part.

    Parameters
    ----------
    group : object
            The group to merge.

    Returns
    -------
    bool
            Returns True on success, False on failure.

    See Also
    --------
    SplitMultiBodyPart

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                part = base.GetPartFromModuleId("1000")
                part.set_entity_values(0, {"Is Multi Body": "YES"})

                base.SplitMultiBodyPart(part=part, check_in_dm=True, dm_path="/home/user/DM/")

                base.MergeMultiBodyPart(group=part)


            if __name__ == "__main__":
                main()


    """


def ShowLogAnalytics(log_type: str):
    """

    This function opens the last input/merge analytics window

    Parameters
    ----------
    log_type : str, optional
            if value "merge_analytics" is provided the merge
            analytics window will be shown instead of input analytics

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                base.InputNastran(filename="C:/temp/users/folder/data.nas")
                base.ShowLogAnalytics()


            if __name__ == "__main__":
                main()


    """


def MidSurfExtrusion(
    min_thick: float,
    max_thick: float,
    length: float,
    elem_type: str,
    join_distance: float,
    paste_triple_len: float,
    collapse_ribs_height: float,
    faces: object,
    ret_ents: bool,
    connect_weldings: bool,
    thickness_ratio: float,
    sharpen_fillets_min_radius: float,
    intersection_angle: float,
    constant_profile_ratio: float,
    thickness_step: float,
    reset_resolution_percentage: int,
    property: str,
    part: str,
) -> object:
    """

    Creates mesh at the middle surface of extruded parts.

    Parameters
    ----------
    min_thick : float, optional
            The minimum thickness of the extruded profile(s), must be > 0.
            Default value: 1

    max_thick : float, optional
            The maximum thickness of the extruded profile(s), must be >= minimum thickness.
            Default value: 5

    length : float, optional
            The target element length, must be >= minimum thickness.
            Default value: 4

    elem_type : str, optional
            The element type to be created. Accepted values: "Mixed", "Quad", "Tria", "Ortho Tria".
            Default value: "Mixed"

    join_distance : float, optional
            The minimum distance under which two double perimeters are collapsed.
            Default value: 0.5*length

    paste_triple_len : float, optional
            The minimum distance under which two triple perimeters are collapsed.
            Default value: 0.5*length

    collapse_ribs_height : float, optional
            The minimum distance under which a rib is collapsed.
            Default value: 0.5*length

    faces : object, optional
            A list of faces that comprise the solid description geometry.
            If it is not specified then the visible faces are used instead.

    ret_ents : bool, optional
            If set to True, a list with the created entities will be returned.
            Default value: False

    connect_weldings : bool, optional
            If set to True, weldings are automatically connected after mesh generation.
            Default value: False

    thickness_ratio : float, optional
            The distance under which the created meshes are connected, expressed as a ratio of the local thickness.
            Default value: 1.1

    sharpen_fillets_min_radius : float, optional
            The radius under which a fillet is sharpened.
            Default value: 0(off)

    intersection_angle : float, optional
            Modifies the intersection angle limit. Accepted values: [5,45] degrees.
            Default value: 20

    constant_profile_ratio : float, optional
            The threshold value of the allowed deviation of the profile along the extrusion direction.
            If the calculated ratio is less than this value no result will be produced.
            A purely extruded part will have ratio = 1.
            A part that has been deformed (pressed, stamped or bent) after the extrusion will have ratio < 1.
            Holes and cut outs do not affect the ratio.
            The calculated ratio of the result is reported in the Part Comments section.
            Default value: 0 (the check is disabled)

    thickness_step : float, optional
            The discretization step of nodal to PID thickness conversion.
            Default value: 0(off)

    reset_resolution_percentage : int, optional
            Reset solid description resolution using a percentage of target element length. If set to 0 resolution is not affected.
            Default value is 50.

    property : str, optional
            Accepted values: "use_existing", "use_current", "auto_create" and "id=<integer>".

    part : str, optional
            Accepted values: "use_existing", "use_current", "auto_create" and "id=<integer>".

    Returns
    -------
    object
            Returns 0 on success or 1 on failure.
            If ret_ents is True it returns a list with the created entities.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                created_shells_list = []
                all_faces = base.CollectEntities(0, None, "FACE", False)
                created_shells_list = base.MidSurfExtrusion(
                    min_thick=2,
                    max_thick=5,
                    length=4,
                    elem_type="Mixed",
                    constant_profile_ratio=0.95,
                    faces=all_faces,
                    ret_ents=True,
                    join_distance=2,
                    paste_triple_len=2,
                    thickness_step=0.5,
                    sharpen_fillets_min_radius=3,
                    property="id=5",
                    part="use_current",
                )


    """


def OrientAxisymmetricElements(elements: object, prototype_element: object) -> object:
    """

    This function will change the node ordering of the given elements to comply with the prototype element.

    Parameters
    ----------
    elements : object
            A list of axisymmetric elements. These elements will be oriented
            by the function and should be either ELSURFACE AXISYMMETRIC or
            MEMBRANE AXISYMMETRIC type

    prototype_element : object
            An element to use as prototype. It must belong to the given elements list.

    Returns
    -------
    object
            Returns a list containing references to the elements that were unable to be oriented according to the given prototype element.
            If no elements have failed, it returns 0.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                elems = base.CollectEntities(0, None, "ELSURFACE AXISYMMETRIC")
                prototype_elem = elems[0]
                failed_elements = base.OrientAxisymmetricElements(elems, prototype_elem)
                print("failed elements are {}".format(len(failed_elements)))


    """


def SetPickAreaAngle(angle: int):
    """

    Sets the area angle for the base.constants.AREA_ANGLE_SELECTION PickMethod

    Parameters
    ----------
    angle : int
            The new area angle in degrees

    See Also
    --------
    SetPickLineAngle

    Examples
    --------
    ::

            import ansa
            from ansa import base

            ansa.base.SetPickMethod(base.constants.AREA_ANGLE_SELECTION)
            ansa.base.SetPickAreaAngle(20)


    """


def SetPickLineAngle(angle: int):
    """

    Sets the area angle for the base.constants.LINE_ANGLE_SELECTION PickMethod

    Parameters
    ----------
    angle : int
            The new line angle in degrees

    See Also
    --------
    SetPickAreaAngle

    Examples
    --------
    ::

            import ansa
            from ansa import base

            ansa.base.SetPickMethod(base.constants.LINE_ANGLE_SELECTION)
            ansa.base.SetPickLineAngle(50)


    """


def MarkDuplicateXref():
    """

    Checks all XREF_NODE entities of the model and marks the ones that are applied on the same node, so as not to lose their initial position

    See Also
    --------
    AirbagXrefFill

    Examples
    --------
    ::

            import ansa
            from ansa import *


            def main():
                nodes = base.CollectEntities(constants.RADIOSS, None, "NODE")
                xref_nodes = []
                for n in nodes:
                    fields = {
                        "NID": n._id,
                        "X": n.position[0] * 2.0,
                        "Y": n.position[1] * 2.0,
                        "Z": n.position[2] * 2.0,
                    }
                    xref_nodes.append(base.CreateEntity(constants.RADIOSS, "XREF_NODE", fields))
                airbag = base.CreateEntity(constants.RADIOSS, "AIRBAG_XREF")

                base.AirbagXrefFill(airbag, xref_nodes)
                base.MarkDuplicateXref()


            if __name__ == "__main__":
                main()


    """


def InputUGRID(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    file_format: str = "c-binary",
    endianness: str = "big-endian",
    precision: str = "double",
    unit_system: utils.UnitSystem = None,
    cfd_light_mode: str = "off",
) -> int:
    """

    The InputUGRID function imports a UGRID model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    file_format : str, optional
            Accepted values: "ascii" or "c-binary".
            (Default: "c-binary")

    endianness : str, optional
            Accepted values: "big-endian" or "little-endian".
            (Default: "big-endian")

    precision : str, optional
            Accepted values: "float" or "double".
            (Default: "double")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    cfd_light_mode : str, optional
            Accepted values: "on" or "off".
            If it is set to "on", ANSA will use the light volume representation,
            which is more suitable for CFD meshes.
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputUGRID(
                    "C:/temp/users/folder/data.lb8.ugrid",
                    file_format="c-binary",
                    endianness="little-endian",
                    precision="double",
                )


    """


def OutputUGRID(
    filename: str,
    mode: str,
    file_format: str,
    endianness: str,
    precision: str,
    unit_system: object,
    scale: float,
) -> int:
    """

    This function outputs a UGRID format file.

    Parameters
    ----------
    filename : str
            The name of the output file; must include the full path.

    mode : str, optional
            "all" or "model" or "visible".
            (Default: "all")

    file_format : str, optional
            Accepted values: "ascii" or "c-binary".
            (Default: "c-binary")

    endianness : str, optional
            Accepted values: "big-endian" or "little-endian".
            (Default: "big-endian")

    precision : str, optional
            Accepted values: "float" or "double".
            (Default: "double")

    unit_system : object, optional
            A UnitSystem object.
            Dictates the length unit to which the
            output will be scaled from the existing
            ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments
            are defined, the latter will override the first.

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputUGRID(
                    filename="C:/users/dat/data.lb8.ugrid",
                    file_format="c-binary",
                    endianness="little-endian",
                    precision="double",
                )


    """


def GetSolidsFromBeamSection(beams: object, deck: int, element_length: float):
    """

    This function creates solid elements in the form of specific beam cross sections.

    Parameters
    ----------
    beams : object
            An object or a list of beam objects, "all", "visible", 0.
            If set to 0 or "all", runs for all compatible elements of the database.
            If set to "visible," runs for all compatible elements which are visible.

    deck : int, optional
            Deck in which function is run.

    element_length : float, optional
            Element length. In case this length is greater than maximum element length, that is estimated from the function, maximum element length is used.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import constants


            def main():
                ents = ansa.base.CollectEntities(constants.NASTRAN, None, "CBEAM3")

                new_ents = ansa.base.GetSolidsFromBeamSection(ents, constants.PERMAS, 1)
                print(new_ents)


    """


def InputImpetus(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    header: str = "overwrite",
    read_only: str = "wp",
    create_parameters: str = "off",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_gebs: str = "on",
    comment_input_kinetics: str = "on",
    comment_input_cross_sections: str = "on",
    comment_input_results_map: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    comment_input_alc_points: str = "on",
    comment_input_alc_points_mode: str = "alc_points",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_connections_user_defined_geometry: str = "off",
    comment_input_fe_perimeters: str = "on",
    comment_input_features: str = "on",
    comment_input_mbcontainers: str = "on",
    paste_nodes_by_id: str = "off",
    eos_id: str = "off",
    functions_id: str = "offset",
    store_unsupported_keywords_to_include: str = "off",
    version: str = "",
) -> int | Entity:
    """

    The InputImpetus function imports an Impetus command file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old"
            or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    header : str, optional
            Accepted values: "overwrite", "merge" or "skip"
            (Default: "overwrite")

    read_only : str, optional
            Accepted values: "wp", "all" or "none".
            (Default: "wp")

    create_parameters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_gebs : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_kinetics : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_cross_sections : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_results_map : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            If left blank, the current ANSA defaults value is assumed.

    comment_input_alc_points : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_alc_points_mode : str, optional
            Accepted values: "alc_points", "lc_points" ,"a_points"
            (Default: "alc_points")

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be input from ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_features : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_mbcontainers : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    eos_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new"
            (Default: "offset")

    functions_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new"
            (Default: "offset")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    version : str, optional
            Accepted values: "6.0", "6.0.630", "6.0.846", "7.0.1" or "7.0.121"
            If left blank, the current version is used.

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is defined,
            it returns a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    See Also
    --------
    OutputImpetus

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import utils


            def main():
                # Read Impetus file with the default options.
                files = utils.SelectOpenFile(0)
                if len(files) > 0:
                    base.InputImpetus(filename="C:/temp/users/folder/data.k", header="merge")


    """


def OutputImpetus(
    filename: str,
    mode: str,
    write_comments: str,
    format: str,
    enddata: str,
    disregard_includes: str,
    apply_subcontainer_rules: str,
    lf_mode: str,
    output_numbering_rules: str,
    include_output_mode: str,
    output_only_main_file: str,
    output_parts_in_xml: str,
    update_include_fname: str,
    output_parameter_keywords: str,
    output_all_same_directory: str,
    use_relative_name_for_readonly_includes: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_gebs: str,
    comment_output_colors: str,
    comment_output_kinetics: str,
    comment_output_cross_sections: str,
    comment_output_results_map: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_field_labels: str,
    comment_output_inline_include: str,
    comment_output_lock_views: str,
    advanced_options: str,
    include: object,
    configuration: object,
    comment_output_annotations: str,
    comment_output_attributes: str,
    create_include_output_directory: str,
    comment_output_alc_points: str,
    comment_output_alc_points_mode: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_connections_user_defined_geometry: str,
    comment_output_fe_perimeters: str,
    comment_output_features: str,
    entities: object,
    force_relative_reference: str,
) -> int:
    """

    This function outputs an Impetus format command file like the FILE>OUTPUT>IMPETUS functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference
            the full path to the file.

    mode : str, optional
            "all" , "model", "visible" or
            "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be
            used along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    format : str, optional
            "6.0", "6.0.630", "6.0.846", "7.0.1" or "7.0.121"
            (Default: what set at the last execution)

    enddata : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    disregard_includes : str, optional
            "on" or "off".
            (Default: "off")

    apply_subcontainer_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    lf_mode : str, optional
            "system native", "unix" or "dos".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    include_output_mode : str, optional
            "contents" or "references".
            (Default: what set at the last execution)

    output_only_main_file : str, optional
            "on" or "off".
            (Default: "off")

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    update_include_fname : str, optional
            "on" or "off". Corresponds to the "Update
            Include ReferenceFile" option of the Output
            Parameters of the GUI function.
            (Default: "off")

    output_parameter_keywords : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_gebs : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_kinetics : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_cross_sections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_results_map : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_field_labels : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_inline_include : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    advanced_options : str, optional
            One of w, dw, followed by Header, UHeader,
            Nodes, UNodes, Elements, UElements,
            Properties, UProperties, Materials,
            UMaterials, Sets, USets, Contacts, UContacts.
            Separate the needed keywords with blanks,
            e.g "dw Properties Materials".

    include : object, optional
            The reference to the include entity.
            Should not be used along with
            "configuration".

    configuration : object, optional
            The reference to the configuration entity.
            Should not be used along with "include"
            argument. Outputs either an inactive
            configuration when no other.

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    create_include_output_directory : str, optional
            "on" or "off". Create non-existent include
            output directories.
            (Default: "off")

    comment_output_alc_points : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_alc_points_mode : str, optional
            Sets whether a, lc or both types will be
            written "alc_points", "lc_points" or
            "a_points"
            (Default: "alc_points")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections_user_defined_geometry : str, optional
            This argument controls whether the stored search area of GEBs with User Defined Area search and Connections with User Defined Geometry search will be output into ANSA comments. Accepted values: "on" or "off". (Default: "off")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    comment_output_features : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    entities : object, optional
            The reference to a list of entities to be output.
            Should not be used along with "include", "configuration" or "mbcontainer" argument.

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    InputImpetus

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def get_include(name):
                ents = base.NameToEnts(name)
                for ent in ents:
                    if base.GetEntityType(constants.IMPETUS, ent) == "INCLUDE":
                        return ent
                return 0


            def main():
                base.OutputImpetus(filename="C:/temp/users/folder/data.k", disregard_includes="on")
                include_file = get_include("data.k")
                if include_file:
                    base.OutputImpetus(include=include_file)


    """


def SaveViolatingVolumeElements(
    filename: str, representation: str, zones_number: int
) -> int:
    """

    Calculates the violating volume elements of the database according to the active quality criteria and saves them in a seperate database.


    Parameters
    ----------
    filename : str
            The name of the new file; must include the full path.

    representation : str, optional
            Option to save the violating volume elements or their COGs
            as points. Accepted values: "elements" or "3dpoints".
            (Default: entity_type="elements")

    zones_number : int, optional
            Number of neighboring zones around violating elements.
            (Default: zones_number=0)

    Returns
    -------
    int
            Returns 0 if the file has been successfully saved and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SaveViolatingVolumeElements(
                    "C:/temp/users/folder/failed_elements.ansa",
                    representation="3dpoints",
                    zones_number=1,
                )


    """


def CopyAnsaModel(model: Entity) -> Entity:
    """

    The function creates a duplicate of the ANSA model it gets passed as an
    argument.

    Parameters
    ----------
    model : Entity
            The ANSA model to duplicate

    Returns
    -------
    Entity
            Returns the newly created ANSA model on success, None otherwise.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                src_model = base.GetEntity(constants.NASTRAN, "MODEL", 0)
                new_model = base.CopyAnsaModel(src_model)
                print(new_model)


    """


def SetMaterialMapping(source_deck: int, target_deck: int, mapping: object):
    """

    This function allows the user to change the Mapping Material type.

    Parameters
    ----------
    source_deck : int
            source deck

    target_deck : int
            target deck

    mapping : object
            A dictionary containing {source deck material name: target deck material name} pairs.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import constants
            from ansa import base


            def main():
                base.SetMaterialMapping(
                    constants.NASTRAN,
                    constants.LSDYNA,
                    {"MAT2": "MAT1 MAT_ELASTIC", "MAT1": "MAT1F MAT_ELASTIC_FLUID"},
                )


            if __name__ == "__main__":
                main()


    """


def GetActiveConfigurations(subsystem: object) -> object:
    """

    Get all active Configurations.

    Parameters
    ----------
    subsystem : object, optional
            a Model Browser container of type ANSA_SUBSYSTEM.
            If Subsystem provided, the function returns the active
            Configuration whose parts belong to this Subsystem.

    Returns
    -------
    object
            Returns a list with active Configurations.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                subsystem = base.GetPartFromName("XXXX", type="ANSA_SUBSYSTEM")
                list = base.GetActiveConfigurations(subsystem)


    """


def GetModelContainerInstances(mbcontainer: object) -> object:
    """

    Returns a list of all instances of a Model Browser Container

    Parameters
    ----------
    mbcontainer : object
            The Model Browser Container that will be used as source to
            fetch instances

    Returns
    -------
    object
            A list of all instances of a Model Browser Container

    Examples
    --------
    ::

            import ansa
            from ansa import base

            subsystem_1 = base.NewSubsystem()
            subsystem_2 = base.NewSubsystem()

            properties = {}
            properties["Name"] = "Subsystem"
            properties["Module Id"] = "Instance_Subsystem"

            base.SetEntityCardValues(0, subsystem_1, properties)
            base.SetEntityCardValues(0, subsystem_2, properties)

            all_instances = base.GetModelContainerInstances(subsystem_1)
            print(all_instances)


    """


def CopyEntitiesToAnsaModel(model: Entity, entities: Entity | Iterable) -> List[Entity]:
    """

    Copies entities from the active Ansa model to another Ansa model.

    Parameters
    ----------
    model : Entity
            The Ansa model to copy entities to.

    entities : Entity | Iterable
            A python list containing the entities to be copied.

    Returns
    -------
    List[Entity]
            Returns a list of the newly created clones of the source entities. Each entity
            clone has the same position within the returned list as its source entity had in
            the original "entities" list. If a source entity could not be copied to the
            destination model, None will be present at the corresponding position of the
            returned list.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                entities = []

                for i in range(8):
                    entity = base.CreateEntity(constants.ABAQUS, "NODE", {"Name": str(i + 1)})
                    entities.append(entity)
                model = base.CreateNewAnsaModel()

                ret = base.CopyEntitiesToAnsaModel(model, entities)
                print(ret)


    """


def OutputRavenCFD(
    filename: str, mode: str, file_format: str, unit_system: object, scale: float
) -> int:
    """

    The OutputRavenCFD function outputs a RavenCFD format file (.grd) and the corresponding bc file (.bc).
    Please note that only  mesh with Light Volume Representation (LVR) is supported for output.

    Parameters
    ----------
    filename : str
            The name of the output file(s); must include the full path

    mode : str, optional
            "all" or "model" or "visible".
            (Default: "all")

    file_format : str, optional
            "formatted" or "unformatted" (fortran binary).
            (Default: "unformatted")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the
            output will be scaled from the existing ANSA length unit
            setting. If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: 1.0)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    See Also
    --------
    UnitSystem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputRavenCFD(filename="C:/temp/data.grd", file_format="unformatted")


    """


def CreateIsoperimeters(
    shells: object,
    thickness_step: float,
    base_value: float,
    cut_mesh: bool,
    expand_level: int,
    expand_level_outside_selection: int,
) -> int:
    """

    This function will create FE perimeters according to the average shell's nodal
    thickness and to the given thickness step.

    Parameters
    ----------
    shells : object
            A list containing the shells to be processed.

    thickness_step : float
            The step that will be used to create thickness groups.

    base_value : float, optional
            The base value that will be used to create thickness groups.

    cut_mesh : bool, optional
            Option for cutting mesh at thickness changes.

    expand_level : int, optional
            The number of expand levels to improve the mesh around the edges where mesh will be cut.

    expand_level_outside_selection : int, optional
            The number of expand levels to improve the mesh out of the selected shells.
            Setting this to 0 will freeze the selection bounds.

    Returns
    -------
    int
            This function always returns 1

    See Also
    --------
    CreatePropertiesFromShellsThickness

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                base.CreateIsoperimeters(shells, 0.5, base_value=0, cut_mesh=True, expand_level=3)


    """


def InputMedHdf5(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    model_action: str = "merge_model",
) -> int:
    """

    The InputMedHdf5 function imports a med-hdf5 model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputMedHdf5("C:/temp/users/folder/data.med", elements_id="offset")


    """


def OutputMedHdf5(filename: str, mode: str):
    """

    This function outputs a med-hdf5 format file.

    Parameters
    ----------
    filename : str
            The name of the output file. must reference the full path
            to the file.

    mode : str, optional
            "all", "model", "visible"

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputMedHdf5(filename="C:/users/folder/file.med")


    """


def GetFastenerMPCNodes(fastener: object) -> object:
    """

    Abaqus' Fasteners create internal MPCs in order to attach to surfaces and connect them. This function returns the nodes of these MPCs.

    Parameters
    ----------
    fastener : object
            The Fastener entity

    Returns
    -------
    object
            The function returns a dictionary with the following properties:
            key   : a reference node of the fastener (there may be more than one, depending on the way the fastener is defined)
            value : a list of lists. The first list contains as many secondary lists as are surfaces in the fastener. Each secondary         list contains the MPC nodes corresponding to that surface.

    Examples
    --------
    ::

            # Requires a model with a Fastener with Id 1
            import os
            import ansa
            from ansa import base


            def main():
                fast = base.GetEntity(ansa.constants.ABAQUS, "FASTENER", 1)
                mpc_nodes = base.GetFastenerMPCNodes(fast)

                for ref_node, surfaces in mpc_nodes.items():
                    labs = ["__id__"]
                    ret = base.GetEntityCardValues(ansa.constants.ABAQUS, ref_node, labs)
                    print(ret["__id__"])
                    print("--------------------------------\\n")
                    for nodes in surfaces:
                        for node in nodes:
                            ret = base.GetEntityCardValues(ansa.constants.ABAQUS, node, labs)
                            print(ret["__id__"])
                        print("--------------------------------\\n")


            if __name__ == "__main__":
                main()


    """


def ImpactorApply(impactor: object) -> int:
    """

    The function applies the transformation of an IMPACTOR entity.

    Parameters
    ----------
    impactor : object
            The IMPACTOR entity.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    See Also
    --------
    ImpactorReset

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.LSDYNA, "IMPACTOR", 1)

                base.ImpactorApply(ent)


    """


def ImpactorReset(impactor: object) -> int:
    """

    The function resets the transformation of an IMPACTOR entity.

    Parameters
    ----------
    impactor : object
            The IMPACTOR entity.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    See Also
    --------
    ImpactorApply

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ent = base.GetEntity(constants.LSDYNA, "IMPACTOR", 1)

                base.ImpactorReset(ent)


    """


def LoadBaseModulesBasedOnConnectivity(entities: object) -> object:
    """

    if DM schema supports feature intermodular_connectivity_links
    the function will load:
            - Interface Representations for some Regular Subsystems and Full Representations for some others,
              depending on the compatibility of connection information with the Subsystem geometry
            - Full Representations for all Connecting Subsystems
            - Actual Representation for Library Items of type Loadcase_Header and Target_Points

    Parameters
    ----------
    entities : object
            A list with model browser containers (modules)

            A model browser container can be:
            - ANSA_SUBSYSTEM
            - ANSA_LIBRARY_ITEM
            - ANSA_SIM_MODEL_ADAPTER
            - ANSA_LOADCASE_ADAPTER

    Returns
    -------
    object
            return a dictionary with entities that failed to be loaded per representation type.

            The following are the keys of the dictionary
            - INVALID, entities not supported by function
            - FULL, failed entities to be loaded with full representation
            - INTERFACE, failed entities to be loaded with interface representation

    """


def OutputCobaltCFD(
    filename: str, mode: str, file_format: str, unit_system: object, scale: float
) -> int:
    """

    The OutputCobaltCFD function outputs a CobaltCFD format file (.grd) and the corresponding bc file (.bc).
    Please note that only  mesh with Light Volume Representation (LVR) is supported for output.

    Parameters
    ----------
    filename : str
            The name of the output file(s); must include the full path

    mode : str, optional
            "all" or "model" or "visible".
            (Default: "all")

    file_format : str, optional
            "formatted" or "unformatted" (fortran binary).
            (Default: "unformatted")

    unit_system : object, optional
            A UnitSystem object. Dictates the length unit to which the
            output will be scaled from the existing ANSA length unit
            setting. If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments are defined,
            the later will override the first.
            (Default: 1.0)

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputCobaltCFD(filename="C:/temp/data.grd", file_format="unformatted")


    """


def InjectionMoldingApplyOrientation(injection_molding: object) -> int:
    """

    Transfers the element orientations, calculated from the analysis, to the model.

    Parameters
    ----------
    injection_molding : object
            A reference to an injection molding entity.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    See Also
    --------
    InjectionMoldingApply, InjectionMoldingGetResults

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.ABAQUS
                vals = {
                    "Name": "InjMold",
                    "connectivity": "#1",
                    "search": "PassThrough",
                    "Gate node set": "1",
                    "Flow rate": 1.0,
                }
                injection_molding = base.CreateEntity(deck, "INJECTION MOLDING", vals)

                ret = base.InjectionMoldingApply(injection_molding)
                ret = base.InjectionMoldingApplyOrientation(injection_molding)


    """


def FacesModifyJoinFaces(cons: object):
    """

    This function joins two faces.

    Parameters
    ----------
    cons : object
            The common cons of the faces that will be joined.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # ansa.base.BCSettingsReadFile("")

                # ---------------------------------
                arg1 = base.GetEntity(ansa.base.CurrentDeck(), "CONS", 125182)
                ansa.base.FacesModifyJoinFaces(cons=arg1)


            if __name__ == "__main__":
                main()


    """


def GetDMIGMatrix(dmig: object) -> object:
    """

    Creates an object containing DMIG entries in a sparse matrix array representation.

    Parameters
    ----------
    dmig : object
            A reference to a DMIG entity.

    Returns
    -------
    object
            Returns an object containing the following:
            ret.row_nodes :(list)A list with tupple entries containing pairs of node-dof
                            for each row index.
            ret.col_nodes :(list)A list with tupple entries containing pairs of node-dof
                            for each column index.
            ret.r         :(list)A list with the integer indeces of rows, where non zero
                            values are located.
            ret.c         :(list)A list with the integer indeces of columns, where non zero
                            values are located.
            ret.d         :(list)A list with the non zero complex values located at
                            indeces (r,c)

    See Also
    --------
    SetDMIGMatrix, CreateDMIGMatrix

    Examples
    --------
    ::

            import ansa
            from ansa import base, constants


            def print_ith_entry(dmig_matrix, i, entry_keyword):

                For DMIG matrix, A[r(i), c(i)] = d(i), where:
                r(i) index corresponds to node: row_nodes[r(i)][0]
                                        and dof: row_nodes[r(i)][1],
                c(i) index corresponds to node: col_nodes[c(i)][0]
                                        and dof: col_nodes[c(i)][1],
                d(i) is the complex value.

                row_index = dmig_matrix.r[i]
                row_node = dmig_matrix.row_nodes[row_index][0]
                row_dof = dmig_matrix.row_nodes[row_index][1]

                col_index = dmig_matrix.c[i]
                col_node = dmig_matrix.col_nodes[col_index][0]
                col_dof = dmig_matrix.col_nodes[col_index][1]

                complex_value = dmig_matrix.d[i]

                print("The ", entry_keyword, " entry is:")
                print(
                    "Node: ",
                    row_node._id,
                    " Dof: ",
                    row_dof,
                    "\\t---\\t",
                    "Node: ",
                    col_node._id,
                    " Dof: ",
                    col_dof,
                    "\\t---\\t",
                    "Value: ",
                    complex_value,
                    "\\n",
                )


            def main():
                dmig = base.GetEntity(constants.NASTRAN, "DMIG", 1)

                dmig_matrix = base.GetDMIGMatrix(dmig)

                # Get first entry of the matrix
                print_ith_entry(dmig_matrix, 0, "first")
                # Get second entry of the matrix
                print_ith_entry(dmig_matrix, 1, "second")
                # Get last entry of the matrix
                print_ith_entry(dmig_matrix, len(dmig_matrix.d) - 1, "last")


    """


def SetDMIGMatrix(dmig: object, dmig_matrix: object) -> int:
    """

    Sets or changes values of a DMIG entity.

    Parameters
    ----------
    dmig : object
            A reference to a DMIG entity.

    dmig_matrix : object
            An object containing the following:
            dmig_matrix.row_nodes :(list)A list with tupple entries containing pairs of node-dof for each row index.
            dmig_matrix.col_nodes :(list)A list with tupple entries containing pairs of node-dof for each column index.
            dmig_matrix.r         :(list)A list with the integer indeces of rows, where non zero values are located.
            dmig_matrix.c         :(list)A list with the integer indeces of columns, where non zero values are located.
            dmig_matrix.d         :(list)A list with the non zero complex values located at indeces (r,c)

    Returns
    -------
    int
            Returns 1 on success, 0 on error.

    See Also
    --------
    GetDMIGMatrix, CreateDMIGMatrix

    Examples
    --------
    ::

            import ansa
            from ansa import base, constants


            def main():
                dmig_1 = base.GetEntity(constants.NASTRAN, "DMIG", 1)
                dmig_2 = base.GetEntity(constants.NASTRAN, "DMIG", 2)

                dmig_matrix = base.GetDMIGMatrix(dmig_1)

                # Set matrix entries of DMIG with id:1 to DMIG with id: 2
                ret = base.SetDMIGMatrix(dmig_2, dmig_matrix)
                print(ret)


    """


def CreateDMIGMatrix(dmig_matrix: object) -> object:
    """

    Creates a DMIG entity that contains the provided dmig matrix entries.

    Parameters
    ----------
    dmig_matrix : object
            An object containing the following:
            dmig_matrix.row_nodes :(list)A list with tupple entries containing pairs of node-dof for each row index.
            dmig_matrix.col_nodes :(list)A list with tupple entries containing pairs of node-dof for each column index.
            dmig_matrix.r         :(list)A list with the integer indeces of rows, where non zero values are located.
            dmig_matrix.c         :(list)A list with the integer indeces of columns, where non zero values are located.
            dmig_matrix.d         :(list)A list with the non zero complex values located at indeces (r,c)

    Returns
    -------
    object
            Returns a reference to the DMIG entity created, None if invalid arguments were specified or an error occurred.

    See Also
    --------
    GetDMIGMatrix, SetDMIGMatrix

    Examples
    --------
    ::

            import ansa
            from ansa import base, constants


            def main():
                dmig = base.GetEntity(constants.NASTRAN, "DMIG", 1)

                dmig_matrix = base.GetDMIGMatrix(dmig)

                # Create a copy of DMIG with id: 1
                new_dmig = base.CreateDMIGMatrix(dmig_matrix)
                print(new_dmig)


    """


def GetAllAnsaWindows() -> list:
    """

    The function returns a list containing all available ANSA windows.

    Returns
    -------
    list
            Returns a list containing all available ANSA windows.

    Examples
    --------
    ::

            from ansa import base


            def main():
                base.CreateNewAnsaWindow()
                base.CreateNewAnsaWindow()
                windows = base.GetAllAnsaWindows()
                window_names = [base.GetAnsaWindowName(window) for window in windows]
                print(window_names)


    """


def GetAnsaModelsOfAnsaWindow(window: object) -> List[Entity]:
    """

    The function returns a list containing all the models that are loaded in a
    given ANSA window.

    Parameters
    ----------
    window : object
            The ANSA window object.

    Returns
    -------
    List[Entity]
            Returns a list of models.

    Examples
    --------
    ::

            from ansa import base


            def main():
                window = base.GetAnsaWindow("Main Window")
                models = base.GetAnsaModelsOfAnsaWindow(window)
                model_names = [model._name for model in models]
                print(", ".join(model_names))


    """


def GetCurrentAnsaWindow() -> object:
    """

    The function returns the Current docked Ansa window.

    Returns
    -------
    object
            Returns the Current docked Ansa window.

    Examples
    --------
    ::

            from ansa import base


            def main():
                window = base.GetCurrentAnsaWindow()
                if window:
                    print(base.GetAnsaWindowName(window))


    """


def AbqStepGetOutputRequestValues(output_request: object, fields: object) -> object:
    """

    Gets values from an output request using its edit card. The labels are taken from the fields in the STEP edit card.
    The respective values of these fields are then assigned the entity's parameters.

    Parameters
    ----------
    output_request : object
            A reference to the output request.

    fields : object
            A list of card field labels to extract the values from.

    Returns
    -------
    object
            Returns a Dictionary with the requested labels as keys and the retrieved values as the dictionary's values.
            If the function fails to find the requested fields, the dictionary's value will be empty.

    See Also
    --------
    AbqStepInsertOutputRequest, AbqStepDeleteOutputRequest, AbqStepCopyOutputRequest, AbqStepUpdateOutputRequest, AbqStepCollectOutputRequests, AbqStepSetAnalysisType, AbqStepGetAnalysisType, AbqStepSetHistoryData, AbqStepInsertModalDampingParam, AbqStepUpdateModalDampingParam, AbqStepDeleteModalDampingParam, AbqStepGetOutputRequestName

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                p_step = base.GetEntity(constants.ABAQUS, "STEP", 1)
                requests = base.AbqStepCollectOutputRequests(p_step)

                for request in requests:
                    print(base.AbqStepGetOutputRequestName(request))
                    print(base.AbqStepGetOutputRequestValues(request, {"FREQUENCY", "MODE LIST"}))


    """


def InputRavenCFD(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    file_format: str = "unformatted",
    unit_system: utils.UnitSystem = None,
) -> int:
    """

    InputRavenCFD imports a RavenCFD file and the corresponding bc file.
    Please have in mind that mesh is imported in Light Volume Representation (LVR).

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset".
            (Default: "offset")

    elements_id : str, optional
            Accepted values: "offset".
            (Default: "offset")

    properties_id : str, optional
            Accepted values: "offset".
            (Default: "offset")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    file_format : str, optional
            Accepted values: "formatted" and "unformatted".
            (Default: "unformatted")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputRavenCFD(
                    filename="C:/temp/users/folder/data.grd", file_format="formatted"
                )


    """


def InputCobaltCFD(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    model_action: str = "merge_model",
    file_format: str = "unformatted",
    precision: str = "double",
    unit_system: utils.UnitSystem = None,
) -> int:
    """

    InputCobaltCFD imports a CobaltCFD file and the corresponding bc file.
     Please have in mind that mesh is imported in Light Volume Representation (LVR).

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset".
            (Default: "offset")

    elements_id : str, optional
            Accepted values: "offset".
            (Default: "offset")

    properties_id : str, optional
            Accepted values: "offset".
            (Default: "offset")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    file_format : str, optional
            Accepted values: "formatted" and "unformatted".
            (Default: "unformatted")

    precision : str, optional
            Accepted values: "single" and "double".
            (Default: "double")

    unit_system : utils.UnitSystem, optional
            A UnitSystem object. Dictates the length unit from which the input
            will be scaled to the existing ANSA length unit setting.
            If left blank, no scaling occurs.

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputCobaltCFD(
                    filename="C:/temp/users/folder/data.grd",
                    file_format="formatted",
                    precision="single",
                )


    """


def GetContactClearanceTabularDataValues(contact: object, fields: object) -> object:
    """

    Gets tabular data values from a contact using its Edit Card. The labels are taken from the fields in the edit card.

    Parameters
    ----------
    contact : object
            A reference to a contact entity.

    fields : object
            A list of card field labels to extract the values from.

    Returns
    -------
    object
            Returns a Dictionary with the requested labels as keys and the retrieved values as the dictionary's values.

    See Also
    --------
    SetContactClearanceTabularDataValues

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                contact = base.GetEntity(constants.ABAQUS, "CONTACT_PAIR", 2)
                vals = base.GetContactClearanceTabularDataValues(
                    contact, {"BOLT", "ANGLE", "PITCH", "datalines"}
                )
                print(vals)


    """


def SetContactClearanceTabularDataValues(contact: object, fields: object) -> int:
    """

    Sets the tabular data values of an existing contact.

    Parameters
    ----------
    contact : object
            The contact entity whose tabular data will be set.

    fields : object
            A dictionary with keys the name of the card labels and values the desired card field values.

    Returns
    -------
    int
            Returns 0 on success or 1 otherwise.

    See Also
    --------
    GetContactClearanceTabularDataValues

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                node1 = base.GetEntity(constants.ABAQUS, "NODE", 1)
                node2 = base.GetEntity(constants.ABAQUS, "NODE", 2)
                contact = base.GetEntity(constants.ABAQUS, "CONTACT_PAIR", 2)
                ret = base.SetContactClearanceTabularDataValues(
                    contact,
                    {
                        "BOLT": "YES",
                        "ANGLE": 25.81,
                        "PITCH": 2.57,
                        "datalines": (
                            {"defined by": "NODE", "NODE": node1, "VALUE": 0.547},
                            {
                                "defined by": "NODE",
                                "NODE": node2,
                                "VALUE": 0.547,
                                "Ax": 0.1,
                                "Ay": 1.2,
                                "Az": 0.258,
                                "Bx": 0.1,
                                "By": 1.2,
                                "Bz": 0.258,
                            },
                        ),
                    },
                )
                print(ret)


    """


def GetContactInterferenceValues(contact: object) -> object:
    """

    Gets contact interference values from a contact using its Edit Card. The labels are taken from the fields in the edit card.

    Parameters
    ----------
    contact : object
            A reference to a contact entity.

    Returns
    -------
    object
            Returns a list of dictionaries, containing the contact interference values. Each dictionary contains the contact interference values of a step.

    See Also
    --------
    SetContactInterferenceValues

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                contact = base.GetEntity(constants.ABAQUS, "CONTACT_PAIR", 2)
                vals = base.GetContactInterferenceValues(contact)
                print(vals)


    """


def SetContactInterferenceValues(contact: object, fields: object) -> int:
    """

    Sets the contact inteference values of an existing contact.

    Parameters
    ----------
    contact : object
            The contact entity whose contact interference data will be set.

    fields : object
            A list of dictionaries, containing the contact interference values. Each dictionary should contain the contact interference values of a step. The keys of each dictionary should be the card labels and values the desired card field values.

    Returns
    -------
    int
            Returns 0 on success or 1 otherwise.

    See Also
    --------
    GetContactInterferenceValues

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                contact1 = base.GetEntity(constants.ABAQUS, "CONTACT_PAIR", 2)

                ret = base.SetContactInterferenceValues(
                    contact=contact1,
                    fields=[
                        {"STEP": 1, "OP": "NEW", "V": 2.444, "X": 0.22, "Y": 0.145, "Z": 0.356},
                        {"STEP": 2, "OP": "MOD", "V": 1.11, "X": 0.11, "Y": 0.33, "Z": 0.23},
                    ],
                )
                print(ret)


    """


def DrawingLineAntiAliasingSetEnabled(enabled: bool):
    """

    Enables or disables drawing line anti-aliasing

    Parameters
    ----------
    enabled : bool
            Set to False in order to disable line anti-aliasing; otherwise True

    Examples
    --------
    ::

            # PYTHON script
            import ansa
            from ansa import base
            from ansa import guitk


            def main():
                window = guitk.BCWindowCreate("Line AA Test", guitk.constants.BCOnExitDestroy)
                button = guitk.BCToolButtonCreate(
                    window, "", "Line AA Enable", onLineAntiAliasChanged, None
                )
                guitk.BCButtonSetToggleButton(button, True)
                guitk.BCButtonSetToggledFunction(button, onLineAntiAliasChanged, None)

                guitk.BCShow(window)


            def onLineAntiAliasChanged(button, state, data):
                base.DrawingLineAntiAliasingSetEnabled(state)


            if __name__ == "__main__":
                main()


    """


def DummyArticulationWindow(
    dummy_element: object,
    show_rotate: bool,
    show_translate: bool,
    show_match_points: bool,
    show_lumbar: bool,
):
    """

    This function launches the Dummy Articulation Tool.

    Parameters
    ----------
    dummy_element : object, optional
            In case of more than one Dummies, a random element of the needed Dummy can be defined. Default value is None.

    show_rotate : bool, optional
            Option to show or hide the Rotate tab. Default value is True.

    show_translate : bool, optional
            Option to show or hide the Translate tab. Default value is True.

    show_match_points : bool, optional
            Option to show or hide the Match Points/Interactive tab. Default value is True.

    show_lumbar : bool, optional
            Option to show or hide the Lumbar operations tab. Default value is True.

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import base


            def main():
                base.DummyArticulationWindow(show_match_points=False)


            if __name__ == "__main__":
                main()


    """


def SeatPositionWizard(
    seat_fore_aft_configuration: object,
    bearing_configuration: object,
    seat_height_configuration: object,
    seat_back_angle_configuration: object,
    head_restraint_height_configuration: object,
    head_restraint_fore_aft_configuration: object,
    base_tilt_configuration: object,
    skip_seat_fore_aft: bool,
    skip_seat_height: bool,
    skip_seat_back_angle: bool,
    skip_head_restraint_height: bool,
    skip_head_restraint_fore_aft: bool,
    skip_base_tilt: bool,
) -> int:
    """

    This function launches the Seat Positioning Tool.

    Parameters
    ----------
    seat_fore_aft_configuration : object, optional
            The Kinematic Configuration of the seat fore/aft
            adjustment.

    bearing_configuration : object, optional
            The bearing's Kinematic Configuration.

    seat_height_configuration : object, optional
            The Kinematic Configuration of the seat height adjustment.

    seat_back_angle_configuration : object, optional
            The Kinematic Configuration of the seat back angle
            adjustment.

    head_restraint_height_configuration : object, optional
            The Kinematic Configuration of the head restraint height
            adjustment.

    head_restraint_fore_aft_configuration : object, optional
            The Kinematic Configuration of the head restraint fore/aft
            adjustment.

    base_tilt_configuration : object, optional
            The Kinematic Configuration of the seat base tilt
            adjustment.

    skip_seat_fore_aft : bool, optional
            True to skip the seat fore/aft adjustment or False to not.

    skip_seat_height : bool, optional
            True to skip the seat height adjustment or False to not.

    skip_seat_back_angle : bool, optional
            True to skip the seat back angle adjustment or False to
            not.

    skip_head_restraint_height : bool, optional
            True to skip the head restraint height adjustment or False
            to not.

    skip_head_restraint_fore_aft : bool, optional
            True to skip the head restraint fore/aft adjustment or
            False to not.

    skip_base_tilt : bool, optional
            True to skip the seat base tilt adjustment or False to
            not.

    Returns
    -------
    int
            Returns 1 on OK or 0 on failure or Cancel.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.SeatPositionWizard(skip_base_tilt=True)


    """


def InputActran(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    sets_id: str = "offset",
    read_comments: str = "off",
    merge_sets_by_name: str = "off",
    paste_nodes_by_name: str = "off",
    tolerance_paste_nodes_by_name: float = 0.0,
    new_include: str = "off",
    merge_parts: str = "on",
    comment_input_general_comments: str = "on",
    comment_input_name_comment: str = "on",
    comment_input_inline_include: str = "on",
    comment_input_connection: str = "on",
    comment_input_parts_groups: str = "on",
    comment_input_colors: str = "on",
    comment_input_numb_rules: str = "on",
    comment_input_misc: str = "on",
    comment_input_lock_views: str = "on",
    model_action: str = "merge_model",
    comment_input_annotations: str = "on",
    coords_id: str = "offset",
    comment_input_attributes: str = "on",
    perform_material_synchronization: str = "",
    comment_input_ids: str = "on",
    comment_input_laminates: str = "on",
    comment_input_fe_perimeters: str = "on",
    paste_nodes_by_id: str = "off",
    store_unsupported_keywords_to_include: str = "off",
    read_hmcomments: str = "off",
) -> int | Entity:
    """

    The InputActran function imports a Actran model file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old"
            or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    sets_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    read_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_sets_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    paste_nodes_by_name : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    tolerance_paste_nodes_by_name : float, optional
            Used by paste_nodes_by_name and paste_nodes_by_id
            (Default: 0.0)

    new_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    merge_parts : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_general_comments : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_name_comment : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_inline_include : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_connection : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_parts_groups : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_colors : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_numb_rules : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_misc : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_lock_views : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
             (Default: "merge_model")

    comment_input_annotations : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    coords_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "keep-new".
            (Default: "offset")

    comment_input_attributes : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    perform_material_synchronization : str, optional
            Accepted values: "on" or "off".
            If left blank, the current ANSA defaults value is assumed.

    comment_input_ids : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_laminates : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    comment_input_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "on")

    paste_nodes_by_id : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    store_unsupported_keywords_to_include : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    read_hmcomments : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    Returns
    -------
    int | Entity
            Returns 1 on success and 0 on failure. If the "new_include" argument is enabled, it returns
            a reference to a new INCLUDE containing all the newly imported entities or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputActran("C:/temp/users/folder/data.edat")


    """


def OutputActran(
    filename: str,
    mode: str,
    write_comments: str,
    output_numbering_rules: str,
    output_parts_in_xml: str,
    output_all_same_directory: str,
    comment_output_name_comment: str,
    comment_output_parts_groups: str,
    comment_output_connections: str,
    comment_output_colors: str,
    comment_output_general_comments: str,
    comment_output_info: str,
    comment_output_misc: str,
    comment_output_lock_views: str,
    comment_output_annotations: str,
    comment_output_attributes: str,
    comment_output_ids: str,
    comment_output_laminates: str,
    comment_output_fe_perimeters: str,
    model_check: str,
    model_check_template: str,
    cancel_output_if_model_check_error: str,
    comment_output_mbcontainers: str,
    use_relative_name_for_readonly_includes: str,
    force_relative_reference: str,
) -> int:
    """

    This function outputs a Actran format file like the FILE>OUTPUT>ACTRAN functionality.

    Parameters
    ----------
    filename : str
            The name of the output file. must reference the full path
            to the file.

    mode : str, optional
            "all", "model", "visible" or "custom_mbcontainer".
            The mode "custom_mbcontainer" can only be used
            along with the mbcontainer argument.
            (Default: what set at the last execution)

    write_comments : str, optional
            "on", "above_key", "as_v_11_2_4", "none",
            "off" or "at_eof".
            (Default: what set at the last execution)

    output_numbering_rules : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_parts_in_xml : str, optional
            "on" or "off".
            (Default: what set at the last execution)

    output_all_same_directory : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_name_comment : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_parts_groups : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_connections : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_colors : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_general_comments : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_info : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_misc : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_lock_views : str, optional
            "on" or "off".
            (Default: "off")

    comment_output_annotations : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_attributes : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_ids : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_laminates : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_fe_perimeters : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_check : str, optional
            Accepted values: "on" or "off".
            (Default: "off")

    model_check_template : str, optional
            The name of template to run if model_check is "on".

    cancel_output_if_model_check_error : str, optional
            "on" or "off".
            (Default: "on")

    comment_output_mbcontainers : str, optional
            "on" or "off".
            (Default: "on")

    use_relative_name_for_readonly_includes : str, optional
            "on" or "off".
            (Default: "off")

    force_relative_reference : str, optional
            "on" or "off".
            (Default: "off")

    Returns
    -------
    int
            Returns 1 on success, 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputActran(
                    filename="C:/users/folder/data.edat",
                    mode="visible",
                    output_all_same_directory="on",
                )


    """


def DrawPerAttribute(entity_type: str, attribute_name: str):
    """

    This function draws entities according to the value of a specific parts/subsystem/property/material attribute.

    Parameters
    ----------
    entity_type : str, optional
            The entity type of the attribute to draw. If empty, the Draw per Attribute window opens to select the entity type and attribute name. Accepted values: ANSAPART, ANSA_SUBSYSTEM, PROPERTY, MATERIAL.

    attribute_name : str, optional
            The attribute name according to which the entities are drawn. If empty, the Draw per Attribute window opens to select the entity type and attribute name.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def openWindowToSelectAttribute():
                base.DrawPerAttribute()


            def openWindowToSelectPartAttribute():
                base.DrawPerAttribute(entity_type="ANSAPART")


            def DrawPerPartVersion():
                base.DrawPerAttribute(entity_type="ANSAPART", attribute_name="Version")


    """


def CrossSectionsCutAreaBest(
    location: object,
    search_radius: float,
    vector_point: object,
    section_type: str,
    corner_angle: float,
    part: object,
    adapt_location: bool,
    scan_angle: float,
) -> object:
    """

    Creates the Cross Section with the minimum area, that intersects elements inside a spherical region.

    Parameters
    ----------
    location : object
            Possible values are:
            a) An entity, whose cog is taken as point
            b) A list of three doubles to define a point

    search_radius : float
            The radius of a sphere that defines the search area.

    vector_point : object, optional
            A list of three doubles that defines a vector with reference to the argument "location".
            This vector represents a draft proposed estimation of the normal vector
            of cross section plane.

    section_type : str, optional
            Defines the section type of the created beam properties.
            Accepted values: "general", "equivalent_box", "pbmsect" or "arbitrary".
            (Default: "general")

    corner_angle : float, optional
            Defines the maximum angle (in degrees) between two consecutive
            section segments, in order for both segments to be represented in the
            same Cross Section curve. If the angle of the segments exceeds the
            defined value, the Cross Section curve will be broken at their matching
            point.
            Accepted values: 0 - 45
            (Default: 30)

    part : object, optional
            The part in which the cross section will be included.

    adapt_location : bool, optional
            Defines whether the location will be adjusted to the elements that are inside
            the search area.
            (Default: True)

    scan_angle : float, optional
            Defines the scan range of the vector defined from location and vector_point.
            The option has effect only if a "vector_point" has been provided.
            Accepted values: (0, 90]
            (Default: 35)

    Returns
    -------
    object
            In case of success, returns the created Cross Section entity, otherwise None.

    See Also
    --------
    CrossSectionsCut, CrossSectionsMulticut

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                point = [760.0, 90.0, 0.0]

                cs_1 = base.CrossSectionsCutAreaBest(
                    location=point, search_radius=100.0, corner_angle=3.0
                )

                shell_586 = base.GetEntity(constants.NASTRAN, "SHELL", 586)
                cs_2 = base.CrossSectionsCutAreaBest(location=shell_586, search_radius=150.0)


    """


def CalculateSimilarityOfCastingParts(
    part: object,
    ref_parts: object,
    ref_sym_parts: object,
    target_length: float,
    min_thickness: float,
    auto_symmetry: bool,
) -> object:
    """

    Compares a part with the reference parts. It works on solid description geometry parts.

    Parameters
    ----------
    part : object
            The part that will be compared with the reference parts.

    ref_parts : object
            A list of the reference parts that lay at the same position as the part.

    ref_sym_parts : object
            A list of the reference parts that are symmetrical to the part, with reference to the default symmetry plane.

    target_length : float
            The target element length, must be >= minimum thickness.

    min_thickness : float
            The minimum thickness of the casting part(s), must be > 0.

    auto_symmetry : bool, optional
            If set to True, the reference parts are checked if they are symmetrical to the part, with reference to the default symmetry plane.

    Returns
    -------
    object
            Returns a dictionary.
            The keys are the reference parts, and the values are dictionaries that contain the result of the comparison.
            values = { "identical_ratio": float, "similar_ratio": float, "diff_ratio": float, "diff_regions": integer, "diff_regions_ext_length": float }

            identical_ratio: The surface that is identical with the reference part divided by the total part surface. Value range: [0,1]

            similar_ratio:   The surface that is similar with the reference part divided by the total part surface. Value range: [0,1]

            diff_ratio:      The surface that is different to the reference part divided by the total part surface. Value range: [0,1]

            diff_regions:    The number of connectivity groups of the diff faces.

            diff_regions_ext_length: The accumulated length of all the external perimeters of the diff faces. I.e. the boundary between diff faces and similar/identical faces.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base


            def main():
                curr_part = base.GetPartFromName("curr_part")

                cand_ref_parts = []
                cand_ref_parts.append(base.GetPartFromName("ref_part1"))
                cand_ref_parts.append(base.GetPartFromName("ref_part2"))
                cand_ref_parts.append(base.GetPartFromName("ref_part3"))

                cand_ref_symmetry_parts = []
                cand_ref_symmetry_parts.append(base.GetPartFromName("ref_symmetry_part1"))
                cand_ref_symmetry_parts.append(base.GetPartFromName("ref_symmetry_part2"))

                ret_dict = base.CalculateSimilarityOfCastingParts(
                    part=curr_part,
                    ref_parts=cand_ref_parts,
                    ref_sym_parts=cand_ref_symmetry_parts,
                    target_length=4.0,
                    min_thickness=2.0,
                )

                min_diff_ratio = 1.0
                min_diff_part = None

                for part, result in ret_dict.items():
                    if min_diff_ratio > result["diff_ratio"]:
                        min_diff_ratio = result["diff_ratio"]
                        min_diff_part = part
                    print("Reference Part: ", part)
                    print("identical ratio: ", result["identical_ratio"])
                    print("similar ratio: ", result["similar_ratio"])
                    print("diff ratio: ", result["diff_ratio"])
                    print("number of diff regions: ", result["diff_regions"])
                    print(
                        "length of external perimeters of the diff regions: ",
                        result["diff_regions_ext_length"],
                    )
                if min_diff_part is not None:
                    print("Most similar reference Part:", min_diff_part)


            if __name__ == "__main__":
                main()


    """


def CalcTshellThetaByVector(deck: int, element: object, vector: object) -> float:
    """

    A function that calculates a thick shell's theta angle according to a given vector.

    Parameters
    ----------
    deck : int
            The deck that the angle will be calculated

    element : object
            The thick shell object.

    vector : object
            A list defining a 3d vector.

    Returns
    -------
    float

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                element = base.GetEntity(ansa.constants.ABAQUS, "CONTINUUM SHELL", 1)
                vector = (0.707, 0.707, 0.0)

                angle = base.CalcTshellThetaByVector(ansa.constants.ABAQUS, element, vector)
                print("Continuum Shell theta using vector {} is {}".format(vector, angle))


    """


def CalcCohesiveThetaByVector(deck: int, element: object, vector: object) -> float:
    """

    A function that calculates a cohesive element's theta angle according to a given vector.

    Parameters
    ----------
    deck : int
            The deck that the angle will be calculated

    element : object
            The cohesive element object.

    vector : object
            A list defining a 3d vector.

    Returns
    -------
    float

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                element = base.GetEntity(ansa.constants.ABAQUS, "COHESIVE", 1)
                vector = (0.707, 0.707, 0.0)

                angle = base.CalcCohesiveThetaByVector(ansa.constants.ABAQUS, element, vector)
                print("Cohesive element's theta using vector {} is {}".format(vector, angle))


    """


def OrientShellEdges(shells: object, edge: object) -> int:
    """

    Just like its GUI counterpart (Elements->SHELL->"Orient by Edge") this function orients selected shells according to a given edge direction by rotating their nodes.

    The edge, that is provided as argument, must belong to a shell element that is connected to the selected shells.

    Parameters
    ----------
    shells : object
            A list of shells. These shells will be oriented by the function.

    edge : object
            An edge that will be used to orient the given shells.

    Returns
    -------
    int
            Returns 0 in all cases.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                set = base.GetEntity(constants.NASTRAN, "SET", 3)
                shells = base.CollectEntities(constants.NASTRAN, set, "SHELL")
                edge = base.Entity(constants.NASTRAN, 52, "SHELL", edge_index=1)
                ret = base.OrientShellEdges(shells, edge)


    """


def LaminatePlybookWindow(laminates: object) -> int:
    """

    Opens a Laminate tool's Generate Plybooks window for the given Laminates.

    Parameters
    ----------
    laminates : object
            A list with laminate properties.

    Returns
    -------
    int

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa import session


            def main():
                session.New("discard")
                base.InputNastran("/home/user/laminates.nas")
                deck = base.CurrentDeck()

                laminates = base.CollectEntities(deck, None, "LAMINATE")
                ret = base.LaminatePlybookWindow(laminates)
                print(ret)


    """


def CalculateAverageMinMaxElementLength(elements: object) -> object:
    """

    This function calculates the average, minimum and maximum element length of a given list with shells or solids.

    Parameters
    ----------
    elements : object
            A list containing the shells or solids to be processed.

    Returns
    -------
    object
            If is True, a dictionary with three values for "average", "min" and "max" is returned.
            Else None is returned.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                elements = base.CollectEntities(
                    constants.NASTRAN, None, ["SHELL", "SOLID"], filter_visible=True
                )

                dict = {}
                dict = base.CalculateAverageMinMaxElementLength(elements)
                print("Average = ", dict.get("average"))
                print("Min = ", dict.get("min"))
                print("Max = ", dict.get("max"))


    """


def GPWGInfo(apply_on: str, custom_entities: object) -> object:
    """

    Calculates the mass and the inertia properties of a given model.
    Entities with generalized material propeties are taken into account.
    Calculated values are returned in a python object.

    Parameters
    ----------
    apply_on : str
            Specifies the target elements for which
            the calculation will be held.
            Accepted values:
            -"whole_db": whole database
            -"visible" : only visible entities
            -"custom"  : custom mode.The user must
                         supply the entities
                         for which the calculation
                         will be held

    custom_entities : object, optional
            if the apply_on argument is set to
            "custom", the user must provide the
            entities for which the calculation will
            be held.
            The object can be either a list of
            ANSA entities or an ANSA entity
            (including SETs, PROPERTIEs, PARTs,
            INCLUDEs)

    Returns
    -------
    object
            Retrun a python object on success, otherwise None.

            The returned object contains the following members:
            mass: (double) The mass: Tuple, (Mx, My, Mz)
            cog : (double) The center of gravity: Tuple of 3 tuples,
                           (X-COGx, Y-COGx, Z-COGx)
                           (X-COGy, Y-COGy, Z-COGy)
                           (X-COGz, Y-COGz, Z-COGz)
            IS  : (double) The inertia tensor about the COG: Tuple of 3 tuples,
                           (ISxx, ISxy, ISxz)
                           (ISyx, ISyy, ISyz)
                           (ISzx, ISzy, ISzz)
            IQ  : (double) The pricipal inertias: Tuple of 3 tuples,
                           (IQ1, O.O, O.O)
                           (0.0, IQ2, 0.0)
                           (0.0, 0.0, IQ3)
            S   : (double) The direction of mass axes system: Tuple of 3 tuples,
                           (Sxx, Syx, Szx)
                           (Sxy, Syy, Szy)
                           (Sxz, Syz, Szz)
            Q   : (double) The pricipal axes of pricipal inertias: Tuple of 3 tuples,
                           (Qxx, Qyx, Qzx)
                           (Qxy, Qyy, Qzx)
                           (Qzx, Qyz, Qzz)

    See Also
    --------
    ansa.base.DeckMassInfo

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                conm1s = []
                for i in range(1, 5):
                    conm1s.append(base.GetEntity(constants.NASTRAN, "CONM1", i))
                mass_info = base.GPWGInfo(apply_on="custom", custom_entities=conm1s)
                print(mass_info.mass)
                print(mass_info.cog)
                print(mass_info.IS)
                print(mass_info.IQ)
                print(mass_info.S)
                print(mass_info.Q)

                dmig = base.GetEntity(constants.NASTRAN, "DMIG", 37)
                mass_info = base.GPWGInfo(apply_on="custom", custom_entities=dmig)
                print(mass_info.mass)

                cmass_prop = base.GetEntity(constants.NASTRAN, "PMASS", 2)
                if cmass_prop:
                    mass_info = base.GPWGInfo(apply_on="custom", custom_entities=cmass_prop)
                    print(mass_info.mass)
                mass_info = base.GPWGInfo(apply_on="whole_db")
                print(mass_info.mass)
                print(mass_info.cog)

                mass_info = base.GPWGInfo(apply_on="visible")
                print(mass_info.IS)
                print(mass_info.IQ)


    """


def CreateBsplCurve(
    control_pnts: object, knot_vector: object, degree: int, part: object
) -> object:
    """

    This function defines B-splines curves from a number of control points and a knot vector.

    Parameters
    ----------
    control_pnts : object
            A list with lists of x, y, z coordinates defining the control points of the B-spline curve.

    knot_vector : object
            A list of the values of the knot vector of the B-spline curve.

    degree : int
            The degree of the B-spline curve.

    part : object, optional
            The part of the created curve.

    Returns
    -------
    object
            Returns the created curve, otherwise None.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def create_bspl_curve():
                cps = []
                cps.append([81.83, -155.675, 290.908])
                cps.append([81.668, -155.82, 289.97])
                cps.append([81.265, -156.4, 288.15])
                cps.append([80.508, -158.1, 285.88])
                cps.append([79.677, -160.42, 284.3])
                cps.append([79.13, -162.23, 283.8])
                cps.append([78.87, -163.155, 283.72])

                rkno = [0.0, 0.0, 0.0, 0.0, 0.25, 0.5, 0.75, 1.0, 1.0, 1.0, 1.0]
                deg = 3

                curve = base.CreateBsplCurve(cps, rkno, deg)
                print(curve)


    """


def CreateCurvesAtTubesCenterLine(input_ents: object) -> object:
    """

    Creates curves at tubes center line.

    Parameters
    ----------
    input_ents : object
            A list of faces and shells.

    Returns
    -------
    object
            Returns a dictionary.
            The keys are the curves and the values are dictionaries that contain information about the curves.
            values = {"diameter": float}

            diameter: The diameter of the tube for which the curve was created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ents = base.CollectEntities(constants.NASTRAN, None, "FACE")
                ents2 = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                ents.extend(ents2)
                curve_dict = base.CreateCurvesAtTubesCenterLine(input_ents=ents)

                for curve, info_dict in curve_dict.items():
                    print("curve: ", curve, " , diameter ", info_dict["diameter"])


    """


def GetModuleWithSolverId(solver_id: int) -> object:
    """

    GetModuleWithSolverId finds a module by its solver id. All solver ids should be unique for the function to work correctly, otherwise the module found might be the wrong one.

    Parameters
    ----------
    solver_id : int
            The module's solver id.

    Returns
    -------
    object
            Returns the module found for the given solver id, or none if no module was found.

    Examples
    --------
    ::

            # assume there is a GRID with id 5, in a module with solver id 12
            # and we want to get that GRID by using GetEntity
            grid_with_id_5 = GetEntity(
                ansa.constants.NASTRAN, "GRID", 5, module=GetModuleWithSolverId(12)
            )
            print(grid_with_id_5)


    """


def OutputTAITHERM(filename: str, mode: str) -> int:
    """

    This function outputs a TAITHERM format file, like the FILE>OUTPUT>TAITHERM functionality.

    Parameters
    ----------
    filename : str, optional
            The name of the output file. Must reference the full path to the file.
            (Default: The path of the current working directory and the name of the model)

    mode : str, optional
            "all" or "model" or "visible".
            (Default: what set at the last execution)

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                base.OutputTAITHERM("/home/test.tdf", "all")


    """


def InputTAITHERM(
    filename: str,
    nodes_id: str = "offset-freeid",
    elements_id: str = "offset-freeid",
    properties_id: str = "offset-freeid",
    materials_id: str = "offset-freeid",
    params_action: str = None,
    model_action: str = "merge_model",
) -> int:
    """

    This function imports a TAITHERM format file in ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    materials_id : str, optional
            Accepted values: "offset", "offset:value", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    params_action : str, optional
            Accepted values: "overwrite" or "skip".
            (Default: what set at the last execution)

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 1 on success and 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputTAITHERM(filename="/home/test.tdf", elements_id="offset")


    """


def AirbagRefGeometryNodeFill(airbag: object, nodes: object):
    """

    Fills an AIRBAG_RG entity with AIRBAG_REFERENCE_GEOMETRY_NODE entities.

    Parameters
    ----------
    airbag : object
            The AIRBAG_RG entity that will be filled with nodes

    nodes : object
            A list with AIRBAG_REFERENCE_GEOMETRY_NODE entities

    Examples
    --------
    ::

            import ansa
            from ansa import *


            def main():
                nodes = base.CollectEntities(constants.LSDYNA, None, "NODE")
                arefg_nodes = []
                for n in nodes:
                    fields = {
                        "NID": n._id,
                        "X": n.position[0] * 2.0,
                        "Y": n.position[1] * 2.0,
                        "Z": n.position[2] * 2.0,
                    }
                    arefg_nodes.append(
                        base.CreateEntity(
                            constants.LSDYNA, "AIRBAG_REFERENCE_GEOMETRY_NODE", fields
                        )
                    )
                airbag = base.CreateEntity(constants.LSDYNA, "AIRBAG_RG")

                base.AirbagRefGeometryNodeFill(airbag, arefg_nodes)


            if __name__ == "__main__":
                main()


    """


def ReadCustomCSVFile(
    filename: str, delimiter: str, preview: bool, has_header: bool, comment_prefix: str
) -> object:
    """

    Reads a custom CSV file using a user-specified delimiter (or ',' if not specified) and returns a dictionary containing the data.

    Parameters
    ----------
    filename : str
            The file to be read.

    delimiter : str, optional
            The delimiter used in the file (default is ',').

    preview : bool, optional
            If true, then only the first ten (10) data lines of the file are processed (default is false).

    has_header : bool, optional
            If true, the reader is forced to interpret the first non-comment line of the file as a header line (default is false).

    comment_prefix : str, optional
            Lines begining with this prefix will be treated as comment lines (i.e. ignored) (default is none)

    Returns
    -------
    object
            Returns a dictionary. Its keys are the names of columns of data as read from file. If a header line exists, it is used to name each column, otherwise columns are named according to their position in the file, i.e. COLUMN_1, COLUMN_2, etc. The data for each key is a list of all the values belonging to the corresponding column. Values in each list keep their order of appearence in the file.

    Examples
    --------
    ::

            import os
            import ansa


            def main():
                fn = "some_CSV_file.txt"
                dict = ansa.base.ReadCustomCSVFile(filename=fn, preview=True)

                if dict:
                    for key, dt in dict.items():
                        print(key)
                        for val in dt:
                            print("\\t{}".format(val))
                        print("==========")


            if __name__ == "__main__":
                main()


    """


def ChangePcompToLaminate(deck: int, pcomp: object) -> object:
    """

    This function changes a PCOMP property to a LAMINATE property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH

    pcomp : object
            A PCOMP property

    Returns
    -------
    object
            Always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.NASTRAN
                prop = base.GetEntity(deck, "PCOMP", 1)
                base.ChangePcompToLaminate(deck, prop)


    """


def ShowEntitiesList(deck: int, types: object, entities: object) -> object:
    """

    Shows the ansa help list that corresponds to ENTITY_TYPES defined through the argument
    "types" or (optional) ENTITIES explicitly defined through the argument "entities".

    Parameters
    ----------
    deck : int
            The deck constant.

    types : object
            A list of types that will be listed.

    entities : object, optional
            A list of entities that will be listed.

    Returns
    -------
    object
            Always returns None.

    See Also
    --------
    SelectEntitiesList

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Show all "SHELL" entities
                types = ["SHELL"]
                base.ShowEntitiesList(constants.NASTRAN, types)

                # Show specific "SHELL" entities of ids: 1, 3 and 7
                entities = []
                entities.append(base.GetEntity(constants.NASTRAN, "SHELL", 1))
                entities.append(base.GetEntity(constants.NASTRAN, "SHELL", 3))
                entities.append(base.GetEntity(constants.NASTRAN, "SHELL", 7))
                base.ShowEntitiesList(constants.NASTRAN, types, entities=entities)


    """


def GetAnsaGroups(deck: int, source: object):
    """

    The GetAnsaGroups returns a list of ansa groups that exist in current model or all model groups supported in selected deck.

    Parameters
    ----------
    deck : int
            The deck constant.

    source : object, optional
            - "in_model" to get all existing model groups in current model
            - "all" to get all model groups supported in selected deck (default value).

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                types = base.GetAnsaGroups(constants.NASTRAN, "in_model")
                print(", ".join(types))
                for type in types:
                    base.CreateNumberingRule(
                        constants.NASTRAN, "TOOL", None, type, "PER_GROUP", 1, 1000000, "group_rule"
                    )


            if __name__ == "__main__":
                main()


    """


def GetInterfaceBoundaryContents(ib: object) -> object:
    """

    Colects and returns all entities that belong to an Interface Boundary entity.

    Parameters
    ----------
    ib : object
            An ANSA entity of type INTERFACE BOUNDARY

    Returns
    -------
    object
            A list with ANSA entities of type G_MASEGM or SHELLEDGE.

    See Also
    --------
    DefineInterfaceBoundary, SmartPaste

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ib = base.GetEntity(ansa.constants.NASTRAN, "INTERFACE BOUNDARY", 1)
                ib_contents = base.GetInterfaceBoundaryContents(ib)
                print(ib_contents)


    """


def ResultsMapperStoreInterpolationWeights(mapper: object, store: bool) -> int:
    """

    Instruct Results Mapper to store the calculated interpolation weights. This function is used in conjunction with ResultsMapperGetInterpolationWeights. ResultsMapperStoreInterpolationWeights is called prior to Results Mapper application. After succesfull application, ResultsMapperGetInterpolationWeights is used in order to obtain the interpolation weights that were used in the mapping of various results types.

    Parameters
    ----------
    mapper : object
            the Results  Mapper entity

    store : bool
            Set to True in order to store interpolation weights, False otherwise.

    Returns
    -------
    int
            Returns 1 upon success.

    See Also
    --------
    ResultsMapperGetInterpolationWeights

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # For this example, it is assumed that two properties with ids 1 and 2 already exist. Propery id:1
                # contains all target shells. Property id:2 is used as source, and has NASTRAN FORCEs on its nodes.
                vals = {
                    "Name": "mapper",
                    "Format": "ANSA PART",
                    "Source Part": "#2",
                    "connectivity": "#1",
                    "Force": "Yes",
                }
                mapper = base.CreateEntity(constants.NASTRAN, "RESULTS_MAPPER", vals)
                base.ResultsMapperStoreInterpolationWeights(mapper, True)
                base.ApplyGenericEntities(mapper)
                interp_data = base.ResultsMapperGetInterpolationWeights(mapper, "Force")
                if interp_data:
                    for key, val in interp_data.items():
                        print("Target entity: {}".format(key))
                        print("   Target has same orientation as sources: {}".format(not val[2]))
                        zipped = zip(val[0], val[1])
                        for ent, wei in zipped:
                            print("   Source entity: {} Weight: {}".format(ent, wei))
                        print("---------------------")


            if __name__ == "__main__":
                main()


    """


def ResultsMapperGetInterpolationWeights(mapper: object, result: str) -> object:
    """

    Retrieves interpolation weights stored in a Results Mapper during the mapping procedure. A call to ResultsMapperStoreInterpolationWeights must precede the Results Mapper application in order for the weights to be available. Interpolation weights are stored for each result type separately, and are retrieved by passing the result type as argument.

    This function returns a dictionary. The keys are the target entities used in the mapping procedure. The value corresponding to each key is a tuple of the form (ents_list, weis_list, must_flip). Here, ents_list is a list of all the source entities that contribute data to the target entity. Each entry in this list is a string of the form <ANSA_KEYWORD>:<ID>. With this, any source entity can be uniquely determined. weis_list is a list of interpolation weights that correspond to each entity in the ents_list, and must_flip is a boolean indicating  whether source and target have the same orientation (False) or they differ in orientation (True).

    Parameters
    ----------
    mapper : object
            The Results Mapper entity

    result : str
            The result type for which interpolation weights are requested

    Returns
    -------
    object
            dictionary with keys target entities and values (ents_list, weis_list, must_flip) tuples (see desctription for details)

    See Also
    --------
    ResultsMapperStoreInterpolationWeights

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # For this example, it is assumed that two properties with ids 1 and 2 already exist. Propery id:1
                # contains all target shells. Property id:2 is used as source, and has NASTRAN FORCEs on its nodes.
                vals = {
                    "Name": "mapper",
                    "Format": "ANSA PART",
                    "Source Part": "#2",
                    "connectivity": "#1",
                    "Force": "Yes",
                }
                mapper = base.CreateEntity(constants.NASTRAN, "RESULTS_MAPPER", vals)
                base.ResultsMapperStoreInterpolationWeights(mapper, True)
                base.ApplyGenericEntities(mapper)
                interp_data = base.ResultsMapperGetInterpolationWeights(mapper, "Force")
                if interp_data:
                    for key, val in interp_data.items():
                        print("Target entity: {}".format(key))
                        print("   Target has same orientation as sources: {}".format(not val[2]))
                        zipped = zip(val[0], val[1])
                        for ent, wei in zipped:
                            print("   Source entity: {} Weight: {}".format(ent, wei))
                        print("---------------------")


            if __name__ == "__main__":
                main()


    """


def ReplaceGroupSegmentsWithSolidFacets(group: object, delete_segments: bool) -> int:
    """

    Given a GROUP that contains appropriate segments, these will be replaced with solid facets. The segments must be immediate contents of the group, so segments contained in children groups won't be replaced.

    Parameters
    ----------
    group : object
            The group whose segments are to be replaced.

    delete_segments : bool, optional
            Option to delete the segments that are left unused when removed from the group
            (Default: False)

    Returns
    -------
    int
            The function will return 0 if the given argument is not a GROUP, otherwise, the
            return value will be 1.

    Examples
    --------
    ::

            import ansa
            from ansa.base import *

            group = GetEntity(ansa.constants.PAMCRASH, "GROUP", 1)
            ReplaceGroupSegmentsWithSolidFacets(group)


    """


def RebuildTopology(entities: object, paste_diff_parts: bool, paste_diff_pids: bool):
    """

    Rebuild topology of selected faces by
    * release CONS
    * set proper length and distortion
    * paste Cons
    * remove geometry errors

    Parameters
    ----------
    entities : object
            A list of ANSA entities of type PART, PROPERTY, SET or FACE. From given entities with type different than FACE we collect Faces that belong to these entities.

    paste_diff_parts : bool, optional
            If this option is set to True, paste operation between CONS belong to different Parts will be allowed. If this argument is not provided the respective value from ANSA defaults will be considered.   (Rebuild Topology Options>REBUILD_TOPOLOGY_PASTE_DIFF_PARTS)

    paste_diff_pids : bool, optional
            If this option is set to True, paste operation between CONS belong to different Pids will be allowed. If this argument is not provided the respective value from ANSA defaults will be considered.   (Rebuild Topology Options>REBUILD_TOPOLOGY_PASTE_DIFF_PIDS)

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import constants
            from ansa import base


            def main():
                base.Open("C:/tmp/users/folder/data.ansa")
                parts = []
                part = base.GetEntity(ansa.constants.NASTRAN, "ANSAPART", 1)
                parts.append(part)
                base.RebuildTopology(entities=parts, paste_diff_parts=False, paste_diff_pids=True)


    """


def InverseFormingExportFldToXlsx(inv_forming: object, filename: str) -> Any:
    """

    Exports the FLD points and curves to an xlsx file

    Parameters
    ----------
    inv_forming : object
            The inverse forming entity

    filename : str
            The filename of the xlsx to be created

    Returns
    -------
    Any

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                filename = "filename.xlsx"
                inv_f = base.GetEntity(ansa.constants.LSDYNA, "INVERSE FORMING", 1)
                base.InverseFormingExportFldToXlsx(inv_f, filename)


            if __name__ == "__main__":
                main()


    """


def InputParaview(
    filename: str,
    nodes_id: str,
    elements_id: str,
    properties_id: str,
    model_action: str,
) -> int:
    """

    Imports a Paraview (Unstructured Grid - *.vtu) file into ANSA.

    Parameters
    ----------
    filename : str
            The path to the filename to import.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or
            "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values: "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window" or
            "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputParaview("C:/temp/users/folder/data.vtu", elements_id="offset")


    """


def OutputParaview(filename: str, mode: str, format: str) -> int:
    """

    Outputs a Paraview (Unstructured Grid - *.vtu) format file.

    Parameters
    ----------
    filename : str
            The name of the output file. It must include the full path.

    mode : str, optional
            "all", "model" or "visible".
            (default: option set in .defaults file)

    format : str, optional
            "ascii" or "binary".
            (default: "ascii")

    Returns
    -------
    int
            Returns 0 on success and 1 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.OutputParaview("C:/temp/users/folder/data.vtu", "all")


    """


def InputKestrel(
    filename: str,
    nodes_id: str,
    elements_id: str,
    properties_id: str,
    model_action: str,
) -> int:
    """

    The InputKestrel function imports an .avm file in ANSA.
    Currently works only for rev. 2, unstructured 3D files.

    Parameters
    ----------
    filename : str
            the path of the file that will be imported.

    nodes_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    elements_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old" or "offset-freeid".
            (Default: "offset-freeid")

    properties_id : str, optional
            Accepted values: "offset", "nooffset", "keep-old", "keep-new" or "offset-freeid".
            (Default: "offset-freeid")

    model_action : str, optional
            Accepted values:
            "overwrite_model", "merge_model",
            "new_model_in_active_window", "new_model_in_new_window"
            or "new_model_in_enabled_windows".
            (Default: "merge_model")

    Returns
    -------
    int

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.InputKestrel("C:/temp/users/folder/data.avm", model_action="overwrite_model")


    """


def ConvertNastranHeaderToLoadcase(nastran_header: object):
    """

    This function converts a Nastran Header to a Loadcase Setup Assistant.

    Parameters
    ----------
    nastran_header : object
            A Nastran Header entity

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.NASTRAN
                header = base.GetEntity(deck, "Nastran Header", 1)
                base.ConvertNastranHeaderToLoadcase(header)


    """


def OutputKestrel(filename: str, mode: str, unit_system: object, scale: float) -> int:
    """

    The OutputKestrel function writes a file in the format required in order to be solved by Kestrel.

    Parameters
    ----------
    filename : str
            The full path and name of the output file

    mode : str, optional
            "all" or "model" or "visible".
            (Default: "all")

    unit_system : object, optional
            A UnitSystem object.
            Dictates the length unit to which the
            output will be scaled from the existing
            ANSA length unit setting.
            If left blank, no scaling occurs.

    scale : float, optional
            A float number for scaling the mesh (scale factor).
            If both scale and unit_system arguments
            are defined, the latter will override the first.
            (Default: 1.0)

    Returns
    -------
    int
            Returns 1 on success and 0 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base, utils
            from ansa import constants


            def main():
                units = utils.UnitSystem(
                    length="inch"
                )  # will internally convert mesh sizes, from current units (e.g. mm) to inches
                base.OutputKestrel("C:/users/data.avm", unit_system=units)


    """


def ImportAbaqusLibrary(imports: object) -> Any:
    """

    Imports models from odb libraries for the selected IMPORT entities

    Parameters
    ----------
    imports : object
            A list of IMPORT entities

    Returns
    -------
    Any

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                abq_imp = base.CollectEntities(constants.ABAQUS, None, "IMPORT", recursive=False)
                base.ImportAbaqusLibrary(abq_imp)


            if __name__ == "__main__":
                main()


    """


def FacesFill(
    axials: object,
    apply_tangency: bool,
    merge_cons: bool,
    part: object,
    property: object,
    set: object,
    improve_mesh: int,
) -> object:
    """

    This script function creates multiple surfaces that fits the elements (CONS, CURVES) of list, in order to host the Fill functionality.
    It takes a list of cons, curves, puts in line the elements of table (automatically) and then creates a faces.

    Parameters
    ----------
    axials : object
            Is a list with entities (CONS, CURVES, ELEMENTS, CONNECTION CURVES etc.).
            A string with value 'visible' or a string with value 'all'.
            The faces will be created based on these entities.

    apply_tangency : bool, optional
            If set to True, the faces will be created respecting start/end tangent vector from input entities` faces.
            (Default: False)

    merge_cons : bool, optional
            Defines whether to merge CONS with the same surface.
            (Default: False)

    part : object, optional
            Defines the Part where the result faces will be added to.

    property : object, optional
            Defines the PID where the result faces will be added to.

    set : object, optional
            Defines the SET where the result faces will be added to.

    improve_mesh : int, optional
            The number of shell zones that will be affected.
            If 0 passed no improvement takes place.
            (Default: 2)

    Returns
    -------
    object
            Returns a list with the created faces, otherwise an empty list.

    See Also
    --------


    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import *


            def main():
                fill_input = []
                for ent in [85, 459, 918, 920, 922, 924, 959, 960]:
                    fill_input.append(base.GetEntity(constants.NASTRAN, "CONS", ent))
                ret = base.FacesFill(fill_input)
                print(ret)


            if __name__ == "__main__":
                main()


    """


def LaminateOffsetInfo(
    deck: int, laminate: object, offset: int, fields: object
) -> object:
    """

    Gets values from an Offset of the specified laminate property.

    Parameters
    ----------
    deck : int
            One of NASTRAN, LSDYNA, ABAQUS, RADIOSS, ANSYS, PERMAS, PAMCRASH, OPTISTRUCT or MARC.

    laminate : object
            A reference to a laminate property.

    offset : int
            The id of the offset to get values from.

    fields : object
            A list of the fields to retrieve info.

            Available fields are:

            name:   The offset's name.
            flag:   The flag of the offset (it is one of "below", "middle", "above", "application_side").
            value:  The offset's value.

    Returns
    -------
    object
            Returns a dictionary with the 'fields' values as keys.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                laminate = base.GetEntity(constants.ABAQUS, "LAMINATE", 1)
                ret = base.LaminateOffsetInfo(
                    constants.ABAQUS, laminate, 1, ("name", "flag", "value")
                )
                print(ret["name"])
                print(ret["flag"])
                print(ret["value"])


    """


def ShowAnsaWindowInfo(window: str, show_title: bool, show_contents: bool):
    """

    Controls "Show Title Info" and "Show Contents Info" status of window

    Parameters
    ----------
    window : str
            Name of ANSA window

    show_title : bool, optional
            Determines whether Title Info (Model name, Current Part, etc) will be displayed or not.

            Default value : True

    show_contents : bool, optional
            Determines whether Contents Info (Shell, Solid, etc) will be displayed or not.

            Default value : True

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                window1 = base.GetAnsaWindow("Main Window")
                base.ShowAnsaWindowInfo(window1, False, False)


    """


class Entity:
    """

    Ansa entities are exported to python as objects of type ansa.base.Entity.
    Such objects are:
    -Returned by functions.
    -Can be created.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants

            # ==============================================================================
            # Getting references to entities

            n = base.CreateEntity(constants.ABAQUS, "NODE")
            nn = base.Entity(constants.ABAQUS, n._id, "NODE")

            if n == nn:
                print("OK: Objects are equal")
            else:
                print("ERROR")

            # ==============================================================================


            nodes = []
            n_coords = [
                (0, 0, 0),
                (1, 0, 0),
                (1, 1, 0),
                (0, 1, 0),
                (0, 0, 1),
                (1, 0, 1),
                (1, 1, 1),
                (0, 1, 1),
            ]
            for i in range(8):
                vals = {}
                for j, v in enumerate(("X1", "X2", "X3")):
                    vals[v] = n_coords[i][j]
                n = base.CreateEntity(constants.NASTRAN, "GRID", vals)
                nodes.append(n)

            vals = {}
            for i, n in enumerate(("G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8")):
                vals[n] = nodes[i]._id
            vals["PID"] = 1
            vals["type"] = "CHEXA"

            solid = base.CreateEntity(constants.NASTRAN, "SOLID", vals)
            facet = base.Entity(constants.NASTRAN, solid._id, "SOLID", facet=1)
            print(facet.ansa_type(constants.NASTRAN))

            edge = base.Entity(constants.NASTRAN, solid._id, "SOLID", edge_index=1)


            # ==============================================================================

            # printing internal representations of entities
            n = base.CreateEntity(constants.ABAQUS, "NODE")
            s = str(n)
            print(s)
            # prints like: Entity: 0x000000001F3BF920: type: 1101(1101,N_GRID) id:-2

            # sorting entities by id
            l = []
            n = base.CreateEntity(constants.ABAQUS, "NODE")
            l.append(n)
            n = base.CreateEntity(constants.ABAQUS, "NODE")
            l.append(n)
            ll = sorted(l, key=lambda e: e._id)
            # checking for defunct objects
            # shell: a Shell with nodes 1, 2, 3, 4
            l = []
            l.append(shell)
            n = base.Entity(constants.ABAQUS, 1, "NODE")

            # the following call with delete the shell
            base.DeleteEntity(n, force=True)

            # now the object in l[0]  has been deleted.
            shell = l[0]
            if not shell.is_usable():
                print("This object is not usable")


            # inheriting from entity
            class myAnsaObject(base.Entity):
                def __init__(self, deck, id, type):
                    super().__init__(deck, id, type)


            def do_stuff():
                n = myAnsaObject(constants.ABAQUS, 1, "NODE")


            # -----------------------------------------------------------------


            def main():
                shell = base.Entity(constants.ABAQUS, "SHELL", 1)
                vals = shell.get_entity_values(constants.ABAQUS, ("G1", "G2", "G3", "G4"))

                print(vals)

                node = base.Entity(constants.ABAQUS, "NODE", 1)
                shell.set_entity_values(constants.ABAQUS, {"G1": node})
                vals = shell.get_entity_values(constants.ABAQUS, ("G1",))

                print(vals)


            def main():
                node = base.CreateEntity(constants.ABAQUS, "NODE")
                node.position = (-12.0193, 0.0, 8.0)
                print(node.position)

                node2 = base.CreateEntity(constants.ABAQUS, "NODE")
                node2.position = node.position
                print(node2.position)


            def main():
                ent = base.GetEntity(ansa.constants.ABAQUS, "SOLID", 16583)

                list = {"G21": 8, "G3": 146564655656}
                debug_mode = constants.REPORT_ALL
                ret, debug_report = ent.set_entity_values(constants.ABAQUS, list, debug=debug_mode)

                if not ret:
                    pprintt.pprint("No errors or warnings found!")
                else:
                    pprint.pprint(debug_report)

    """

    _id: int = None
    """
	Returns the Ansa Entity Id, internal implementation detail.

	"""

    _name: str = None
    """
	Returns the Ansa Entity Name, internal implementation detail.

	"""

    _edge_index: int = None
    """
	The objects edge index (if available). Optional argument for the Entity constructor.

	"""

    _comment: str = None
    """
	Returns the Ansa Entity Comment, internal implementation detail.

	"""

    position: tuple = None
    """
	Directly get and set global x,y,z coordinates for point-like Entities. Supported entities:
	GRIDs, MORPH POINTs, CONNECTION:SpotWeld_Points, CONNECTION:GumDrops
	CONNECTION:Bolts, CONNECTION:Robscans, CONNECTION:Points
	TARGET POINTs, POINTs, CENTERs, HOT POINTs, CONNECTOR ENTITY,  
	GENERIC_ENTITIES_BUILDER, GEB_BC, GEB_OR, GEB_MT
	GEB_SB, GEB_GN, A_POINT, LC_POINT.

	"""

    _bname: str = None
    """
	The entity's name in byte representation.

	"""

    _bcomment: str = None
    """
	The entity's comment in byte representation.

	"""

    def __init__(
        self, deck: int, id: int, type: str, facet: int, edge_index: int
    ) -> Entity:
        """

        Entity object constructor.


        Parameters
        ----------
        deck : int
                The selected deck.

        id : int
                The id of the entity.

        type : str
                The type of the entity.

        facet : int, optional
                If a facet is required, the respective solid facet.

        edge_index : int, optional
                If an element edge is required, the respective edge (starting with 1).

        Returns
        -------
        Entity
                Returns the created Entity object.

        """

    def ansa_type(self, deck: int) -> str:
        """

        Asks the object for its ANSA type.


        Parameters
        ----------
        deck : int
                The ANSA deck.

        Returns
        -------
        str
                A string stating the ANSA type.

        """

    def card_fields(self, deck: int, ret_values: bool = False) -> list | dict:
        """

        Asks the object to return a list with the names of all the active card fields of the object's NASTRAN card.
        If the optional argument "ret_values" is set to True, then both the fields and their values will be returned in a dictionary. This approach is 50% faster than using the "get_entity_values" method.


        Parameters
        ----------
        deck : int
                The deck constant.

        ret_values : bool, optional
                If set to True, then the method will return both the fields and their values in a dictionary.

        Returns
        -------
        list | dict
                Returns a list with the NASTRAN card fields of an entity in the specified deck, or a dictionary with both the fields and their values.

        """

    def is_usable(self) -> bool:
        """

        Checks if the object refers to a usable ANSA entity.


        Returns
        -------
        bool
                Returns True if the Entity is usable. False otherwise.

        """

    def get_entity_values(self, deck: int, fields: Iterable[str]) -> dict:
        """

        Get values from the entity using the edit card's field names. This method works similarly with base.GetEntityCardValues. This method returns directly the entity objects for the fields that reference Entity objects.


        Parameters
        ----------
        deck : int
                The selected deck.

        fields : Iterable[str]
                A list of card field labels to extract the values from.

        Returns
        -------
        dict
                Returns a Dictionary with the requested labels as keys and the retrieved values as the dictionary's values. If the function fails to find the requested fields the dictionary's value will be empty. For the fields that reference Entity object the return dictionary encapsulates these objects.

        """

    def set_entity_values(
        self, deck: int, fields: dict, items: list, debug: int
    ) -> int | tuple:
        """

        Set or change values of the entity using its Edit Card Fields.


        Parameters
        ----------
        deck : int
                The deck type.

        fields : dict
                A dictionary with keys the name of the ANSA card
                labels and values the desired card field values
                fields dictionary you can also use as a pair:

                __table_curves : Curves willing to insert into a table.
                __table_values : The Rate values that will be used
                for the above curves.

        items : list, optional
                A pair of lists, one that contains curves and another that contains x values.
                Only for use with TABLE entities
                (e.g. [ [curve1, curve2, ...], [x1, x2, ...] ])

        debug : int, optional
                If debug is set to ansa.constants.REPORT_ALL returns a tuple that has two items:
                        an integer that values 0 on success, non zero on error
                and     a dictionary that holds any errors / warnings found. This dictionary has as keys the fields that were used upon calling the function and lead to errors / warnings. The data for each field is a dictionary with two keys:
                                'type' that holds the words 'error' or 'warning' as data.
                                'message' that holds the error message generated by this field.

                If debug is ansa.constants.REPORT_SILENCE returns a tuple that has two items:
                        an integer that values 0 on success, non zero on error and an empty dictionary

                If not given ony an integer will be returned.

        Returns
        -------
        int | tuple
                When debug argument is not given: Returns 0 on success, non zero on error.If debug argument is given: Returns a tuple with an integer as before and a dictionary with errors. Note, that if one of the fields results in an error, then none of the other fields will be set.

        """


class Fmvss226:
    """

    Class for the creation of an FMVSS226 loadcase.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def Fmvss226():
                hf = base.GetEntity(constants.LSDYNA, "SET", 7)
                ag = base.GetEntity(constants.LSDYNA, "SET", 6)
                ff = base.GetEntity(constants.LSDYNA, "SET", 2)
                fg = base.GetEntity(constants.LSDYNA, "SET", 1)
                cs = base.GetEntity(constants.LSDYNA, "DEFINE_COORDINATE_NODES_DIR_X", 1)

                obj_226 = base.Fmvss226(
                    front_frame=ff,
                    front_glazing=fg,
                    all_glazings=ag,
                    cid=cs,
                    apply_rules=1,
                    headform=hf,
                )

                obj_226.create_target_points()

                obj_226.create_load_cases(
                    output_path="/users/test/Fmvss226/", write_out_set="ON", use_point_names="ON"
                )

    """

    front_frame: object = None
    """
	Front Frame surface Set.

	"""

    rear_frame: object = None
    """
	Rear Frame surface Set.

	"""

    front_glazing: object = None
    """
	Front Glazing surface Set.

	"""

    rear_glazing: object = None
    """
	Rear Glazing surface Set.

	"""

    dlo_offset: float = None
    """
	Day Light Opening Offset. (Default: 25)

	"""

    headform: object = None
    """
	Headform elements Set.

	"""

    all_glazings: object = None
    """
	All Glazing surfaces Set.

	"""

    cid: object = None
    """
	Headform Coordinate.

	"""

    move_back: float = None
    """
	Move back distance of headform after positioning.

	"""

    apply_rules: int = None
    """
	Apply Reduction Rules. (Default: 1)

	"""

    target_point_id: object = None
    """
	Target Point Entity.

	"""

    third_row_frame: object = None
    """
	Third Row Frame surface Set.

	"""

    third_row_glazing: object = None
    """
	Third Row Glazing surface Set.

	"""

    def create_load_cases(
        self,
        master_filename: str,
        files_prefix_name: str,
        output_path: str,
        transf_filename: str,
        meta_filename: str,
        velocity: float,
        dyna_trsfm_mode: str,
        headform_include: object,
        targets_set: object,
        write_out_set: str,
        use_point_names: str,
        relative_name_includes: bool,
        files_extension: str,
        write_inline: bool,
        skip_subfolders: bool,
    ):
        """

        Initializes the FMVSS226 functionality for multi-positioning of the headform and creation of the load cases.


        Parameters
        ----------
        master_filename : str, optional
                Full path name of master file that contains the
                include hierarchy.

        files_prefix_name : str, optional
                Prefix of include files that will be created.
                Default name is "FMVSS226_Shot".

        output_path : str, optional
                Output directory.

        transf_filename : str, optional
                Name of the Transformation csv file that will be created.
                Default name is "FMVSS226_TransfList.csv".

        meta_filename : str, optional
                Name of the Meta file that will be created.
                Default name is "FMVSS226_MetaList.csv".

        velocity : float, optional
                Velocity of headform. If a value is defined
                previously in target point's card, then the
                function disregards this one.

        dyna_trsfm_mode : str, optional
                Values supported "NODE_TRANSFORM",
                "INCLUDE_TRANSFORM".
                Default is "NODE_TRANSFORM".
                It works for LSDYNA only.

        headform_include : object, optional
                Include of the Fmvss226 Headform. Only if
                DYNA_TRSFM_MODE is "INCLUDE_TRANSFORM".

        targets_set : object, optional
                Set that contains the target points for the
                creation of the load cases. If this is not  defined
                the function works on all database's target points.

        write_out_set : str, optional
                Values supported "ON", "OFF". If this flag is on
                the definition of headform set will be written out
                in the include file.

        use_point_names : str, optional
                Values supported "ON", "OFF" If this flag is on
                the created master files and directories will get
                target point's name.

        relative_name_includes : bool, optional
                Use relative names for includes. This will enable
                the copy of referenced includes that are contained
                in master file, in each target point's directoty. Default value is False

        files_extension : str, optional
                The preferred extension of all the include files that
                will be created (e.g .inc). If left blank the default extension
                of the current deck, will be used.

        write_inline : bool, optional
                Option for writing the Transformation/Velocity keywords inside the Master file.

        skip_subfolders : bool, optional
                Option to skip the creation of a sub-folder for each Target Point.

        """

    def position(self):
        """

        This functions position the Headform according to the values set during initialization.The horizontal impact angle is defined from the corresponding field of the target point entity.


        """

    def create_target_points(self):
        """

        This method calculates all target points and secondary entities for the FMVSS226 - Ejection Mitigation regulation.


        """


class Fmvss201U:
    """

    Class that handles all the FMVSS201U functionality.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_201U():
                op1 = base.Fmvss201U()

                options1 = {
                    "front_sgrp": (3115, -360, 459),
                    "rear_sgrp": (3903, -360, 470),
                    "distance_m": 269.2,
                    "int_surfaces": 1,
                    "ext_surfaces": 6,
                    "a_pillar": 2,
                    "b_pillar": 4,
                    "other_pillar": 5,
                    "rear_pillar": 8,
                    "ip_points": 12,
                    "windscreen": 3,
                    "int_roof": 7,
                    "seatbelt_anchors": 13,
                    "side_openings": 100001,
                    "front_opening_points": 10,
                    "rear_opening": 9,
                    "rear_opening_points": 11,
                    "fmh": 100002,
                    "fiz": 100000,
                    "trim": 1,
                    "fmh_coord": 100000,
                    "fiz_node": 20000,
                }

                op1 = base.Fmvss201U(**options1)
                op1.create_target_points()

                trgt = base.GetEntity(constants.LSDYNA, "TARGET_POINT", 2)

                op1.position(target_point=trgt, mode="full_positioning", save_position=True)
                op1.create_stochastic_circles(target_point=trgt, circles=4, circle_radius=5)
                trgt = base.GetEntity(constants.LSDYNA, "TARGET_POINT", 3)
                op1.position(target_point=trgt, mode="auto_horizontal", save_position=True)
                op1.position(target_point=trgt, mode="reset")
                op1.match_fiz_with_target_point(target_point=trgt)
                op1.save_position(trgt, new_position="MATCHED_FIZ")
                op1.position(target_point=trgt, mode="reset")
                op1.move_to_saved_position(target_point=trgt)

                set = base.GetEntity(constants.LSDYNA, "SET", 100006)

                op1.create_load_cases(
                    files_prefix_name="fmvssshot",
                    output_path="/home/alioras/fem_g/FMVSS201/",
                    transf_filename="TransfListPY.csv",
                    meta_filename="MetalistPY.csv",
                    velocity=7.66,
                    headform=100002,
                    targets_set=set._id,
                    write_out_set=False,
                    use_point_names=True,
                )

    """

    front_sgrp: object = None
    """
	Front Seating Reference Point. A list with (x,y,z) coordinates is required.

	"""

    rear_sgrp: object = None
    """
	Rear Seating Reference Point. A list with (x,y,z) coordinates is required.

	"""

    distance_m: float = None
    """
	Horizontal travel distance of the adjustable front seat in the test vehicle.

	"""

    int_surfaces: object = None
    """
	Internal Surfaces Set.

	"""

    ext_surfaces: object = None
    """
	External Surfaces Set.

	"""

    a_pillar: object = None
    """
	A-Pillar Surfaces Set.

	"""

    b_pillar: object = None
    """
	B-Pillar Surfaces Set.

	"""

    other_pillar: object = None
    """
	Other Pillar Surfaces Set.

	"""

    rear_pillar: object = None
    """
	Rear Pillar Surfaces Set.

	"""

    ip_points: object = None
    """
	A set that contains the highest point at the intersection of the Instrument Panel and the A-Pillar. If the set contains elements or geometry, the tool will calculate the intersection with the A-Pillar automatically.

	"""

    windscreen: object = None
    """
	Windscreen Surfaces Set.

	"""

    int_roof: object = None
    """
	Interior Roof Surfaces Set.

	"""

    seatbelt_anchors: object = None
    """
	Seatbelt Anchor Nodes Set.

	"""

    side_openings: object = None
    """
	Frame elements of Side Doors or DLO Set.

	"""

    front_opening_points: object = None
    """
	Highest Nodes of forwardmost Door Opening and lowest Nodes of 
	forwardmost DLO Set.

	"""

    rear_opening: object = None
    """
	Frame elements of Rear Door or DLO Set.

	"""

    rear_opening_points: object = None
    """
	Highest Nodes of Door Opening and lowest Nodes of DLO forward of 
	the Other Pillar Set.

	"""

    sun_roof: object = None
    """
	Sun Roof Opening Surfaces Set.

	"""

    roll_bar: object = None
    """
	Roll Bar Surfaces Set.

	"""

    stiffener: object = None
    """
	Stiffener Surfaces Set.

	"""

    sliding_opening: object = None
    """
	Nodes that define the widest Sliding Door Opening Set.

	"""

    fmh: object = None
    """
	FMH Set.

	"""

    fiz: object = None
    """
	FIZ Set.

	"""

    trim: object = None
    """
	TRIM Set.

	"""

    fmh_coord: object = None
    """
	FMH Coordinate.

	"""

    fiz_node: object = None
    """
	FIZ Node.

	"""

    glass_surface: object = None
    """
	Glass Surface.

	"""

    max_divergence_distance: float = None
    """
	Maximum divergenece between contact and target points.
	(Default: 2.0)

	"""

    max_target_point_movement: float = None
    """
	Maximum distance between initial and final position 
	of target point (Conservative Positioning).
	(Default: 200)

	"""

    place_target_to_contact: int = None
    """
	Places the TARGET_POINT to contact point after positioning.
	(Default: 0)

	"""

    ignore_property_thick: int = None
    """
	Positioning algorithm ignores property thickness.

	"""

    repeat_with_other_fiz_nodes: int = None
    """
	Repeats positioning with other FIZ nodes in case of failure.
	(Default: 1)

	"""

    ur_front_point: object = None
    """
	Front point of the upper roof zone. A list with (x,y,z) coordinates is required.

	"""

    ur_rear_point: object = None
    """
	Rear point of the upper roof zone. A list with (x,y,z) coordinates is required.

	"""

    respect_initial_x_coordinate: int = None
    """
	Preserves the initial x-coordinate of the initial position of TARGET_POINT, 
	during Conservative positioning.

	"""

    use_dist_to_hard_parts: int = None
    """
	Use FIZ Node distance to hard parts (along the head's X-axis) to find optimum horizontal angle. If set, the optimization is recalculated until the most optimized FIZ Node is found.

	"""

    move_back: float = None
    """
	The distance that the headform will be moved back from the selected target point.

	"""

    reposition_step: float = None
    """
	Sampling step when relocating the target point, in case the contact point is not adjacent to the target point.

	"""

    reposition_max_r: float = None
    """
	Maximum relocation distance of the target point.

	"""

    hard_parts: object = None
    """
	Hard Parts Set ID.

	"""

    exhaustive_relocation: int = None
    """
	0: Relocation finds the valid Target Point closest to the original Target Point.
	1: Relocation finds all valid Target Points inside the reposition_max_r radius.

	"""

    autodetect_trim: int = None
    """
	0: TRIM surface has to be defined using the 'trim' member to specify a set.
	1: TRIM surface is the property closest to the Target Point ('trim' member is disregarded).

	"""

    max_local_dist: object = None
    """
	Maximum local distances (X, Y) between the central lowest FIZ Node and the Contact Point. A list with (X, Y) distanfes is required.

	"""

    limit_local_d: int = None
    """
	0: Disregard max_local_dist values.
	1: Respect max_local_dist values when evaluating the final solution.

	"""

    animation_save: int = None
    """
	0: Do not save animation files.
	non-zero: Save animation files.

	"""

    animation_views: object = None
    """
	List of integers, one for each available animation view.
	0: Do not create an animation file for the corresponding view
	1: Create an animation file for the corresponding view
	e.g. (1, 0, 1) to save animation files of the Front - Aft and the Headform - Target Point views.
	
	Ordered available animation views:
	1. Front - Aft
	2. Left - Right
	3. Headform - Target Point

	"""

    animation_path: str = None
    """
	The output path of the animation files.

	"""

    bleed_through: int = None
    """
	Whether to display "bleed through" info (1) or not (0).

	"""

    bleed_through_max_width: float = None
    """
	The maximum "bleed through" width that's considered valid. Any width values greater than this will be considered erroneous.

	"""

    respect_thick_contact_point: bool = None
    """
	Whether to calculate the Contact Point on the mid-surface of TRIM (false) or offseted from it based on its thickness (true).

	"""

    vertical_step: float = None
    """
	The vertical angle step used during auto vertical positioning.

	"""

    rename_positioned_targets: bool = None
    """
	Whether to rename the auto-saved positioned target points or not. The rename follows the pattern: "original_name_H.angle_V.angle_YYYY_MM_DD"

	"""

    prioritize_divergence: bool = None
    """
	If true, extra computations are performed to minimize the divergence.

	"""

    abort_failed_conservative: bool = None
    """
	If true, vertical positioning with fixed angle will only succeed if the fixed angle can be achieved.

	"""

    def create_target_points(self):
        """

        This method calculates all target points and secondary entities for the FMVSS201U regulation.


        """

    def position(
        self,
        target_point: object,
        mode: str,
        save_position: bool,
        expand_target_point: bool,
        save_before_rebound: bool,
    ):
        """

        This method positions the headform on the given target point.


        Parameters
        ----------
        target_point : object
                The target point entity reference, or a list of target point entities.

        mode : str, optional
                'auto_horizontal'or 'auto_vertical' or 'full_positioning'
                or reset'.

        save_position : bool, optional
                True or False for saving the positioning information
                in the target point card.

        expand_target_point : bool, optional
                If True, the Target Point will be relocated in order to achieve an almost zero distance to the Contact Point.

        save_before_rebound : bool, optional
                If True, the position just before vertical rebound will be saved in a new Target Point.

        """

    def create_load_cases(
        self,
        master_filename: str,
        files_prefix_name: str,
        output_path: str,
        transf_filename: str,
        meta_filename: str,
        velocity: float,
        dyna_trsfm_mode: str,
        headform: object,
        headform_include: object,
        targets_set: object,
        write_out_set: bool,
        use_point_names: bool,
        files_extension: str,
        mode: str,
        write_inline: bool,
        skip_subfolders: bool,
    ):
        """

        This method sets the various parameters of the FMVSS201 function to create the load cases of previous defined saved positions through target point entities.


        Parameters
        ----------
        master_filename : str, optional
                Full path name of master file that contains
                the include hierarchy.

        files_prefix_name : str, optional
                Prefix of include files that will be created.
                Default name is "FMH_Shot".

        output_path : str, optional
                Output directory.

        transf_filename : str, optional
                Name of transformations list file that will
                be created. Default name is
                "FMH_TransfList.csv".

        meta_filename : str, optional
                Name of the Meta file that will be created.
                Default name is "FMH_MetaList.csv".

        velocity : float, optional
                Velocity of headform. If a value is defined
                previously in target point's card, then the
                function disregards this one.

        dyna_trsfm_mode : str, optional
                Values supported "NODE_TRANSFORM",
                "INCLUDE_TRANSFORM". Default is
                "NODE_TRANSFORM". It works for
                LSDYNA only.

        headform : object, optional
                Set of the Free Motion Headform.

        headform_include : object, optional
                Include of the Free Motion Headform. Only
                if DYNA_TRSFM_MODE is
                "INCLUDE_TRANSFORM".

        targets_set : object, optional
                Set that contains the target points for the
                creation of the load cases. If this is not defined
                the function works on all database's target points.

        write_out_set : bool, optional
                If this flag is enabled the definition of FMH set will be written out in the include file.

        use_point_names : bool, optional
                Use the target points names for naming the created
                include files. Default value is False.

        files_extension : str, optional
                Define the preferred extension of all the include files that will be created (e.g .key). If left blank the default
                extension of the current deck, will be used.

        mode : str, optional
                Output files option mode ("master_file_and_folders", "include_files_only").
                "master_file_and_folders" will use the master file and create file for each Target Point containing a modified master file and include current position,
                "include_files_only" will create only the extra include files for each position.

        write_inline : bool, optional
                Option for writing the Transformation/Velocity keywords inside the Master file.

        skip_subfolders : bool, optional
                Option to skip the creation of a sub-folder for each Target Point.

        """

    def create_stochastic_circles(
        self,
        target_point: object,
        part: object,
        circles: int,
        points_per_circle: int,
        circle_radius: float,
        specific_angle: float,
    ):
        """

        This method creates uniform or not target points around a central target point.


        Parameters
        ----------
        target_point : object
                The target point entity reference.

        part : object, optional
                Part for adding the new target point entities.

        circles : int, optional
                Number of concentic circles.
                (Default: 1)

        points_per_circle : int, optional
                Number of uniform points on each circle.
                (Default: 8)

        circle_radius : float, optional
                Radius increment for each circle.
                (Default: 5)

        specific_angle : float, optional
                Specific angle for single target point creation.
                If this parameter is defined then only a single
                point is created.

        """

    def match_fiz_with_target_point(self, target_point: object):
        """

        This method moves the Headform according to the input values set duringthe objects' initialization and H.ANGLE and V.ANGLE fields of thetarget_point entity that is given as argument.Actually it matches thedefined FIZ node with the target point at the angles that mentioned above.No depenetration is performed, so it is recommended to call theFMVSS201ValidatePosition afterwards.


        Parameters
        ----------
        target_point : object
                The target point entity reference.

        """

    def move_to_saved_position(self, target_point: object):
        """

        This method moves the headform to a previous saved position through target point entity.


        Parameters
        ----------
        target_point : object
                This method moves the headform to a previous
                saved position through target point entity.

        """

    def save_position(self, target_point: object, new_position: str):
        """

        This method saves the headform position and data throughthe target point entity.If target_name is blank the current position is saved, otherwise it saves as a new position (target point).


        Parameters
        ----------
        target_point : object, optional
                The target point entity reference.

        new_position : str, optional
                The new position name.

        """

    def validate_position(self, check_vertical: bool):
        """

        This method checks if the vertical angle is within the limits of the regulation.


        Parameters
        ----------
        check_vertical : bool, optional
                True or False. Checks the vertical angle
                violation according the vertical angle limits
                that were previously defined in the current
                target point entity.

        """

    def manual_move(
        self,
        translate: object,
        translate_vec: object,
        translate_increment: float,
        axis: str,
        rotate_vertical: float,
        rotate_horizontal: float,
    ):
        """

        This method performs manual move operations of the headform.


        Parameters
        ----------
        translate : object, optional
                Translate along a vector. A list of (x,y,z).

        translate_vec : object, optional
                Translate along a unit vector. A list of (x,y,z).

        translate_increment : float, optional
                Translation increment.

        axis : str, optional
                "local" or "global".

        rotate_vertical : float, optional
                Angle of vertical rotation.

        rotate_horizontal : float, optional
                Angle of horizontal rotation.

        """

    def minimize_contact_distance(self, target_point: object):
        """

        This function translates the headform to minimize the contact distance from the target point, according to the values set in object's initialization. It is recommended to call it after manual rotations of the headform.


        Parameters
        ----------
        target_point : object
                The target point entity reference.

        """

    def get_lowest_central_fiz_node(self):
        """

        This method finds the lowest central node of the Forehead Impact Zone.


        """


class CheckDescription:
    """

    See Also
    --------
    base.CheckReport

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                options = {
                    "name": "my_check",
                    "exec_action": ("my_exec_fun", "path/to/my_exec_fun_module.py"),
                    "fix_action": ("my_fix_fun", "path/to/my_fix_fun_module.py"),
                    "deck": ansa.constants.NASTRAN,
                    "requested_types": ("CBAR", "CBEAM", "__PROPERTIES__"),
                }

                # The next step is to create a CheckDescription object using the aforementioned dictionary as
                # an argument to the constructor:

                my_check = base.CheckDescription(**options)

                # We can also create a user-defined check by passing the arguments directly to the constructor. We
                # can also create a new user-defined check by passing only its name to the constructor, and then
                # by using the various attribute setters, we can set the properties to desired values:

                my_check = base.CheckDescription(name="my_check")
                my_check.deck = ansa.constants.NASTRAN
                print(my_check.deck)

                my_check.exec_action = ("my_exec_fun", "path/to/my_exec_fun_module.py")
                print(my_check.exec_action)
                # print result:('my_exec_fun', 'path/to/my_exec_fun_module.py')
                # if the first element of this tuple is the empty string '', then when
                # this check is executed, the current loaded module will be searched.

                my_check.fix_action = ("my_fix_fun", "path/to/my_fix_fun_module.py")
                print(my_check.fix_action)
                # print result: ('my_fix_fun', 'path/to/my_fix_fun_module.py')
                # if the first element of this tuple is the empty string '', then when
                # this check is executed, the current loaded module will be searched.

                my_check.requested_types = ("CBAR", "CBEAM", "__PROPERTIES__")
                print(my_check.requested_types)
                # print result:['CBAR', 'CBEAM', '__PROPERTIES__']

                # A user-defined check can also have parameters. Parameters are read-write fields that can be edited by
                # the Checks Manager. We can add four (4) types of parameters:

                # To add a float parameter, use the `add_float_param` member function:
                my_check.add_float_param(name="my_float_param", value=4.2)

                # To add an int parameter, use the `add_int_param` member function:
                my_check.add_int_param(name="my_int_param", value=-10)

                # To add a boolean parameter, use the `add_bool_param` member function:
                my_check.add_bool_param(name="my_bool_param", value=True)

                # To add a string parameter, use the `add_str_param` member function:
                my_check.add_str_param(name="my_str_param", value="ALL")

                # Have in mind that all parameter names MUST be unique. Creating a parameter with an already
                # used key will result in a runtime exception:
                my_check.add_int_param("my_bool_param", 18)

                # After creating all our user-defined checks, we can save them so that they can be read
                # by the Checks Manager. To save them, use the `save_descriptions` class function:

                descr = [my_check]
                saved = base.CheckDescription.save(descriptions=descr, file="./userdefined.plist")
                print(saved)

                # The function returns the number of descriptions saved, which can be less than the length of the first
                # argument, if all names are not unique, e.g:

                saved = base.CheckDescription.save(descriptions=[my_check, my_check])
                print(saved)

                # If `file` is not given, the descriptions will be saved to $BETA_HOME directory.
                # The file is always overwritten!

    """

    name: str = None
    """
	The check's name, which should be unique among checks, and is mandatory.

	"""

    exec_action: object = None
    """
	A two-member tuple of strings that contains the name of the function to be executed
	for this check, as well as the module path that this function is contained. This function
	has a specific signature. See CUSTOM_CHECK_EXEC_FUNCTION for details.
	CUSTOM_CHECK_EXEC_FUNCTION(entities, params)
	Arguments:
	entities    list    The entities on which the check is being applied.
	params   dict   A dictionary containing as keys the parameters of the check and as 
	values the corrpesponding values of the parameters with which the check is being applied.
	Return:
	The function should create and return the result items of the Check, which are 
	represented as objects of the class base.CheckReport.

	"""

    fix_action: object = None
    """
	A two-member tuple of strings that contains the name of the fix function to be executed
	for this check, as well as the module path where it is contained. This function
	has a specific signature. See CUSTOM_CHECK_FIX_FUNCTION for details.
	CUSTOM_CHECK_FIX_FUNCTION(issues)
	The function to be called when the automatic fix option of the check is used, 
	e.g when applying Fix from the context menu of the Checks Manager 
	or when running issue.try_fix() from within a script.
	Arguments:
	issues    list    The issues of the Checks Manager where the fix action is being applied.
	Return:
	The return value of the function has to be one of the following:
	-base.Check.FIX_APPLIED
	Denotes that the fix has been applied succesfully.
	-base.Check.FIX_CANCELED
	Denotes that the fix hasn't been applied succesfully.
	-base.Check.FIX_APPLIED_REQUEST_RERUN
	Triggers the automatic rerun of the check.

	"""

    deck: int = None
    """
	A deck specifier (e.g ansa.constants.NASTRAN, ansa.constants.LSDYNA, etc).
	(Default: NASTRAN)

	"""

    requested_types: object = None
    """
	A sequence of strings, whose values can be either deck types (e.g CBAR, CQUAD4 etc) 
	or general entity keywords (e.g. __PROPERTIES__, __ELEMENTS__ etc). 
	This sequence defines the entities that will be gathered to be checked by this 
	user-defined check.
	Accepted general entity keywords are:
	"__PROPERTIES__", 
	"__MATERIALS__",
	"__ELEMENTS__",
	"__MBCONTAINERS__",
	"__ALL_ENTITIES__",
	"__CONNECTIONS__",
	"__KINEMATIC__",
	"__KINETIC__",
	"__FEATURES__",
	"__COORD_SYSTEMS__" and
	"__CONNECTION_TEMPLATES__"

	"""

    info: str = None
    """
	The description of the check.

	"""

    execute_on: str = None
    """
	The default execution mode when the check is executed as part of a Checks Template.
	Allowed values: 'All Entities', 'Visible' or 'Model'.
	(Default: 'All Entities')

	"""

    def __init__(
        self,
        name: str,
        exec_action: object,
        fix_action: object,
        deck: int,
        requested_types: object,
        info: str,
        execute_on: str,
    ) -> object:
        """

        Object constructor method.


        Parameters
        ----------
        name : str
                The check's name, which should be unique among
                checks and is mandatory.

        exec_action : object
                A two-member tuple of strings that contains the name of the function to be executed
                for this check, as well as the module path that this function is contained. This function
                has a specific signature. See CUSTOM_CHECK_EXEC_FUNCTION for details.
                CUSTOM_CHECK_EXEC_FUNCTION(entities, params)
                Arguments:
                entities    list    The entities on which the check is being applied.
                params   dict   A dictionary containing as keys the parameters of the check and as
                values the corrpesponding values of the parameters with which the check is being applied.
                Return:
                The function should create and return the result items of the Check, which are
                represented as objects of the class base.CheckReport.

        fix_action : object, optional
                A two-member tuple of strings that contains the name of the fix function to be executed
                for this check, as well as the module path where it is contained. This function
                has a specific signature. See CUSTOM_CHECK_FIX_FUNCTION for details.
                CUSTOM_CHECK_FIX_FUNCTION(issues)
                The function to be called when the automatic fix option of the check is used,
                e.g when applying Fix from the context menu of the Checks Manager
                or when running issue.try_fix() from within a script.
                Arguments:
                issues    list    The issues of the Checks Manager where the fix action is being applied.
                Return:
                The return value of the function has to be one of the following:
                -base.Check.FIX_APPLIED
                Denotes that the fix has been applied succesfully.
                -base.Check.FIX_CANCELED
                Denotes that the fix hasn't been applied succesfully.
                -base.Check.FIX_APPLIED_REQUEST_RERUN
                Triggers the automatic rerun of the check.

        deck : int, optional
                The deck specifier (e.g ansa.constants.NASTRAN,
                ansa.constants.LSDYNA, etc). (Default: NASTRAN)

        requested_types : object, optional
                A sequence of strings, whose values can either be
                deck types (e.g. CBAR, CQUAD4 etc) or general entity
                keywords (e.g __PROPERTIES__ , __ELEMENTS__ etc)

        info : str, optional
                The description of the Check.

        execute_on : str, optional
                The default execution mode when the check is executed as part of a Checks Template.
                Allowed values: 'All Entities', 'Visible' or 'Model'.
                (Default: 'All Entities')

        Returns
        -------
        object
                Returns a CheckDescription object.

        """

    def add_float_param(self, name: str, value: float):
        """

        Method to add a float parameter.


        Parameters
        ----------
        name : str
                The name of the parameter.

        value : float
                The value of the parameter.

        """

    def add_int_param(self, name: str, value: int):
        """

        Method to add an int parameter.


        Parameters
        ----------
        name : str
                The name of the parameter.

        value : int
                The value of the parameter.

        """

    def add_bool_param(self, name: str, value: bool):
        """

        Method to add a boolean parameter.


        Parameters
        ----------
        name : str
                The name of the parameter.

        value : bool
                The value of the parameter.

        """

    def add_str_param(self, name: str, value: str):
        """

        Method to add a string parameter.


        Parameters
        ----------
        name : str
                The name of the parameter.

        value : str
                The value of the parameter.

        """

    def parameters(self) -> dict:
        """

        Provides information for the parameters of the CheckDescription


        Returns
        -------
        dict
                Returns a dictionary with the parameters of the CheckDescription and their default values.

        """

    @classmethod
    def save(cls, save: object, file: str, append: bool):
        """


        Parameters
        ----------
        save : object
                A list of descriptions to a given file.

        file : str, optional
                The file path. If `file' is not given, the descriptions are
                saved in the default storage location.

        append : bool, optional
                Activating this flag allows to append the list of check
                descriptions to the selected file. (default = False)

        """

    @classmethod
    def read_descriptions(cls, file: str) -> dict:
        """


        Parameters
        ----------
        file : str, optional
                The file from which the CheckDescriptions will be read. If omitted, the default User-Defined Checks file will be used.

        Returns
        -------
        dict
                A dictionary with the CheckDescription names as keys and the CheckDescriptions as values

        """


class CheckReport:
    """

    A CheckReport object contains information about the results of a check run.
    It roughly corresponds to an item of the Checks Results list in ANSA, however,
    it can be used in a no-gui mode. Currently, the CheckReport class should be created
    only in conjunction with the user defined checks functionality, and should not be used
    as a standalone class. Objects of type CheckReport are also created from the script
    function ansa.base.ExecuteCheckTemplate() and also when executing stand-alone
    checks (e.g checks.general.Length(), checks.mesh.SharpEdges(), etc).

    See Also
    --------
    ExecuteCheckTemplate

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # To create a CheckReport object, use the constructor:

                table = base.CheckReport(type="My Check Results")
                print(table.type)

                # A CheckReport object corresponds to a top-level item in the Checks Result List.
                # To add children you can use the `add_issue` method:

                table.add_issue(
                    status="warning",
                    entities=[],
                    description="the issue's description",
                    _data="custom data",
                )
                print(len(table.issues))

                for issue in table.issues:
                    print(issue.status, issue.description, issue._data)
                # The `add_issue` method should be used only for a table object.
                # If `add_issue` is called for a child of a table, then a runtime exception
                # will be raised:

                issues = table.issues
                first_issue = issues[0]
                try:
                    first_issue.add_issue("warning", [], "another description")
                except RuntimeError as e:
                    print("first_issue is not a table !!!")
                # For a table, the `type` attribute is the argument given to the constructor. For a child issue,
                # it is a string with the same value as its status.
                # The attribute `entities` must be a sequence of ANSA entities.

                # CheckReport and the Check Results List
                # ======================================
                # It was mentioned earlier that CheckReport objects correspond to list items in Check Results List,
                # when CheckReport instances are created in conjunction with the used-defined checks functionality (see CheckDescription)
                # In this case, a CheckReport table (and only a table) can offer (or not) a `fix` option. To indicate
                # that a CheckReport (table) offers a `fix` option, you MUST set its `has_fix` attribute to `True`:

                table.has_fix = True
                print(table.has_fix)

                # If a CheckReport table has its `has_fix` attribute as `False`, then by right clicking on its item, in the
                # Check Results List, the `Fix` option will be disabled.

                # Place two CheckReport objects under an existing CheckReport, as children entries of a tree list.
                header1 = base.CheckReport(type="MyCheck1", parent=table)
                elem1 = base.GetFirstEntity(constants.NASTRAN, "SHELL")
                header1.add_issue(entities=[elem1], description="problem1", status="warning")
                header2 = base.CheckReport(type="MyCheck2", parent=table)
                elem2 = base.GetNextEntity(constants.NASTRAN, elem1)
                header2.add_issue(entities=[elem2], description="problem2", status="error")

    """

    description: str = None
    """
	Same as `type` for header items. Will return the issue's description
	message if instance is an `issue`.

	"""

    entities: object = None
    """
	A list with the entities given during creation of the issue. Will return
	an empty list if instance is header item.

	"""

    has_fix: bool = None
    """
	Read/Write member. If is True, a Fix option will be enabled
	at right clicking on Results List.

	"""

    is_fixed: bool = None
    """
	Read/Write member. If is True, its corresponding item will be
	removed from Results List, when `update()` is called.

	"""

    issues: object = None
    """
	A list will all children issues.

	"""

    status: str = None
    """
	Allowed values: "ok", "error", or "warning".

	"""

    type: str = None
    """
	If instance is a header, returns the `type` used for the
	construction of this instance. Else, it returns its status
	("OK", "Error", "Warning").

	"""

    parent: object = None
    """
	A CheckReport object. Used to place the created CheckReport under an already existing one (as a child entry in a tree list).

	"""

    def __init__(self, type: str) -> object:
        """

        Object construction method. Creates a header report item (a top level item in Check Results List).A header report item can have many children items, known as `issues` for this header.


        Parameters
        ----------
        type : str
                If instance is a header, returns the `type` used for
                the construction of this instance. Else, it returns its
                status ("OK", "Error", "Warning").

        Returns
        -------
        object
                Returns a CheckReport object.

        """

    @classmethod
    def notify(cls, reports: object):
        """

        This class method "reports" all issues to the Checks Manager's Result List.It should be used only by user-defined checks.


        Parameters
        ----------
        reports : object
                A sequence of CheckReport instances.

        """

    def update(self):
        """

        updates the items' status in Check Results List. For example, if anyCheckReport is marked as fixed, the `update` function will have itremoved from the list. In nogui mode, this function has no effect.


        """

    def add_issue(
        self, status: str, entities: object, description: str, has_fix: bool
    ) -> object:
        """

        Creates an issue CheckReport with the given status, description and entities. Note, that further arguments can be provided, which will create the respective attributes on the CheckReport object.


        Parameters
        ----------
        status : str
                Allowed values: ok", "error", or "warning".

        entities : object
                A list with the entities given during creation of the issue.
                Will return an empty list if instance is header item.

        description : str
                Same as `type` for header items. Will return the
                issue's description message if instance is an `issue`.

        has_fix : bool, optional
                If set to True, the Auto Fix option will be enabled at right clicking on Results List.

        Returns
        -------
        object
                Returns None.

        """

    def try_fix(self, request_gui: bool, issues: object) -> object:
        """

        If an issue is a header, this function will try to fix all issues of this header.


        Parameters
        ----------
        request_gui : bool, optional
                If False (default value), then no window will appear for
                user interaction during the fix process. Otherwise, and
                depending on the issue, a window may appear if the
                script is not running in a no-gui mode.

        issues : object, optional
                An optional sequence of children CheckReport objects.
                If given, then only those issues will be fixed. By default,
                all issues will be fixed.

        Returns
        -------
        object
                Return None.This function will throw an exception (RuntimeError) if a fix is not available, or it was called for a non-header CheckReport object (e.g an issue of a header).

        """


class CollectNewModelEntities:
    """

    Monitors and collects new entities created or imported into the model.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                collector = base.CollectNewModelEntities()
                n = base.CreateEntity(ansa.constants.ABAQUS, "NODE")
                new_entities = collector.report()
                del collector
                print(len(new_entities))

    """

    def __init__(self, deck: int, filter_types: object) -> object:
        """

        The object's construction method.


        Parameters
        ----------
        deck : int, optional
                The deck constant.

        filter_types : object, optional
                A list of ANSA entity types ie SECTION_SHELL.

        Returns
        -------
        object
                Returns a CollectNewModelEntities object.

        """

    def report(self) -> object:
        """

        This method returns all the created/imported entities from the object initialization to the report() method calling.


        Returns
        -------
        object
                A list with all the collect ANSA entities.

        """

    def model(self) -> object:
        """

        This method returns the model that was current when the object was initialized.


        Returns
        -------
        object
                The mobel object.

        """


class MassBalanceOp:
    """

    Class for Mass balance operation.

    See Also
    --------
    MassBalanceResults

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa.base import MassBalanceOp, MassBalanceResults


            def main():
                # This is an example of using the MassBalanceOp entity. First import the class from 'ansa.base':
                # Create a new MassBalanceOp object:
                mb = MassBalanceOp()

                # Now, we need to describe the mass balance operation, by setting the operation's parameters. One way
                # to do this, is to use the various setter attributes of MassBalanceOp:
                mb.initial_mass = 0.0
                mb.desired_mass = 4.0

                # After setting the initial and desired masses, we should setup the initial and desired CoGs:
                mb.initial_cog = (0.0, 0.0, 0.0)
                print(mb.initial_cog)
                mb.desired_cog = (0.5, 0.5, 0.0)
                print(mb.desired_cog)

                # After settings the parameters, we must set the ANSA entities the nodes of which
                # will be assigned nodal masses. This can be done by using the 'entities' attribute.

                # First, we create four (4) nodes, as a very simple example model:
                n1 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", 1.0, "X2", 1.0, "X3", 0.0)
                )
                n2 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", -1.0, "X2", 1.0, "X3", 0.0)
                )
                n3 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", -1.0, "X2", -1.0, "X3", 0.0)
                )
                n4 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", 1.0, "X2", -1.0, "X3", 0.0)
                )
                mb.entities = (n1, n2, n3, n4)

                # We can now execute the mass balance operation. Our model initially weighs 0.0Kg, and
                # we would like to add 4Kg and move the CoG to (0.5, 0.5, 0.0). To proceed with the
                # mass balance operation, use the 'execute' method:
                results = mb.execute()

                # `execute' returns an anonymous object of type MassBalanceResults, which you can query to
                # check about the results of the mass balance operation. To find out the final mass
                # achieved, use the `final_mass' attribute.

                # We can now check the final mass, and CoG achieved by the mass balance operation:
                print(round(results.final_mass, 2))

                # To check the final CoG, use the `final_cog' attribute:
                cx, cy, cz = results.final_cog

                print(round(cx, 2))
                print(round(cy, 2))
                print(round(cz, 2))

                # And finally, we could create the masses by looping on the `masses' attribute:
                results.create_masses()

                # We also have the option to take into account the inertias, by using the appropriate
                # attributes:

                mb.initial_inertia = (10.0, 10.0, 20.0, -5.0, -5.0, 2.0)
                mb.desired_inertia = (11.0, 20.0, 18.0, -5.0, -2.0, 2.0)

                # The inertias are given by a sequence in the following order: Ixx, Iyy, Izz, Ixy, Ixz, Iyz.
                # The CoGs and inertias need not be tuples. They must be however sequences.

    """

    entities: object = None
    """
	The entities where the mass balance will done.

	"""

    initial_cog: object = None
    """
	Initial center of gravity. A list with the x,y,z coordinates of the center of gravity.

	"""

    initial_inertia: object = None
    """
	Initial inertia list. The inertias are given by a sequence in the following 
	order: Ixx, Iyy, Izz, Ixy, Ixz, Iyz.

	"""

    initial_mass: float = None
    """
	Initial mass of the model.

	"""

    desired_cog: object = None
    """
	Target center of gravity.

	"""

    desired_inertia: object = None
    """
	Target inertia.

	"""

    desired_mass: float = None
    """
	Target mass.

	"""

    def __init__(
        self,
        initial_cog: object,
        initial_inertia: object,
        initial_mass: float,
        desired_cog: float,
        desired_inertia: object,
        desired_mass: float,
    ) -> object:
        """

        Object construction method.


        Parameters
        ----------
        initial_cog : object
                Initial center of gravity.

        initial_inertia : object
                Initial inertia.

        initial_mass : float
                Initial mass.

        desired_cog : float
                Target center of gravity.

        desired_inertia : object
                Target inertia.

        desired_mass : float
                Target mass.

        Returns
        -------
        object
                Returns a MassBalanceOp object.

        """

    def execute(self) -> object:
        """

        Executes the mass balance operation.


        Returns
        -------
        object
                Returns a MassBalanceResults type Object.

        """


class MassBalanceResults:
    """

    See Also
    --------
    MassBalanceOp

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants
            from ansa.base import MassBalanceOp, MassBalanceResults


            def main():
                # This is an example of using the MassBalanceOp entity. First import the class from 'ansa.base':
                # Create a new MassBalanceOp object:
                mb = MassBalanceOp()

                # Now, we need to describe the mass balance operation, by setting the operation's parameters. One way
                # to do this, is to use the various setter attributes of MassBalanceOp:
                mb.initial_mass = 0.0
                mb.desired_mass = 4.0

                # After setting the initial and desired masses, we should setup the initial and desired CoGs:
                mb.initial_cog = (0.0, 0.0, 0.0)
                print(mb.initial_cog)
                mb.desired_cog = (0.5, 0.5, 0.0)
                print(mb.desired_cog)

                # After settings the parameters, we must set the ANSA entities the nodes of which
                # will be assigned nodal masses. This can be done by using the 'entities' attribute.

                # First, we create four (4) nodes, as a very simple example model:
                n1 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", 1.0, "X2", 1.0, "X3", 0.0)
                )
                n2 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", -1.0, "X2", 1.0, "X3", 0.0)
                )
                n3 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", -1.0, "X2", -1.0, "X3", 0.0)
                )
                n4 = base.CreateEntity(
                    ansa.constants.NASTRAN, "GRID", ("X1", 1.0, "X2", -1.0, "X3", 0.0)
                )
                mb.entities = (n1, n2, n3, n4)

                # We can now execute the mass balance operation. Our model initially weighs 0.0Kg, and
                # we would like to add 4Kg and move the CoG to (0.5, 0.5, 0.0). To proceed with the
                # mass balance operation, use the 'execute' method:
                results = mb.execute()

                # `execute' returns an anonymous object of type MassBalanceResults, which you can query to
                # check about the results of the mass balance operation. To find out the final mass
                # achieved, use the `final_mass' attribute.

                # We can now check the final mass, and CoG achieved by the mass balance operation:
                print(round(results.final_mass, 2))

                # To check the final CoG, use the `final_cog' attribute:
                cx, cy, cz = results.final_cog

                print(round(cx, 2))
                print(round(cy, 2))
                print(round(cz, 2))

                # And finally, we could create the masses by looping on the `masses' attribute:
                results.create_masses()

                # We also have the option to take into account the inertias, by using the appropriate
                # attributes:

                mb.initial_inertia = (10.0, 10.0, 20.0, -5.0, -5.0, 2.0)
                mb.desired_inertia = (11.0, 20.0, 18.0, -5.0, -2.0, 2.0)

                # The inertias are given by a sequence in the following order: Ixx, Iyy, Izz, Ixy, Ixz, Iyz.
                # The CoGs and inertias need not be tuples. They must be however sequences.

    """

    final_cog: object = None
    """
	The final center of gravity (read only).

	"""

    final_inertia: object = None
    """
	The final inertia tensor (wrt the final cog) (read only).

	"""

    final_mass: float = None
    """
	The final mass reached after the mass balance operation (read only).

	"""

    masses: object = None
    """
	Dictionary with keys node references and values mass values (read only).

	"""

    def create_masses(self):
        """

        This method creates CONM2 masses on the nodes contained in themasses dictionary of the instance.


        """


class ASeatbelt:
    """

    A class that handles all the SeatBelt functionality.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def test_ASeatbelt():
                obj_options = {
                    "create_contact": True,
                    "use_real_thickness": True,
                    "auto_recreate": True,
                }

                obj_belt = base.ASeatbelt(**obj_options)

                parts2wrap = base.CollectEntities(constants.LSDYNA, search_types="SECTION_SOLID")
                obj_belt.fill_parts_to_wrap(parts2wrap)

                nodes = []
                nodes.append(base.GetEntity(constants.LSDYNA, "NODE", 1))
                nodes.append(base.GetEntity(constants.LSDYNA, "NODE", 2))
                nodes.append(base.GetEntity(constants.LSDYNA, "NODE", 3))
                nodes.append(base.GetEntity(constants.LSDYNA, "NODE", 4))

                obj_belt.set_component_points(component=2, nodes=nodes)

                known = []
                known.append(nodes[2])

                obj_belt.set_known_points(component=2, nodes=known)

                obj_belt.set_component_parameters(
                    component=2,
                    starting_length=0.0,
                    ending_length=0.0,
                    num_of_shells=8,
                    el_length=6,
                )

                obj_belt.create_component(component=2)

    """

    seatbelt: object = None
    """
	A predefined seatbelt entity.  If this is not set at initialization,
	a new one will be created.

	"""

    create_contact: bool = None
    """
	Flag for creating a contact entity.

	"""

    contact_id: object = None
    """
	The predefined contact that will be updated after the 
	creation of a seatbelt. If it is not set and the create_contact
	flag is not zero, a default contact will be created.

	"""

    disable_parts2wrap: bool = None
    """
	Flag for disabling parts2wrap item of a seatbelt entity.
	If it is equal to True then the function will run on visible parts.

	"""

    auto_recreate: bool = None
    """
	Flag for auto-recreating the seatbelt after dummy articulation.

	"""

    use_real_thickness: bool = None
    """
	Flag for using the real property thickness of the model for
	calculating the seatbelt components offset.

	"""

    real_thick_factor: float = None
    """
	Factor for multiplying the calculated real thickness of the model.

	"""

    nodal_rbody_on_set: bool = None
    """
	Flag for creating Nodal Rigid Body Constraints on Sets / Groups instead of individual Nodes.

	"""

    apply_constant_width: bool = None
    """
	Flag for keeping the width of the belt contant, whereever is this possible.

	"""

    smooth: bool = None
    """
	Flag for smoothing the created shell elements.

	"""

    unfold: bool = None
    """
	Flag for not folding the belt sections on the parts to wrap.

	"""

    keep_id_range: bool = None
    """
	Keep the id ranges of previous created or auto-detected elements on recreate.

	"""

    is_3point: bool = None
    """
	If seatbelt argument is not defined, the auto-created entity will be a 3-point seatbelt.

	"""

    mat_orient: str = None
    """
	'PSI' (default) or 'MCID' for the material orentation of the created shells.

	"""

    smooth_factor: int = None
    """
	Seatbelt smoothing factor. 0 -> no smoothing, 5 -> max smoothing.

	"""

    length_param_name: str = None
    """
	Name of the parameter that reports the seatbelt's total length.

	"""

    def add_component(self, name: str):
        """

        This method adds a new children component to the seatbelt object.


        Parameters
        ----------
        name : str, optional
                The name of the new component.

        """

    def delete_all_elements(self):
        """

        This method deletes all the contents of a seatbelt object.


        """

    def reset_all_paths(self):
        """

        This method deletes all the contents of a seatbelt object.


        """

    def container(self):
        """

        This method returns in a list all the contained elements of aseatbelt object.


        """

    def fill_parts_to_wrap(self, parts: object):
        """

        This method adds an entity or a list of entities in parts2wrap itemof a seatbelt object.


        Parameters
        ----------
        parts : object
                Ansa entity or a list of ansa entities to be added.

        """

    def create_all_components(self, interactive_edit: bool, keep_anchor_entities: bool):
        """

        This method creates and recreates all the seatbelt components of theseatbelt object.


        Parameters
        ----------
        interactive_edit : bool, optional
                Flag for enabling the interactive edit of each  component.
                It works only in gui mode. Default value is False.

        keep_anchor_entities : bool, optional
                Flag for keeping the previously created anchor entities (e.g sliprings, retractors e.t.c) after recreation of the whole seatbelt.

        """

    def delete_component(self, component: object, delete_elements: bool):
        """

        This method deletes a seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        delete_elements : bool, optional
                Flag to delete the component's elements also.

        """

    def delete_component_elements(self, component: object):
        """

        This method deletes the created elements of a seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        """

    def delete_component_points(self, component: object):
        """

        This method deletes selected points of a seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        """

    def reset_component_path(self, component: object):
        """

        This method resets the saved path of a specific seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        """

    def component_container(self, component: object):
        """

        This method returns in a list all the contained elements of a seatbeltcomponent.


        Parameters
        ----------
        component : object
                The name or index of the component.

        """

    def set_component_parameters(
        self,
        component: object,
        points_prefix: str,
        generic_type: str,
        starting_elements: str,
        starting_length: float,
        starting_anchor: str,
        elem_property_1d: object,
        rds_nstrand_property: object,
        start_elem_property_2d: object,
        main_elements: int,
        el_length: float,
        offset: float,
        num_of_shells: int,
        entry_vec: object,
        exit_vec: object,
        shells_property: object,
        ending_elements: str,
        ending_length: float,
        ending_anchor: str,
        end_elem_property_2d: object,
        num_to_extend: int,
        create_trias_at_end: bool,
        create_trias_at_start: bool,
        is_frozen: bool,
        dyna_cross_sect_dist: float,
        load_limiter_length: float,
        pretensioner_length: float,
        connecting_elem_at_start: str,
        connecting_elem_at_end: str,
        start_spring4_property: object,
        start_spring12_property: object,
        start_spring13_property: object,
        end_spring4_property: object,
        end_spring12_property: object,
        end_spring13_property: object,
        start_pretensioner_length: float,
        dyna_cross_sect_dist_2: float,
        create_stiffener_springs: bool,
        stiffener_spring_property: object,
        is_membrane: bool,
        start_retractor_elem_num: int,
        end_retractor_elem_num: int,
        start_1d_elem_length: float,
        end_1d_elem_length: float,
        create_start_rigid_master: bool,
        create_end_rigid_master: bool,
        slipring_3d_pid_start: object,
        slipring_3d_pid_end: object,
        always_create_start_edgeset: bool,
        always_create_end_edgeset: bool,
    ):
        """

        This method sets the creation parameters of a seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        points_prefix : str, optional
                The prefix of name that will be set at the selected path
                points of the seatbelt component.

        generic_type : str, optional
                "1D", "2D". The generic type of the seatbelt component.
                The 1D type can create only 1D elements and the 2D
                type can create both 1D and 2D elements.

        starting_elements : str, optional
                The type of starting elements that will be created.
                LS-DYNA: "1D_BELT", "2D_BELT", "NONE".
                PAM-CRASH: "BARS", "BELTS", "NONE".
                ABAQUS: "CONNECTOR", "TRUSS", "NONE".
                RADIOSS: "TRUSS", "NSTRAND", "SPRING 4", "SPRING 13", "LOAD LIMITER", "NONE".

        starting_length : float, optional
                The total length of component's starting part.

        starting_anchor : str, optional
                The type of starting anchor entity that will be created.
                "SLIPRING", "SLIPRING_3D", "RETRACTOR", "PRETENSIONER"(LS-DYNA), "FIXED", "NONE".
                RADIOSS: "PRETENSIONER", "PULLEY", "PULLEY & SPRING 4", "FIXED", "NONE"

        elem_property_1d : object, optional
                The 1D elements property. If not set, a default
                property will be created.

        rds_nstrand_property : object, optional
                The Radioss Nstrand elements property.
                If not set, a default property will be created.

        start_elem_property_2d : object, optional
                The Ls-Dyna 2D seatbelt elements property.
                If not set, a default property will be created.

        main_elements : int, optional
                One of "SHELLS", "QUADS", "TRIAS" or "2D_BELT".
                The type of elements that will be created at the main
                part. If not set regular shells will be created. The option
                "2D_BELT" stands only for Ls-Dyna deck.

        el_length : float, optional
                The length of all elements that will be created.

        offset : float, optional
                Offset of seatbelt elements from the parts that will be
                wrapped.

        num_of_shells : int, optional
                The number of 2D elements that will be created at the
                width of the seat belt.

        entry_vec : object, optional
                Entry vector. The starting part's width direction will be
                alligned with this vector. A list(x, y, z) is required.

        exit_vec : object, optional
                Exit vector. The ending part's width direction will be
                alligned with this vector. A list(x, y, z) is required.

        shells_property : object, optional
                The 2D elements property.If not set, a default
                property will be created.

        ending_elements : str, optional
                The type of ending elements that will be created.
                LS-DYNA: "1D_BELT", "2D_BELT", "NONE".
                PAM-CRASH: "BARS", "BELTS", "NONE".
                ABAQUS: "CONNECTOR", "TRUSS", "NONE".
                RADIOSS: "TRUSS", "NSTRAND", "SPRING 4", "SPRING 13", "LOAD LIMITER", "NONE".

        ending_length : float, optional
                The total length of component's ending part.

        ending_anchor : str, optional
                The type of ending anchor entity that will be created.
                "SLIPRING", "SLIPRING_3D", "RETRACTOR", "PRETENSIONER"
                (LS-DYNA), "FIXED", "NONE".
                RADIOSS: "PRETENSIONER", "PULLEY", "PULLEY & SPRING 4", "FIXED", "NONE"

        end_elem_property_2d : object, optional
                The Ls-Dyna 2D seatbelt elements property.
                If not set, a default property will be created.83

        num_to_extend : int, optional
                The number of Ls-Dyna 1D seatbelt elements that will
                extend 1D starting and ending part.

        create_trias_at_end : bool, optional
                Create trias at end of the starting part of the component
                (instead of rigid body line elements).

        create_trias_at_start : bool, optional
                Create trias at start of the ending part of the component
                (instead of rigid body line elements).

        is_frozen : bool, optional
                Freeze/unfreeze component.

        dyna_cross_sect_dist : float, optional
                The Cross Section Distance of the component. It is
                measured approximately from the Starting point
                of the component and across its centerline.

        load_limiter_length : float, optional
                The distance of Load Limiter set node from Node 2
                of Cylindrical Joint. Radioss only.

        pretensioner_length : float, optional
                Length of Ending Pretensioner at global X-direction.
                Radioss only.

        connecting_elem_at_start : str, optional
                Type of elements that connect the shells part with
                the starting linear part of the component.
                Valid only for Radioss.
                Available options" "RIGID BODY", "TRIAS", "SPRINGS 13".

        connecting_elem_at_end : str, optional
                Type of elements that connect the shells part with
                the ending linear part of the component.
                Valid only for Radioss.
                Available options" "RIGID BODY", "TRIAS", "SPRINGS 13".

        start_spring4_property : object, optional
                Property of the starting Radioss TYPE4 Springs .
                If not set, a default property will be created.

        start_spring12_property : object, optional
                Property of the starting Radioss TYPE12 Springs .
                If not set, a default property will be created.

        start_spring13_property : object, optional
                Property of the starting Radioss TYPE13 Springs .
                If not set, a default property will be created.

        end_spring4_property : object, optional
                Property of the ending  Radioss TYPE4 Springs .
                If not set, a default property will be created.

        end_spring12_property : object, optional
                Property of the ending  Radioss TYPE12 Springs .
                If not set, a default property will be created.

        end_spring13_property : object, optional
                Property of the ending  Radioss TYPE12 Springs .
                If not set, a default property will be created.

        start_pretensioner_length : float, optional
                Length of Starting Pretensioner at global X-direction.
                Radioss only.

        dyna_cross_sect_dist_2 : float, optional
                Create a *DATABASE_CROSS_SECTION entity
                approximately at this distance83, measured from the ending
                point of the component's main part.

        create_stiffener_springs : bool, optional
                Create springs along the width of the seatbelt in order
                to give stiffness to the component.

        stiffener_spring_property : object, optional
                Property of the springs that will be created along the width of the component. If not set, a default property will be created.

        is_membrane : bool, optional
                Create PAM-CRASH membrane elements at the main part of the component.

        start_retractor_elem_num : int, optional
                Number of additional collapsed seatbelt elements to be created inside the starting retractor.

        end_retractor_elem_num : int, optional
                Number of additional collapsed seatbelt elements to be created inside the ending retractor.

        start_1d_elem_length : float, optional
                The 1D element length for the 1D start part of a 2D component. If not set, it defaults to the same element length as the main part.

        end_1d_elem_length : float, optional
                The 1D element length for the 1D end part of a 2D component. If not set, it defaults to the same element length as the main part.

        create_start_rigid_master : bool, optional
                If false, the start rigid body's master node will be created on the edge of the 2D part of the component. Otherwise, its master node will be created on the centerline, distanced one 'element length' from the 2D part of the component.

        create_end_rigid_master : bool, optional
                If false, the end rigid body's master node will be created on the edge of the 2D part of the component. Otherwise, its master node will be created on the centerline, distanced one 'element length' from the 2D part of the component.

        slipring_3d_pid_start : object, optional
                Property of the 3D Slipring that's on the start side of the component.

        slipring_3d_pid_end : object, optional
                Property of the 3D Slipring that's on the end side of the component.

        always_create_start_edgeset : bool, optional
                If true, an EDGESET will be created on the seatbelt start with Anchor Type 'None'.

        always_create_end_edgeset : bool, optional
                If true, an EDGESET will be created on the seatbelt end with Anchor Type 'None'.

        """

    def set_component_points(self, component: object, nodes: object):
        """

        This method sets the path points of a seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        nodes : object
                List of nodes that will be used as path points.

        """

    def calculate_component_length(self, component: object):
        """

        This method calculates the total length of a created seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        """

    def create_component(
        self, component: object, interactive_edit: bool, keep_anchor_entities: bool
    ):
        """

        This method creates - recreates a seatbelt component.


        Parameters
        ----------
        component : object
                The name or index of the component.

        interactive_edit : bool, optional
                Flag for enabling the interactive edit of the component.
                It works only in gui mode. Default value is False.

        keep_anchor_entities : bool, optional
                Flag for keeping the previously created anchor entities (e.g sliprings, retractors e.t.c) after recreation of the component.

        """

    def show_window(self):
        """

        This method pops up the SeatBelt Manager window for the specific seatbelt.


        """

    def set_known_points(self, component: object, nodes: object):
        """

        This function sets as known a number of nodes that were previouslyset as component points of the component.


        Parameters
        ----------
        component : object
                The name or the index of the seatbelt component.

        nodes : object
                A list of nodes that are going to be set as known.

        """

    @classmethod
    def change_path_point(
        cls, component: object, node_name: str, new_node: object, new_node_name: str
    ) -> int:
        """

        It changes a path point of a seatbelt component.


        Parameters
        ----------
        component : object
                The name or the index of the seatbelt component.

        node_name : str
                The name of the path point that is going to be replaced.

        new_node : object
                The node that will be set as a path point.

        new_node_name : str, optional
                In case a name for the new node is set, the previous
                node will keep its name. Otherwise the new node
                will take the name of the previous node (node_name).

        Returns
        -------
        int
                Returns 1 in success 0 in failure.

        """

    @classmethod
    def get_components(cls) -> object:
        """

        Returns the names of the components of the seatbelt entity.


        Returns
        -------
        object
                It returns a list with the names of the seatbelt components.

        """

    @classmethod
    def get_points_of_component(cls, component: object, return_names: bool) -> object:
        """

        Returns the nodes or the names of the path nodes of a seatbelt component.


        Parameters
        ----------
        component : object
                The name or the index of the seatbelt component.

        return_names : bool, optional
                If it is enabled the function will return the names of the path
                points, otherwise it will return the path nodes (if they exist). Default value is false.

        Returns
        -------
        object
                Returns a list with the path nodes or the names of the path pointsif the return_names argument is set to true.

        """

    def tension_component(
        self,
        component: object,
        edge: str,
        crop: bool,
        smooth_elements: bool,
        force: float,
        direction_auto: bool,
        direction: object,
        friction_coefficient: float,
        try_to_keep_vector: bool,
        recreate: bool,
        fix_edge_shells: bool,
    ) -> int:
        """

        Applies tensioning on a component's start or end.


        Parameters
        ----------
        component : object
                Integer (1-based index) or string (name) of the seatbelt's component to be tensioned.

        edge : str
                'Start' or 'End' to pull from the component's start or end respectively.

        crop : bool, optional
                If True, the component over the original Seatbelt point will be cropped. Default = True.

        smooth_elements : bool, optional
                If True, elements will be smoothed after the tensioning is performed. Default = False.

        force : float, optional
                The force to be applied when pulling. A number in (0, 100]. Default = 10.

        direction_auto : bool, optional
                If True, the pulling direction will be automatically computed. Default = True.

        direction : object, optional
                Vector of pulling direction. If direction_auto is True, this is not used. Default: none.

        friction_coefficient : float, optional
                The friction coefficient. Default = 0.

        try_to_keep_vector : bool, optional
                If True, try to keep vectors. Default = False.

        recreate : bool, optional
                If true, after tensioning, the seatbelt component will be recreated along the tensioned centerline.

        fix_edge_shells : bool, optional
                If true, any cropped shells will be kept square.

        Returns
        -------
        int
                1

        """

    def fill_3dslipring_wrapped_elems(self, elems: object):
        """

        Define the wrapped elements of the 3D sliprings


        Parameters
        ----------
        elems : object
                Collection of the 3D slipring elements to be used for wrapping.

        """


class CheckTemplate:
    """

    The CheckTemplate class encapsulates the behaviour of check templates in Checks Manager.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # read templates from default ANSA location in a python `dictionary`
                templates = base.CheckTemplate.read_templates()

                # get the template to run:
                templ = templates[
                    "PRE_Surface_Meshing_Checks"
                ]  # will throw exception if not found !

                # activate and deactive checks to run,
                # e.g do not run the 'Contacts' check
                for check in templ.checks():
                    if check.name == "Contacts":
                        check.active = False

                # execute all checks in the template, and get back the reported issues
                results = templ.execute()

                # for all issues found, ask for an automatic fix, if one is available
                new_headers = []
                for header in results.reports:
                    if header.has_fix:
                        res = header.try_fix(rerun=True)
                        new_headers.append(res)

    """

    name: str = None
    """
	Gets the template's name (readonly).

	"""

    @classmethod
    def read_templates(cls, file: str, check_definitions: str) -> object:
        """

        Reads templates from a given file.


        Parameters
        ----------
        file : str, optional
                The file path. If it is not given, the templates
                will be read from BETA_HOME. If no templates are
                found in BETA_HOME, the function will try to read
                templates from ANSA_HOME, if any. If the file
                contains also user-defined checks.

        check_definitions : str, optional
                It should be a path to the user-defined check definitions
                that are used in the template file.

        Returns
        -------
        object
                Returns a dictionary with keys strings and values the corresponding CheckTemplate objects.

        """

    def execute(
        self,
        report_level: int = 1,
        make_current: bool = True,
        report: int = Check.REPORT_ALWAYS,
    ) -> object:
        """

        For a given CheckTemplate object, 'execute' will execute the template.
        After the template execution, the function returns an object whose type is '_CheckTemplateExecutionResults' (see the return description for more information).


        Parameters
        ----------
        report_level : int, optional
                One of the following values:
                - 0, to show results only if an error or warning occured.
                - 1, to always show results.
                - 2, o never show results.
                This options is only relevant in GUI mode, and all issues are
                reported in Checks Manager.

        make_current : bool, optional
                When True, it is ensured that the Checks Manager displays the results of the given template. To be used in scripts where more than one templates are executed.

        report : int, optional
                Define when should the Checks List (the list with the reported issues)
                should appear. There are three (3) options. Use
                - Check.REPORT_NONE so that  the Checks List never appears,
                - Check.REPORT_IF_ERROR to show the Checks List only if errors or warnings exist.
                - Check.REPORT_ALWAYS  to always show the list.

        Returns
        -------
        object
                Returns a "_CheckTemplateExecutionResults" object, that contains the following attributes:

                Attributes
                warnings: (integer) The number of checks that finished with warnings.
                errors: (integer) The number of checks that finished with errors.
                ok: (integer) The number of checks that finished with no errors or warnings.
                reports: (list) A list of CheckReport objects (see ansa.base.CheckReport for more information).

        """

    def run(self):
        """

        Deprecated. Use the "execute" method instead, that works in the same way.


        """

    def checks(self) -> object:
        """

        Returns a list of all the template's checks.


        Returns
        -------
        object
                A list of all the template's checks.

        """


class PedSafety:
    """

    Class that handles the Pedestrian Tool functionality.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                ext_parts = base.GetEntity(constants.LSDYNA, "SET", 1)
                bonnet = base.GetEntity(constants.LSDYNA, "SET", 5)
                windscr = base.GetEntity(constants.LSDYNA, "SET", 2)
                ped_device = base.GetEntity(constants.LSDYNA, "SET", 3)
                coord = base.GetEntity(constants.LSDYNA, "DEFINE_COORDINATE_NODES_DIR_X", 1)
                grnd_point = base.GetEntity(constants.LSDYNA, "POINT", 1)

                ped_obj = base.PedSafety(
                    external_parts=ext_parts,
                    bonnet=bonnet,
                    windscreen=windscr,
                    device=ped_device,
                    coord_sys=coord,
                    device_type="HEADFORM",
                    ground_1=grnd_point.position,
                    apply_reg="EURONCAP_GRID",
                )
                ped_obj.mark()

                point = base.GetEntity(constants.LSDYNA, "TARGET_POINT", 10)
                target_point = point.get_entity_values(constants.LSDYNA, ("X", "Y", "Z"))

                final = ped_obj.position(
                    target_xyz=point.position,
                    impact_angle=30,
                    move_back=2,
                    positioning_type="TARGET",
                )

    """

    external_parts: object = None
    """
	External Parts Set.

	"""

    windscreen: object = None
    """
	Windscreen Set.

	"""

    ground_1: object = None
    """
	First Ground Point. An array that contains the (x,y,z) coordinates of the point.

	"""

    apply_reg: str = None
    """
	Apply marking of regulation or protocol ("EURONCAP_GRID_V8", "EUPHASE_1",
	"EUPHASE_2" or "GTR-9/UN-R 127", "JNCAP", "TRIAS_63", "EURONCAP_V51",
	"EURONCAP_GRID_V7", "KNCAP_GRID",
	"CNCAP_GRID", "ANCAP_GRID", "EURONCAP_GRID_V9", "CNCAP_2022", 
	"GTR9/UN-R 127(Proposal)", "KNCAP_V2022", ""GBT_CHINA","C_IASI_GRID", "C_IASI_AREAS",
	"JNCAP_2019").

	"""

    test_type: str = None
    """
	The type of test device ("HEADFORM", "LEGFORM" or "BOTH").

	"""

    bonnet: object = None
    """
	Bonnet Set.

	"""

    bumper: object = None
    """
	Bumper Set. For Legform marking.

	"""

    bumper_beam: object = None
    """
	Bumper Beam Set. For Legform marking of EURONCAP_GRID protocol.

	"""

    wiper_blades: object = None
    """
	Wiper Blades Set. For xxxNCAP_GRID only.

	"""

    upper_legform_2015: bool = None
    """
	Apply the EuroNCAP 2015 proposal for Upper Legform.
	Default value is False.

	"""

    inclined_ground: bool = None
    """
	Use inclined ground according ground_point_1 and ground_point_2.
	Default value is False.

	"""

    ground_2: object = None
    """
	Second Ground Point. A tupple containing the (x,y,z) coordinates of the point.

	"""

    lbrl_angle: float = None
    """
	Lower bumper reference line angle.
	Default value is 25 degrees.

	"""

    ubrl_angle: float = None
    """
	Upper bumper reference line angle.
	Default value is 20 degrees.

	"""

    bc_angle: float = None
    """
	Bumper corner angle.
	Default value is 60 degrees.

	"""

    blerl_angle: float = None
    """
	Bonnet leading edge angle.
	Default value is 50 degrees.

	"""

    blerl_height: float = None
    """
	Bonnet leading edge height.
	Default value is 600 mm.Improve BLE Marking in case of large gap between bonnet and front fascia

	"""

    bsrl_angle: float = None
    """
	Bonnet side reference line angle.
	Default value is 45 degrees.

	"""

    adult_radius: float = None
    """
	Adult headform radius.
	Default value is 82.5 mm.

	"""

    child_radius: float = None
    """
	Child headform radius.
	Default value is 82.5 mm.

	"""

    disregard_dist: float = None
    """
	Disregard distance from side lines. For xxxNCAP_GRID only.
	Default value is 50 mm.

	"""

    stepsize: float = None
    """
	Resolution of lines.
	Default value is 50 mm.

	"""

    gridsize: float = None
    """
	Grid size of xxxNCAP_GRID.
	Default value is 100 mm.

	"""

    wad_project_limit: float = None
    """
	The projection of the flexible tape's edge on the car's surface,
	will not be performed for WADs less than this value.
	Default value is 0 mm.

	"""

    delete_excluded: bool = None
    """
	The excluded points according the sides lines or corners will be deleted. 
	If is False the excluded points will not be deleted and will be marked as 'EXCLUDED'. 
	For xxxNCAP_GRID only.
	Default value is True.

	"""

    smooth_curves: bool = None
    """
	Smooth created curves for stepsize values less than 20mm.
	Default values is False.

	"""

    different_pids: bool = None
    """
	Create a different PID for each curve in conv2line_elements.
	Default value is False.

	"""

    boundaries_only: bool = None
    """
	Create only the lines of xxxNCAP_GRID.
	Default value is False.

	"""

    wads_euroncap_grid: object = None
    """
	An array that contains the Wrap Around Distances.
	Default values are (1000, 1500, 1700, 2100, 775, 930).

	"""

    wads_euphase_1: object = None
    """
	An array that contains the Wrap Around Distances.
	Default values are (1000, 2100).

	"""

    wads_euphase_2: object = None
    """
	An array that contains the Wrap Around Distances.
	Default values are (1000, 1700, 2100).

	"""

    wads_jncap: object = None
    """
	An array that contains the Wrap Around Distances.
	Default values are (1000, 1175, 1350, 1525, 1700, 1900, 2100).

	"""

    wads_trias_63: object = None
    """
	An array that contains the Wrap Around Distances.
	Default values are (1000, 1700, 2100).

	"""

    wads_euroncap_old: object = None
    """
	An array that contains the Wrap Around Distances.
	Default values are (1000, 1250, 1500, 1700, 1800, 2100).

	"""

    bc_matching_dist: float = None
    """
	BLE and BSRL matching distance for Bonnet Corner Points calculation.
	Default value is 1mm.

	"""

    raster_zone: float = None
    """
	The marked zone that raster will be applied ("ADULT", "CHILD" or "BOTH").
	Default value is "ADULT".

	"""

    raster_length: float = None
    """
	Length of raster's box.
	Default value is 80 mm.

	"""

    paste_tol: float = None
    """
	Paste tolerance between raster points and boundary lines.
	Default value is 20 mm.

	"""

    follow_all_lines: bool = None
    """
	Target points will be created at all lines, not only at those on boundaries.
	Default value is False.

	"""

    critical_mode: str = None
    """
	Detect critical points at corresponding areas ("HEADFORM" or "LEGFORM").
	Default value is "HEADFORM". The "LEGFORM" mode concerns the Lower Legform lines.

	"""

    hard_parts_head: object = None
    """
	Hard Parts Set for "HEADFORM" mode.

	"""

    hard_parts_leg: object = None
    """
	Hard Parts Set for lower "LEGFORM" mode.

	"""

    impact_angle_head: float = None
    """
	Impact angle for "HEADFORM" mode.
	Default value is 30 degrees.

	"""

    impact_angle_leg: float = None
    """
	Impact angle for "LEGFORM" mode.
	Default value is 0 degrees.

	"""

    critical_zone: str = None
    """
	The corresponding zone for critical points detection ("ADULT", "CHILD" or "BOTH").
	For "HEADFORM" mode.

	"""

    points_per_area: int = None
    """
	The number of points that will be detected in each area.
	Default value is 1.

	"""

    points_distance: float = None
    """
	The minimum desired distance between two consecutive critical points in each
	area. Default value is 50 mm.

	"""

    max_distance: float = None
    """
	The maximum distance from Hard Parts that the target points will be disregarded.
	Default value is blank.

	"""

    search_step: float = None
    """
	Searching step in X and Y local directions of each area.
	Default value is 10 mm.

	"""

    ble_points: int = None
    """
	The number of target points that will be calculated in each BLE segment.
	Default value is 4.

	"""

    device: object = None
    """
	The Set of test device that will be positioned.

	"""

    device_type: str = None
    """
	The type of test device ("HEADFORM" or "LEGFORM").
	Default value is "HEADFORM".

	"""

    coord_sys: object = None
    """
	The Coordinate System that is located at the center of the test device.

	"""

    lower_leg_z_level: float = None
    """
	The lowest Z-level at impact position of Lower Legform.
	Default value is blank.

	"""

    rotate_back_inclined: bool = None
    """
	Rotate back the created entities when Ground type is 'Inclined'. 
	Default value is False.

	"""

    wad_tapes_to_ble: bool = None
    """
	Create WAD tapes from Ground to BLE for covering possible gaps (e.g grills).
	 Default value is False.

	"""

    wad_tapes_y_limits: object = None
    """
	An array that contains the Y-coordinate limits of WAD tapes on the right 
	and on the left side of the car. Default values are (blank, blank).

	"""

    forward_angle_limit: float = None
    """
	If the vehicle's Forward Angle is greater than this value then horizontal
	projection will be performed. For xxxNCAP_GRID (version >= 8.1.0).
	Default values is 60 degrees.

	"""

    ec_proposal: bool = None
    """
	Enable proposal of the EC to GRSP - December 2014. For EU_PHASE2.
	Default value is False.

	"""

    bc_gauge_limits: object = None
    """
	An array that contains the EC proposal Gauge lower and upper limit. 
	For EU_PHASE2 and ec_proposal = True.
	Default values are (75, 1001).

	"""

    use_cid_for_lowest_point: bool = None
    """
	If the 'lower_leg_z_level' is not blank then the legform lowest point will be
	defined from the 'coord_sys'. Otherwise the 'position' method will compute 
	the lowest point from the impactor's nodes.
	Default value is False.

	"""

    geom_points_curves: bool = None
    """
	Create 3D points on target points, and curves between them.
	Default value is False.

	"""

    custom_legform_targets: bool = None
    """
	The mark() function will create additional legform target points
	at user defined Y coordinates of WAD 775(or BLE) and UBRL.
	The Y coordinates must be set by variables custom_upper_leg_points
	and custom_lower_leg_points.
	Default value is false.

	"""

    custom_upper_leg_points: str = None
    """
	The Y-coordinates of Upper legform additional points that will be created.
	They should be given in comma separated format (e.g 80, 160, -80, -160 e.t.c)
	Default value is blank. It applies only if the custom_legform_points = True.

	"""

    custom_lower_leg_points: str = None
    """
	The Y-coordinates of Lower legform additional points that will be created.
	They should be given in comma separated format (e.g 80, 160, -80, -160 e.t.c)
	Default value is blank. It applies only if the custom_legform_points = True.

	"""

    rename_inclined_targets: bool = None
    """
	Add post-fix '_Inclined_Angle' at Target Points names when
	Ground Type is 'Inclined'.
	Default value is true.

	"""

    consider_inclination: bool = None
    """
	The inclination angle calculated from 'ground_1', 'ground_2' points will be taken 
	into account, during the positioning of the impactor.
	Default value is false.

	"""

    min_energy: float = None
    """
	No Upper Legform Test required if the Impact Energy is calculated less than 
	this value.
	Default value is 160.

	"""

    max_energy: float = None
    """
	If the Impact Energy is calculated greater than this value, then this value is used.
	Default value is 457.

	"""

    nominal_mass: float = None
    """
	The Impact Energy is calculated using this value and the Nominal Impact Velocity.
	Default value is 7.4.

	"""

    test_mass: float = None
    """
	The Test Velocity is calculated using this value and the Nominal Impact Energy.
	Default value is 10.5.

	"""

    vel_factor_1: float = None
    """
	Factor 'Vo' in formula: Vc = Vo * cos(k * angle), for calculating the Nominal 
	Impact Velocity.
	Default value is 40.

	"""

    vel_factor_2: float = None
    """
	Factor 'k' in formula: Vc = Vo * cos(k * angle), for calculating the Nominal 
	Impact Velocity.
	Default value is 1.2.

	"""

    max_ibh: float = None
    """
	Maximum Bumper Beam Height. Default value is 520.

	"""

    proj_distance: float = None
    """
	Maximum Bumper Beam Project Distance for calculating the qualifying Height.
	Default value is 10.

	"""

    targets_near_wad_tol: float = None
    """
	Distance to the WAD Lines for excluding target points that are out of impact area.
	Default value is 2.

	"""

    deployed_bonnet: object = None
    """
	The set that contains the parts of the bonnet in the deployed position (for Active Bonnets).
	In case of xxxNCAP positioning this set should be used in combination with External Parts set.

	"""

    auto_calc_rot_point: bool = None
    """
	Automatic calculation of ground rotation point at the intersection of the line that is defined
	by the two points (ground_1, ground_2) and the vertical plane that is tangent to the most 
	forward point of the External Parts. Default is False.

	"""

    a_pillars: object = None
    """
	A set that contains the A-Pillars. It will be used for NCAP calculation of target points.

	"""

    gtr_bumper_lines_offset: float = None
    """
	Offset longitudinal Bumper Lines along global Y-axis and towards the centerline of the vehicle.
	Default value is 42.

	"""

    bc_gauge_edges_tol: float = None
    """
	Tolerance for checking if the contact point is on the lower or upper edge of the Gauge. Default value is 1.0.

	"""

    bsrl_stepsize: float = None
    """
	Separate step size for the BSRL calculation. If it is not defined the generic Step Size will be used. Default value is blank.

	"""

    mark_on_prop_thickness: bool = None
    """
	In case of FE-models the Property Thickness will be taken into account during marking. For getting correct results the external surfaces must have uniform orientation. Default value is False.

	"""

    fill_z_level: str = None
    """
	Fill Z-level value in Lower Leg Target points according impactor type. Accepted values : 
	"No value", "Flex-PLI", "a-PLI". Default value is "No value".

	"""

    mark_from_zero_y: bool = None
    """
	Mark vehicle starting from Y=0.0. In case the car is not symmetric on left and right side this option will ensure that marking will start from 0.0. If the car is not positioned on Y=0.0  this option should be disabled. Default value if True.

	"""

    calculate_targets_wad: bool = None
    """
	Calculate WAD of target points during marking. Default value is False.

	"""

    always_offset_ble: bool = None
    """
	In case the BLE stick top touches the car surface we skip the offset of BLE. 
	Enable this option to offset the BLE curve even in that case. Default value is False.

	"""

    wrrl_angle_encap: float = None
    """
	Windscreen Rear Reference Line angle of stick in EuroNCAP . Default is 45 degrees.

	"""

    wrrl_angle_jncap: float = None
    """
	Windscreen Rear Reference Line angle of stick in JNCAP . Default is 75 degrees.

	"""

    height_limit_jncap: float = None
    """
	Height Limit of vehicle in JNCAP. Default value is 1900mm.

	"""

    def mark(self):
        """

        This method marks the vehicle according the marking members of the object.


        """

    def conv2line_elements(self):
        """

        This method convert all created curves in line elements.


        """

    def create_wad_line(self, length: float, name: str) -> object:
        """

        This method creates a custom WAD line.


        Parameters
        ----------
        length : float
                The Wrap Around Distance of the custom line.

        name : str
                The desired name of the custom line.

        Returns
        -------
        object
                Returns an ANSA CURVE Entity.

        """

    def create_raster(self):
        """

        This method creates a raster of target points according the rastermembers of the object.


        """

    def detect_critical_points(self):
        """

        This method detects the critical points according the criticaltarget points members of the object.


        """

    def create_ble_points(self, y_coord: float) -> object:
        """

        This method creates target points on Bonnet Leading Edge linethat is created from mark() function.


        Parameters
        ----------
        y_coord : float, optional
                Optional argument for creating a single target point at
                a specific Y coordinate of the BLE line.

        Returns
        -------
        object
                Returns a list that contains the created target points.

        """

    def position(
        self,
        target_xyz: object,
        impact_angle: float,
        move_back: float,
        positioning_type: str,
        get_all_contact_points: bool,
        undo: bool,
        target_entity: object,
    ) -> object:
        """

        This method positions the test device according the given arguments andthe positioning members of the object.


        Parameters
        ----------
        target_xyz : object
                An array that contains the (x, y, z) coordinates of the
                target point.

        impact_angle : float, optional
                The impact angle. The default value is 30 degrees if the
                'device_type' is "HEADFORM" and 0 degrees if the
                'device_type' is "LEGFORM".

        move_back : float, optional
                The distance from target point that the test item will be
                moved back. Default value is 0 mm.

        positioning_type : str, optional
                The positioning point type ("TARGET", "CONTACT",
                "TEST"). Default value is "TARGET".

        get_all_contact_points : bool, optional
                The method will also calculate the contact point
                coordinates for all the other positioning types,
                besides the one that is selected.
                Default value is False.

        undo : bool, optional
                Repositions the test device at its initial position.
                Default value is False.

        target_entity : object, optional
                The target point entity if it exists, for using its inside
                information for positioning customization.

        Returns
        -------
        object
                Returns an array a[] of 26 entries that define the transformation in an LS_DYNA way and also contains other information of the positioning.Specifically rotate through an angle a[6], about a line with direction cosines a[0], a[1] and a[2], passing throughthe point a[3], a[4] and a[5].Translation vector is a[7],a[8] and a[9].The function also returns the coordinates of the true target point at a[10], a[11] and a[12], thecoordinates of the contact point for the current positioning mode at a[13], a[14] and a[15],the coordinates of the contact point if thepositioning mode was Target Point at a[16], a[17] and a[18], the coordinates of the contact point if the positioning mode was ContactPoint at a[19], a[20] and a[21],the coordinates of the contact point if the positioning mode was Test Point at a[22], a[23] and a[24], and theresult of the positioning at a[25]. If a[25] is equal to 1 then the positioning was successfull otherwise will be equal to zero.

        """

    def create_load_cases(
        self,
        targets_set: object,
        positioning_type: str,
        impact_angle: float,
        move_back: float,
        master_filename: str,
        files_prefix_name: str,
        output_path: str,
        transf_filename: str,
        meta_filename: str,
        velocity: float,
        dyna_trsfm_mode: str,
        device_include: object,
        write_out_set: bool,
        use_point_names: bool,
        relative_name_includes: bool,
        files_extension: str,
        write_velocity: bool,
        do_not_create_files: bool,
        vel_referring_cid: bool,
        mode: str,
        write_inline: bool,
        skip_subfolders: bool,
    ):
        """

        This method positions the device at multiple target points and createsthe load cases according the current Deck and the given arguments.


        Parameters
        ----------
        targets_set : object, optional
                Set that contains the target points for the creation of
                the load cases. If this is not defined the function works
                on all database's Ansa target points.

        positioning_type : str, optional
                The positioning point type ("TARGET", "CONTACT",
                "TEST"). Default value is "TARGET".

        impact_angle : float, optional
                The impact angle. The default value is 30 degrees if the
                'device_type' is "HEADFORM" and 0 degrees if the
                'device_type' is "LEGFORM".

        move_back : float, optional
                The distance from target point that the test item will be
                moved back. Default value is 0 mm.

        master_filename : str, optional
                Full path name of master file that contains the include
                hierarchy.

        files_prefix_name : str, optional
                Prefix of include files that will be created. Default name is
                "Ped_Shot".

        output_path : str, optional
                Output directory.

        transf_filename : str, optional
                The name of transformations list file that will be created.
                Default name is "Ped_TransfList.csv".

        meta_filename : str, optional
                The name of the Meta file that will be created.
                Default name is "FMVSS226_MetaList.csv".

        velocity : float, optional
                Velocity of the test device. If a value is defined previously
                in target point's card then the function disregards this
                one. Default value is blank.

        dyna_trsfm_mode : str, optional
                The type of Transformation Keywords in LS-DYNA
                ("NODE_TRANSFORM", "INCLUDE_TRANSFORM").
                Default is "NODE_TRANSFORM".

        device_include : object, optional
                Include of the test device. Only if dyna_trsfm_mode is
                "INCLUDE_TRANSFORM".

        write_out_set : bool, optional
                The definition of the device set will be written out in the
                include file. Default value is True.

        use_point_names : bool, optional
                Use target point names for naming the created include
                files. Default value is False.

        relative_name_includes : bool, optional
                Use relative names for includes. This will enable
                the copy of referenced includes that are contained
                in master file, in each target point's directoty. Default value is False.

        files_extension : str, optional
                The preferred extension of all the include files that                                  will be created (e.g .inc). If left blank the default extension of the current deck, will be used.

        write_velocity : bool, optional
                Enable or Disable the output of velocity keywords.
                Default value is False.

        do_not_create_files : bool, optional
                Enable or disable the option to perform the positioning and
                store the information inside Target Point entities, without
                creating any files. Default value is False.

        vel_referring_cid : bool, optional
                Option for creating the Initial Velocity keywords with reference to impactor's Coordinate System (CID). Default value is False. Valid only in LS-DYNA, RADIOSS.

        mode : str, optional
                Output files option mode ("master_file_and_folders", "include_files_only", "no_files").
                "master_file_and_folders" will use the master file and create file for each Target Point containing a modified master file and include current position,
                "include_files_only" will create only the extra include files for each position,
                "no_files" will store the information inside Target Point entities, without creating any files.

        write_inline : bool, optional
                Option for writing the Transformation/Velocity keywords inside the Master file.

        skip_subfolders : bool, optional
                Option to skip the creation of a sub-folder for each Target Point.

        """

    def create_wad_raster(
        self,
        front_wad: float,
        rear_wad: float,
        length_x: float,
        length_y: float,
        left_curve: object,
        right_curve: object,
        front_curve: object,
        rear_curve: object,
        exclude_wad: float,
        project_vert: bool,
        create_on_boundaries: bool,
        is_windscreen: bool,
    ) -> object:
        """

        This method creates a WAD based raster. Regarding thelength_x it will create multiple wad curves and along those curves it will distribute points according the length y.


        Parameters
        ----------
        front_wad : float
                The initial WAD. According this all the intermediate
                wad curves will be created.

        rear_wad : float
                The final WAD. According this all the intermediate
                wad curves will be created.

        length_x : float
                The step size for creating the intermediate wad curves.

        length_y : float
                The step size measured along global Y direction for distributing the target points.

        left_curve : object
                The left boundary curve. For trimming the intermediate
                wad curves.

        right_curve : object
                The right boundary curve. For trimming the intermediate
                wad curves.

        front_curve : object, optional
                The first curve that defines the frontal reference line of raster.

        rear_curve : object, optional
                The last  curve that defines the rear reference line of raster.

        exclude_wad : float, optional
                Exclude from target points creation a wad that exists between the front and rear.

        project_vert : bool, optional
                Select if the created target points will be vertically projected on External Parts. Default is True.

        create_on_boundaries : bool, optional
                Enable/Disable creation of target points on boundary curves. Default value is True.

        is_windscreen : bool, optional
                Enable this flag in case the raster will be applied on Windscreen impact zone. Default value is False.

        Returns
        -------
        object
                A list containing the created target points.

        """

    def show_window(
        self, car_marking_tab: bool, target_points_tab: bool, positioning_tab: bool
    ) -> bool:
        """

        This method launches the Pedestrian tool's window.


        Parameters
        ----------
        car_marking_tab : bool, optional
                Show or not the 'Car Marking' tab. Default value is True.

        target_points_tab : bool, optional
                Show or not the 'Target Points' tab. Default value is True.

        positioning_tab : bool, optional
                Show or not the 'Positioning' tab. Default value is True.

        Returns
        -------
        bool
                Returns True in success.

        """

    @classmethod
    def calculate_wad_of_targets(cls, targets: object) -> object:
        """

        This method calculates the Wrap Around Distance of a list of target points. The 'external_parts' set and the 'ground_1' must have been defined in the main object.


        Parameters
        ----------
        targets : object
                A list of target points.

        Returns
        -------
        object
                It returns a dictionary that have as keys the target point entities and as data the WAD values.

        """

    @classmethod
    def get_targets_inside_zone(
        cls, zone_curve: object, targets: object, tolerance: float
    ) -> object:
        """

        This method checks which targets points inside the given list lie inside the zone defined by the given closed curve.


        Parameters
        ----------
        zone_curve : object
                The curve which defines the zone (e.g the Windscreen Green/Exclusion Zone curve).

        targets : object
                A list that contains the target points that will be checked.

        tolerance : float, optional
                Distance tolerance. Default value is zero.

        Returns
        -------
        object
                Returns a list that contains the target points that lie inside the zone.

        """

    @classmethod
    def create_separate_line(cls, line: str) -> object:
        """

        This function creates separate marking lines according the selected regulation/protocol and the current marking parameters.


        Parameters
        ----------
        line : str
                A string that defines the line that is going to be created. Available values are ("BRRL", "WRRL", "BLE", "UBRL", "LBRL", "Left_BSRL", "Right_BSRL")

        Returns
        -------
        object
                Returns the created CURVE.

        """

    @classmethod
    def offset_line(cls, line: object, is_side: bool, offset: float) -> object:
        """

        This function creates an Offset line along the longitudinal or the lateral direction using a flexible tape for measuring along the surface of the car.


        Parameters
        ----------
        line : object
                The CURVE that will be used to create the OFFSET CURVE.

        is_side : bool
                A flag that defines if the line is a side reference line or not. This option actually defines the direction of the Offset. If it is set to True, the offset will take place along global Y-axis, otherwise it will take place along global X-axis.

        offset : float, optional
                The Offset value. Default value is 82.5mm.

        Returns
        -------
        object
                Returns the Offset CURVE.

        """

    def load_settings(self, filename: str) -> int:
        """

        Load a pedestrian tool settings file (.json) for the PedSafety class


        Parameters
        ----------
        filename : str
                the path of the pedestrian tool settings file

        Returns
        -------
        int
                1 on success, 0 on failure.

        """


class TankTool:
    """

    TankTool is an object that provides the whole funcitonality of the ANSA Tank module.
    It can be used via script in both GUI and no-GUI mode.
    It does not alter in any way the drawing of the model when used.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa.base import TankTool
            import os


            cur_dir = os.path.dirname(os.path.realpath(__file__))


            def PrintResults(data_list):
                if not data_list:
                    return
                for item in data_list:
                    print(len(item.curves))
                    for data in item.data:
                        print(
                            "type {} volume {:.3} wall_volume {:.3} wall_surface {:.3} height {:.3}, ".format(
                                data.type,
                                data.LiquidVolume,
                                data.wall_volume,
                                data.wall_surface,
                                data.height,
                            )
                        )
                        if data.type == "Gravity":
                            print(
                                "liquid_weight {:.3}, liquid_COG{}, combined_COG {}".format(
                                    data.liquid_weight, data.liquid_COG, data.combined_COG
                                )
                            )
                        elif (
                            data.type == "Filling"
                            or data.type == "Real Filling"
                            or data.type == "Suction"
                        ):
                            print("Point coords  {} ".format(data.point))


            def PrintFivePosResults(data_list):
                if not data_list:
                    return
                for pos_items in data_list:
                    for pos_data in pos_items:
                        print(len(pos_data.curves))
                        if pos_data.data.type == "Five Positions Suction":
                            print(
                                "angle_value {}, angle_type {}".format(
                                    pos_data.data.angle_value, pos_data.data.angle_type
                                )
                            )
                            print(
                                "total_rest_volume {}, liquid_trapped {}, rest_volume {}".format(
                                    pos_data.data.total_rest_volume,
                                    pos_data.data.liquid_trapped,
                                    pos_data.data.rest_volume,
                                )
                            )
                            print("Point coords {}".format(pos_data.data.point))


            def test_VolumeLevel(my_ttool):
                data_list = my_ttool.volume_level(max_volume=90.0)
                html_path = os.path.join(cur_dir, "html", "test_VolumeLevel.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_VolumeToHeight(my_ttool):
                data_list = my_ttool.volume_to_height(number_of_steps=5)
                html_path = os.path.join(cur_dir, "html", "test_VolumeToHeight.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_VolumeToStep(my_ttool):
                data_list = my_ttool.volume_to_step(volume_step=25.0)
                html_path = os.path.join(cur_dir, "html", "VolumeToStep.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_StepToVolume(my_ttool):
                data_list = my_ttool.step_to_volume(number_of_steps=5)
                html_path = os.path.join(cur_dir, "html", "StepToVolume.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_VolumeMinMax(my_ttool):
                data_list = my_ttool.volume_min_max(
                    min_volume=50.0, volume_step=5.0, max_volume=90.0
                )
                html_path = os.path.join(cur_dir, "html", "VolumeMinMax.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_VolumeToStep(my_ttool):
                data_list = my_ttool.volume_to_step(volume_step=25.0)
                html_path = os.path.join(cur_dir, "html", "VolumeToStep.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_StepToVolume(my_ttool):
                data_list = my_ttool.step_to_volume(number_of_steps=5)
                html_path = os.path.join(cur_dir, "html", "StepToVolume.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_VolumeMinMax(my_ttool):
                data_list = my_ttool.volume_min_max(
                    min_volume=50.0, volume_step=5.0, max_volume=90.0
                )
                html_path = os.path.join(cur_dir, "html", "VolumeMinMax.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_HeightMinMax(my_ttool):
                data_list = my_ttool.height_min_max(
                    min_height=100.0, height_step=25.0, max_height=150.0
                )
                html_path = os.path.join(cur_dir, "html", "HeightMinMax.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_FillingPoints(my_ttool):
                pnts = ((84.3068, 271.362, 499.094), (224.512, 238.128, 314.23))
                data_list = my_ttool.filling_points(points=pnts)
                html_path = os.path.join(cur_dir, "html", "FillingPoints.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_RealFilling(my_ttool):
                pnts = ((84.3068, 271.362, 499.094), (224.512, 238.128, 314.23))
                data_list = my_ttool.real_filling(points=pnts, volume_step=50.0)
                html_path = os.path.join(cur_dir, "html", "RealFilling.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_SuctionPoints(my_ttool):
                pnts = ((84.3068, 271.362, 499.094), (224.512, 238.128, 314.23))
                data_list = my_ttool.suction_points(points=pnts)
                html_path = os.path.join(cur_dir, "html", "SuctionPoints.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_FivePositions(my_ttool):
                pnts = ((84.3068, 271.362, 499.094), (224.512, 238.128, 314.23))
                data_list = my_ttool.five_positions(
                    points=pnts, rot_x=15.0, rot_y=15.0, volume=60.0
                )
                html_path = os.path.join(cur_dir, "html", "FivePositions.html")
                my_ttool.tank_info(html_path)


            def test_GravityCenter(my_ttool):
                data_list = my_ttool.gravity_center(steps=5)
                html_path = os.path.join(cur_dir, "html", "GravityCenter.html")
                my_ttool.tank_info(html_path)
                PrintResults(data_list)


            def test_SPH(my_ttool):
                p_psph = base.CreateEntity(ansa.constants.ABAQUS, "PARTICLE_SECTION")
                new_sph = my_ttool.SPH(
                    deck=ansa.constants.ABAQUS,
                    liquid_volume=60.0,
                    sph_radius=5.0,
                    sph_property=p_psph,
                )
                print(new_sph)


            def tank_tool_test():
                my_ttool = TankTool(
                    surface_definition=TankTool.MIDDLE_SURFACE,
                    is_thickness_constant=True,
                    constant_thickness_value=1.0,
                )
                print("Constant thickness flag {}".format(my_ttool._is_thickness_constant))
                if my_ttool._is_thickness_constant:
                    print("Constant thickness value {}".format(my_ttool._constant_thickness_value))
                else:
                    print(
                        "Variable thickness filename {}".format(
                            my_ttool._variable_thickness_filename
                        )
                    )
                print("Surface definition type {}".format(my_ttool._surface_definition_type))

                my_ttool.tilt(original_position=False, rot_x=0.0, rot_y=15.0, rot_z=0.0)

                test_VolumeLevel(my_ttool)
                test_VolumeToHeight(my_ttool)
                test_VolumeToStep(my_ttool)
                test_StepToVolume(my_ttool)
                test_VolumeMinMax(my_ttool)
                test_HeightMinMax(my_ttool)
                test_FillingPoints(my_ttool)
                test_RealFilling(my_ttool)
                test_SuctionPoints(my_ttool)
                test_FivePositions(my_ttool)
                test_GravityCenter(my_ttool)
                test_SPH(my_ttool)


            tank_tool_test()

    """

    _is_thickness_constant: bool = None
    """
	Depicts if the TankTool object is set to be used with a constant thickness or not.

	"""

    _constant_thickness_value: float = None
    """
	The constant thickness selected for all the TankTool processes.

	"""

    _variable_thickness_filename: str = None
    """
	The file name that holds all the data for the variable thickness 
	to be used for all the TankTool processes.

	"""

    _surface_definition_type: int = None
    """
	A code to control whether the TankTool will be defined to operate 
	on the Outer, Middle or Inner surface of the tank.
	It can take three different values defined as :
	-ansa.base.TankTool.INNER_SURFACE
	-ansa.base.TankTool.MIDDLE_SURFACE
	-ansa.base.TankTool.OUTER_SURFACE

	"""

    def __init__(
        self,
        surface_definition: int,
        is_thickness_constant: bool,
        constant_thickness_value: float,
        variable_thickness_filename: str,
    ) -> object:
        """

        Object Constructor Method.


        Parameters
        ----------
        surface_definition : int
                Defines whether the TankTool will use the
                Outer, Middle or Inner surface of the Tank.
                Can take three values:
                -ansa.base.TankTool.OUTER_SURFACE.
                -ansa.base.TankTool.MIDDLE_SURFACE.
                -ansa.base.TankTool.INNER_SURFACE.

        is_thickness_constant : bool
                Define whether to use a constant thickness
                or a variable one.

        constant_thickness_value : float, optional
                The thickness that will be used through out the
                model for TankTool purposes.
                Must be used when is_thickness_constant is set
                to True.

        variable_thickness_filename : str, optional
                The full path and file name of the file that holds
                the variable thickness data that will be used through
                out the model for TankTool purposes.
                Must be used when is_thickness_constant is set to False.

        Returns
        -------
        object
                Returns a new TankTool object.

        """

    def volume_level(self, max_volume: float) -> object:
        """

        The method that will calculate the liquid height when filling at specified volume. It will also calculate the cut curves that mark the specified volume's liquid height.This method is deprecated. Use the volume_levels method.


        Parameters
        ----------
        max_volume : float
                The desired volume of liquid inside the tank.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), type ("Height").Returns None on failure.

        """

    def volume_to_height(self, number_of_steps: int) -> object:
        """

        A method in order to cut the model in different height levels based on a given number of steps.


        Parameters
        ----------
        number_of_steps : int
                The needed number of steps. (Maximum 50)

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), type ("Height").Returns None on failure.

        """

    def volume_to_step(self, volume_step: float) -> object:
        """

        A method to cut the tank in different levels from the bottom up in given volume steps.This method is deprecated. Use the volume_levels method.


        Parameters
        ----------
        volume_step : float
                The step the method will use to cut the model.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), type ("Height").Returns None on failure.

        """

    def step_to_volume(self, number_of_steps: int) -> object:
        """

        A methid to cut the tank in different levels of volume depending on a given number of steps.


        Parameters
        ----------
        number_of_steps : int
                The number of the desired steps.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), type ("Height").Returns None on failure.

        """

    def volume_min_max(
        self, min_volume: float, volume_step: float, max_volume: float
    ) -> object:
        """

        Method to cut the tank from a minimum volume level to a maximum volume level cutting in between at different levels depending on a given step.This method is deprecated. Use the volume_levels method.


        Parameters
        ----------
        min_volume : float
                The start volume from which we begin cutting.

        volume_step : float
                The volume step we use to calculate each cut.

        max_volume : float, optional
                The maximum volume upon which we stop cutting.
                If omitted the method will try to cut all along the
                height of the tank.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), type ("Height").Returns None on failure.

        """

    def height_min_max(
        self, min_height: float, height_step: float, max_height: float
    ) -> object:
        """

        Method to cut the tank from a minimum height level to a maximum height level cutting in between at different levels depending on a given step.


        Parameters
        ----------
        min_height : float
                The start height from which we begin cutting.

        height_step : float
                The volume step we use to calculate each cut.

        max_height : float, optional
                The maximum height upon which we stop cutting.
                If omitted the method will try to cut all along the tank height.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), type ("Height").Returns None on failure.

        """

    def filling_points(self, points: object) -> object:
        """

        Method to calculate the volume and height depending on filling points.


        Parameters
        ----------
        points : object
                A tuple that holds coordinates for each of the desired
                points packaged into tuples.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), point (tuple holding the three coordinates of the filling point), type ("Filling").Returns None on failure.

        """

    def suction_points(self, points: object) -> object:
        """

        Method to create suction points and calculate the height and the volume on the level of these points.


        Parameters
        ----------
        points : object
                A tuple that holds coordinates for each of the desired
                points packaged into tuples.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the model on a particular height, volume or point. Each one of these tuples contain aseries of dictionaries. Each of these dictionaries have a 'curves' key that holds as data a list of curves and a 'data' tuple that holds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), point (tuple holding the three coordinates of the filling point), type ("Suction").Returns None on failure.

        """

    def five_positions(
        self, points: object, rot_x: object, rot_y: object, volume: float
    ) -> object:
        """

        Method to calculate cuts using one or more suction points and a volume.In each combination 5 cuts are calculated by rotating the cut at:zero degrees, +rot_x, -rot_x, +rot_y, -rot_y.Whereas rot_x a given angle at the  X'X tank axisand rot y a given angle at the Y'Y tank axis.


        Parameters
        ----------
        points : object
                A tuple that holds coordinates for each of the desired
                suction points, packaged into tuples.

        rot_x : object
                An angle in degrees, to calculate rotation around
                the X'X axis.

        rot_y : object
                An angle in degrees, to calculate rotation around
                the Y'Y axis.

        volume : float
                The volume with which the variable cuts will be calculated.

        Returns
        -------
        object
                Returns a Tuple of tuples.These tuples represent a suction point. Each one of these tuples contain a series of dictionaries. Each of these dictionaries corresponds to a cut and have: a 'curves' keywhich holds as data a list of curvesand a 'data' object with the followingfields: rest_volume (float), liquid_trapped (float), total_rest_volume (float), angle_type (string ('Flat', '+XX', '-XX', '+YY or '-YY')), angle_value (float), point (Tuple that holds the coordinates of the corresponding point), type, "Five Positions Suction".Returns PyNone on failure.

        """

    def gravity_center(
        self, material_density: float, liquid_density: float, steps: int
    ) -> object:
        """

        Method to calculate center of gravity on different levels of the tank.These levels are calculated to correspond to a given number of steps.The CoG calculation is done on specific tank material density and liquid density, vlaues that must be provided by the user.


        Parameters
        ----------
        material_density : float, optional
                The tank material density.
                If omitted a density of 1,0 (one) is used.

        liquid_density : float, optional
                The liquid material density.
                If omitted a density of 1,0 (one) is used.

        steps : int, optional
                The desired number of steps.
                If omitted 10 steps are implied.

        Returns
        -------
        object
                Returns a Tuple of tuples. These tuples represent a cut of the modelon a particular height, volume or point. Each one of these tuplescontain a series of dictionaries.Each of these dictionaries have: a'curves' key which holds as data a list of curvesand a 'data'tuple thatholds objects with the following fields: liquid_volume (float), wall_volume (float), wall_surface (float), height (float), liquid_weight (float), liquid_COG (Tuple that holds the coordinates of the liquid center of gravity), combined_COG (Tuple that holds the coordinates of the combined center of gravity), type ("Gravity").Returns PyNone on failure.

        """

    def SPH(
        self,
        deck: int,
        liquid_volume: float,
        sph_radius: float,
        sph_property: object,
        part: object,
    ) -> object:
        """

        A method in order to create SPH elements that will fill the tank up to a given volume.


        Parameters
        ----------
        deck : int
                The desired deck.
                Should use the decks coding as it is inside
                ansa.base.constants. e.g. ansa.constants.ABAQUS.

        liquid_volume : float
                The desired volume height.

        sph_radius : float
                The SPH element radius.

        sph_property : object
                A property object (e.g. a PARTICLE SECTION object) to
                 be used by the SPH element.

        part : object, optional
                A part object in which the newly created SPH element will be set.
                If omitted the element will be set inside the current part.

        Returns
        -------
        object
                Returns an object holding the created SPH element on success, or None on failure.

        """

    def tilt(
        self, original_position: bool, rot_x: float, rot_y: float, rot_z: float
    ) -> object:
        """

        Method to tilt the tank around the X, Y and Z axes.


        Parameters
        ----------
        original_position : bool
                Flag to return the tank to each original position.
                Set to False in order to enter a new tilt.

        rot_x : float, optional
                Tilt angle (degrees) around X'X axis.
                Only fuctional if original_position = False.

        rot_y : float, optional
                Tilt angle (degrees) around Y'Y axis.
                Only fuctional if original_position = False.

        rot_z : float, optional
                Tilt angle (degrees) around Z'Z axis.
                Only fuctional if original_position = False.

        Returns
        -------
        object
                Always return None.

        """

    def tank_info(self, filename: str) -> object:
        """

        Method to export last functions calculation to Html report.


        Parameters
        ----------
        filename : str, optional
                The full filename for the report to be saved.
                If omitted an on screen Html report will be shown.
                (If GUI mode is on)

        Returns
        -------
        object
                Always returns None.

        """

    def volume_levels(
        self,
        min_volume: float,
        max_volume: float,
        volume_step: float,
        first_level: float,
    ):
        """

        Method to cut the tank from a minimum volume level to a maximum volume level cutting in between at different levels depending on a given step. Also will calculate the liquid height when filling at specified volume.


        Parameters
        ----------
        min_volume : float
                The start volume from which we begin cutting.

        max_volume : float
                The maximum volume upon which we stop cutting.
                If omitted the method will try to cut all along the
                height of the tank.

        volume_step : float
                The volume step we use to calculate each cut.

        first_level : float
                The desired volume of liquid inside the tank.

        """


class Options:
    """

    Modifies the various options in the 'Kinetic Options' window of 'Simulator'.
    It can be created only through initialization of Simulator object. It can be
    accessed in order to modify its members, but no modification of the object itself
    is permitted (exception is thrown). A reference to it can be created in order
    to change options. See EXAMPLE.
    Each member of the class is prefixed with the corresponding tab's name.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import kinetics


            def test1():
                # modify options of KIN_CONFIG with id 2
                # directly from Simulator object

                kf = base.GetEntity(base.CurrentDeck(), "KIN_CONFIG", 2)
                kin_sim = kinetics.Simulator(kin_config=kf, type="Kinematic")

                kin_sim.options.kinematics_hinit = 0.2
                kin_sim.options.kinematics_maxiter = 30
                kin_sim.options.kinematics_line_search_method = "LINEAR_MODIFIED"


            def test2():
                # modify options of whole model
                # through reference to Options of Simulator

                kin_sim = kinetics.Simulator(type="Contact")

                opts = kin_sim.options

                opts.contacts_integrator_type = "Adjustment Step Size"
                opts.contacts_hmax = 0.02
                opts.contacts_coordinate_projection = False
                opts.contacts_lcp_solver_type = "SORprox"

    """

    general_disregard_forces_motions: bool = None
    """
	Disregard Forces and Motions during the KIN_CONFIG simulation modes 
	'By Actuator Joint', 'By Matching Points' and 'Interactive'.

	"""

    general_derivative_method: str = None
    """
	Method for Derivative's evaluation 'NUMERICAL', 'SYMBOLIC'.

	"""

    general_auto_fix_joints: bool = None
    """
	Auto check and fix joints.

	"""

    general_flexible_joint_tol: float = None
    """
	Flexible joint tolerance (>=0).

	"""

    general_flexible_body_tol: float = None
    """
	Flexible body tolerance (>=0).

	"""

    general_tolj: float = None
    """
	Relative tolerance for redundant constraints.

	"""

    general_body_euler_tol: float = None
    """
	Euler angle singularity tolerance [DEG 0-90].

	"""

    general_tol_distance: float = None
    """
	Collision Parameters - Distance tolerance for contact points clean up (mm).

	"""

    general_max_contact_points: int = None
    """
	Collision Parameters - Maximum number of contact points per manifold.

	"""

    dynamics_alpha: float = None
    """
	Coefficient for HHT Integrator (-1/3 <= alpha <= 0) or WBZ-ALPHA Integrator (alpha <= 0)

	"""

    dynamics_hmax: float = None
    """
	Maximum time step size allowed.

	"""

    dynamics_hmin: float = None
    """
	Minimum time step size allowed (hmin < hinit & hmin < hmax).

	"""

    dynamics_hinit: float = None
    """
	Initial time step size (hinit < hmax).

	"""

    dynamics_error: float = None
    """
	Relative and absolute local integration tolerance.

	"""

    dynamics_tolf: float = None
    """
	Error tolerance for forces.

	"""

    dynamics_maxiter: int = None
    """
	Maximum number of iterations allowed.

	"""

    dynamics_extrapolation: bool = None
    """
	Extrapolation.

	"""

    kinematics_hinit: float = None
    """
	Initial step size.

	"""

    kinematics_hmin: float = None
    """
	Minimum step size allowed (hmin < hinit).

	"""

    kinematics_tolx: float = None
    """
	Error tolerance for displacements.

	"""

    kinematics_tolf: float = None
    """
	Error tolerance for forces.

	"""

    kinematics_tolg: float = None
    """
	Relative tolerance for spurious converge.

	"""

    kinematics_maxiter: int = None
    """
	Maximum number of iterations allowed.

	"""

    kinematics_line_search_method: str = None
    """
	Method of Line Search 'CUBICAL', 'LINEAR', 'LINEAR_MODIFIED'.

	"""

    contacts_integrator_type: str = None
    """
	Type of Integrator: 'Constant Step Size', 'Adjustment Step Size'.

	"""

    contacts_hinit: float = None
    """
	Step size allowed (for constant type).

	"""

    contacts_hmax: float = None
    """
	Maximum step size allowed (for adjustment type).

	"""

    contacts_hmin: float = None
    """
	Minimum step size allowed (for adjustment type).

	"""

    contacts_coordinate_projection: bool = None
    """
	Apply Coordinate Projection on Bilateral Constraint space (for both types).

	"""

    contacts_nmax: int = None
    """
	Value of maximium integration order allowed for smooth extrapolation. 
	Valid values: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21.
	(Smooth Extrapolation Parameters - Adjustment Type)

	"""

    contacts_atol: float = None
    """
	Absolute tolerance for stepsize adjustement and extrapolation.
	(Smooth Extrapolation Parameters - Adjustment Type)

	"""

    contacts_rtol: float = None
    """
	Relative tolerance for stepsize adjustement and extrapolation.
	(Smooth Extrapolation Parameters - Adjustment Type)

	"""

    contacts_lcp_solver_type: str = None
    """
	Type of Linear Complementarity Solver 'JORprox', 'SORprox'.
	( Linear Complementarity Parameters - for both types)

	"""

    contacts_lcp_maxiter: int = None
    """
	Maximum number of iterations allowed.
	(Linear Complementarity Parameters - for both types)

	"""

    contacts_lcp_atol: float = None
    """
	Absolute tolerance. (Linear Complementarity Parameters - for both types)

	"""

    contacts_lcp_rtol: float = None
    """
	Relative tolerance. (Linear Complementarity Parameters - for both types)

	"""

    contacts_lcp_gtol: float = None
    """
	Gradient tolerance for spurious convergence.
	(Linear Complementarity Parameters - for both types)

	"""

    ic_wi: float = None
    """
	Weight factor.

	"""

    ic_maxerror: float = None
    """
	Max anchor error.

	"""

    ic_maxiter: int = None
    """
	Maximum number of iteration allowed.

	"""

    ic_tolx: float = None
    """
	Error tolerance for displacements.

	"""

    ic_tolf: float = None
    """
	Error tolerance for forces.

	"""

    ic_tolg: float = None
    """
	Error tolerance for spurious converge.

	"""

    ic_line_search_method: str = None
    """
	Method of Linear Search 'CUBICAL', 'LINEAR', 'LINEAR_MODIFIED'.

	"""

    steq_maxiter: int = None
    """
	Maximum number of iterations allowed.

	"""

    steq_tolx: float = None
    """
	Error tolerance for displacements.

	"""

    steq_tolf: float = None
    """
	Error tolerance for forces.

	"""

    steq_tolg: float = None
    """
	Error tolerance for spurious converge.

	"""

    steq_stability: float = None
    """
	Fraction of the mass and damping matrices 
	(added to the equilibrium jacobian matrix).

	"""

    steq_tlimit: float = None
    """
	Specifies the maximum translational increment allowed per iteration (mm).

	"""

    steq_alimit: float = None
    """
	Specifies the maximum angular increment allowed per iteration (mm).

	"""

    steq_line_search_method: float = None
    """
	Method of Linear Search 'CUBICAL', 'LINEAR', 'LINEAR_MODIFIED'.

	"""

    ic_stability: float = None
    """
	Fraction of the mass and damping matrices 
	(added to the equilibrium jacobian matrix).

	"""

    ic_tlimit: float = None
    """
	Specifies the maximum translational increment allowed while testing trial solutions during a solution step (mm).

	"""

    ic_alimit: float = None
    """
	Specifies the maximum angular increment allowed while testing trial solutions during a solution step (deg).

	"""

    dynamics_tolx: float = None
    """
	Error tolerance for corrections

	"""

    dynamics_max_depth: float = None
    """
	Max depth tolerance for soft contact detection (mm)

	"""

    dynamics_min_time_step: float = None
    """
	Mim time-step threshold for soft contact detection (mm)

	"""

    dynamics_ndamp: float = None
    """
	Coefficient for Newmark Integrator (ndamp <= 0) or Generalized-Alpha Integrator (0 <= ndamp <= 1)

	"""

    dynamics_integrator_type: str = None
    """
	Type of Integrator: 'HHT-I3', 'Newmark-Beta', 'WBZ-Alpha', 'Generalized-Alpha', 'NSTIFF'

	"""


class DrawMode:
    """

    The DrawMode object creates a custom drawing style in order to alter the view of the model. It affects Shells or Solid Facets.

    Each DrawMode is defined by its name and can hold multiple drawing categories. Each category consists of Shells or Solid
    Facets entities, along with a name and a color. A widget is created in the ANSA drawing area, in order to control the
    visibility and interact with categories. The created DrawMode appears in the Draw Mode button of the Drawing Styles
    toolbar, as USER along with its name. It can be enabled/disabled manually just like the native Draw Modes.

    The programmer may create DrawModes and allow the control to return to ANSA. The application will continue to draw using
    the last DrawMode created or enabled. If the User performs a File>New action, all DrawModes are deleted.

    See Also
    --------
    DrawModeList, Canvas

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Collect Shells
                entities = base.CollectEntities(constants.ABAQUS, None, "SHELL")

                # Collect Facets
                solids = base.CollectEntities(constants.ABAQUS, None, "SOLID")
                all_facets = base.GetInternalAndExternalFacets(constants.ABAQUS, solids)
                facets = all_facets["external_facets"]

                # Create DrawMode
                draw_mode = base.DrawMode("MyDrawMode")

                index = draw_mode.add_category(
                    entities=entities[:100], label="Shells 1", color=0xFF000000
                )
                index = draw_mode.add_category(
                    entities=entities[100:], label="Shells 2", color=0x00FF0000
                )
                index = draw_mode.add_category(
                    entities=facets[100:], label="Facets", color=0x0000FF00
                )

                draw_mode.enable()

                # \tdraw_mode.update(0, entities = entities[120:], label = 'Shells 3', color = 0xFF00FF00)
                # \tdraw_mode.update(0, visible = False)
                # \tdraw_mode.remove_category(1)

                # Get info
                for index in range(draw_mode.categories()):
                    print("category ", index)
                    info = draw_mode.category_info(index)
                    print("\tentities: ", len(info["entities"]))
                    print("\tlabel: ", info["label"])
                    print("\tcolor: ", info["color"])
                    print("\tcolor (hex): ", hex(int(info["color"], 16)))
                # Delete all DrawModes


            # \tdraw_modes = base.DrawModeList()
            # \tfor draw_mode in draw_modes:
            # \t\tprint(draw_mode._name)
            # \t\tdraw_mode.delete()

            if __name__ == "__main__":
                main()

    """

    _name: str = None
    """
	The name of the DrawMode.

	"""

    @classmethod
    def enable(cls) -> object:
        """

        Enable the DrawMode. The model is drawn with the categories and colors of the propgrammer.


        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def disable(cls) -> object:
        """

        Disable the DrawMode. The model is now drawn with the previous draw mode (ENT, PID, MID ...)


        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def show_legend(cls) -> object:
        """

        Show the legend of the DrawMode. The legend shows the categories of the DrawMode.


        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def hide_legend(cls) -> object:
        """

        Hide the legend of the DrawMode. The legend shows the categories of the DrawMode.


        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def add_category(cls, entities: object, label: str, color: int) -> int:
        """

        Add a category to the DrawMode.


        Parameters
        ----------
        entities : object
                An iterable with the entities to be added in the category.

        label : str
                The name of the category. This will appear in the legend widget.

        color : int
                The color of the category. It must be in hex RGBA format e.g. 0xFF000000 for Red color.
                Transparency is not supported.

        Returns
        -------
        int
                Returns the index of the added category.

        """

    @classmethod
    def remove_category(cls, index: int) -> int:
        """

        Remove a category from the DrawMode.


        Parameters
        ----------
        index : int
                The index of the category to be removed. Note that by removing a category,
                previous indexes to other categories in the DrawMode will be invalidated.

        Returns
        -------
        int
                Returns 0 on success or 1 otherwise.

        """

    @classmethod
    def update(
        cls, index: int, entities: object, label: str, color: int, visible: bool
    ) -> int:
        """

        Update the entities, label, color or visibility of a category of the DrawMode.


        Parameters
        ----------
        index : int
                The index of the category to be updated.

        entities : object, optional
                An iterable with the new entities of the category. The entities
                previously contained in the category are removed.

        label : str, optional
                The new name of the category.

        color : int, optional
                The new color of the category. It must be in hex RGBA format
                e.g. 0xFF000000 for Red color. Transparency is not supported.

        visible : bool, optional
                Show/Hide the category. When hidden, the elements in the category
                will be drawn as if they belonged to no category.

        Returns
        -------
        int
                Returns 0 on success or 1 otherwise.

        """

    @classmethod
    def categories(cls) -> int:
        """

        The total number of the categories of the DrawMode.


        Returns
        -------
        int
                Returns the total number of the categories.

        """

    @classmethod
    def category_info(cls, index: int) -> object:
        """

        It returns the entities, color, label and visibility of the category.


        Parameters
        ----------
        index : int
                The index of the category to get info.

        Returns
        -------
        object
                It returns a dictionary with keys 'entities', 'color', 'label' and 'visibile' of the category or None in case of failure.

        """

    @classmethod
    def delete(cls) -> object:
        """

        Delete the DrawMode. When a DrawMode is deleted, the application will revert to the previous drawing style.


        Returns
        -------
        object
                Always returns None.

        """

    def __init__(self, name: str, icon: str) -> object:
        """

        DrawMode object constructor.


        Parameters
        ----------
        name : str
                The name of the DrawMode. If you call the constructor with a name
                that already exists the existing object will be returned.

        icon : str, optional
                The path for the icon to be displayed next to the DrawMode name
                in the Draw Mode button popup. By default a USR icon will be displayed.

        Returns
        -------
        object
                Returns the created DrawMode object.

        """


class Canvas:
    """

    A Canvas object allows you to draw primitives on the GL area.

    Available artifacts are:
    * point
    * line, stippled line
    * label
    * arrow
    * triangle, quad
    * sphere, cube and cylinder.

    Points and some arrows are not affected by the view's zoom.

    It is also possible to draw lines, triangles, cones and labels that will not be affected by the view's zoom.
    Those primitives are named as symbols. Before drawing a symbol the symbol_origin must be set. symbol_origin
    is the point from which the scale will take place.

    The programmer may create Canvas and allow the control to return to ANSA. A Canvas cannot be modified.
    If the User performs a File>New action, all Canvas are deleted.

    See Also
    --------
    CanvasList, DrawMode

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                canvas = base.Canvas("MyCanvas")

                # Points
                canvas.set_color(0xFF0000FF)
                canvas.point_size(10)
                canvas.point(0, 0, -1)
                canvas.point(1, 0, -1, "square_hollow")
                canvas.point(2, 0, -1, "circle")
                canvas.point(3, 0, -1, "circle_hollow")
                canvas.point(4, 0, -1, "diamond")
                canvas.point(5, 0, -1, "diamond_hollow")
                canvas.point(6, 0, -1, "hexa_hollow")
                canvas.point(7, 0, -1, "cross")

                # Label
                canvas.label((8, 0, -1), "Label")

                # Lines
                canvas.set_color(0xFF0000FF)
                canvas.line((0, 0, 0), (1, 0, 0))
                canvas.line_width(2)
                canvas.stippled_line((0, 0, 1), (1, 0, 1))

                # Arrows
                canvas.set_color(0x00FF00FF)
                canvas.arrow((2, 0, 2), (2, 1, 2))
                canvas.arrow((3, 0, 2), (3, 1, 2), type=1)
                canvas.arrow((4, 0, 2), (4, 1, 2), type=2)
                canvas.arrow(
                    (5, 0, 2), (5, 1, 2), line_width=2, size_of_tip=0.25, pos_of_tip=0.6, type=0
                )

                # Shapes 2D
                canvas.set_color(0x0000FFFF)
                canvas.triangle((0, 0, 7), (1, 0, 7), (0.5, 1, 7))
                canvas.triangle((4, 0, 7), (5, 0, 7), (4.5, 1, 7), shade=False)
                canvas.triangle((8, 0, 7), (9, 0, 7), (8.5, 1, 7), wireframe=True)
                canvas.quad((2, 0, 7), (3, 0, 7), (3, 1, 7), (2, 1, 7))
                canvas.quad((6, 0, 7), (7, 0, 7), (7, 1, 7), (6, 1, 7), shade=False)
                canvas.quad((10, 0, 7), (11, 0, 7), (11, 1, 7), (10, 1, 7), wireframe=True)

                # Shapes 3D
                canvas.set_color(0x0000FFFF)
                canvas.sphere((0, 0, 5), 0.5)
                canvas.sphere((5, 0, 5), 0.5, shade=False)
                canvas.sphere((10, 0, 5), 0.5, wireframe=True)
                canvas.cylinder((1.5, 0, 5), (0, 1, 0), 0.5, 1)
                canvas.cylinder((6.5, 0, 5), (0, 1, 0), 0.5, 1, shade=False)
                canvas.cylinder((11.5, 0, 5), (0, 1, 0), 0.5, 1, wireframe=True)
                canvas.cube(
                    (3, 0, 4.5),
                    (4, 0, 4.5),
                    (4, 1, 4.5),
                    (3, 1, 4.5),
                    (3, 0, 5.5),
                    (4, 0, 5.5),
                    (4, 1, 5.5),
                    (3, 1, 5.5),
                )
                canvas.cube(
                    (8, 0, 4.5),
                    (9, 0, 4.5),
                    (9, 1, 4.5),
                    (8, 1, 4.5),
                    (8, 0, 5.5),
                    (9, 0, 5.5),
                    (9, 1, 5.5),
                    (8, 1, 5.5),
                    shade=False,
                )
                canvas.cube(
                    (13, 0, 4.5),
                    (14, 0, 4.5),
                    (14, 1, 4.5),
                    (13, 1, 4.5),
                    (13, 0, 5.5),
                    (14, 0, 5.5),
                    (14, 1, 5.5),
                    (13, 1, 5.5),
                    wireframe=True,
                )

                # Symbols
                canvas.set_color(0xFF00FFFF)
                canvas.symbol_origin(5, 0, 0)
                canvas.symbol_line((5, 0, 1), (6, 0, 1))
                canvas.symbol_triangle((7, 0, 1), (8, 0, 1), (7.5, 0, 2))
                canvas.symbol_cone((9, 0, 1), (10, 0, 1), 0.5)
                canvas.symbol_label((5, 0, 0), "Symbols")

                canvas.show()
                # \tcanvas.hide()
                # \tcanvas.delete()

                names = base.CanvasList()
                for name in names:
                    canvas = base.Canvas(name)
                    print(canvas._name)

    """

    _name: str = None
    """
	The name of the Canvas.

	"""

    def show(self) -> None:
        """

        Show the Canvas. All Canvas primitives will be drawn on GL area.


        Returns
        -------
        None
                Always returns None.

        """

    def hide(self) -> None:
        """

        Hide the Canvas. All Canvas primitives will become invisible.


        Returns
        -------
        None
                Always returns None.

        """

    def delete(self) -> None:
        """

        Delete the Canvas.


        Returns
        -------
        None
                Always returns None.

        """

    def set_color(self, color: int) -> None:
        """

        Set the color for the primitives that will follow.


        Parameters
        ----------
        color : int
                It must be in hex RGBA format e.g. 0xFF000000 for Red color.

        Returns
        -------
        None
                Always returns None.

        """

    def point_size(self, size: int) -> None:
        """

        Set the size of the points that will follow.


        Parameters
        ----------
        size : int
                The size of the points.

        Returns
        -------
        None
                Always returns None.

        """

    def point(self, x: float, y: float, z: float, type: str = "square") -> None:
        """

        Draw a point.


        Parameters
        ----------
        x : float
                The x coordinate.

        y : float
                The y coordinate.

        z : float
                The z coordinate.

        type : str, optional
                Available types are 'square', 'square_hollow', 'cross',
                'circle', 'circle_hollow', 'diamond', 'diamond_hollow',
                'hexa_hollow' (default = 'square').

        Returns
        -------
        None
                Always returns None.

        """

    def line_width(self, width: int) -> None:
        """

        The width of the lines that will follow.


        Parameters
        ----------
        width : int
                The width of the lines.

        Returns
        -------
        None
                Always returns None.

        """

    def line(self, start: tuple, end: tuple) -> None:
        """

        Draw a line.


        Parameters
        ----------
        start : tuple
                A tuple with (x, y, z) coordinates of the line's starting point.

        end : tuple
                A tuple with (x, y, z) coordinates of the line's ending point.

        Returns
        -------
        None
                Always returns None.

        """

    def stippled_line(self, start: tuple, end: tuple) -> None:
        """

        Draw a stippled line.


        Parameters
        ----------
        start : tuple
                A tuple with (x, y, z) coordinates of the stippled line's starting point.

        end : tuple
                A tuple with (x, y, z) coordinates of the stippled line's ending point.

        Returns
        -------
        None
                Always returns None.

        """

    def arrow(
        self,
        start: tuple,
        end: tuple,
        line_width: int = 1,
        size_of_tip: float = 0.16,
        pos_of_tip: float = 0.7,
        type: int = 0,
    ) -> None:
        """

        Draw an arrow.


        Parameters
        ----------
        start : tuple
                A tuple with (x, y, z) coordinates of the arrow's starting point.

        end : tuple
                A tuple with (x, y, z) coordinates of the arrow's ending point.

        line_width : int, optional
                Width of the arrow. (Default: 1)

        size_of_tip : float, optional
                Size of the tip (0 < size_of_tip < 1). (Default: 0.16)

        pos_of_tip : float, optional
                Position of the tip (0 < pos_of_tip < 1). (Default: 0.7)

        type : int, optional
                0: Default arrow.
                1: Dynamic scale with fixed start.
                2: Dynamic scale with fixed end.

        Returns
        -------
        None
                Always returns None.

        """

    def triangle(
        self,
        p1: tuple,
        p2: tuple,
        p3: tuple,
        shade: bool = True,
        wireframe: bool = False,
    ) -> None:
        """

        Draw a triangle.


        Parameters
        ----------
        p1 : tuple
                A tuple with (x, y, z) coordinates of the triangle's 1st point.

        p2 : tuple
                A tuple with (x, y, z) coordinates of the triangle's 2nd point.

        p3 : tuple
                A tuple with (x, y, z) coordinates of the triangle's 3rd point.

        shade : bool, optional
                Add shade to the triangle. (Default: True)

        wireframe : bool, optional
                Draw only the wireframe of the triangle. (Default: False)

        Returns
        -------
        None
                Always returns None.

        """

    def quad(
        self,
        p1: tuple,
        p2: tuple,
        p3: tuple,
        p4: tuple,
        shade: bool = True,
        wireframe: bool = False,
    ) -> None:
        """

        Draw a quad.


        Parameters
        ----------
        p1 : tuple
                A tuple with (x, y, z) coordinates of the quad's 1st point.

        p2 : tuple
                A tuple with (x, y, z) coordinates of the quad's 2nd point.

        p3 : tuple
                A tuple with (x, y, z) coordinates of the quad's 3rd point.

        p4 : tuple
                A tuple with (x, y, z) coordinates of the quad's 4th point.

        shade : bool, optional
                Add shade to the quad. (Default: True)

        wireframe : bool, optional
                Draw only the wireframe of the quad. (Default: False)

        Returns
        -------
        None
                Always returns None.

        """

    def sphere(
        self, center: tuple, radius: tuple, shade: bool = True, wireframe: bool = False
    ) -> None:
        """

        Draw a sphere.


        Parameters
        ----------
        center : tuple
                A tuple with (x, y, z) coordinates of the sphere's center.

        radius : tuple
                Sphere's radius.

        shade : bool, optional
                Add shade to the sphere. (Default: True)

        wireframe : bool, optional
                Draw only the wireframe of the sphere. (Default: False)

        Returns
        -------
        None
                Always returns None.

        """

    def cylinder(
        self,
        origin: tuple,
        direction: tuple,
        radius: float,
        height: float,
        shade: bool = True,
        wireframe: bool = False,
    ) -> None:
        """

        Draw a cylinder.


        Parameters
        ----------
        origin : tuple
                A tuple with (x, y, z) coordinates of the cylinder's origin,
                the center of the bottom circle.

        direction : tuple
                A tuple with (x, y, z) coordinates of the cylinder's direction.

        radius : float
                Cylinder's radius.

        height : float
                Cylinder's height.

        shade : bool, optional
                Add shade to the cylinder. (Default: True)

        wireframe : bool, optional
                Draw only the wireframe of the cylinder. (Default: False)

        Returns
        -------
        None
                Always returns None.

        """

    def cube(
        self,
        p1: tuple,
        p2: tuple,
        p3: tuple,
        p4: tuple,
        p5: tuple,
        p6: tuple,
        p7: tuple,
        p8: tuple,
        shade: bool = True,
        wireframe: bool = False,
    ) -> None:
        """

        Draw a cube.


        Parameters
        ----------
        p1 : tuple
                A tuple with (x, y, z) coordinates of the cube's 1st point.

        p2 : tuple
                A tuple with (x, y, z) coordinates of the cube's 2nd point.

        p3 : tuple
                A tuple with (x, y, z) coordinates of the cube's 3rd point.

        p4 : tuple
                A tuple with (x, y, z) coordinates of the cube's 4th point.

        p5 : tuple
                A tuple with (x, y, z) coordinates of the cube's 5th point.

        p6 : tuple
                A tuple with (x, y, z) coordinates of the cube's 6th point.

        p7 : tuple
                A tuple with (x, y, z) coordinates of the cube's 7th point.

        p8 : tuple
                A tuple with (x, y, z) coordinates of the cube's 8th point.

        shade : bool, optional
                Add shade to the cube. (Default: True)

        wireframe : bool, optional
                Draw only the wireframe of the cube. (Default: False)

        Returns
        -------
        None
                Always returns None.

        """

    def symbol_origin(self, x: float, y: float, z: float) -> None:
        """

        The point where scaling will take place for the symbols to follow.


        Parameters
        ----------
        x : float
                The x coordinate.

        y : float
                The y coordinate.

        z : float
                The z coordinate.

        Returns
        -------
        None
                Always returns None.

        """

    def symbol_line(self, start: tuple, end: tuple) -> None:
        """

        Draw a line which is dynamically scaled.


        Parameters
        ----------
        start : tuple
                A tuple with (x, y, z) coordinates of the symbol line's starting point.

        end : tuple
                A tuple with (x, y, z) coordinates of the symbol line's ending point.

        Returns
        -------
        None
                Always returns None.

        """

    def symbol_triangle(self, p1: tuple, p2: tuple, p3: tuple) -> None:
        """

        Draw a triangle which is dynamically scaled.


        Parameters
        ----------
        p1 : tuple
                A tuple with (x, y, z) coordinates of the triangle's 1st point.

        p2 : tuple
                A tuple with (x, y, z) coordinates of the triangle's 2nd point.

        p3 : tuple
                A tuple with (x, y, z) coordinates of the triangle's 3rd point.

        Returns
        -------
        None
                Always returns None.

        """

    def symbol_cone(self, start: tuple, end: tuple, radius: float) -> None:
        """

        Draw a cone which is dynamically scaled.


        Parameters
        ----------
        start : tuple
                A tuple with (x, y, z) coordinates of the cone's starting point.

        end : tuple
                A tuple with (x, y, z) coordinates of the cone's ending point.

        radius : float
                The cone's radius.

        Returns
        -------
        None
                Always returns None.

        """

    def symbol_label(self, position: tuple, text: str, font_size: int = 12) -> None:
        """

        Draw a label which is dynamically scaled.


        Parameters
        ----------
        position : tuple
                A tuple with (x, y, z) coordinates of the label.

        text : str
                The label's text.

        font_size : int, optional
                The label's pixel size

        Returns
        -------
        None
                Always returns None.

        """

    def __init__(self, name: str) -> None:
        """

        Canvas object constructor.


        Parameters
        ----------
        name : str
                The name of the Canvas. If you call the constructor
                with a name that already exists the existing object will
                be returned.

        Returns
        -------
        None
                Returns the created Canvas object.

        """

    def label(self, position: tuple, text: str, font_size: int = 12) -> None:
        """

        Draw a label.


        Parameters
        ----------
        position : tuple
                A tuple with (x, y, z) coordinates of the label.

        text : str
                The label's text.

        font_size : int, optional
                The label's pixel size

        Returns
        -------
        None
                Always returns None.

        """


class Loadcase:
    """

    A class that handles all the Loadcase Manager functionality.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                deck = constants.NASTRAN

                loadcase = base.Loadcase(deck)

                header = loadcase.nastran_header

                base.SetEntityCardValues(deck, header, {"SOL": "Statics (101)"})

                loadcase.new_subcase("Sub1")
                loadcase.new_subcase("SubcaseToDel")
                loadcase.new_subcase("Subcase2")
                loadcase.delete_subcase(subcase=2)
                loadcase.modify_subcase(subcase=1, name="Subcase1", run_type="Transfer Function")
                ret = loadcase.info_subcase(subcase=1, fields=("name", "run_type"))
                print("subcase 1: name =", ret["name"])
                print("subcase 1: run_type =", ret["run_type"])

                bcs = base.GetEntity(deck, "GEB_BC", 1004)
                forces = base.CollectEntities(deck, None, "FORCE")

                loadcase.add_entity(entity=bcs, subcase=[1, 2])
                loadcase.add_entity(entity=forces, subcase=[1, 2])
                loadcase.remove_entity(entity=forces, subcase=1)
                ents = loadcase.get_entities(subcase=2, category="boundary_conditions")
                print("subcase 2: boundary_conditions =", ents)

                print("loadcase.subcases_num =", loadcase.subcases_num)
                print("loadcase.categories =", loadcase.categories)


            def main():
                # exaple that demonstates how to get an existing abaqus loadcase assistant,
                # create a new step and add a boundary entity to it.

                # get for example a boundary
                boundary = base.GetEntity(ansa.constants.ABAQUS, "BOUNDARY", 1)
                # get the loadcase as "step manager"
                abaqus_loadcase = base.GetEntity(ansa.constants.ABAQUS, "STEP MANAGER", 2)
                # connect the class with existing loadcase
                loadcase = base.Loadcase(constants.ABAQUS, abaqus_loadcase)
                # insert a new step
                step = loadcase.abaqus.new_step("new_step")
                # add entities with a dictionary, where key=entity, value=steps
                loadcase.abaqus.set_entities({boundary: step})

    """

    nastran_header: object = None
    """
	Nastran Header entity.

	"""

    subcases_num: int = None
    """
	Number of subcases.

	"""

    categories: str = None
    """
	Categories of entities.

	"""

    has_common_subcase: bool = None
    """
	True if common subcase exists.

	"""

    loadcase_entity: object = None
    """
	LOADCASE entity.

	"""

    def __init__(self, deck: int, entity: object) -> object:
        """

        Object construction method.


        Parameters
        ----------
        deck : int
                NASTRAN or ABAQUS

        entity : object, optional
                A Nastran Header, a Step Manager or a LOADCASE entity.
                If not given and deck is NASTRAN a new Nastran Header of type Loadcase is created.
                If not given and deck is ABAQUS a new Step Manager of type Loadcase is created.

        Returns
        -------
        object
                Returns a Loadcase object.

        """

    def new_subcase(
        self,
        name: str,
        common: bool,
        title: str,
        subtitle: str,
        run_type: str,
        domain: str,
        steps_num: int,
        is_repcase: bool,
        repcase_parent: int,
        subcase_id: int,
    ) -> int:
        """

        Create a new subcase.


        Parameters
        ----------
        name : str, optional
                Subcase Name.

        common : bool, optional
                Set to True if you want to create a common subcase.

        title : str, optional
                Subcase Title.

        subtitle : str, optional
                Subcase Subtitle.

        run_type : str, optional
                Subcase Run Type.

        domain : str, optional
                Subcase Domain.

        steps_num : int, optional
                The number of steps (SOL 400).

        is_repcase : bool, optional
                Set to True if you want to create a REPCASE (SOL 101, 103)

        repcase_parent : int, optional
                The subcase to which the REPCASE refers

        subcase_id : int, optional
                Subcase id

        Returns
        -------
        int
                The index of the new subcase.

        """

    def delete_subcase(self, subcase: int):
        """

        Delete a subcase.


        Parameters
        ----------
        subcase : int
                The index of the subcase. (0 for common subcase)

        """

    def add_entity(self, entity: object, subcase: int, step: int):
        """

        Add an entity to a loadcase or specific subcase.


        Parameters
        ----------
        entity : object
                The entity to add.

        subcase : int, optional
                The index of the subcase in which the entity will be
                added (0 for common subcase). If not given, the entity
                will be added to the loadcase, but not to a specific subcase.

        step : int, optional
                The index of the step (SOL 400).

        """

    def remove_entity(self, entity: object, subcase: int, step: int):
        """

        Remove an entity from the loadcase or a specific subcase.


        Parameters
        ----------
        entity : object
                The entity to remove.

        subcase : int, optional
                The index of the subcase from which the entity will be
                removed (0 for common subcase). If not given, the entity
                will be removed from the loadcase and all subcases.

        step : int, optional
                The index of the step (SOL 400).

        """

    def get_entities(self, subcase: int, category: str, step: int) -> object:
        """

        Get the entities of the loadcase or a specific subcase.


        Parameters
        ----------
        subcase : int, optional
                The index of a specific subcase (0 for common subcase).
                If not given, all the entities of the loadcase are returned.

        category : str, optional
                The category of the entities. Available options:
                "boundary_conditions", "output_requests",
                "modes_definition", "panels", "time_step",
                "frequency_range", "contacts", "control_parameters".
                If not given, entities from all categories are returned.

        step : int, optional
                The index of the step (SOL 400).

        Returns
        -------
        object
                A list of entities.

        """

    def modify_subcase(
        self,
        subcase: int,
        name: str,
        title: str,
        subtitle: str,
        run_type: str,
        domain: str,
        subcase_id: int,
        active: bool,
    ):
        """

        Modify a subcase.


        Parameters
        ----------
        subcase : int
                The index of the subcase (0 for common subcase).

        name : str, optional
                Subcase Name.

        title : str, optional
                Subcase Title.

        subtitle : str, optional
                Subcase Subtitle.

        run_type : str, optional
                Subcase Run Type.

        domain : str, optional
                Subcase Domain.

        subcase_id : int, optional
                Subcase id

        active : bool, optional
                Set subcase active

        """

    def info_subcase(self, subcase: int, fields: object) -> object:
        """

        Get information about a subcase.


        Parameters
        ----------
        subcase : int
                The index of the subcase (0 for common subcase).

        fields : object
                A tuple of strings. Available fields are: "name", "title",
                "subtitle", "run_type", "domain", "subcase_id", "active".

        Returns
        -------
        object
                A dictionary with the requested fields as keys and values.

        """

    def apply(self):
        """

        Apply all items used (active) by loadcase subcases.


        """

    def load_parameters_from_file(self, filename: str, insert_option: str):
        """

        Loads parameters from file.


        Parameters
        ----------
        filename : str
                The file name.

        insert_option : str, optional
                Insert option: "merge" or "overwrite".

        """

    def set_options(self, options: object) -> object:
        """

        Set Nastran options.


        Parameters
        ----------
        options : object
                A dictionary with keys the name of option and values the desired field value.
                options:                                      values
                "echo_bulk_bata_selection"  string: "SORT", "UNSORT", "BOTH" or "NONE"
                "echo_print_out"                    string: "PUNCH", "FILE" or "PUNCH, FILE"
                "result_file_format"                 string: "OP2" or  "PUNCH"
                "add_mpc"                              string: "COMMON_CASE" or ALL_SUBCASES"
                "structural_damping_table"    entity
                "fluid_damping_table"            entity
                "resvec_enable"                     bool
                "resvec_value"                       string: "YES" or "NO"
                "rvdof_enable"                       bool
                "rvdof_by"                              string: "SET" or "BCDOFS"
                "rvdof_set"                             entity
                "rvdof_dof"                             integer
                "uset1_enable"                      bool
                "uset1_by"                             string: "SET" or "BCDOFS"
                "uset1_set"                            entity
                "uset1_dof"                            integer
                "autospc_enable"                  bool
                "autospc_apply_constraints" string: "SPC" or "MPC"
                "autospc_print_singular_table"  string: "PRINT" or "NOPRINT"
                "autospc_generate_constraints"  string: "PUNCH" or "NOPUNCH"
                "nastran_file_management_statements"  string
                "executive_control"                      string
                "common_case"                           string
                "add_parameters_in_case_control" bool
                "restart"                                        bool
                "restart_logical"                          bool
                "restart_keep"                             bool
                "restart_log_name"                    string
                "restart_file"                                string

        Returns
        -------
        object
                Always return None

        """

    def get_options(self, options: object) -> object:
        """

        Get Nastran options.


        Parameters
        ----------
        options : object
                A list with the options' names that the user wants to extract the values from.
                Available options:
                "echo_bulk_bata_selection"
                "echo_print_out"
                "result_file_format"
                "add_mpc"
                "structural_damping_table"
                "fluid_damping_table"
                "resvec_enable"
                "resvec_value"
                "rvdof_enable"
                "rvdof_by"
                "rvdof_set"
                "rvdof_dof"
                "uset1_enable"
                "uset1_by"
                "uset1_set"
                "uset1_dof"
                "autospc_enable"
                "autospc_apply_constraints"
                "autospc_print_singular_table"
                "autospc_generate_constraints"
                "nastran_file_management_statements"
                "executive_control"
                "common_case"
                "add_parameters_in_case_control"
                "restart"
                "restart_logical"
                "restart_keep"
                "restart_log_name"
                "restart_file_name"

        Returns
        -------
        object
                Returns a dictionary with the requested options as keys and the retrieved values as the dictionary's values.

        """

    def set_options(self, options: object):
        """

        Set Sonate options.


        Parameters
        ----------
        options : object
                A dictionary with keys the name of option and values the desired field value.
                options:                             values
                "Domain"                         string: "FREQUENCY" or "TIME"
                "Cfl"                              float
                "DeltaT"                     float
                "TsRelax"                   float
                "FastLVL"                    integer
                "InternalImpedance"     integer
                "FrequencyRange"         a list (start, stop)
                "SmoothingFactor"         float
                "MeshVerification"  bool
                "TransferFunction"   bool
                "Acoustic Mesh"                   entity
                "Ground Plane"                     entity
                "Acoustic Material"               entity
                "Structure Mesh"                  entity
                "Modal Basis"                       string: filename
                "Modal Basis Type"              string: "TRANSLATION" or "ROTATION"
                "Visualization Mesh"            entity
                "Post Frequency"        entity
                "Analysis"                             string: "Weakly Coupled", "Strongly Coupled", "Acoustic", "Blocked Pressure", "Acoustic Transient Response", or "Transient Modal superposition Weakly Coupled"

        """

    def get_options(self, options: object) -> object:
        """

        Get Sonate options.


        Parameters
        ----------
        options : object
                A list with the options' names that the user wants to extract the values from.
                Available options:
                "Domain"
                "Cfl"
                "DeltaT"
                "TsRelax"
                "FastLVL"
                "InternalImpedance"
                "FrequencyRange"
                "SmoothingFactor"
                "MeshVerification"
                "TransferFunction"
                "Acoustic Mesh"
                "Ground Plane"
                "Acoustic Material"
                "Structure Mesh"
                "Modal Basis"
                "Modal Basis Type"
                "Visualization Mesh"
                "Post Frequency"
                "Analysis"

        Returns
        -------
        object
                Returns a dictionary with the requested options as keys and the retrieved values as the dictionary's values.

        """

    def add_acoustic_panels(self, acoustic_panels: object):
        """

        Add Sonate acoustic panels.


        Parameters
        ----------
        acoustic_panels : object
                A list of acoustic panels to be added in sonate loadcase.

        """

    def remove_acoustic_panels(self, acoustic_panels: object):
        """

        Remove Sonate acoustic panels.


        Parameters
        ----------
        acoustic_panels : object
                A list of acoustic panels to be removed from sonate loadcase.

        """

    def get_acoustic_panels(self) -> object:
        """

        Get Sonate acoustic panels.


        Returns
        -------
        object
                A list of acoustic panels of sonate loadcase.

        """

    def add_couplings(self, couplings: object):
        """

        Add Sonate couplings.


        Parameters
        ----------
        couplings : object
                A list of couplings to be added in sonate loadcase.

        """

    def remove_couplings(self, couplings: object):
        """

        Remove Sonate couplings.


        Parameters
        ----------
        couplings : object
                A list of couplings to be removed from sonate loadcase.

        """

    def get_couplings(self) -> object:
        """

        Get Sonate couplings.


        Returns
        -------
        object
                A list of couplings of sonate loadcase.

        """

    def set_method_type(self, method: object, subcase_ids: object, type: str):
        """

        Set Nastran method type.


        Parameters
        ----------
        method : object
                The method entity to be set with the given type.

        subcase_ids : object
                A list of subcase ids, where the method will be set with the given type.

        type : str
                The method type to be set:
                "STRUCTURE", "FLUID" or "BOTH".

        """

    def get_method_type(self, method: object, subcase_id: int) -> str:
        """

        Get Nastran method type.


        Parameters
        ----------
        method : object
                The method entity.

        subcase_id : int
                Subcase id.

        Returns
        -------
        str
                Returns the method type.

        """

    def new_step(
        self, subcase: int, name: str, title: str, subtitle: str, common: bool
    ) -> int:
        """

        Add a new step in a subcase (SOL 400).


        Parameters
        ----------
        subcase : int
                The index of the subcase in which the step will be
                added.

        name : str, optional
                Step Name.

        title : str, optional
                Step Title.

        subtitle : str, optional
                Step Subtitle.

        common : bool, optional
                True to create common step.

        Returns
        -------
        int
                Returns the index of the new step.

        """

    def delete_step(self, subcase: int, step: int):
        """

        Delete a step from a subcase (SOL 400).


        Parameters
        ----------
        subcase : int
                The index of the subcase.

        step : int
                The index of the step.

        """

    def info_step(self, subcase: int, step: int, fields: object) -> object:
        """

        Get information about a step of a subcase (SOL 400).


        Parameters
        ----------
        subcase : int
                The index of the subcase.

        step : int
                The index of the step.

        fields : object
                A tuple of strings. Available fields are: "name", "title",
                "subtitle".

        Returns
        -------
        object
                A dictionary with the requested fields as keys and values.

        """

    def modify_step(
        self,
        subcase: int,
        step: int,
        name: str,
        title: str,
        subtitle: str,
        active: bool,
    ):
        """

        Modify a step of a subcase (SOL 400).


        Parameters
        ----------
        subcase : int
                The index of the subcase.

        step : int
                The index of the step.

        name : str, optional
                Step Name.

        title : str, optional
                Step Title.

        subtitle : str, optional
                Step Subtitle.

        active : bool, optional
                Set step active

        """

    def get_steps_num(self, subcase: int) -> int:
        """

        Get the number of steps of a subcase (SOL 400).


        Parameters
        ----------
        subcase : int
                The index of the subcase.

        Returns
        -------
        int
                The number of steps.

        """

    def has_common_step(self, subcase: int) -> bool:
        """

        Check if a subcase has a common step.


        Parameters
        ----------
        subcase : int
                The index of the subcase.

        Returns
        -------
        bool

        """

    def get_analysis(self, subcase: int, step: int) -> str:
        """

        Get the analysis of a subcase.


        Parameters
        ----------
        subcase : int
                The index of the subcase.

        step : int, optional
                The index of the step (SOL 400).

        Returns
        -------
        str
                The analysis keyword.

        """

    def set_analysis(self, subcase: int, keyword: str, step: int):
        """

        Set the analysis of a subcase.


        Parameters
        ----------
        subcase : int
                The index of the subcase.

        keyword : str
                The analysis keyword.

        step : int, optional
                The index of the step (SOL 400).

        """

    def set_parameters(self, parameters: object):
        """

        Set Nastran parameters


        Parameters
        ----------
        parameters : object
                A dictionary with keys the name of parameter and values the desired field value.

        """

    def get_parameters(self, parameters: object) -> object:
        """

        Get Nastran parameters.


        Parameters
        ----------
        parameters : object, optional
                A list with the parameters' names that the user wants to extract the values from.

        Returns
        -------
        object
                Returns a dictionary with the requested parameters as keys and the retrieved values as the dictionary's values.If no parameters are provided, then the dictionary will contain all the parameters of the loadase.

        """

    def remove_parameters(self, parameters: object):
        """

        Remove Nastran parameters


        Parameters
        ----------
        parameters : object
                A list with the parameters' names that the user wants to remove from loadcase

        """

    def new_step(self, name: str) -> object:
        """

        Create an Abaqus Step


        Parameters
        ----------
        name : str, optional
                Step name

        Returns
        -------
        object
                The created Step

        """

    def delete_step(self, step: object) -> object:
        """

        Delete an Abaqus Step


        Parameters
        ----------
        step : object
                An Abaqus Step

        Returns
        -------
        object
                Always returns None

        """

    def get_entities(self) -> object:
        """

        Get entities


        Returns
        -------
        object
                A dictionary with key the entity and data its steps, *LOAD CASEs, or "Initial State" string

        """

    def set_entities(self, entities: object):
        """

        Set entities


        Parameters
        ----------
        entities : object
                A dictionary with key the entity and data its Steps, *LOAD CASEs or "Initial State" string

        """

    def new_loadcase(self, step: object, name: str) -> object:
        """

        Create a *LOAD CASE


        Parameters
        ----------
        step : object
                The step of the *LOAD CASE

        name : str, optional
                The name of the *LOAD CASE

        Returns
        -------
        object
                The created *LOAD CASE

        """

    def delete_loadcase(self, loadcase: object) -> object:
        """

        Delete a *LOAD CASE


        Parameters
        ----------
        loadcase : object
                A *LOAD CASE entity

        Returns
        -------
        object
                Always returns None

        """

    def get_loadcases(self, step: object) -> object:
        """

        Get *LOAD CASEs of a step


        Parameters
        ----------
        step : object
                A step entity

        Returns
        -------
        object
                A list with the *LOAD CASEs of the specified step

        """

    def save_template(self, filename: str) -> int:
        """

        Save a loadcase template.


        Parameters
        ----------
        filename : str
                The name of the new file with which the current
                loadcase template is going to be saved.

        Returns
        -------
        int
                Returns 0 if the file has been successfully saved and 1 otherwise.

        """

    def move_step(self, step: object, new_pos: int) -> object:
        """

        Move an Abaqus Step


        Parameters
        ----------
        step : object
                An Abaqus Step

        new_pos : int
                The new position of the step

        Returns
        -------
        object
                Always returns None

        """

    def new_increment(self, name: str) -> object:
        """

        Create a Marc Increment (obsolete, replaced by marc.new_loadcase)


        Parameters
        ----------
        name : str, optional
                Increment name

        Returns
        -------
        object
                The created Increment

        """

    def copy_increment(self, increment: object) -> object:
        """

        Copy a Marc Increment (obsolete, replaced by marc.copy_loadcase)


        Parameters
        ----------
        increment : object
                The Marc Increment to copy.

        Returns
        -------
        object
                The new Marc Increment

        """

    def move_increment(self, increment: object, new_pos: int) -> object:
        """

        Move a Marc Increment (obsolete, replaced by marc.move_loadcase)


        Parameters
        ----------
        increment : object
                The Marc Increment

        new_pos : int
                The new position of the Marc Increment

        Returns
        -------
        object
                Always return None

        """

    def delete_increment(self, increment: object) -> object:
        """

        Delete a Marc Increment (obsolete, replaced by marc.delete_loadcase)


        Parameters
        ----------
        increment : object
                The Marc Increment to delete

        Returns
        -------
        object
                Always return None

        """

    def get_entities(self, loadcase: object) -> object:
        """

        Get entities of a loadcase


        Parameters
        ----------
        loadcase : object
                A "LOADCASE OPTIONS" entity or the string "Initial State"

        Returns
        -------
        object
                A list of tuples (entity, flag)

        """

    def set_entities(self, loadcase: object, entities: object) -> object:
        """

        Set entities of a loadcase


        Parameters
        ----------
        loadcase : object
                A "LOADCASE OPTIONS" entity or the string "Initial State"

        entities : object
                A list of entities or a list of tuples (entity, flag)

        Returns
        -------
        object
                Always return None

        """

    def new_loadcase(self, name: str) -> object:
        """

        Create a new loadcase


        Parameters
        ----------
        name : str, optional
                The name of the "LOADCASE OPTIONS" entity

        Returns
        -------
        object
                The created "LOADCASE OPTIONS" entity

        """

    def copy_loadcase(self, loadcase: object) -> object:
        """

        Copy a loadcase


        Parameters
        ----------
        loadcase : object
                The "LOADCASE OPTIONS" entity to copy

        Returns
        -------
        object
                The copied "LOADCASE OPTIONS" entity.

        """

    def move_loadcase(self, loadcase: object, new_pos: int) -> object:
        """

        Move a loadcase


        Parameters
        ----------
        loadcase : object
                The "LOADCASE OPTIONS" entity

        new_pos : int
                The new position of the loadcase

        Returns
        -------
        object
                Always return None

        """

    def delete_loadcase(self, loadcase: object) -> object:
        """

        Delete a loadcase


        Parameters
        ----------
        loadcase : object
                The "LOADCASE OPTIONS" entity to delete

        Returns
        -------
        object
                Always return None

        """

    def set_mdl_parameters(self, parameters: object):
        """

        Set Nastran mdl parameters


        Parameters
        ----------
        parameters : object
                A dictionary with keys the name of parameter and values the desired field value.

        """

    def set_swld_parameters(self, parameters: object):
        """

        Set Nastran swld parameters


        Parameters
        ----------
        parameters : object
                A dictionary with keys the name of parameter and values the desired field value.

        """

    def get_mdl_parameters(self, parameters: object) -> object:
        """

        Get Nastran mdl parameters.


        Parameters
        ----------
        parameters : object, optional
                A list with the mdl parameters' names that the user wants to extract the values from.

        Returns
        -------
        object

        """

    def get_swld_parameters(self, parameters: object) -> object:
        """

        Get Nastran swld parameters.


        Parameters
        ----------
        parameters : object, optional
                A list with the swld parameters' names that the user wants to extract the values from.

        Returns
        -------
        object

        """

    def remove_mdl_parameters(self, parameters: object):
        """

        Remove Nastran mdl parameters


        Parameters
        ----------
        parameters : object
                A list with the mdl parameters' names that the user wants to remove from loadcase

        """

    def remove_swld_parameters(self, parameters: object):
        """

        Remove Nastran swld parameters


        Parameters
        ----------
        parameters : object
                A list with the swld parameters' names that the user wants to remove from loadcase

        """

    def set_subcases_renumber_method(
        self, renumber_method: str, start_id: int, step: int
    ) -> object:
        """

        Set renumber method for subcases' ids.


        Parameters
        ----------
        renumber_method : str
                "Auto", "Manual", "Range"

        start_id : int, optional
                start id for "Range" renumber method

        step : int, optional
                step for "Range" renumber method

        Returns
        -------
        object
                Always return None

        """


class CompareTool:
    """

    The comparison object, which is created through this class, provides access to the Compare Tool functionality through
    script. A comparison object can be created either by specifying two models to be compared or by opening the comparison
    results which are stored in an *.ansa_compare file. When the comparison object is created by specifying two models, the
    run() method should be executed to compare the defined models. In both cases, the user is able to:

    - launch the Compare Tool and show the comparison results list,
    - save the comparison results in an *.ansa_compare file,
    - generate a report with the identified differences in PDF, PPTX, XLSX, and CSV formats, and
    - get the matched parts (with and without diffs) of the models which have been compared.

    The initial values of the class members below are specified through ANSA.defaults. The "Keyword" and the "Default Value"
    in ANSA.defaults are presented for each member.

    Examples
    --------
    ::

            import ansa
            from ansa import base, connections, constants, session, utils


            # Function for the creation of a Model which contains a specified ANSA database
            # This function is called in main for the creation of the Models to be compared
            def createNewModelFromAnsaDatabase(path_of_ansa_db):
                # Create a new model and merge the specified ANSA database
                model = base.CreateNewAnsaModel()
                base.SetCurrentAnsaModel(model)
                utils.Merge(path_of_ansa_db)

                # Remove the remaining 'Untitled' part
                untitled_part = base.GetPartFromName("Untitled", "ANSAPART")
                untitled_part_contents = base.CollectEntities(0, untitled_part, "__ALL_ENTITIES__")
                if len(untitled_part_contents) == 0:
                    base.DeleteEntity(untitled_part)
                return model


            # Scenario 01: Compare two models and generate a Comparison Report
            # This function is called in main for the execution of the Comparison Scenario
            def runComparisonScenario01(model_01, model_02, exporting_directory):
                # Create a comparison object from Model 01 and Model 02
                comparison = base.CompareTool(model_01, model_02)

                # Execute the comparison between Model 01 and Model 02 according to the criteria defined in object's attributes
                comparison.run()

                # Create the Compare Report according to the specifications defined in object's attributes
                comparison.report_exporting_directory = exporting_directory
                comparison.generate_report()


            # Main function for the Models Comparison.
            # NOTE: The models are created and destroyed manually.
            def main():
                # Full paths of the ANSA databases
                path_of_ansa_db_01 = "//full/path/of/database/01.ansa"
                path_of_ansa_db_02 = "//full/path/of/database/02.ansa"
                exporting_directory = "//full/path/of/exporting/directory/"

                # Creation of models
                session.New("discard")
                model_01 = createNewModelFromAnsaDatabase(path_of_ansa_db_01)
                model_02 = createNewModelFromAnsaDatabase(path_of_ansa_db_02)

                # Execution of Models Comparison
                if model_01 and model_02:
                    runComparisonScenario01(model_01, model_02, exporting_directory)
                # Destruction of models
                base.DestroyAnsaModel(model_01)
                base.DestroyAnsaModel(model_02)


            if __name__ == "__main__":
                main()


            # Scenario 02: Compare two models to:
            # - get the matched parts in Model_02
            # - get the differences on a part in Model 02
            # - modify the identified geometrical differences on this part, and
            # - apply the geometrical differences from this part to its matching part in Model_01
            # This function could be customized and called in main for the execution of the Comparison Scenario
            def runComparisonScenario02(model_01, model_02):
                # Create a comparison object from Model 01 and Model 02
                comparison = base.CompareTool(model_01, model_02)

                # Execute the comparison between Model 01 and Model 02 according to the criteria defined in object's attributes
                comparison.run()

                # Get matched parts in Model 02
                matched_parts = comparison.get_matched_parts()
                matched_parts_in_model_02 = list(matched_parts.values())

                # Get the geometrical differences on a part in Model 02
                part_in_model_02 = matched_parts_in_model_02[0]
                identified_diffs = comparison.get_part_differences(part_in_model_02)
                geometrical_diffs = identified_diffs.geometry
                differences_percentage = geometrical_diffs.percentage
                print(
                    "The "
                    + part_in_model_02._name
                    + " part is "
                    + str("{0:.2f}".format(differences_percentage))
                    + " different from its matching part"
                )

                # Modify the identified geometrical differences on this part
                different_entities = geometrical_diffs.entities
                area_diffs_threshold = 100
                similar_entities = []
                for group in different_entities:
                    total_area = 0
                    for face in group:
                        face_area = base.GetFaceArea(face)
                        total_area = total_area + face_area
                    if total_area < area_diffs_threshold:
                        similar_entities.append(group)
                comparison.modify_geometrical_differences(
                    part=part_in_model_02, entities_to_remove=similar_entities
                )

                # Apply the geometrical differences from this part to its matching part in Model_01
                comparison.apply_similarities_differences(
                    part_in_model_02, "MODEL_2", "DIFFERENT", "KEEP_OLD"
                )


            # Scenario 03: Open a file with the comparison results, and launch the results list.
            # This function could be executed as stand-alone as no Models need to be created/destroyed in this Comparison Scenario.
            def runComparisonScenario03(path_of_comparison_results):
                # Create a comparison object from the comparison results
                ansa.session.New("discard")
                comparison = base.CompareTool.open(path_of_comparison_results)

                # Launch the Compare Report window with the results list
                comparison.show_results()


            # HINTS: Find below functions for the creation of models in different use cases
            # Create a model from specific parts of an ANSA database
            def createNewModelFromSpecificPartsOfAnsaDatabase(
                path_of_ansa_db, module_id_of_part_01, module_id_of_part_02
            ):
                # Create a temporary model from the specified ANSA database
                tmp_model = createNewModelFromAnsaDatabase(path_of_ansa_db)

                # Collect the specified parts
                part_01 = base.GetPartFromModuleId(module_id_of_part_01)
                part_02 = base.GetPartFromModuleId(module_id_of_part_02)
                parts = [part_01, part_02]

                # Create a model from the specified parts
                model = base.CreateNewAnsaModel()
                base.CopyPartsToAnsaModel(parts, model)
                base.SetCurrentAnsaModel(model)

                # Destroy the temporary model
                base.DestroyAnsaModel(tmp_model)

                return model


            # Create a model from a Keyword file
            def createNewModelFromKeywordFile(path_of_input_file, deck):
                # Create a new model
                model = base.CreateNewAnsaModel()
                base.SetCurrentAnsaModel(model)

                # Set the current deck and input the specified keyword file (e.g. NASTRAN, LSDYNA)
                if deck == "Nastran":
                    base.SetCurrentDeck(constants.NASTRAN)
                    base.InputNastran(path_of_input_file)
                elif deck == "LSDyna":
                    base.SetCurrentDeck(constants.LSDYNA)
                    base.InputLSDyna(path_of_input_file)
                else:
                    return None
                return model


            # Create a model from a Connections file
            def createNewModelFromConnectionsFile(path_of_connections_file, file_type):
                # Create a new model
                model = base.CreateNewAnsaModel()
                base.SetCurrentAnsaModel(model)

                # Read the Connections file
                connections.ReadConnections(file_type, path_of_connections_file)

                return model

    """

    working_directory: str = None
    """
	The full path of the directory where all the files, which are
	generated throughout the comparison process, are exported. (Keyword:
	"Compare_Working_Directory" - Default Value: 'Temp' folder in the
	user's home directory).

	"""

    geometry_matching_parts_mode: str = None
    """
	Defines how the parts are matched. The accepted values are:
	- 'MATCH_BASED_ON_MODULE_ID' where parts are matched by their
	Module Id, and in case of failure, they are matched by their Name,
	- 'MATCH_BASED_ON_GEOMETRY' where parts located in similar position
	are matched by their Geometry, and
	- 'MATCH_BASED_ON_ID_AND_GEOM' where parts are matched by their
	Module Id/Name, and in case of failure, they are matched by their
	Geometry.
	- 'AUTO_MATCH' where the geometrical entities are matched by proximity and the same structure is automatically generated for both models
	(Keyword: "Matching_Part_Options" - Default Value: 'MATCH_BASED_ON_ID_AND_GEOM').

	"""

    geometry_matching_distance: float = None
    """
	The maximum distance between two areas in order to be considered
	as similar. (Keyword: "Geometry_Matching_Distance" - Default Value: 0.5).

	"""

    geometry_similarity_factor: float = None
    """
	The threshold of the overlap (%) between two areas in order to be
	considered as identical. (Keyword: "Geometry_Matching_Similarity" -
	Default Value: 90)

	"""

    geometry_compare_skinned_with_solid: bool = None
    """
	defines whether a skinned representation is compared with a solid
	(3D) description (True) or two solid (3D) models are compared
	(False). (Keyword: "Geometry_Compare_Middle_With_Skin" - Default Value: True)

	"""

    geometry_compare_shell_thickness: bool = None
    """
	defines whether the shell thickness is considered in the geometrical
	comparison (True) or not (False). (Keyword: "Geometry_Compare_To_Thickness" - Default Value: False)

	"""

    geometry_check_bounds: bool = None
    """
	defines whether the bounds are checked and compared in the
	geometrical comparison (True) or not (False). (Keyword: "Geometry_Check_Bounds" - Default Value: True)

	"""

    geometry_check_single_bounds: bool = None
    """
	defines whether the single (red) bounds are checked and compared in
	the geometrical comparison (True) or not (False). (Keyword:
	"Geometry_Check_Single_Bounds" - Default Value: True)

	"""

    geometry_check_double_triple_bounds: bool = None
    """
	defines whether the double (yellow) and triple (cyan) bounds are
	checked and compared in the geometrical comparison (True) or not
	(False). (Keyword: "Geometry_Check_Double_Triple_Bounds" - Default Value: False).

	"""

    geometry_allow_different_bounds_matching: bool = None
    """
	defines whether different types of bounds are allowed to be matched
	(True) or not (False). (Keyword: "Geometry_Allow_Different_Bounds_Matching" - Default Value: False).

	"""

    connections_points_distance: float = None
    """
	is the threshold used for the matching of connection points. It is
	calculated based on the distance between the projections of the
	connection points. (Keyword: "Connections_Matching_Distance" -
	Default Value: 10)

	"""

    connections_average_thickness_factor: float = None
    """
	is the threshold used for the matching of connection points. It is
	calculated as a factor of the average thickness of the parts which
	are connected by the connection points. (Keyword: "Connections_Average_Thickness" - Default Value: 0.5)

	"""

    connections_matching_distance: float = None
    """
	is the maximum distance between two connection curves or faces in
	order to be considered as similar. (Keyword: "Connections_Faces_Matching_Distance" - Default Value: 0.5)

	"""

    connections_similarity_factor: float = None
    """
	is the threshold of the overlap (%) between two connection curves or
	faces in order to be considered as identical. (Keyword:
	"Connections_Matching_Similarity" - Default Value: 90)

	"""

    connections_equivalent_connectivity: bool = None
    """
	defines whether the connections should have equivalent connectivity
	in order to be matched (True) or not (False). (Keyword:
	"Connections_Equiv_Connectivity_check" - Default Value: False)

	"""

    connections_same_type: bool = None
    """
	defines whether the connections should be of the same type in order
	to be matched (True) or not (False). (Keyword: "Connections_Same_Types_check" - Default Value: False)

	"""

    report_types: object = None
    """
	is a list with the types of the created report. The accepted types
	are 'PDF', 'PPTX', 'XLSX', and 'CSV'. (Keywords: "Export_PDF_Report", "Export_PPTX_Report", "Export_XLSX_Report", and "Export_CSV_Report" - Default Value: ['PDF'])

	"""

    report_filename: str = None
    """
	is the name of created report. (Default Value: 'compare_report')

	"""

    report_exporting_directory: str = None
    """
	is the directory where the created report and all the related files
	are exported. (Keyword: "Export_Report_Dir" - Default Value: 'Temp'
	folder in the user's home directory)

	"""

    report_visible_list: bool = None
    """
	defines whether only the isolated entities in the Compare Report
	list (True) or all the entities are included in the created report
	(False). (Keyword: "Export_visible_list" - Default Value: False)

	"""

    report_geometry_info: bool = None
    """
	defines whether the differences in parts are included in the created
	report (True) or not (False). (Keyword: "Export_geometry_in_report"
	- Default Value: True)

	"""

    report_matched_parts_no_differences: bool = None
    """
	defines whether the matched parts without differences are included in
	created report of type XLSX/CSV (True) or not (False). (Keyword:
	"Export_matched_parts_no_differences" - Default Value: False)

	"""

    report_unmatched_parts: bool = None
    """
	defines whether the differences in unmatched parts are included in
	created report (True) or not (False). (Keyword: "Export_unmatched_parts" - Default Value: False)

	"""

    report_model_images_per_diff: str = None
    """
	defines the layout of the created report. The accepted values are:
	- 'PAIR_OF_PICS' the models are displayed in two separate images,
	- 'SINGLE_PIC' the models are displayed overlapped in same image,
	- 'BOTH_SINGLE_AND_PAIR' the models are displayed both in two
	separate images and overlapped in a single image,
	- 'NO_PIC' where no model images are included in the created report.
	(Keyword: "Num_of_pics_per_diff" - Default Value: 'BOTH_SINGLE_AND_PAIR')

	"""

    report_3d_model: bool = None
    """
	defines whether the common display of the models is presented in 3D
	(True) or in 2D (False) representation. (Keyword: "Export_MetaDB" -
	Default Value: True)

	"""

    report_part_location_in_model: bool = None
    """
	defines whether the images of the part's location in the model are
	included in the created report (True) or not (False). (Keyword:
	"Show_part_location_in_model" - Default Value: True)

	"""

    report_connections_info: bool = None
    """
	defines whether the differences in connections are included in the
	created report (True) or not (False). (Keyword: "Export_connections_in_report" - Default Value: False)

	"""

    report_unmatched_connections: bool = None
    """
	defines whether the differences in unmatched connections are
	included in the created report (True) or not (False). (Keyword:
	"Export_unmatched_connections" - Default Value: False)

	"""

    report_ansa_post_script: str = None
    """
	is the full path of the script which is used for the creation of the
	XLSX and the CSV reports. (Keyword: "Ansa_Script_File" - Default
	Value: '$ANSA_EXEC_DIR/scripts/General/CompareReportList.pyb')

	"""

    report_meta_executable_path: str = None
    """
	is the full path of the META executable which is used for the
	creation of the PDF and the PPTX reports. (Keyword: "Metapost_Command" - Default Value: The path of META executable)

	"""

    report_meta_post_arguments: str = None
    """
	defines the additional command line arguments which should be passed
	to META for the compilation of the PDF and the PPTX reports.
	(Keyword: "Metapost_Arguments" - Default Value: Blank)

	"""

    report_meta_post_script: str = None
    """
	is the full path of the script which is used for the creation of the
	PDF and the PPTX reports. (Keyword: "Meta_Script_File" - Default
	Value: '$ANSA_EXEC_DIR/scripts/General/CompareReport.pyb')

	"""

    report_run_meta_in_batch_mode: bool = None
    """
	defines whether META runs in batch mode (True) or GUI is launched
	(False) during the compilation of the PDF and PPTX reports.
	(Keyword: "Meta_Batch_Mode" - Default Value: True)

	"""

    report_keep_current_visibility_settings: bool = None
    """
	defines whether the current visibility settings are used (True) or
	not (False) when the pictures are taken. (Keyword: "Keep_current_visibility_settings" - Default Value: False)

	"""

    report_model_transparency: int = None
    """
	is the level of transparency in the images of part's location in
	model. (Keyword: "Level_of_transparency" - Default Value: 90)

	"""

    report_image_width: int = None
    """
	is the width of all the exported images. (Keyword: "Photo_width" -
	Default Value: 1024)

	"""

    report_image_height: int = None
    """
	is the height of all the exported images. (Keyword: "Photo_height" -
	Default Value: 768)

	"""

    report_image_view_type: str = None
    """
	defines the view type of the images in order to display as much
	geometrical differences as possible. The accepted values are
	'DEFAULT' and 'BEST'. (Keyword: "Set_export_pictures_view_type" -
	Default Value: 'DEFAULT')

	"""

    report_image_background: str = None
    """
	defines the background color of the images. The accepted values are
	'WHITE', 'TRANSPARENT', and 'CURRENT'. (Keyword: "Set_export_pictures_background" - Default Value: 'WHITE')

	"""

    geometry_expand_differences_to_common_bounds: bool = None
    """
	defines whether geometric differences will be expanded until common bounds between Model 1 and Model 2 are found. This option improves the result of 'apply_similarities_differences' resulting in better topology. ((Keyword: "Geometry_Expand_Differences_To_Common_Bounds" - Default Value: False)

	"""

    geometry_automatch_search_distance: float = None
    """
	defines the proximity threshold for the matching of geometrical entites in Auto match mode.

	"""

    geometry_automatch_source_model: str = None
    """
	defines the model based on which the parts structure will be created in Auto match mode

	"""

    connections_matching_mode: str = None
    """
	Defines how the connections will be matched. The accepted values are:
	- 'MATCH_BASED_ON_NAME' where connections will be matched based on Name if it is not empty
	- 'MATCH_BASED_ON_GEOMETRY' where connections will be matched based on distance and geometrical similarity
	- 'MATCH_BASED_ON_NAME_AND_GEOMETRY' where connections will be matched based on Name. The remaining unmatched connections will be matched based on Geometry.
	
	Default value: MATCH_BASED_ON_GEOMETRY

	"""

    def run(self, comparison_scenario: str):
        """

        Execute the specified comparison scenario between the defined Model_01 and Model_02 according to the criteria specified through the comparisonobject's attributes (please check the class members which start with"geometry" and "connections" prefixes).


        Parameters
        ----------
        comparison_scenario : str, optional
                Defines the comparison scenario which is executed. The accepted values are:
                - 'GEOMETRY' to identify the differences only in parts.
                - 'CONNECTIONS' to identify the differences only in connections.
                - 'GEOMETRY_AND_CONNECTIONS' to identify the differences only in parts and connections.
                - 'FULL_COMPARISON' to identify all the differences in the models.
                (Default Value: 'FULL_COMPARISON').

        """

    def show_results(self, results_filter_name: str):
        """

        Launch the Compare Tool window to display the comparison results. A pre-defined filter can be optionally set and applied on the results list.


        Parameters
        ----------
        results_filter_name : str, optional
                The name of a pre-defined filter which is applied on the
                Compare Report list. (Keyword: "CURRENT_ADVANCED_FILTER_CONFIGURATION" - Default Value: 'Default')

        """

    def generate_report(self):
        """

        Create a report with the identified differences according to the specifications defined through the comparison object's attributes (please check the class members which start with the "report" prefix).


        """

    def save(self, filename: str):
        """

        Save the comparison results in an .ansa_compare file.


        Parameters
        ----------
        filename : str
                The full path of the *.ansa_compare file where the comparison results are stored.

        """

    def get_matched_parts(self) -> object:
        """

        get the matched parts/groups (with and without diffs) of the comparison process.


        Returns
        -------
        object
                return a dictionary with keys the objects of the parts/groups which have been matched in Model_01 and values the objects of their matching parts/groups in Model_02 {'object_of_part_in_Model_01' : 'object_of_matching_part_in_Model_02'}.

        """

    def get_part_differences(self, part: object) -> object:
        """

        get the identified differences on a part/group.


        Parameters
        ----------
        part : object
                is the part/group where the differences have been identified.

        Returns
        -------
        object
                returns an object of objects (one object for each category of differences). The "geometry" object includes the geometrical differences and it has the "percentage" attribute, which is the differences percentage (float) of the part, and the "entities" attribute, which is a list of lists which include the identified different faces and shells (the faces and shells are automatically organized into lists through the Connectivity Groups function). The "attributes" object is a dictionary with keys the part/group attributes where differences have been identified and values the respective part/group attribute values.

        """

    def modify_geometrical_differences(
        self, part: object, entities_to_add: object, entities_to_remove: object
    ):
        """

        Add and/or remove entities (faces/shells) from the identified geometrical differences of a part.


        Parameters
        ----------
        part : object
                The part where the modification is applied.

        entities_to_add : object, optional
                A list with the entities (faces/shells) which should be added to the identified geometrical differences.

        entities_to_remove : object, optional
                A list with the entities (faces/shells) which should be removed from the identified geometrical differences.

        """

    def apply_similarities_differences(
        self,
        parts: object,
        model: str,
        entities_to_replace: str,
        properties_to_keep: str,
        treat_target_perimeters_as_frozen: bool,
        face_macro_mode: str,
        mesh_action_on_macros_release: str,
        undelete_original_faces: bool,
        properties_matching: str,
        paste_red_bounds: bool,
    ) -> int:
        """

        Apply the identified similar or different entities from a list of parts in Model 1/2 to their matching parts in Model 2/1 respectively.


        Parameters
        ----------
        parts : object
                A list of part objects where the function is applied.

        model : str
                Define if the identified similar/different entities are transferred from Model 1 ('MODEL_1') or Model 2 ('MODEL_2').

        entities_to_replace : str
                Define if the similar ('SIMILAR') or the different ('DIFFERENT') entities are replaced.

        properties_to_keep : str, optional
                Define if the properties of the incoming ('KEEP_NEW') or the outgoing ('KEEP_OLD') entities are kept.

        treat_target_perimeters_as_frozen : bool, optional
                Define if the perimeters of the Model where the similarities / differences will be applied will be frozen (True) or not (False). Default is False. Note that if set to to True and the perimeters to be pasted are incompatible, paste will fail.

        face_macro_mode : str, optional
                Available values are "FACE", "MACRO". If set to "FACE", the function will work on face level and any joined CONS will be released. If set to "MACRO", the entire macro will be applied. Default is "FACE".

        mesh_action_on_macros_release : str, optional
                Available values are "ERASE", "RECONSTRUCT", "REMESH", "KEEP". Define the action on the mesh if joined CONS need to be released. Default is "ERASE".

        undelete_original_faces : bool, optional
                Define if outgoing Faces will be recoverable through Faces>Undelete. Default is False.

        properties_matching : str, optional
                Available values are "NAME_ID", "NAME", "ID". Define how incoming properties will be merged with outgoing. If "NAME_ID" is set, an incoming property will be merged with an outgoing if either the Name or the ID match. If "NAME" is set, merging will take place only for properties with the same Name. If "ID" is set, merging will take place only for properties with the same ID. Default is "NAME_ID".

        paste_red_bounds : bool, optional
                If True, single Cons of Model 1 and / or Model 2 will be pasted to any matching neighbouring Cons. Default is False.

        Returns
        -------
        int
                Returns 0 if no entities were applied, or 1 otherwise.

        """

    @classmethod
    def open(cls, filename: str) -> object:
        """

        Open the comparison results which are stored in an .ansa_compare file.


        Parameters
        ----------
        filename : str
                The full path of the *.ansa_compare file where the comparison results are stored.

        Returns
        -------
        object
                Returns a comparison object/instance.

        """

    def __init__(self, model1: object, model2: object):
        """

        CompareTool constructor


        Parameters
        ----------
        model1 : object
                The first model object to compare

        model2 : object
                The second model object to compare

        """

    def apply_mesh(self, parts: object, model: str) -> object:
        """

        Copies the mesh from one Model onto the other


        Parameters
        ----------
        parts : object
                A list of part objects where the function is applied.

        model : str
                Define if the mesh is transferred from Model 1 ('MODEL_1') or Model 2 ('MODEL_2').

        Returns
        -------
        object
                A dictionary with the following keys:'source_succeeded_macros' is a list with the input meshed macros whose mess got transferred successfully, 'target_succeeded_macros'is a list with the target meshed macros that successfully received the mesh, 'source_failed_macros' is a list with the input meshed macros whose mesh failed to be transferred and 'target_failed_macros' is a list with the target macros that failed to be meshed.

        """

    def get_matched_features(self) -> object:
        """

        get the matched features (with and without diffs) of the comparison process.


        Returns
        -------
        object
                return a dictionary with keys the objects of the features which have been matched in Model_01 and values the objects of their matching feature in Model_02.

        """

    def get_feature_differences(self, feature: object) -> object:
        """

        get the identified differences on a feature.


        Parameters
        ----------
        feature : object
                It is the feature where the differences have been identified.

        Returns
        -------
        object
                returns an object of objects (one object for each category of differences). The "geometry" object includes "percentage" attribute, which is the differences percentage (float) of the feature. The "attributes" object is a dictionary with keys the feature attributes where differences have been identified and values the respective attribute values.

        """

    def get_matched_connections(self) -> object:
        """

        get the matched connections (with and without diffs) of the comparison process.


        Returns
        -------
        object
                return a dictionary with keys the objects of the connections which have been matched in Model_01 and values the objects of their matching connections in Model_02.

        """

    def get_connection_differences(self, connection: object) -> object:
        """

        get the identified differences on a connection.


        Parameters
        ----------
        connection : object
                It is the connection where the differences have been identified.

        Returns
        -------
        object
                returns an object containing the attributes category of differences. The "attributes" object is a dictionary with keys the connection attributes where differences have been identified and values the respective attribute values.

        """


class SearchByProximityTool:
    """

    The SearchByProximityTool is a module that enables the search of items that are proximal to a list of input items,
    according to their position.

    The module is initialized by defining:
    1. The source items, i.e., the items whose proximal items we seek (acceptable types are: parts, groups, Subsystems, server ids, and boxes).
    2. The target items, i.e., the candidate items that will take part in the search (acceptable types are: parts, groups, Subsystems and server ids).
    3. The tolerance, i.e., the maximum allowed distance between two items in order to be considered proximal.

    The module returns the list of proximal items, i.e., the subset of target items that are proximal to the source items.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import session
            from ansa import dm


            def main():
                use_case_01()


            def use_case_01():
                # search for parts in model and DM proximal to other parts
                search_engine = base.SearchByProximityTool()
                search_engine.tolerance = 0

                search_engine.should_search_in_model = True
                search_engine.should_search_in_dm = False

                source_group = base.GetPartFromModuleId("GROUP_7")
                source_parts = base.CollectEntities(0, source_group, "ANSAPART")

                model_parts = base.CollectEntities(0, None, "ANSAPART")
                if search_engine.should_search_in_dm:
                    source_parts.append(source_group)
                    model_parts.extend(base.CollectEntities(0, None, "ANSAGROUP"))
                search_engine.source_entities = source_parts
                search_engine.target_entities = list(set(model_parts) - set(source_parts))
                search_engine.run()
                proximal_parts = search_engine.proximal_entities

                non_proximal_entities = list(
                    set(search_engine.target_entities) - set(search_engine.proximal_entities)
                )
                base.Not(non_proximal_entities)
                fields = {"Is Active": "NO"}
                for entity in proximal_parts:
                    base.SetEntityCardValues(0, entity, fields)


            def use_case_02():
                # search subsystems in DM proximal to model parts
                part1 = base.GetPartFromModuleId("6010001")
                source_parts = [part1]
                subsystems_server_ids = get_all_subsystems_server_ids()
                search_engine = base.SearchByProximityTool()
                search_engine.tolerance = 100
                search_engine.source_entities = source_parts
                search_engine.target_server_ids = subsystems_server_ids
                search_engine.run()
                proximal_server_ids = search_engine.proximal_server_ids
                print_results(proximal_server_ids)


            def use_case_03():
                # search the subsystems in DM that reside to a bounding box
                box = get_box(1)
                subsystems_server_ids = get_all_subsystems_server_ids()
                search_engine = base.SearchByProximityTool()
                search_engine.tolerance = 0
                search_engine.source_boxes = [box]
                search_engine.target_server_ids = subsystems_server_ids
                search_engine.run()
                proximal_server_ids = search_engine.proximal_server_ids
                print_results(proximal_server_ids)


            def get_all_subsystems_server_ids():
                subsystems_in_dm = base.GetAllItemsInDM("Subsystems")
                subsystems_server_ids = []
                for item in subsystems_in_dm:
                    subsystems_server_ids.append(item["_server_id_"])
                return subsystems_server_ids


            def print_results(server_ids):
                list_of_dicts = dm.GetAttributesFromUniqueRepresentations(
                    server_id=server_ids, type="Subsystems"
                )
                print("Results:")
                for each_dict in list_of_dicts:
                    print(
                        "Module Id = "
                        + each_dict["Module Id"]
                        + "\\t"
                        + "  Study Version = "
                        + each_dict["Study Version"]
                    )


            def get_subsystems_module_id(proximal_server_ids):
                subsystems_in_dm = base.GetAllItemsInDM("Subsystems")
                proximal_subsystems_module_id = []
                for item in subsystems_in_dm:
                    if item["_server_id_"] in proximal_server_ids:
                        proximal_subsystems_module_id.append(item["Module Id"])
                return proximal_subsystems_module_id


            def get_box(id):
                box_entity = base.GetEntity(0, "BCBOX", id)
                position = ["XMN", "YMN", "ZMN", "XMX", "YMX", "ZMX"]
                dict = base.GetEntityCardValues(0, box_entity, position)
                box = [dict["XMN"], dict["YMN"], dict["ZMN"], dict["XMX"], dict["YMX"], dict["ZMX"]]
                return box

    """

    tolerance: float = None
    """
	(INPUT) The maximum allowed distance between two items in order to be considered 
	proximal. 'tolerance' should take positive float values.
	The default value is 0.

	"""

    source_entities: object = None
    """
	(INPUT) The list of ANSA entities whose proximal items we seek. 
	Available types are: 'parts', 'groups', and 'Subsystems'. 
	The source entities position information is taken either from the current ANSA model or 
	the DM, according to the value of the flags 'should_search_in_model' and 
	'should_search_in_DM'.
	This member is optional if 'source_server_ids' or 'source_boxes' are defined.

	"""

    source_server_ids: str = None
    """
	(INPUT) The list of server ids whose proximal items we seek.
	This member is optional if 'source_entities' or 'source_boxes' are defined.

	"""

    source_boxes: float = None
    """
	(INPUT) The list of boxes whose proximal items we seek.
	A box is defined by its main diagonal as a list of 6 floats in the form: 
	[mixx, miny, minz, maxx, maxy, maxz].
	This member is optional if 'source_entities' or 'source_server_ids' are defined.

	"""

    target_entities: object = None
    """
	(INPUT) The list of ANSA entities that will be searched.
	Available types are: parts, groups, and Subsystems.
	The target entities position information is taken either from the current ANSA model or 
	the DM, according to the value of the flags 'should_search_in_model' and 
	'should_search_in_DM'.
	This member is optional if 'target_server_ids' is defined.

	"""

    target_server_ids: str = None
    """
	(INPUT) The list of server ids that will be searched.
	This member is optional if 'target_entities' is defined.

	"""

    should_search_in_model: bool = None
    """
	(INPUT) This flag, in combination with the flag 'should_search_in_DM' regulates if the 
	position information of the ANSA entities defined in 'source_entities' and 
	'target_entities' will be calculated from the current ANSA model or the DM.
	This flag is valid only if 'source_entities' or 'target_entities' are defined.
	The default value is True.
	See the REMARKS for mode information.

	"""

    should_search_in_dm: bool = None
    """
	(INPUT) This flag, in combination with the flag 'should_search_in_model' regulates if 
	the position information of the ANSA entities defined in 'source_entities' and 
	'target_entities' will be calculated from the current ANSA model or the DM.
	This flag is valid only if 'source_entities' or 'target_entities' are defined.
	The default value is False.
	See the REMARKS for mode information.

	"""

    proximal_entities: object = None
    """
	(OUTPUT) A subset of the 'target_entities' that are proximal to the source data.
	'proximal_entities' are available only if 'target_entities' are defined.

	"""

    proximal_server_ids: str = None
    """
	(OUTPUT) A subset of the 'target_server_ids' that are proximal to the source data.
	'proximal_server_ids' are available only if 'target_server_ids' are defined.

	"""

    error_messages: str = None
    """
	(OUTPUT) The list of error messages returned by the run() method. 
	In case of no errors, it returns an empty string.

	"""

    def run(self):
        """

        This method executes the SearchByProximity job.


        """


class DBStorage:
    """

    With the DBStorage object the user can save data in the ANSA database in a key-value manner.
    This object is accompanied by a GUI which can be found in Utilites > User Storage:Database.

    DBStorage is a unique object (singleton) in the program, every DBStorage instance points to the same object.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dbs = base.DBStorage()

                dbs.set("ia", 15)
                dbs.set("da", 17.2)
                dbs.set("sa", "abc")
                dbs.set("img", open("file.png", "rb").read())

                ia = dbs.get("ia", 0)  # returns 15
                da = dbs.get("da", 0.0)  # returns 17.2
                sa = dbs.get("sa", "default")  # returns 'abc'
                sa = dbs.get("img", bytes())  # returns img file.png

                ret = dbs.get("ib", 0)  # returns 0
                ret = dbs.get("ib")  # returns None

                ret = dbs.contains("ia")  # returns True
                ret = dbs.contains("ib")  # returns False

                ret = (
                    dbs.contents()
                )  # returns a dictionary will all contents of User Database Storage

                print(dbs.remove("ia", 2))  # removes key 'ia' and returns 15
                print(dbs.remove("ib", 2))  # key doesn't exist. returns 2
                dbs.remove("ib")  # key doesn't exist. raises exception

                base.SaveAs("dbstorage/db.ansa")

                dbs.clear_contents()
                del dbs

    """

    def clear_contents(self) -> object:
        """

        Clears the contents of the User Storage:Database.


        Returns
        -------
        object
                Always returns None.

        """

    def contains(self, key: str) -> bool:
        """

        Searches for a particular key in the User Storage:Database.


        Parameters
        ----------
        key : str
                The key that will be searched for inside the User Storage:Database.

        Returns
        -------
        bool
                True if the key is found else, it returns False.

        """

    def contents(self) -> object:
        """

        et all contents of the User Storage:Database.


        Returns
        -------
        object
                Returns a dictionary object with the keys and the values that are stored inside User Storage:Database, or None if User Storage:Database is empty.

        """

    def get(self, key: str, default: object) -> object:
        """

        Retrieve the value of a particular key from the User Storage:Database.


        Parameters
        ----------
        key : str
                The key that will be retrieved from the User Storage:Database.

        default : object, optional
                A value that will be returned if the key is not found in User Storage:Database.

        Returns
        -------
        object
                On success, returns the value that is stored under the given key. On failure returns the given value if provided. Else, returns None.

        """

    def remove(self, key: str, default: object) -> object:
        """

        Remove a particular key record from the User Storage:Database.


        Parameters
        ----------
        key : str
                The key that will be removed from the User Storage:Database.

        default : object, optional
                A value that will be returned if the key is not found in User Storage:Database.

        Returns
        -------
        object
                On success, it returns the value that was stored under the given key. On failure, it returns the given value if provided, otherwise it raises a KeyError exception.

        """

    def set(self, key: str, value: object) -> object:
        """

        Set a new value in the User Storage:Database under a given key.


        Parameters
        ----------
        key : str
                The key that will be used to store the value inside User Storage:Database.

        value : object
                The value that will be stored under the key in User Storage:Database.
                It can be:
                -string
                -int
                -double
                -bytes
                -list of Entities

        Returns
        -------
        object
                If the key already exists in User Storage:Database returns an object that contains its prior value.Else, it returns None.

        """


class ImportV1:
    """

    With ImportV1 the user can import whichever FE format into ANSA in a very fast way.
    The API supports creation of Nodes, Shells and Solids (1st and 2nd order), Shell Properties and Solid Properties.

    Examples
    --------
    ::

            import itertools

            import ansa
            from ansa import base
            from ansa import session


            def main():

                Example for reading a Free Format file

                session.New("discard")

                a = base.ImportV1()

                a.start()

                f = open("file.free")
                line = f.readline()

                s = line.split()

                n_nodes = int(s[0])
                n_shells = int(s[1])
                n_solids = 0
                if len(s) == 3:
                    n_solids = int(s[2])
                # Create Nodes
                id = [None] * n_nodes
                x = [None] * n_nodes
                y = [None] * n_nodes
                z = [None] * n_nodes

                n_count = 0

                for _ in map(str.split, itertools.islice(f, n_nodes)):
                    id[n_count] = n_count + 1
                    x[n_count] = float(_[0])
                    y[n_count] = float(_[1])
                    z[n_count] = float(_[2])
                    n_count = n_count + 1
                a.create_nodes(id, x, y, z)

                del id
                del x
                del y
                del z
                # ~Create Nodes

                # Create Shells
                id = [None] * n_shells
                t = [None] * n_shells
                pid = [None] * n_shells
                n1 = [None] * n_shells
                n2 = [None] * n_shells
                n3 = [None] * n_shells
                n4 = [None] * n_shells

                n_count = 0

                for _ in map(str.split, itertools.islice(f, n_shells)):
                    id[n_count] = n_count + 1
                    pid[n_count] = 1
                    n1[n_count] = int(_[0])
                    n2[n_count] = int(_[1])
                    n3[n_count] = int(_[2])
                    n4[n_count] = int(_[3])
                    if n3[n_count] == n4[n_count]:
                        t[n_count] = a.TRIA
                    else:
                        t[n_count] = a.QUAD
                    n_count = n_count + 1
                a.create_shells(id, t, pid, n1, n2, n3, n4)

                del id
                del t
                del pid
                del n1
                del n2
                del n3
                del n4
                # ~Create Shells

                # Create Solids
                if n_solids > 0:
                    id = [None] * n_solids
                    pid = [None] * n_solids
                    n1 = [None] * n_solids
                    n2 = [None] * n_solids
                    n3 = [None] * n_solids
                    n4 = [None] * n_solids
                    n5 = [None] * n_solids
                    n6 = [None] * n_solids
                    n7 = [None] * n_solids
                    n8 = [None] * n_solids
                    t = [None] * n_solids

                    n_count = 0

                    for _ in map(str.split, itertools.islice(f, n_solids)):
                        id[n_count] = n_count + 1
                        pid[n_count] = 2
                        n1[n_count] = int(_[0])
                        n2[n_count] = int(_[1])
                        n3[n_count] = int(_[2])
                        n4[n_count] = int(_[3])
                        n5[n_count] = int(_[4])
                        n6[n_count] = int(_[5])
                        n7[n_count] = int(_[6])
                        n8[n_count] = int(_[7])

                        if n5[n_count] == 0:
                            t[n_count] = a.TETRA
                        elif n6[n_count] == 0:
                            t[n_count] = constans.HEOP
                        elif n7[n_count] == 0 or n8[n_count] == 0:
                            t[n_count] = a.PENTA
                        else:
                            t[n_count] = a.HEXA
                        n_count = n_count + 1
                    a.create_solids(id, t, pid, n1, n2, n3, n4, n5, n6, n7, n8)

                    del id
                    del pid
                    del t
                    del n1
                    del n2
                    del n3
                    del n4
                    del n5
                    del n6
                    del n7
                    del n8
                # ~Create Solids

                f.close()

                a.build()

                # \tprint(a.nodes)
                # \tprint(a.shells)
                # \tprint(a.solids)
                # \tprint(a.pshells)
                # \tprint(a.psolids)

                a.finish()
                del a

    """

    nodes: object = None
    """
	Returns a list with the created Nodes or None if there aren't any created.
	This member is accessible only between build() and finish().

	"""

    shells: object = None
    """
	Returns a list with the created 1st order Shells or None if there aren't any created.
	This member is accessible only between build() and finish().

	"""

    shells2: object = None
    """
	Returns a list with the created 2nd order Shells or None if there aren't any created.
	This member is accessible only between build() and finish().

	"""

    solids: object = None
    """
	Returns a list with the created 1st order Solids or None if there aren't any created.
	This member is accessible only between build() and finish().

	"""

    solids2: object = None
    """
	Returns a list with the created 2nd order Solids or None if there aren't any created.
	This member is accessible only between build() and finish().

	"""

    pshells: object = None
    """
	Returns a list with the created Shell Properties or None if there aren't any created.
	This member is accessible only between build() and finish().

	"""

    psolids: object = None
    """
	Returns a list with the created Solid Properties or None if there aren't any created.
	This member is accessible only between build() and finish().

	"""

    TRIA: int = None
    """
	Denotes TRIA shell type.

	"""

    QUAD: int = None
    """
	Denote Quad shell type.

	"""

    TRIA6: int = None
    """
	Denote TRIA6 shell type.

	"""

    QUAD8: int = None
    """
	Denote QUAD8 shell type.

	"""

    TETRA: int = None
    """
	Denote TETRA shell type.

	"""

    PENTA: int = None
    """
	Denote PENTA shell type.

	"""

    HEOP: int = None
    """
	Denote HEOP shell type.

	"""

    HEXA: int = None
    """
	Denote HEXA shell type.

	"""

    TETRA2: int = None
    """
	Denote TETRA2 shell type.

	"""

    PENTA2: int = None
    """
	Denote PENTA2 shell type.

	"""

    HEXA2: int = None
    """
	Denote HEXA2 shell type.

	"""

    HEOP2: int = None
    """
	Denote HEOP2 shell type.

	"""

    @classmethod
    def start(cls) -> object:
        """

        Start import.


        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def create_nodes(cls, id: object, x: object, y: object, z: object) -> object:
        """

        Create Nodes with the read data.


        Parameters
        ----------
        id : object
                A list with the Node ids.

        x : object
                A list with the x coordinates.

        y : object
                A list with the y coordinates.

        z : object
                A list with the z coordinates.

        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def create_shells(
        cls,
        id: object,
        type: object,
        pid: object,
        node1: object,
        node2: object,
        node3: object,
        node4: object,
    ) -> object:
        """

        Create 1st order Shells with the read data.


        Parameters
        ----------
        id : object
                A list with the Shell ids.

        type : object
                A list with the Shell types.

                Available types are:
                -ImportV1.TRIA
                -ImportV1.QUAD

        pid : object
                A list with the Shell Property ids.

        node1 : object
                A list with the node1 ids.

        node2 : object
                A list with the node2 ids.

        node3 : object
                A list with the node3 ids.

        node4 : object
                A list with the node4 ids.

        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def create_shells2(
        cls,
        id: object,
        type: object,
        pid: object,
        node1: object,
        node2: object,
        node3: object,
        node4: object,
        node5: object,
        node6: object,
        node7: object,
        node8: object,
    ) -> object:
        """

        Create 2nd order Shells with the read data.


        Parameters
        ----------
        id : object
                A list with the Shell ids.

        type : object
                A list with the Shell types.

                Available types:
                -ImportV1.TRIA6
                -ImportV1.QUAD8

        pid : object
                A list with the Shell Property ids.

        node1 : object
                A list with the node1 ids.

        node2 : object
                A list with the node2 ids.

        node3 : object
                A list with the node3 ids.

        node4 : object
                A list with the node4 ids.

        node5 : object
                A list with the node5 ids.

        node6 : object
                A list with the node6 ids.

        node7 : object
                A list with the node7 ids.

        node8 : object
                A list with the node8 ids.

        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def create_solids(
        cls,
        id: object,
        type: object,
        pid: object,
        node1: object,
        node2: object,
        node3: object,
        node4: object,
        node5: object,
        node6: object,
        node7: object,
        node8: object,
    ) -> object:
        """

        Create 1st order Solids with the read data.


        Parameters
        ----------
        id : object
                A list with the Solid ids.

        type : object
                A list with the Solid types.

                Available types are:
                -ImportV1.TETRA
                -ImportV1.PENTA
                -ImportV1.HEOP
                -ImportV1.HEXA

        pid : object
                A list with the Solid Property ids.

        node1 : object
                A list with the Solid node1 ids.

        node2 : object
                A list with the Solid node2 ids.

        node3 : object
                A list with the Solid node3 ids.

        node4 : object
                A list with the Solid node4 ids.

        node5 : object
                A list with the Solid node5 ids.

        node6 : object
                A list with the Solid node6 ids.

        node7 : object
                A list with the Solid node7 ids.

        node8 : object
                A list with the Solid node8 ids.

        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def create_solids2(
        cls,
        id: object,
        type: object,
        pid: object,
        node1: object,
        node2: object,
        node3: object,
        node4: object,
        node5: object,
        node6: object,
        node7: object,
        node8: object,
        node9: object,
        node10: object,
        node11: object,
        node12: object,
        node13: object,
        node14: object,
        node15: object,
        node16: object,
        node17: object,
        node18: object,
        node19: object,
        node20: object,
    ) -> object:
        """

        Create 2nd order Solids with the read data.


        Parameters
        ----------
        id : object
                A list with the Solid ids.

        type : object
                A list with the Solid types.

                Available types are:
                -ImportV1.TETRA2
                -ImportV1.PENTA2
                -ImportV1.HEOP2
                -ImportV1.HEXA2

        pid : object
                A list with the Solid Property ids.

        node1 : object
                A list with the node1 ids.

        node2 : object
                A list with the node2 ids.

        node3 : object
                A list with the node3 ids.

        node4 : object
                A list with the node4 ids.

        node5 : object
                A list with the node5 ids.

        node6 : object
                A list with the node6 ids.

        node7 : object
                A list with the node7 ids.

        node8 : object
                A list with the node8 ids.

        node9 : object
                A list with the node9 ids.

        node10 : object
                A list with the node10 ids.

        node11 : object
                A list with the node11 ids.

        node12 : object
                A list with the node12 ids.

        node13 : object
                A list with the node13 ids.

        node14 : object
                A list with the node14 ids.

        node15 : object
                A list with the node15 ids.

        node16 : object
                A list with the node16 ids.

        node17 : object
                A list with the node17 ids.

        node18 : object
                A list with the node18 ids.

        node19 : object
                A list with the node19 ids.

        node20 : object
                A list with the node20 ids.

        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def create_shell_properties(cls, id: object, thickness: object) -> object:
        """

        Create Shell Properties with the read data.


        Parameters
        ----------
        id : object
                A list with the Shell Property ids.

        thickness : object, optional
                A list with the Shell Property thicknesses.

        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def create_solid_properties(cls, id: object) -> object:
        """

        Create Solid Properties with the read data.


        Parameters
        ----------
        id : object
                A list with the Solid Property ids.

        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def build(cls) -> object:
        """

        Build the model with the previously created entities.


        Returns
        -------
        object
                Always returns None.

        """

    @classmethod
    def finish(cls) -> object:
        """

        Finish the import procedure.


        Returns
        -------
        object
                Always returns None.

        """


class FringeDrawMode:
    """

    The FringeDrawMode object creates a custom fringe drawing style in order to alter the view of the model.
    It affects Shells, Solids, Solid Facets and Nodal results.

    Each FringeDrawMode is defined by its name and can hold a single fringe. All the created FringeDrawModes
    appear in the Fringe button of the Drawing Styles toolbar along with their names. They can be enabled/disabled
    manually just like the native Fringe Draw Modes. Color bar options are applied to them as well.

    By default the FringeDrawMode will be visible in the deck being current when created.
    To define manually the decks use FringeDrawMode.deck_visibility() method.

    The Fringe values will be automatically recalculated when needed e.g. a Shell is created or deleted.
    Depending on the calculations this may not always be possible. In this case you can use the static method
    FringeDrawMode.recalculate() to force recalculation.

    In case data used in fringe drawing are constant and they are not affected from ANSA operations like visibility change, elements creation/deletion etc.
    You could avoid extra calculations and improve performance by using static method FringeDrawMode.fringe_static()

    The programmer may create many FringeDrawModes and allow the control to return to ANSA.
    A FringeDrawMode stays alive for the whole ANSA session unless deleted by the programmer.

    See Also
    --------
    FringeDrawModeList, DrawMode, DrawModeList, Canvas

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            # Draw every shell with its id as value
            class DrawOnShells:
                def __init__(self, deck):
                    self.values = {}
                    self.deck = deck

                def start(self):
                    self.values.clear()

                def end(self):
                    return self.values

                def __call__(self, entity, *args, **kwargs):
                    self.values[entity] = entity._id


            # Draw every solid facet with its index as value
            class DrawOnFacets:
                def __init__(self, deck):
                    self.values = {}
                    self.deck = deck

                def start(self):
                    self.values.clear()

                def end(self):
                    return self.values

                def __call__(self, entity, *args, **kwargs):
                    type = entity.get_entity_values(self.deck, ("type",))["type"]
                    if type == "HEXA":
                        facets = 6
                    elif type == "PENTA":
                        facets = 5
                    elif type == "TETRA":
                        facets = 4
                    for index in range(1, facets + 1):
                        self.values[
                            base.Entity(constants.NASTRAN, entity._id, "SOLID", facet=index)
                        ] = index


            # Draw every node with its nodal thickness as value
            class DrawOnNodes:
                def __init__(self, deck):
                    self.values = {}
                    self.deck = deck

                def start(self):
                    self.values.clear()

                def end(self):
                    return self.values

                def __call__(self, entity, *args, **kwargs):
                    type = entity.get_entity_values(self.deck, ("type",))["type"]
                    if type == "TRIA":
                        ret = entity.get_entity_values(
                            self.deck, ("G1", "G2", "G3", "t1", "t2", "t3")
                        )
                        self.values[ret["G1"]] = ret["t1"]
                        self.values[ret["G2"]] = ret["t2"]
                        self.values[ret["G3"]] = ret["t3"]
                    elif type == "QUAD":
                        ret = entity.get_entity_values(
                            self.deck, ("G1", "G2", "G3", "G4", "t1", "t2", "t3", "t4")
                        )
                        self.values[ret["G1"]] = ret["t1"]
                        self.values[ret["G2"]] = ret["t2"]
                        self.values[ret["G3"]] = ret["t3"]
                        self.values[ret["G4"]] = ret["t4"]


            # Draw every Shell with the mod 2 of its id and every Solid with the mod 3 of its id
            class DrawShellsSolids:
                def __init__(self, deck):
                    self.values = {}
                    self.deck = deck

                def start(self):
                    self.values.clear()

                def end(self):
                    return self.values

                def __call__(self, entity, *args, **kwargs):
                    ansa_type = entity.ansa_type(self.deck)
                    if ansa_type == "SHELL":
                        self.values[entity] = entity._id % 2
                    elif ansa_type == "SOLID":
                        self.values[entity] = entity._id % 3


            # Draw each side of every Shell with the values (1, 2), if its id is even and (3, 4), if it is odd.
            # (The first number of the tuple is the color of the top side of the Shell and the second number is the bottom side).
            # Also, draw every Solid with the mod 3 of its id.
            class DrawShellsBothSides:
                def __init__(self, deck):
                    self.values = {}
                    self.deck = deck

                def start(self):
                    self.values.clear()

                def end(self):
                    return self.values

                def __call__(self, entity):
                    ansa_type = entity.ansa_type(self.deck)
                    if ansa_type == "SHELL":
                        if entity._id % 2 == 0:
                            self.values[entity] = (1, 2)
                        else:
                            self.values[entity] = (3, 4)
                    elif ansa_type == "SOLID":
                        self.values[entity] = entity._id % 3


            # Draw every Shell with the value of the INITIAL CONDITIONS TYPE=HARDENING that is applied onto it
            class DrawInitHard:
                def __init__(self, deck):
                    self.values = {}
                    self.deck = deck

                def start(self):
                    self.values.clear()

                def end(self):
                    return self.values

                def __call__(self, entity, *args, **kwargs):
                    ret = base.GetEntityCardValues(
                        self.deck, entity, ("by", "EID", "ELSET", "STRAIN")
                    )

                    strain = ret["STRAIN"]

                    if ret["by"] == "element":
                        eid = ret["EID"]
                        element = base.GetEntity(self.deck, "SHELL", eid)
                        self.values[element] = self.values.get(element, 0) + strain
                    else:
                        sid = ret["ELSET"]
                        elset = base.GetEntity(self.deck, "SET", sid)
                        elements = base.CollectEntities(self.deck, elset, "SHELL")
                        for element in elements:
                            self.values[element] = self.values.get(element, 0) + strain


            def main():
                deck = constants.ABAQUS

                draw_mode = base.FringeDrawMode("SHELLS")
                draw_mode.fringe(deck, "SHELL", "element", DrawOnShells(deck))

                draw_mode = base.FringeDrawMode("FACETS")
                draw_mode.fringe(deck, "SOLID", "element", DrawOnFacets(deck))

                draw_mode = base.FringeDrawMode("NODES")
                draw_mode.fringe(deck, "SHELL", "node", DrawOnNodes(deck))

                draw_mode = base.FringeDrawMode("SHELLS/SOLIDS")
                draw_mode.fringe(deck, ("SHELL", "SOLID"), "element", DrawShellsSolids(deck))

                draw_mode = base.FringeDrawMode("SHELLS TOP BOTTOM PLUS SOLIDS")
                draw_mode.fringe(
                    deck, ("SHELL", "SOLID"), "shell_top_bottom", DrawShellsBothSides(deck)
                )

                draw_mode = base.FringeDrawMode("INIT.HARD.")
                draw_mode.fringe(
                    deck, "INITIAL CONDITIONS TYPE=HARDENING", "element", DrawInitHard(deck)
                )

                # Enable the last FringeDrawMode


            #       draw_mode.enable()

            # Delete all FringeDrawModes
            #       draw_modes = base.FringeDrawModeList()
            #       for draw_mode in draw_modes:
            #               print(draw_mode._name)
            #               draw_mode.delete()

    """

    _name: str = None
    """
	The name of the FringeDrawMode.

	"""

    def __init__(self, name: str, icon: str) -> object:
        """

        FringeDrawMode object constructor.


        Parameters
        ----------
        name : str
                The name of the FringeDrawMode. If you call the
                constructor with a name that already exists the existing
                object will be returned.

        icon : str, optional
                The path for the icon to be displayed next to the
                FringeDrawMode name in the Fringe button popup.
                By default no icon will be displayed.

        Returns
        -------
        object
                Returns the created FringeDrawMode object.

        """

    def enable(self) -> object:
        """

        Enable the FringeDrawMode. The model is drawn with the values of the programmer.


        Returns
        -------
        object
                Always returns None.

        """

    def disable(self) -> object:
        """

        Disable the FringeDrawMode. The model is now drawn with the previous draw mode (ENT, PID, MID ...).


        Returns
        -------
        object
                Always returns None.

        """

    def fringe(
        self, deck: int, element_type: object, mode: str, draw: object
    ) -> object:
        """

        This functions supplies all the necessary data to calculate the fringe values.


        Parameters
        ----------
        deck : int
                The deck in which the FringeDrawMode will appear.

        element_type : object
                The element type whose field values will be used for the Fringe calculations.
                It can be retrieved from the title of the elements edit card, where it is
                displayed within brackets.
                It can be either a single string or a list with strings.

        mode : str
                The mode is where drawing will take place.
                Valid values are:
                -'element', to draw shells, solids or solid facets.
                -'node', to draw shells with gradient.
                -'shell_top_bottom', to draw on shells with a different color on each side.

        draw : object
                A callable object. It must have implemented the __init__,
                start, end and __call__ functions.

                The object must have a values dictionary member. Key
                will be the element and data its fringe value.

                __init__ is the constructor. You can use it to pass data
                from main() to be used in the calculations.

                start() You can use it to initialize anything you want
                before procceeding to the calculations. The values
                dictionary must be cleared here.

                __call__ The calculations for each element will be done
                here. This function runs for every entity with type
                element_type of the model. Here you must assign a
                value to the element you want to be drawn.

                end() You can use to free your data. The values
                dictionary must be returned here.

                class Draw():
                        def __init__(self, deck):
                                self.values = {}
                                self.deck = deck
                        def start(self):
                                self.values.clear()
                        def end(self):
                                return self.values
                        def __call__(self, entity):
                                self.values[entity] = entity._id % 2

        Returns
        -------
        object
                Always returns None.

        """

    def delete(self) -> object:
        """

        Delete the FringeDrawMode. When a FringeDrawMode is deleted, the application will revert to the previous drawing style.


        Returns
        -------
        object
                Always returns None.

        """

    @staticmethod
    def recalculate() -> object:
        """

        Force recalculation of the fringe bar values. This is a staticmethod it can be called either on the class (such as ansa.base.FringeDrawMode.recalculate()) or on an instance (such as ansa.base.FringeDrawMode('MyFringeDrawMode').recalculate()).


        Returns
        -------
        object
                Always returns None.

        """

    def deck_visibility(self, decks: object) -> object:
        """

        Control in which decks the FringeDrawMode will be visibile.


        Parameters
        ----------
        decks : object
                Decks can be either a list with decks or 'all' to massively
                make the FringeDrawMode visible in all decks.

        Returns
        -------
        object
                Always returns None.

        """

    def fringe_static(self, values: object, mode: str) -> object:
        """

        This function supplies all the necessary data to calculate the fringe values. The provided values are cached and no recalculation takes place after ANSA operations like visibility change, elements creation/deletion etc


        Parameters
        ----------
        values : object
                A dictionary with an ANSA entity as a key and the respected value that will be used to draw the entity as data.

        mode : str
                The mode is where drawing will take place.
                Valid values are:
                -'element', to draw shells, solids or solid facets.
                -'node', to draw shells with gradient.
                -'shell_top_bottom', to draw on shells with a different color on each side.

        Returns
        -------
        object
                Always returns None.

        """


class PLMXMLFileHandlingInfo:
    """

    The objects of this class describe how a group of files (as identified by their
    extension) will be handled during PLM XML export.

    See Also
    --------
    ExportPLMXMLTree

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                file_export_info = []

                info = base.PLMXMLFileHandlingInfo(
                    "jt", dataset_type="DirectModel", assoc_dataset_role="IMAN_rendering"
                )
                file_export_info.append(info)

                info = base.PLMXMLFileHandlingInfo(
                    "ansa", dataset_type="T4T_ANSA", assoc_dataset_role="IMAN_Specification"
                )
                file_export_info.append(info)

                base.ExportPLMXMLTree(
                    "output.plmxml", export_jt=True, file_handling=file_export_info
                )

    """

    extension: str = None
    """
	File extension identifying which files these rules apply to.
	The wildcard characters * (zero or more of any character) and
	? (any character) can be used in order to express more 
	versatile extension patterns.

	"""

    dataset_type: str = None
    """
	Value to insert as attribute 'type' in <DataSet> elements.

	"""

    assoc_dataset_role: str = None
    """
	Value to insert as attribute 'role' in <AssociatedDataSet>
	elements.

	"""

    def __init__(self, extension: str, dataset_type: str, associated_dataset_role: str):
        """


        Parameters
        ----------
        extension : str

        dataset_type : str

        associated_dataset_role : str

        """


class PLMXMLEngineSettings:
    """

    The objects of this class hold settings of the PLMXML engine, used during exporting.

    See Also
    --------
    ExportPLMXMLTree

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def drop_PTEditor_attrs(name, value):
                # Return False for all attributes names that start with PTEditor/
                return not name.startswith("PTEditor/")


            def main():
                settings = base.PLMXMLEngineSettings()
                settings.convert_part_names = False

                settings.export_user_attributes = True
                settings.user_attributes_filter = drop_PTEditor_attrs

                base.ExportPLMXMLTree(
                    "output.plmxml",
                    structure_info="hierarchy",
                    representation_info="all",
                    engine_settings=settings,
                )

    """

    export_user_attributes: bool = None
    """
	Describes if the user attributes of the exported parts
	should be included in the PLMXML file (within UserData
	elements).
	(Default value: True)

	"""

    convert_part_names: bool = None
    """
	Describes whether the Part names should be transformed
	during export: if the Module ID + Version appear as prefix
	(underscore as separators), then they will be trimmed from
	the Part name in the PLMXML file.
	(Default value: True)

	"""

    rename_flattened_files: bool = None
    """
	Describes whether the file that are flattened should be
	renamed or not.
	(Default value: True)

	"""

    skip_save: bool = None
    """
	Describes whether the in-memory representations of the
	output part should be saved, or files should be directly
	looked up in the current DMs.
	(Default value: False)

	"""

    skip_download: bool = None
    """
	Describes whether the part related files should be downloaded
	from the DM, or should be referenced in the PLMXML file without
	actually being downloaded. If this option is set, it is expected 
	that the actual files will be provided via an external mechanism.
	(Default value: False)

	"""

    fallback_file_attr: str = None
    """
	Describes which entity attribute should be queried for the file
	placeholder in the PLMXML file, in case both Save / Download are
	to be skipped and the part could not be found in the DM.
	(Default value: Empty)

	"""

    user_attributes_filter: object = None
    """
	A callback function that will be invoked for every user attribute that
	is to be exported to the PLMXML file. If it returns True, the attribute will
	be exported to the PLMXML, otherwise it won't.
	If no callback has been set, then no user attributes will be filtered out of
	the PLMXML File.
	
	Arguments:
	name   string   The attribute's name.
	value  string   The attribute's value.
	
	Return: True to output the attribute, False not to output.
	
	(Default value: None)

	"""


class FeatureHandler:
    """

    The FeatureHandler object provides functionality to handle ANSA Features.
    It can be used via script in both GUI and no-GUI mode.

    See Also
    --------
    base.CreateEntity

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants
            from ansa import mesh


            def main():
                parts = []
                parts.append(base.GetPartFromModuleId("151"))
                mesh.ReadMeshParams(
                    "/ansa/params_for_recognition.ansa_mpar"
                )  # otherwise global mesh parameters will be used
                fm = base.FeatureHandler(parts)
                fm.clear(False)
                fm.recognize(True)
                features = fm.get_features_of_part(base.GetPartFromModuleId("151"))
                for feature in features:
                    if feature._ansaType(constants.NASTRAN) == "STAMP" and feature._id == 29:
                        stamp_items = []
                        stamp_items.append(base.GetEntity(constants.NASTRAN, "FACE", 12))
                        stamp_items.append(base.GetEntity(constants.NASTRAN, "FACE", 16))
                        fm.replace_contents_of_feature(feature, stamp_items)
                del fm


            # To cluster similar Fasteners


            def main2():
                parts = base.CollectEntities(constants.NASTRAN, None, "ANSAPART")
                fm = base.FeatureHandler(parts)
                features = []
                for part in parts:
                    features.extend(fm.get_features_of_part(part))
                clusters = fm.similarity_detector.find_similar(features, "fastener")
                cluster_index = 1
                for cluster in clusters:
                    print("Cluster", cluster_index)
                    for fastener in cluster:
                        print("    ", fastener)
                    cluster_index += 1


            # To create a 2D Hole feature


            def main3():
                deck = constants.NASTRAN
                part = base.GetFirstEntity(deck, "ANSAPART")
                fh = base.FeatureHandler(part)

                # FE Perimeters need to have been recognized before creating a feature on FE-Model mesh.
                # But, the setting for 2d holes recognition must be disabled, otherwise all the candidate openings
                # get already identified.
                features_status = part.get_entity_values(deck, ["Features Status"])[
                    "Features Status"
                ]
                if features_status == "Not Recognized":
                    initial_setting = base.BCSettingsGetValues(["recognize_holes_2d"])
                    if initial_setting["recognize_holes_2d"]:
                        base.BCSettingsSetValues({"recognize_holes_2d": False})
                    fh.recognize()
                    base.BCSettingsSetValues(initial_setting)

                # Pass a loop of edges, \tFE Perimeters or (in case of geometry) CONSes.
                ents = base.PickEntities(deck, {"EDGE", "FE PERIMETER", "CONS"})
                hole = base.CreateEntity(deck, "HOLE 2D", {"contents": ents})
                print("created", hole)

    """

    parts: object = None
    """
	A list of parts.

	"""

    def __init__(self, parts: object) -> object:
        """

        FeatureHandler object constructor.


        Parameters
        ----------
        parts : object
                A list of parts. Accepted values are a list of parts, "all", "visible".

        Returns
        -------
        object
                Returns the created FeatureHandler object.

        """

    def recognize(self, lock_fe_perimeters: bool) -> object:
        """

        This function recognizes features for the parts of the object, using the global meshing parameters.


        Parameters
        ----------
        lock_fe_perimeters : bool, optional
                Used to declare whether existing FE perimeters of object parts will be locked during recognition or not. The default value is set to False.

        Returns
        -------
        object
                Always returns None.

        """

    def clear(self, clear_fe_perimeters: bool) -> object:
        """

        This function clears features for the parts of the object.


        Parameters
        ----------
        clear_fe_perimeters : bool
                Used to declare whether FE perimeters will also be cleared or not.

        Returns
        -------
        object
                Always returns None.

        """

    def get_features_of_part(self, part: object) -> object:
        """

        This function returns the features for a part of the object.


        Parameters
        ----------
        part : object
                Used to determine which part's features will be returned.

        Returns
        -------
        object
                Returns a list of features.

        """

    def replace_contents_of_feature(self, feature: object, contents: object) -> object:
        """

        This function replaces the contents of a feature (except holes) that belongs to a part of the object.


        Parameters
        ----------
        feature : object
                The feature whose contents will be replaced.

        contents : object
                A list of entities that will be the new contents of feature.

        Returns
        -------
        object
                Always returns none.

        """

    def design_remove(
        self,
        features: object,
        holes: str,
        faces: str,
        create_points: bool,
        create_curves: bool,
    ) -> object:
        """

        Removes Fasteners and treats embedded ones.


        Parameters
        ----------
        features : object
                The Fastener entities to be removed.

        holes : str
                The treatment to be applied on the holes left when embedded Fasteners are removed. Available values are 'keep' and 'fill'. 'fill' creates new geometry to fill the hole completely. 'keep' preserves the hole and creates new geometry to fix the red bounds created by the detachment of the embedded Fasteners.

        faces : str
                Available values are 'keep' and 'delete'. 'delete' deletes the Fastener and its contents. 'keep' preserves the Fastemer contents.

        create_points : bool, optional
                If True, 3D points are created at the center of embedded Fastener holes. The default value is False. This option is applicable only on embedded Fasteners.

        create_curves : bool, optional
                If True, Curves are created at the perimeters of embedded Fastener holes. The default value is False. This option is applicable only on embedded Fasteners.

        Returns
        -------
        object
                Returns a dict with the following keys:'failed_features' contains a list of the embedded Fasteners that could not be removed.'faces' contains a dict with all the removed Fastener contents. The Fastener entity ID is set as key and a list with the Fastener faces is set as data. This dict is returned only if 'faces' option is set to 'keep'.

        """

    def assembly_create_connection(
        self, features: object, connection_type: str
    ) -> object:
        """

        Creates connection points for the given Fastener entities.


        Parameters
        ----------
        features : object
                The Fastener entities to create Connection Points for.

        connection_type : str
                The available values are "spotweld point", "gum drop", "bolt", "robscan", "rivet", "screw".

        Returns
        -------
        object
                Returns a list with the created connection points, in the order of the input features.

        """

    @classmethod
    def update(cls) -> object:
        """

        Update features characteristics (e.g. after modifying their geometry some characteristics slightly change).


        Returns
        -------
        object
                Always returns none.

        """

    def find_similar(self, features: object, feature_type: str) -> object:
        """

        This function clusters geometrically similar Stamps and Fasteners.


        Parameters
        ----------
        features : object
                A list of Fastener objects, or Stamp objects.

        feature_type : str
                The type of the features provided. Accepted values: "fastener", "stamp".

        Returns
        -------
        object
                Returns a list of lists of features (Fasteners or Stamps, depending on the feature_type argument provided). Each list of features is a cluster.

        """


class ProductTree:
    """

    An object that holds information of the parts in the input model definition.

    See Also
    --------
    base.InputModelDefinition, base.InputProductTreeSettings

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                my_settings = base.InputProductTreeSettings()
                my_settings.post_actions_script_function = "MyFun"
                my_settings.post_actions_script_path = "//home/post_actions_script.py"
                my_settings.should_open_window = True

                filename = "//home/file.xml"

                base.InputModelDefinition(
                    file_name=filename, file_type="PLMXML", settings=my_settings
                )


            # example of post_actions_script.py:
            def MyFun(product_tree, *args, **kwargs):
                all_part_ids = product_tree.get_all_part_ids()

                print("Total number of parts in product_tree: " + str(len(all_part_ids)))

                for part_id in all_part_ids:
                    name = product_tree.get_part_attribute_value(part_id, "Name")
                    module_id = product_tree.get_part_attribute_value(part_id, "Module Id")
                    version = product_tree.get_part_attribute_value(part_id, "Version")
                    is_group = product_tree.get_part_attribute_value(part_id, "Is Group")
                    print("----------------------------------------------------------------")
                    print("Part with id: " + part_id)
                    print("   Name: " + name)
                    print("   Module Id: " + module_id)
                    print("   Version: " + version)
                    print("   Is Group: " + is_group)
                    print(
                        "   All Attributes: "
                        + str(product_tree.get_all_part_attribute_values(part_id))
                    )
                    print("----------------------------------------------------------------")

                    # fix empty versions:
                    if version == "A":
                        product_tree.set_part_attribute_value(part_id, "Version", "test")
                        print("Changed Version to Part with id: " + part_id)
                    # totally remove some parts:
                    if "SCREW" in name:
                        product_tree.remove_part(part_id)
                        print("Removed Part with id :" + part_id)

    """

    def get_parsed_file(self) -> str:
        """

        Returns the parsed file.


        Returns
        -------
        str

        """

    def get_all_part_ids(self) -> object:
        """

        Returns a list with the ids of all parts in the tree. If no part is found, it returns an empty list.


        Returns
        -------
        object

        """

    def get_all_part_attribute_values(self, part_id: str) -> object:
        """

        Returns a dictionary will all attributes of the part with id = part_id. If the part has no attributes, it returns an empty dictionary. If the part does not exist it returns None.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        Returns
        -------
        object

        """

    def get_part_attribute_value(self, part_id: str, attribute_name: str) -> str:
        """

        Returns the value of 'attribute_name' of the part with id = part_id.If the part does not exist or it does not have an attribute with this name it returns None.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        attribute_name : str
                The attribute name.

        Returns
        -------
        str

        """

    def set_part_attribute_value(
        self, part_id: str, attribute_name: str, attribute_value: str
    ) -> bool:
        """

        Sets the value of a specific attribute of part with id = part_id. The attributes that can be set are "Name", "Version", "Module Id" and any user defined attribute.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        attribute_name : str
                The attribute name.

        attribute_value : str
                The new attribute value.

        Returns
        -------
        bool
                Returns True on success, False on failure, None if no part with id = part_id exists.

        """

    def remove_part(self, part_id: str) -> bool:
        """

        Deletes the part with id = part_id from the product tree.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        Returns
        -------
        bool
                Returns True on success, False on failure.

        """

    def create_new_part_attribute(self, attribute_name: str) -> bool:
        """

        Creates a new part user attribute with name 'attribute_name'.


        Parameters
        ----------
        attribute_name : str
                The new attribute name.

        Returns
        -------
        bool
                Returns True on success, False on failure.

        """

    def get_part_file_ids_of_part(self, part_id: str) -> object:
        """

        Returns a list with the ids of all part files. If the part with part_id does not exist, it returns None. If the part does not have any part files it returns an empty list.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        Returns
        -------
        object

        """

    def get_all_part_file_ids(self) -> object:
        """

        Returns a list with the ids of all part files in the tree. If no part file is found, it returns an emtpy list.


        Returns
        -------
        object

        """

    def remove_part_file(self, part_file_id: str) -> object:
        """

        Deletes the part file with id = part_file_id from the part and the tree.


        Parameters
        ----------
        part_file_id : str
                The identifier of the part file.

        Returns
        -------
        object
                Returns True on success, False on failure.

        """

    def get_all_part_file_attribute_values(self, part_file_id: str) -> object:
        """

        Returns a dictionary will all attributes of the part file with id = part_file_id. If the part file has no attributes it returns an empty dictionary. If the part file does not exist it returns None.


        Parameters
        ----------
        part_file_id : str
                The identifier of the part file.

        Returns
        -------
        object

        """

    def set_part_file_attribute_value(
        self, part_file_id: str, attribute_name: str, attribute_value: str
    ) -> bool:
        """

        Sets the value of a specific attribute of part file with id = part_file_id. The attributes we can set are "File Name", "Transformation Matrix", "Pid Offset" and any user defined attribute.


        Parameters
        ----------
        part_file_id : str
                The identifier of the part.

        attribute_name : str
                The attribute name.

        attribute_value : str
                The new attribute value.

        Returns
        -------
        bool
                Returns True on success, False on failure, None if no part file with id = part_file_id exists.

        """

    def get_part_file_attribute_value(
        self, part_file_id: str, attribute_name: str
    ) -> str:
        """

        Returns the value of 'attribute_name' of the part file with id = part_file_id. If the part file does not exist or it does not have an attribute with this name it returns None.


        Parameters
        ----------
        part_file_id : str
                The identifier of the part file

        attribute_name : str
                The attribute name

        Returns
        -------
        str

        """

    def create_new_part_file_attribute(self, attribute_name: str) -> bool:
        """

        Creates a new part file user attribute with name 'attribute_name'.


        Parameters
        ----------
        attribute_name : str
                The new attribute name.

        Returns
        -------
        bool
                Returns True on success, False on failure.

        """

    def remove_part_attribute(self, attribute_name: str) -> bool:
        """

        Deletes the part attribute with name 'attribute_name'.


        Parameters
        ----------
        attribute_name : str
                The attribute name to be deleted.

        Returns
        -------
        bool
                Returns True on success, False on failure.

        """

    def remove_part_file_attribute(self, attribute_name: str) -> bool:
        """

        Deletes the part file attribute with name 'attribute_name'.


        Parameters
        ----------
        attribute_name : str
                The part file attribute name.

        Returns
        -------
        bool
                Returns True on success, False on failure.

        """

    def get_part_instances(self, part_id: str) -> object:
        """

        Returns a list with all instance ids of the part with id = part_id. If the part does not exist it returns None.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        Returns
        -------
        object

        """

    def get_instance_attribute_value(
        self, instance_id: str, attribute_name: str
    ) -> object:
        """

        Returns the value of 'attribute_name' of the part instance with id = instance_id.If the part instance does not exist or it does not have an attribute with this name it returns None.


        Parameters
        ----------
        instance_id : str
                The identifier of the part instance.

        attribute_name : str
                The attribute name.

        Returns
        -------
        object

        """

    def set_instance_attribute_value(
        self, instance_id: str, attribute_name: str, attribute_value: str
    ) -> bool:
        """

        Sets the value of a specific attribute of part instance with id = instance_id. The attributes that can be set are "Variant Condition" and any user defined attribute.


        Parameters
        ----------
        instance_id : str
                The identifier of the part instance.

        attribute_name : str
                The attribute name.

        attribute_value : str
                The new attribute value

        Returns
        -------
        bool
                Returns True on success, False on failure, None if no part instance with id = instance_id exists.

        """

    def create_new_part_file(
        self, part_id: str, file_path: str, transformation_matrix: object
    ) -> str:
        """

        Creates a new part file with specific transformation matrix for a part.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        file_path : str
                The file path of the new part file.

        transformation_matrix : object, optional
                A 4X3 list defining the transformation matrix of the part file.

        Returns
        -------
        str
                Returns the identifier of the created part file or None if no part file was created.

        """

    @classmethod
    def get_top_root_instances(cls) -> object:
        """

        Returns a list with the ids of the top root instances. In case no top root instance is found it returns an empty list.


        Returns
        -------
        object

        """

    @classmethod
    def get_parent_instance(cls, instance_id: str) -> str:
        """

        Returns the parent instance id of a part instance with specific id. If no part exists with this instance id or if it is a top root instance it returns None.


        Parameters
        ----------
        instance_id : str
                The id of the part instance.

        Returns
        -------
        str

        """

    @classmethod
    def get_children_instances(cls, instance_id: str) -> object:
        """

        It returns the list of children instance ids of a part with specific instance id. If the part does not have any children it returns an empty list.


        Parameters
        ----------
        instance_id : str
                The id of the part instance.

        Returns
        -------
        object

        """

    @classmethod
    def get_part_from_instance(cls, instance_id: str) -> str:
        """

        Returns the corresponding part id of the instance. If no part exists with this instance id it returns None.


        Parameters
        ----------
        instance_id : str
                The id of the part instance.

        Returns
        -------
        str

        """

    @classmethod
    def create_new_instance_attribute(cls, attribute_name: str) -> bool:
        """

        Creates a new attribute for part instances.


        Parameters
        ----------
        attribute_name : str
                The new attribute name

        Returns
        -------
        bool
                Returns True if a new attribute with this name has been created, False if the attribute already exists.

        """

    @classmethod
    def is_group_item(cls, part_id: str) -> bool:
        """

        Provides the info if a structure item is a 'group' item or a 'part' item.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        Returns
        -------
        bool
                Returns True if the item is a 'group' and False if the item is a 'part'.

        """

    @classmethod
    def switch_part_to_group(cls, part_id: str) -> bool:
        """

        Gives the ability to switch a 'part' item to a 'group' item.


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        Returns
        -------
        bool
                Returns True if the part was successfully switched to a group else it returns False.

        """

    @classmethod
    def switch_group_to_part(cls, part_id: str) -> bool:
        """

        Gives the ability to switch a 'group' item to a 'part' item. In order to perform this action the group should be empty (not contain any child item).


        Parameters
        ----------
        part_id : str
                The identifier of the part.

        Returns
        -------
        bool
                Returns True if the group was successfully switched to a part else it returns False.

        """


class Marionette:
    """

    Class for positioning a dummy with the help of the solver.

    Creates a number of loadcases (output files) to "pull" a dummy to one or more target positions, either with or without a seat.

    Examples
    --------
    ::

            import ansa
            from ansa import utils, base, constants


            def marionette_test():
                _positions = [
                    base.GetEntity(constants.LSDYNA, "KIN_POSITION", 2),
                    base.GetEntity(constants.LSDYNA, "KIN_POSITION", 3),
                ]
                rigbodies = [
                    base.GetEntity(constants.LSDYNA, "KIN_BODY", 5),
                    base.GetEntity(constants.LSDYNA, "KIN_BODY", 4),
                ]
                sourcef = "/mnt/raid_disk/titanas/FTSS/ls-dyna/H350/v7.1/H350_s2v7.1_dummy1.key"
                opath = "~/"
                marionette = base.Marionette(
                    base.GetEntity(constants.LSDYNA, "KIN_JOINT", 1),
                    _positions,
                    rigbodies,
                    "g, mm, ms",
                    10.5,
                    5.0,
                    1.0,
                    20.0,
                    0.5,
                    "Monolithic",
                    sourcef,
                    True,
                    opath,
                    "pre_",
                    "ID",
                    "k",
                    False,
                    True,
                )
                v_h5 = marionette.GetHandleNodes(base.GetEntity(constants.LSDYNA, "KIN_BODY", 5))
                marionette.ResetHandleNodes(base.GetEntity(constants.LSDYNA, "KIN_BODY", 5))
                marionette.Position()

    """

    hpoint: Entity = None
    """
	The Dummy's H-Point kinetic Joint.

	"""

    positions: list = None
    """
	Target positions for the Dummy.

	"""

    rigid_bodies: list = None
    """
	Any of the Dummy's kinetic Bodies to be treated as totally rigid.

	"""

    units: str = None
    """
	The unit system used.
	
	For LsDyna one of:
	'g, mm, ms',
	'kg, m, s',
	'kg, mm, ms',
	'ton, mm, s'
	
	For Radioss a list with the units for mass, length and time. Either all the units in numeric format (e.g. 14, 8, 8) or all of them in string format (e.g. "kg", "mm", "ms").

	"""

    cable_force: list | float = None
    """
	Constant force applied in cables to pull the bodies into position.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.
	(Ls-Dyna only)

	"""

    cable_forces: list | float = None
    """
	Constant force applied in cables to pull the bodies into position.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.
	(Ls-Dyna only)

	"""

    time_to_develop: list | float = None
    """
	Time needed for force to reach its max value
	(in both Force-based and Displacement-based loadcases).
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.
	(Ls-Dyna only)

	"""

    ramp_times: list | float = None
    """
	Time needed for force to reach its max value
	(in both Force-based and Displacement-based loadcases).
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.
	(Ls-Dyna only)

	"""

    cable_damping: list | float = None
    """
	Damping applied in-line with the cables used to pull the bodies into position.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.

	"""

    cable_dampings: list | float = None
    """
	Damping applied in-line with the cables used to pull the bodies into position.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.

	"""

    total_time: list | float = None
    """
	Stage's termination time for analysis.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.

	"""

    stages_time: list | float = None
    """
	Stage's termination time for analysis.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage is the final one.

	"""

    global_damping: float = None
    """
	Global damping used in analysis.
	(Ls-Dyna only)

	"""

    source_option: str = None
    """
	One of:
	'Monolithic' : The current database will be output in a monolithic file
	for each target position.
	'Source File' : The source_file will be included in each output file,
	together with the entities needed to 'pull' the dummy to the target position.

	"""

    source_file: str = None
    """
	Define the read-only file that holds the dummy definition.

	"""

    relative_path: bool = None
    """
	If set, the source_file will be considered to be in the output path during analysis.

	"""

    output_path: str = None
    """
	Path where the output files will be placed.

	"""

    output_prefix: str = None
    """
	Concatenated with suffix and extension to create the output filenames (PrefixSuffix.Extension).

	"""

    output_suffix: str = None
    """
	Concatenated with prefix and extension to create the output filenames (PrefixSuffix.Extension). One of: "Name", "ID", "Counter".

	"""

    output_extension: str = None
    """
	Concatenated with prefix and suffix to create the output filenames (PrefixSuffix.Extension).

	"""

    keep_entities: bool = None
    """
	If set, any entities created will remain in the database after the window closes, otherwise they will be removed. If more than one positions are selected, this option is not available.

	"""

    move_hpoint: bool = None
    """
	Deprecated! Use rigid_move instead.
	
	If set, the dummy will first be moved and rotated to the target H-Point by ANSA and will not be allowed to move away from its target location during analysis. If not moved, ANSA will not move the dummy; instead, all required movements and rotations will be performed during the analysis, using cables. In this case, it's not ensured that the dummy will reach the exact target position.

	"""

    stages_num: int = None
    """
	Number of pre-positioning stages (last one is the final one).

	"""

    rigid_move: str = None
    """
	The dummy's initial rigid movement type. One of:
	'None': no initial rigid movement,
	'Position': initial rigid movement to a kinetic position (no articulation is performed),
	'Final': initial rigid movement to the final kinetic position,
	'Penetration-free': initial rigid movement to a position close to the destination position
	of the first stage, but penetration free ('depenetration_vec' is used for the depenetration).

	"""

    additional_file: str = None
    """
	Define the read-only file that holds the seat definition.

	"""

    load_type: list | str = None
    """
	Loadcase type. One of: 'Forces', 'Displacements'.
	Single value: updates the final stage's type.
	List: updates all stages' type (one value for each stage). Last stage in the list is the final one.
	(Ls-Dyna only)

	"""

    load_types: list | str = None
    """
	Loadcase type. One of: 'Forces', 'Displacements'.
	Single value: updates the final stage's type.
	List: updates all stages' type (one value for each stage). Last stage in the list is the final one.
	(Ls-Dyna only)

	"""

    cable_stiffness: list | float = None
    """
	Stiffness of cables for displacement-based stages.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage in the list is the final one.

	"""

    cable_stiffnesses: list | float = None
    """
	Stiffness of cables for displacement-based stages.
	Single value: updates the final stage's value.
	List: updates all stages' values (one value for each stage). Last stage in the list is the final one.

	"""

    dest_positions: list = None
    """
	List of destination kinetic positions. One for each stage of the analysis, except the final one.

	"""

    depenetration_vec: list = None
    """
	Movement vector for each step of the depenetration procedure.

	"""

    cable_property: list | Entity = None
    """
	List of Properties used by the cables. One value for each stage of the analysis (final stage is the last one in the list). For each stage, if the Propertry is set, the other properties governing the cables - except cable_damping - have no effect.
	A single value applies to the final stage.

	"""

    cable_properties: list | Entity = None
    """
	List of Properties used by the cables. One value for each stage of the analysis (final stage is the last one in the list). For each stage, if the Propertry is set, the other properties governing the cables - except cable_damping - have no effect.
	A single value applies to the final stage.

	"""

    mass_density: list | float = None
    """
	List of mass densities of the displacement-based cables. One value for each stage of the analysis (final stage is the last one in the list). A single value applies to the final stage.
	(Ls-Dyna only)

	"""

    mass_densities: list | float = None
    """
	List of mass densities of the displacement-based cables. One value for each stage of the analysis (final stage is the last one in the list). A single value applies to the final stage.
	(Ls-Dyna only)

	"""

    mass: list | float = None
    """
	List of cables' masses. One value for each stage of the analysis (final stage is the last one in the list). A single value applies to the final stage.
	(Radioss)

	"""

    masses: list | float = None
    """
	List of cables' masses. One value for each stage of the analysis (final stage is the last one in the list). A single value applies to the final stage.
	(Radioss)

	"""

    seat_props: list | None = None
    """
	Seat's Properties. If set to an empty list or None, only the dummy is included in the presimulation.

	"""

    contact: Entity = None
    """
	The dummy - seat contact. If set to None, the contact is created automatically if a seat is included.

	"""

    initial_pos: Entity = None
    """
	The position of the dummy at the start of the simulation when rigid_move = 'Position'.

	"""

    seat_rigid_props: list | None = None
    """
	Seat properties to be handled as rigid.

	"""

    dtinit: float = None
    """
	Initial timestep.

	"""

    non_dummy_bodies: bool = None
    """
	Set to true, to handle kinetic bodies contained in the target position, but not part of the dummy mechanism.

	"""

    bundle: bool = None
    """
	Set to true to copy the dummy source file and the additional source file to the destination path.

	"""

    def SetHandleNodes(self, body: Entity, nodes: list) -> None:
        """

        Sets the 3 handle nodes for a specific kinetic Body.


        Parameters
        ----------
        body : Entity
                The Dummy's kinetic Body for which the 3 handle Nodes will be assigned.

        nodes : list
                List of 3 Nodes to be used as handle Nodes. They must be included in the 'body' kinetic Body and be in a rigid region of the kinetic Body.

        Returns
        -------
        None

        """

    def ResetHandleNodes(self, body: Entity) -> None:
        """

        Reset the Handle Nodes of a Dummy's kinetic Body to the ones automatically calculated.


        Parameters
        ----------
        body : Entity
                One of the Dummy's kinetic Bodies.

        Returns
        -------
        None

        """

    def GetHandleNode(self, body: Entity) -> list:
        """

        Get the 3 handle Nodes of a kinetic Body.


        Parameters
        ----------
        body : Entity
                A kinetic Body of the Dummy.

        Returns
        -------
        list

        """

    def Position(self) -> None:
        """

        Create the position files / position the dummy.


        Returns
        -------
        None

        """

    def __init__(
        self,
        hpoint: Entity,
        positions: list,
        rigid_bodies: list,
        units: str,
        cable_forces: list | float,
        ramp_times: list | float,
        cable_dampings: list | float,
        stages_time: list | float,
        global_damping: float,
        source_option: str,
        source_file: str,
        relative_path: bool,
        output_path: str,
        output_prefix: str,
        output_suffix: str,
        output_extension: str,
        keep_entities: bool,
        move_hpoint: bool,
        rigid_move: str,
        load_types: list | str,
        cable_stiffnesses: list | float,
        mass_densities: list | float,
        additional_file: str,
        stages_num: int,
        dest_positions: list,
        depenetration_vec: list,
        cable_properties: list | Entity,
        masses: list | float,
        initial_pos: Entity,
        seat_props: list | None,
        contact: Entity,
        py_seat_rigid_props: list | None,
        dtinit: float,
        non_dummy_bodies: bool,
        bundle: bool,
    ) -> int:
        """


        Parameters
        ----------
        hpoint : Entity
                The Dummy's H-Point kinetic Joint.

        positions : list, optional
                Target positions for the Dummy. Each one will create a separate load case.

        rigid_bodies : list, optional
                Any of the Dummy's kinetic Bodies to be treated as totally rigid.

        units : str, optional
                The unit system used.
                For LsDyna one of:
                'g, mm, ms',
                'kg, m, s',
                'kg, mm, ms',
                'ton, mm, s'
                For Radioss a list with the units for mass, length and time. Either all the units in numeric format (e.g. 14, 8, 8) or all of them in string format (e.g. "kg", "mm", "ms").

        cable_forces : list|float, optional
                Constant force applied in cables to pull the bodies into position. Single value: updates the final stage's value. List: updates all stages' values (one value for each stage). Last stage is the final one. (Ls-Dyna only)

        ramp_times : list|float, optional
                Time needed for force to reach its max value (in both Force-based and Displacement-based loadcases). Single value: updates the final stage's value. List: updates all stages' values (one value for each stage). Last stage is the final one. (Ls-Dyna only)

        cable_dampings : list|float, optional
                Damping applied in-line with the cables used to pull the bodies into position. Single value: updates the final stage's value. List: updates all stages' values (one value for each stage). Last stage is the final one.

        stages_time : list|float, optional
                Stage's termination time for analysis. Single value: updates the final stage's value. List: updates all stages' values (one value for each stage). Last stage is the final one.

        global_damping : float, optional
                Global damping used in analysis.
                (Ls-Dyna only)

        source_option : str, optional
                One of:
                'Monolithic' : The current database will be output in a monolithic file for each target position.
                'Source File' : The source_file will be included in each output file, together with the entities needed to 'pull' the dummy to the target position.

        source_file : str, optional
                Define the read-only file that holds the dummy definition.

        relative_path : bool, optional
                If true, the source_file will be considered to be in the output path during analysis.

        output_path : str, optional
                Path where the output files will be placed.

        output_prefix : str, optional
                Concatenated with suffix and extension to create the output filenames (PrefixSuffix.Extension).

        output_suffix : str, optional
                Concatenated with prefix and extension to create the output filenames (PrefixSuffix.Extension). One of: "Name", "ID", "Counter".

        output_extension : str, optional
                Concatenated with prefix and suffix to create the output filenames (PrefixSuffix.Extension).

        keep_entities : bool, optional
                If set, any entities created will remain in the database after the window closes, otherwise they will be removed. If more than one positions are selected, this option is not available.

        move_hpoint : bool, optional
                Deprecated! Use rigid_move instead.

        rigid_move : str, optional
                The dummy's initial rigid movement type. One of:
                'None': no initial rigid movement,
                'Position': initial rigid movement to a kinetic position (no articulation is performed),
                'Final': initial rigid movement to the final kinetic position,
                'Penetration-free': initial rigid movement to a position close to the destination position of the first stage, but penetration free ('depenetration_vec' is used for the de-penetration).

        load_types : list|str, optional
                Loadcase type. One of: 'Forces', 'Displacements'. Single value: updates the final stage's type. List: updates all stages' type (one value for each stage). Last stage in the list is the final one. (Ls-Dyna only)

        cable_stiffnesses : list|float, optional
                Stiffness of cables for displacement-based stages. Single value: updates the final stage's value. List: updates all stages' values (one value for each stage). Last stage in the list is the final one.

        mass_densities : list|float, optional
                List of mass densities of the displacement-based cables. One value for each stage of the analysis (final stage is the last one in the list). A single value applies to the final stage.
                (Ls-Dyna only)

        additional_file : str, optional
                Define the read-only file that holds the seat definition.

        stages_num : int, optional
                Number of pre-positioning stages (last one is the final one).

        dest_positions : list, optional
                List of destination kinetic positions. One for each stage of the analysis, except the final one.

        depenetration_vec : list, optional
                Movement vector for each step of the depenetration procedure.

        cable_properties : list|Entity, optional
                List of Properties used by the cables. One value for each stage of the analysis (final stage is the last one in the list). For each stage, if the Propertry is set, the other properties governing the cables - except cable_damping - have no effect. A single value applies to the final stage.

        masses : list|float, optional
                List of cables' masses. One value for each stage of the analysis (final stage is the last one in the list). A single value applies to the final stage. (Radioss only)

        initial_pos : Entity, optional
                The position of the dummy at the start of the simulation when rigid_move = 'Position'.

        seat_props : list|None, optional
                Seat's Properties. If set to an empty list or None, only the dummy is included in the pre-simulation.

        contact : Entity, optional
                The dummy - seat contact. If set to None, the contact is created automatically if a seat is included.

        py_seat_rigid_props : list|None, optional
                Seat properties to be handled as rigid.

        dtinit : float, optional
                Initial time step. (LsDyna only)

        non_dummy_bodies : bool, optional
                Set to true, to handle kinetic bodies contained in the target position, but not part of the dummy mechanism.

        bundle : bool, optional
                Set to true to copy the dummy source file and the additional source file to the destination path.

        Returns
        -------
        int
                0: success, 1: error

        """

    def ShowWindow(self) -> bool:
        """

        Pops up the Marionette Tool, pre-filled with any data already defined for the Marionette object.


        Returns
        -------
        bool
                True if the tool completed, False if it was cancelled.

        """

    def HidePage(self, index: int) -> None:
        """

        Sets a specific page or a list of pages to be skipped when ShowWindow is called.Deprecated! Use HideNamedPage instead.


        Parameters
        ----------
        index : int
                Either a single integer or a list of integers. Each one is the 1-based index of a page to be skipped.

        Returns
        -------
        None

        """

    def ShowPage(self, index: int) -> None:
        """

        Sets a specific page or a list of pages to be shown when ShowWindow is called. The default is to show all pages, but previous calls to HidePage can be negated using this function.Deprecated! Use ShowNamedPage instead.


        Parameters
        ----------
        index : int
                Either a single integer or a list of integers. Each one is the 1-based index of a page - previously defined to be skipped - to be shown by the ShowWindow method.

        Returns
        -------
        None

        """

    def ShowNamedPage(self, name: str) -> None:
        """

        Sets a specific page or a list of pages to be shown when ShowWindow is called. The default is to show all pages, but previous calls to HideNamedPage can be negated using this function.


        Parameters
        ----------
        name : str
                Either a single name or a list of names from the list: [ Positions, Rigidify, Handles, Seat, Options, Stages, Output ] - previously defined to be skipped - to be shown by the ShowWindow method.

        Returns
        -------
        None

        """

    def HideNamedPage(self, name: str) -> None:
        """

        Sets a specific page or a list of pages to be skipped when ShowWindow is called.


        Parameters
        ----------
        name : str
                Either a single name or a list of names from the list: [ Positions, Rigidify, Handles, Seat, Options, Stages, Output ] to be skipped.

        Returns
        -------
        None

        """


class MBCBuildProcess:
    """

    The MBCBuildProcess object gives control to the build actions of the Model Browser. You can get information about an action, add or remove a script action and build a model browser container or some specific actions.

    Examples
    --------
    ::

            import ansa
            from ansa import *


            def print_action(action):
                print("Name:  %s" % action.name)
                print("Active:  %r" % action.active)
                print("Builtin:  %r" % action.builtin)
                print("Status: %s" % action.status)
                print("Type: %s" % action.type)
                print("Execute Always: %r" % action.execute_always)
                print("Build Comment: %s" % action.build_comment)
                if action.type == "script":
                    print("Builtin:  %s" % action.script)
                    print("Status: %s" % action.status)
                print("")


            def main():
                session.New("discard")

                subsystem = base.CreateEntity(constants.ABAQUS, "ANSA_SUBSYSTEM")

                build_process = base.MBCBuildProcess(subsystem)

                actions = build_process.actions()
                print("Total actions: %d" % len(actions))
                print("")
                for index, action in enumerate(actions):
                    print("Index: %d" % (index + 1))
                    print_action(action)
                    print("")
                print("")

                build_process.build(subsystem, (1, 2))

                betascript.LoadModule("/path/to/build_scripts.py")

                build_process.add(
                    index=1,
                    name="Action1",
                    active=True,
                    script="/path/to/build_scripts.py",
                    on_build_function="foo_a",
                )

                actions = build_process.actions()
                print("Total actions: %d" % len(actions))
                print("")
                for index, action in enumerate(actions):
                    print("Index: %d" % (index + 1))
                    print_action(action)
                print("")

                action = build_process.get(index=1)
                print("Get action with index = 1")
                print_action(action)

                action.name = "NewAction1"
                action.on_build_function = "foo_b"
                action.status = "error"

                build_process.update(index=1, action=action)

                action = build_process.get(index=1)
                print("Updated action with index = 1")
                print_action(action)

                print("")

                ret = base.MBCBuildProcess.build(subsystem)
                print("Script result: %r" % ret)

                print("")

                build_process.remove(index=1)

                actions = build_process.actions()
                print("Total actions: %d" % len(actions))
                print("")
                for index, value in enumerate(actions):
                    print("Index: %d" % (index + 1))
                    print_action(action)
                print("")

                print("Container status: " + build_process.status)
                build_process.status = "error"
                print("Container status: " + build_process.status)

                actions = build_process.actions()
                print("Total actions: %d" % len(actions))
                print("")
                for index, action in enumerate(actions):
                    print("Index: %d" % (index + 1))
                    print_action(action)
                    print("")
                print("")


            if __name__ == "__main__":
                main()

    """

    status: str = None
    """
	The status member allows setting/getting the current status of the model browser container item of the object. Available values are: 'needs_build', 'wip', 'error', 'ok'.

	"""

    source_representation: str = None
    """
	The source_representation member allows setting/getting the Source Representation attribute value for the Build Process which has been assigned to the plain part item of the object. Valid value is any value which can be assigned to the part's Representation attribute.

	"""

    def __init__(self, mbcontainer: object):
        """

        MBCBuildProcess object constructor


        Parameters
        ----------
        mbcontainer : object
                A model browser container e.g. ANSA_SUBSYSTEM, ANSA_SIMULATION_MODEL, ANSA_SIMULATION_RUN, ANSA_SIM_MODEL_ADAPTER, ANSA_SIM_RUN_ADAPTER

        """

    @staticmethod
    def build(mbcontainers: object, index: object) -> bool:
        """

        A static method to build a model browser container or some specific actions of it.


        Parameters
        ----------
        mbcontainers : object
                A list with model browser containers or a single model browser container to be builded.

        index : object, optional
                A list with the indexes of the build actions to be builded. If index is given, a single model browser container must be given in the mbcontainers argument.

        Returns
        -------
        bool
                Returns True on success or False otherwise.

        """

    def add(
        self,
        index: int,
        name: str,
        active: bool,
        script: str,
        on_build_function: str,
        execute_always: bool,
    ) -> bool:
        """

        Add a new script action to a model browser container


        Parameters
        ----------
        index : int
                Index of the action.

        name : str
                Name of the action.

        active : bool
                Active status of the action.

        script : str
                Path of the script file

        on_build_function : str
                Name of the script function to be executed on build.

        execute_always : bool, optional
                Mark the action to be always executed even if build is successful.

        Returns
        -------
        bool
                Returns True on success, False otherwise.

        """

    def remove(self, index: int) -> bool:
        """

        Removes an action


        Parameters
        ----------
        index : int
                Index of the action to be removed

        Returns
        -------
        bool
                Returns True on success, False otherwise.

        """

    def get(self, index: int) -> object:
        """

        Get an action.


        Parameters
        ----------
        index : int
                Index of the action.

        Returns
        -------
        object
                Returns a named tuple created from the action at the given index.If the action is Built-in the values are:'name', 'builtin', 'type', 'active', 'status'If the action is Script the values are:'name', 'builtin', 'type', 'active', 'status', 'script', 'on_build_function'If the action is Check the values are:'name', 'builtin', 'type', 'active', 'status'

        """

    def update(self, index: int, action: object) -> object:
        """

        Update an action


        Parameters
        ----------
        index : int
                Index of the action to be updated.

        action : object
                An action provided by the get method.

                If an action is Built-in the fields that can be updated are its active and status values.

                If an action is Script the fields that can be updated are its active, status, name, script, on_build_function values

        Returns
        -------
        object
                Returns True on sucess, False otherwise.

        """

    def actions(self) -> object:
        """

        All the actions of the model browser container


        Returns
        -------
        object
                Returns a list with all the actions of the model browser container as named tuples.

        """

    def add_check(
        self, name: str, active: bool, execute_always: bool, index: int
    ) -> bool:
        """

        Add a new Check action to a model browser container


        Parameters
        ----------
        name : str
                Name of the action. It must be a valid Check Template.

        active : bool, optional
                Active status of the action. Default is True.

        execute_always : bool, optional
                Mark the action to be always executed even if build is successful.

        index : int, optional
                Index of the action.If no index is provided the Check Template will be appended to the existing actions.

        Returns
        -------
        bool
                Always returns True.

        """


class TailoredBlankHandler:
    """

    The TailoredBlankHandler object provides functionality to handle a TAILORED_BLANK entity.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            # ------------------------------
            # Example 1:
            # ------------------------------
            def example1():
                vals = {}
                vals["DIRECTION"] = "AXIS"
                vals["DX"] = 0
                vals["DY"] = 0
                vals["DZ"] = 1

                vals["ORIGIN_X"] = 1603.637
                vals["ORIGIN_Y"] = -739.356
                vals["ORIGIN_Z"] = 276.2518

                vals["POS_REGIONS_NUM"] = 2
                vals["NEG_REGIONS_NUM"] = 2

                # 1st positive region--------:
                vals["POS_REG_1_WIDTH"] = 100
                vals["POS_REG_1_ZONE"] = "WIDTH"
                vals["POS_REG_1_ZONE_WIDTH"] = 10
                vals["POS_REG_1_THICKNESS"] = "LINEAR"
                vals["POS_REG_1_T_START"] = 3
                vals["POS_REG_1_T_END"] = 1.5

                # 2nd positive region--------:
                vals["POS_REG_2_INFINITE_WIDTH"] = "YES"
                vals["POS_REG_2_ZONE"] = "NUMBER"
                vals["POS_REG_2_ZONE_NUMBER"] = 1
                vals["POS_REG_2_THICKNESS"] = "USE_EXISTING"

                # 1st negative region----------:
                vals["NEG_REG_1_WIDTH"] = 200
                vals["NEG_REG_1_ZONE"] = "WIDTH"
                vals["NEG_REG_1_ZONE_WIDTH"] = 20
                vals["NEG_REG_1_THICKNESS"] = "LINEAR"
                vals["NEG_REG_1_T_START"] = 3
                vals["NEG_REG_1_T_END"] = 2

                # 2nd negative region----------:
                vals["NEG_REG_2_INFINITE_WIDTH"] = "YES"
                vals["NEG_REG_2_ZONE"] = "NUMBER"
                vals["NEG_REG_2_ZONE_NUMBER"] = 1
                vals["NEG_REG_2_THICKNESS"] = "CONSTANT"
                vals["NEG_REG_2_T_CONST"] = 2

                tb = base.CreateEntity(constants.NASTRAN, "TAILORED_BLANK", vals)

                tb_handler = base.TailoredBlankHandler(tb)

                set = base.GetEntity(ansa.constants.NASTRAN, "SET", 1)
                shells = base.CollectEntities(constants.NASTRAN, set, "SHELL", recursive=True)
                tb_handler.add_to_area(shells)

                tb_handler.apply()


            # ------------------------------
            # Example 2:
            # ------------------------------
            def example2():
                vals = {}
                vals["DIRECTION"] = "TRAJECTORY"
                vals["TRAJECTORY_POINTS_NUM"] = 3
                vals["TRP_1_X"] = 1754.311
                vals["TRP_1_Y"] = -751.764
                vals["TRP_1_Z"] = 642.6149

                vals["TRP_2_X"] = 1607.134
                vals["TRP_2_Y"] = -800.742
                vals["TRP_2_Z"] = 82.79335

                vals["TRP_3_X"] = 1632.044
                vals["TRP_3_Y"] = -808.0
                vals["TRP_3_Z"] = -92.647

                vals["ORIGIN_X"] = 1603.637
                vals["ORIGIN_Y"] = -739.356
                vals["ORIGIN_Z"] = 276.2518

                vals["POS_REGIONS_NUM"] = 2
                vals["NEG_REGIONS_NUM"] = 0
                vals["MIRROR_POSITIVE"] = "YES"

                # 1st positive region--------:
                vals["POS_REG_1_WIDTH"] = 100
                vals["POS_REG_1_ZONE"] = "NUMBER"
                vals["POS_REG_1_ZONE_NUMBER"] = 4
                vals["POS_REG_1_THICKNESS"] = "LINEAR"
                vals["POS_REG_1_T_START"] = 2
                vals["POS_REG_1_T_END"] = 1

                # 2nd positive region--------:
                vals["POS_REG_2_INFINITE_WIDTH"] = "YES"
                vals["POS_REG_2_ZONE"] = "NUMBER"
                vals["POS_REG_2_ZONE_NUMBER"] = 1
                vals["POS_REG_2_THICKNESS"] = "CONSTANT"
                vals["POS_REG_2_T_CONST"] = 1

                tb = base.CreateEntity(constants.NASTRAN, "TAILORED_BLANK", vals)

                tb_handler = base.TailoredBlankHandler(tb)

                part = base.GetPartFromModuleId("1")
                shells = base.CollectEntities(constants.NASTRAN, part, "SHELL", recursive=True)
                tb_handler.add_to_area(shells)

                tb_handler.apply()


            # ------------------------------
            # Example 3:
            # ------------------------------
            def example3():
                vals = {}
                vals["DIRECTION"] = "AXIS"
                vals["DX"] = 0
                vals["DY"] = 0
                vals["DZ"] = 1

                vals["ORIGIN_X"] = 3285.9856
                vals["ORIGIN_Y"] = 774.6174
                vals["ORIGIN_Z"] = 362.1972

                vals["POS_REGIONS_NUM"] = 1
                vals["NEG_REGIONS_NUM"] = 0

                # 1st positive region--------:
                vals["POS_REG_1_INFINITE_WIDTH"] = "YES"
                vals["POS_REG_1_ZONE"] = "WIDTH"
                vals["POS_REG_1_ZONE_WIDTH"] = 20
                vals["POS_REG_1_THICKNESS"] = "CONSTANT"
                vals["POS_REG_1_T_CONST"] = 1.2

                tb = base.CreateEntity(constants.NASTRAN, "TAILORED_BLANK", vals)

                tb_handler = base.TailoredBlankHandler(tb)

                part = base.GetPartFromModuleId("1")
                shells = base.CollectEntities(constants.NASTRAN, part, "SHELL", recursive=True)
                tb_handler.add_to_area(shells)

                tb_handler.apply()

    """

    @classmethod
    def __init__(cls, tailored_blank: object) -> object:
        """

        TailoredBlankHandler object constructor.


        Parameters
        ----------
        tailored_blank : object
                The TAILORED_BLANK entity that will be handled.

        Returns
        -------
        object
                Returns the created TailoredBlankHandler object.

        """

    @classmethod
    def add_to_area(cls, area: object):
        """

        Adds FE shells or faces to the area of the object's TAILORED_BLANK entity.


        Parameters
        ----------
        area : object
                A list of shells or faces that will be added to the area of the TAILORED_BLANK entity.

        """

    @classmethod
    def clear_area(cls):
        """

        Clears the area of the TAILORED_BLANK entity.


        """

    @classmethod
    def apply(cls) -> bool:
        """

        Applies the TAILORED_BLANK entity.


        Returns
        -------
        bool
                Returns True if application succeeded, False if failed.

        """


class SgraphTool:
    """

    This tool creates an sgraph object that provides access to all functionalities of Separation Graph.
    The sgraph object can be constructed with the following ways:
    1. sgrpah = base.SgraphTool(model1 = Model1, model2 = Model2)
    where Model1, Model2 are two ANSA models.
    2. sgraph = base.SgraphTool(group1 = ents1, group2 = ents2)
    where ents1, ents2 are lists of ANSA entities, such as, shells, solids, volumes, and containers, such as, groups, parts, sets.
    3. sgraph = base.SgraphTool()
    In this case, the tool will try to separate the entities in two groups automatically.

    Examples
    --------
    ::

            # case 1: Execute Sgraph and print results
            import ansa
            from ansa import base


            def main():
                model1 = base.GetEntity(0, "MODEL", 0)
                model2 = base.GetEntity(0, "MODEL", 1)

                sgraph = base.SgraphTool(model1=model1, model2=model2)
                sgraph.search_range = 1
                sgraph.signed_dist = True
                sgraph.run()

                sgraph_results = sgraph.get_results()

                if sgraph_results is not None:
                    for key in sorted(sgraph_results, key=lambda x: x._id):
                        val = sgraph_results[key]
                        for val_dict in val:
                            for key2 in sorted(val_dict, key=lambda x: x._id):
                                print("source_ent_id = " + str(key2._id))
                                i = 0
                                for val2 in val_dict[key2]:
                                    if i == 0:
                                        print("target_ent_id = " + str(val2._id))
                                        i = 1
                                    else:
                                        print("distance = " + val2)
                                        i = 0


            # case 2: Execute Sgraph, apply parts and pids on matched entities and print results
            import ansa
            from ansa import base


            def main():
                model1 = base.GetEntity(0, "MODEL", 0)
                model2 = base.GetEntity(0, "MODEL", 1)

                sgraph = base.SgraphTool(model1=model1, model2=model2)
                sgraph.search_range = 1
                sgraph.signed_dist = True
                sgraph.run()

                mapping_results = sgraph.match_parts_with_entities(
                    create_parts=True,
                    return_mapping_results=True,
                    mapping_mode=1,
                    source_model_or_group=0,
                    is_structural=True,
                )

                if mapping_results is not None:
                    for run_part in sorted(mapping_results, key=lambda x: x._name):
                        print("Target_part_name = " + str(run_part._name))
                        for run_result in mapping_results[run_part]:
                            print("Reference_part_name = " + str(run_result["source_group"]._name))
                            print("Area_overlap = " + str(run_result["area_overlap"]))
                            print(
                                "Num_of_matched_entities = "
                                + str(len(run_result["target_group_matched_entities"]))
                            )
                mapping_results = sgraph.match_pids_with_entities(
                    create_pids=False,
                    return_mapping_results=True,
                    mapping_mode=1,
                    source_model_or_group=0,
                    is_structural=False,
                )

                if mapping_results is not None:
                    for run_pid in sorted(mapping_results, key=lambda x: x._name):
                        print("Target_pid_id = " + str(run_pid._name))
                        for run_result in mapping_results[run_pid]:
                            print("Reference_pid_id = " + str(run_result["source_group"]._name))
                            print("Area_overlap = " + str(run_result["area_overlap"]))
                            print(
                                "Num_of_matched_entities = "
                                + str(len(run_result["target_group_matched_entities"]))
                            )


            # case 3: Execute Sgraph, replace parts and pids print results
            import ansa
            from ansa import base


            def main():
                model1 = base.GetEntity(0, "MODEL", 0)
                model2 = base.GetEntity(0, "MODEL", 1)

                sgraph = base.SgraphTool(model1=model1, model2=model2)
                sgraph.search_range = 1
                sgraph.signed_dist = True
                sgraph.run()

                replace_parts_results = sgraph.replace_parts(source_model_or_group=0, threshold=0.8)

                if replace_parts_results is not None:
                    for run_key in sorted(replace_parts_results):
                        print("Target_part_name = ", run_key)
                        print("Reference_part_name = ", replace_parts_results[run_key])
                replace_pids_results = sgraph.replace_pids(source_model_or_group=0, threshold=0.8)

                if replace_pids_results is not None:
                    for run_key in sorted(replace_pids_results):
                        print("Target_pid_name = ", run_key)
                        print("Reference_pid_name = ", replace_pids_results[run_key])


            # case 4: Execute Sgraph, delete unmatched parts and pids print results
            import ansa
            from ansa import base


            def main():
                model1 = base.GetEntity(0, "MODEL", 0)
                model2 = base.GetEntity(0, "MODEL", 1)

                sgraph = base.SgraphTool(model1=model1, model2=model2)
                sgraph.search_range = 1
                sgraph.signed_dist = True
                sgraph.run()

                delete_unmatched_parts_results = sgraph.delete_unmatched_parts(
                    source_model_or_group=1, threshold=0.1
                )

                if delete_unmatched_parts_results is not None:
                    for run_val in sorted(delete_unmatched_parts_results):
                        print("Deleted target_part_name = ", run_val)
                delete_unmatched_pids_results = sgraph.delete_unmatched_pids(
                    source_model_or_group=1, threshold=0.1
                )

                if delete_unmatched_pids_results is not None:
                    for run_val in sorted(delete_unmatched_pids_results):
                        print("Deleted target_pid_name", run_val)

    """

    search_range: float = None
    """
	The search range of Separation Graph.
	Default value is taken from ANSA defaults of Separation Graph.

	"""

    signed_dist: bool = None
    """
	If True, Separation Graph will compute signed distances.
	Default value is taken from ANSA defaults of Separation Graph.

	"""

    use_shells_cog: bool = None
    """
	If True, Separation Graph will compute the distance of the shells' cog.
	Default value is taken from ANSA defaults of Separation Graph.

	"""

    use_shells_nodes: bool = None
    """
	If True, Separation Graph will compute the distance of the shells' nodes.
	Default value is taken from ANSA defaults of Separation Graph.

	"""

    @classmethod
    def run(cls) -> object:
        """

        Executes the Separation Graph diffing


        Returns
        -------
        object
                Returns None

        """

    @classmethod
    def get_results(cls, detailed_results: bool) -> object:
        """

        Returns a dictionary with the Separation Graph diffing results.The keys are the elements and their respective data are lists of dictionaries.If the key element is shell then the list contains only one dictionary.This dictionary structure is described below.   KEY               VALUE  shell         list( nearest_entity, dist )  =  results referred to shell's COG        node1         list( nearest_entity, dist )  =  results referred to shell's node1  node2         list( nearest_entity, dist )  =  results referred to shell's node2   node3         list( nearest_entity, dist )  =  results referred to shell's node3   node4         list( nearest_entity, dist )  =  results referred to shell's node4 If the key element is solid then list contains one dictionary for-each solid's facet. These dictionaries have the following structure.   KEY                  VALUE  facet(SOLIDFACET)  list( nearest_entity, dist )  =  results referred to facet's COG    node1              list( nearest_entity, dist )  =  results referred to facet's node1  node2              list( nearest_entity, dist )  =  results referred to facet's node2   node3              list( nearest_entity, dist )  =  results referred to facet's node3   node4              list( nearest_entity, dist )  =  results referred to facet's node4 nearest_entity:: the entity from the other group that nodes or COGs find the projection with minimum distance.dist:: the distance information. Depends on input 'detailed_results'.Faces are not supported in this function.


        Parameters
        ----------
        detailed_results : bool, optional
                If True, dist will contain the projection vector coordinates
                 (x_start, y_start, z_start, x_end, y_end, z_end).
                Otherwise, dist will contain the projection distance.
                Default value is False.

        Returns
        -------
        object
                Returns the dictionary of Separation Graph diffing results

        """

    @classmethod
    def match_parts_with_entities(
        cls,
        source_model_or_group: int,
        mapping_mode: int,
        is_structural: bool,
        create_parts: bool,
        return_mapping_results: bool,
    ) -> object:
        """

        This function changes the parts hierarchy of the entities in the target group so that it matches the parts hierarchy of the source group.


        Parameters
        ----------
        source_model_or_group : int, optional
                Determines the source group.
                If <= 0: the source group is group 1.
                If > 0: the source group is group 2.
                The default value is taken from ANSA defaults of Separation Graph.

        mapping_mode : int, optional
                Determines how the mapping of entities will be performed.
                If <= 0: Only the entities nearest to the source group are mapped.
                If > 0: All entities within search distance from the source group are mapped.
                The default value is taken from ANSA defaults of Separation Graph.

        is_structural : bool, optional
                If True, all entities that belong to the same connectivity group will be mapped to the same part of the source group.
                The default value is taken from ANSA defaults of Separation Graph.

        create_parts : bool, optional
                If True, the parts hierarchy of the target group will change. Otherwise, it will remain untouched.
                The default value is taken from ANSA defaults of Separation Graph.

        return_mapping_results : bool, optional
                If True, the function returns a dictionary with the mapping results. Otherwise, it returns None.

        Returns
        -------
        object

        """

    @classmethod
    def match_pids_with_entities(
        cls,
        source_model_or_group: int,
        mapping_mode: int,
        is_structural: bool,
        create_pids: bool,
        return_mapping_results: bool,
    ) -> object:
        """

        Changes the PID hierarchy of the entities in the target group so that it matches the PID hierarchy of the source group.


        Parameters
        ----------
        source_model_or_group : int, optional
                Determines the source group.
                If <= 0: the source group is group1.
                If > 0: the source group is group2.
                The default value is taken from ANSA defaults of Separation Graph.

        mapping_mode : int, optional
                Determines how the mapping of entities will be performed.
                If <= 0: Only the entities nearest to the source group are mapped.
                If > 0: All entities within search distance from the source group are mapped.
                The default value is taken from ANSA defaults of Separation Graph.

        is_structural : bool, optional
                If True, all entities that belong to the same connectivity group will be mapped to the same PID of the source group.
                The default value is taken from ANSA defaults of Separation Graph.

        create_pids : bool, optional
                If True, the PID hierarchy of the target group will change. Otherwise, it will remain untouched.
                The default value is taken from ANSA defaults of Separation Graph.

        return_mapping_results : bool, optional
                If True, the function returns a dictionary with the mapping results. Otherwise, it returns None.

        Returns
        -------
        object

        """

    @classmethod
    def replace_parts(cls, source_model_or_group: int, threshold: float) -> object:
        """

        This function maps the parts in the target group with the parts in the source group.


        Parameters
        ----------
        source_model_or_group : int, optional
                Determines the source group.
                If <= 0: the source group is group1.
                If > 0: the source group is group2.
                The default value is taken from ANSA defaults of Separation Graph.

        threshold : float, optional
                Is the matched area percentage above which parts are considered unmatched. (Default: 0.1)

        Returns
        -------
        object
                Returns a dictionary. The key is a Part of group_2 and the data is another dictionary, with key a Part of group_1 and data the matching area percentage between the respective Part of group_2 and Part of group_1.

        """

    @classmethod
    def replace_pids(cls, source_model_or_group: int, threshold: float) -> object:
        """


        Parameters
        ----------
        source_model_or_group : int, optional
                Determines the source group.
                If <= 0: the source group is group1.
                If > 0: the source group is group2.
                The default value is taken from ANSA defaults of Separation Graph.

        threshold : float, optional
                Is the matched area percentage above which parts are considered unmatched. (Default: 0.1)

        Returns
        -------
        object
                Returns a dictionary. The key is a Part of group_2 and the data is another dictionary, with key a Part of group_1 and data the matching area percentage between the respective Part of group_2 and Part of group_1.

        """

    @classmethod
    def delete_unmatched_parts(
        cls, source_model_or_group: int, threshold: float
    ) -> object:
        """

        Deletes the parts of the target group that where not matched with any part of the source group


        Parameters
        ----------
        source_model_or_group : int, optional
                Determines the source group.
                If <= 0: the source group is group1.
                If > 0: the source group is group2.
                The default value is taken from ANSA defaults of Separation Graph.

        threshold : float, optional
                Is the matched area percentage above which parts are considered unmatched. (Default: 0.1)

        Returns
        -------
        object
                Returns the list of unmatched parts

        """

    @classmethod
    def delete_unmatched_pids(
        cls, source_model_or_group: int, threshold: float
    ) -> object:
        """

        Deletes the PIDs of the target group that where not matched with any PID of the source group


        Parameters
        ----------
        source_model_or_group : int, optional
                Determines the source group.
                If <= 0: the source group is group1.
                If > 0: the source group is group2.
                The default value is taken from ANSA defaults of Separation Graph.

        threshold : float, optional
                Is the matched area percentage above which PIDs are considered unmatched. (Default: 0.1)

        Returns
        -------
        object
                Returns the list of unmatched parts

        """


class ReplaceTool:
    """

    The replacement object, which is created through this class, provides access to the Replace Tool functionality through
    script. A replacement object can be created by specifying
     1) a list with MB containers or Faces/Macros that are going to be replaced
     2) the full path to the database which will replace the specified MB containers or Faces/Macros.

    The initial values of the class members below are specified through ANSA.defaults. The "Keyword" and the "Default Value"
    in ANSA.defaults are presented for each member.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import session
            from ansa import constants


            def main():
                session.New("discard")
                run_replace()
                run_replace_faces()


            def run_replace():
                base.Open("//full/path/of/database/initial_db.ansa")
                part = base.GetPartFromName("part_to_be_replaced")
                parts = [part]
                engine = base.ReplaceTool(parts, "//full/path/of/database/new_part.ansa")
                engine.handle_external_connections = "keep"
                engine.handle_internal_connections = "delete"
                engine.handle_internal_connectors = "delete"
                engine.handle_external_model_setup_entities = "keep"
                engine.update_incomming_pids = False
                engine.run()
                results = engine.get_results()
                for ents_type, ents_list in results.items():
                    print(ents_type + ": " + str(len(ents_list)))


            def run_replace_faces():
                base.Open("//full/path/of/database/initial_db.ansa")
                faces = collectFacesToReplace()
                engine = base.ReplaceTool(faces, "//full/path/of/new_faces_db.ansa")
                engine.paste_cons_bounds = True
                engine.reconstruct_cons_bounds = "keep_new"
                engine.try_to_paste_all_red_cons = True
                engine.allow_reconstruct_on_frozen_perims = True
                engine.release_joined_perims_option = "reconstruct"
                engine.run()


            if __name__ == "__main__":
                main()

    """

    handle_internal_connections: str = None
    """
	Defines whether the internal Connections will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'.  (Keyword: "Internal_Connections" - Default Value: keep).
	This member is applicable only in Replace MB containers.

	"""

    handle_external_connections: str = None
    """
	Defines whether the external Connections will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "External_Connections" - Default Value: keep).
	This member is applicable only in Replace MB containers.

	"""

    handle_internal_connectors: str = None
    """
	Defines whether the internal Connectors will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Internal_Connectors - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_connectors: str = None
    """
	Defines whether the external Connectors will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'.  (Keyword: "External_Connectors - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_internal_trim_items: str = None
    """
	Defines whether the internal Trim items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Interrnal_Trim_Items - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_trim_items: str = None
    """
	Defines whether the external Trim items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "External_Trim_Items - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_internal_output_request: str = None
    """
	Defines whether the internal Output Requests items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Interrnal_Output_Requests - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_output_request: str = None
    """
	Defines whether the external Output Requests items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "External_Output_Requests - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_internal_boundary_conditions: str = None
    """
	Defines whether the internal Boundary Condition items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Internal_Boundary_Conditions - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_boundary_conditions: str = None
    """
	Defines whether the external Boundary Condition items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "External_Boundary_Conditions - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_internal_set_builder: str = None
    """
	Defines whether the internal Set Builder items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Interrnal_Set_Builders - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_set_builder: str = None
    """
	Defines whether the external Set Builder items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'.  (Keyword: "External_Set_Builders - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_internal_general_builder: str = None
    """
	Defines whether the internal General Builder items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'.  (Keyword: "Internal_General_Builders - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_general_builder: str = None
    """
	Defines whether the external General Builder items will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'.  (Keyword: "External_General_Builders - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_internal_model_setup_entities: str = None
    """
	Defines whether the internal Model Setup Entities will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Internal_Model_Setup_Entities - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_model_setup_entities: str = None
    """
	Defines whether the external Model Setup Entities will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "External_Model_Setup_Entities - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_internal_interfaces: str = None
    """
	Defines whether the internal Interfaces will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Internal_Interfaces - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_external_interfaces: str = None
    """
	Defines whether the external Interfaces will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "External_Interfaces - Default Value: keep). This member is applicable only in Replace MB containers.

	"""

    handle_mass_elements: str = None
    """
	Defines whether the Mass Elements will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Mass_Elements - Default Value: delete). This member is applicable only in Replace MB containers.

	"""

    handle_dpatches: str = None
    """
	Defines whether the Damping Patches will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Affected_Damping_Patches - Default Value: delete). This member is applicable only in Replace MB containers.

	"""

    handle_resmaps: str = None
    """
	Defines whether the Result Mappers will be kept and re-applied during replace.
	Accepted values: 'keep' and 'delete'. (Keyword: "Affected_Result_Mappers - Default Value: delete). This member is applicable only in Replace MB containers.

	"""

    merge_sets_by_name: bool = None
    """
	Merge incoming with existing Sets by name (True) or not (False).
	(Keyword: "Merge_Sets_By_Name" - Default Value: True).

	"""

    paste_nodes_by_name: bool = None
    """
	Paste incoming with existing Nodes by name (True) or not (False).
	(Keyword: "Replace_Parts_Paste_Nodes_by_Name" - Default Value: True).

	"""

    paste_nodes_by_name_tolerance: float = None
    """
	Paste incoming with existing Nodes by name tolerance.
	(Keyword: "Replace_Parts_Paste_Nodes_By_Name_with_tolerance" - Default Value: 0.05).

	"""

    paste_cons_by_name: bool = None
    """
	Paste incoming with existing Cons by name (True) or not (False)
	This member is applicable only in Replace MB containers.

	"""

    update_incoming_pids: bool = None
    """
	Apply Pids of outgoing Parts in elements of incoming Parts (True) or not (False).
	 (Keyword: "Update_Incoming_Pids" - Default Value: True).
	This member is applicable only in Replace MB containers.

	"""

    update_incoming_pids_tolerance: float = None
    """
	Apply Pids of outgoing Parts in elements of incoming Parts tolerance (Keyword: "Update_Incoming_Pids_Tolerance" - Default Value: 1.0).
	This member is applicable only in Replace MB containers.

	"""

    realize_connections: bool = None
    """
	Realize connections, connectors and builders during replace (True) or not (False).  (Keyword: "Realize_Connections" - Default Value: True). 
	This member is applicable only in Replace MB containers.

	"""

    update_connections_connectivity: bool = None
    """
	Update pid/part connectivity of connections, connectors and builders during replace (True) or not (False).  (Keyword: "Update_Connections_Connectivity" - Default Value: False). 
	This member is applicable only in Replace MB containers.

	"""

    update_connections_connectivity_tolerance: float = None
    """
	Update pid/part connectivity of connections, connectors and builders during replace, tolerance.  (Keyword: "Update_Connections_Connectivity_Tolerance" - Default Value: 1.0). 
	This member is applicable only in Replace MB containers.

	"""

    update_instance_chain_based_on: str = None
    """
	When a multi-insatnce part is replaced this setting specifies the source to be used so as to update the Name and Module Id of all part instances. Accepted values: 'incoming'  and 'outgoing'. (Keyword: "Update_Instance_Chain_Based_On - Default Value: "incoming").

	"""

    paste_nodes: bool = None
    """
	Paste incoming with outgoing Nodes during replace (True) or not (False).

	"""

    paste_nodes_tolerance: float = None
    """
	Paste incoming with outgoing Nodes during replace tolerance. (Keyword: "Paste_Node_Tolerance" - Default Value: 0.2).

	"""

    update_sets: bool = None
    """
	Update set's contents (shell/solid elements) during replace (True) or not (False).

	"""

    update_sets_compatibility_check: bool = None
    """
	Check for mesh compatibility, when update set's contents during replace (True) or not (False). 
	(Keyword: "Prefer_Compatible_Mesh" - Default Value: True).

	"""

    update_sets_expand_factor: float = None
    """
	Shell's expand factor, when update set's contents during replace.
	(Keyword: "Replace_Parts_Shell_Expansion_Factor" - Default Value: 1.0).

	"""

    update_sets_tolerance: float = None
    """
	Update set's contents (shell/solid elements) during replace tolerance.  
	(Keyword: "Sets_Node_Tolerance" - Default Value: 1.0).

	"""

    keep_names_of_nodes: bool = None
    """
	Try to keep names of outgoing nodes during replace (True) or not (False). 
	(Keyword: "Replace_Parts_Keep_Names_of_Nodes" - Default Value: True).

	"""

    keep_names_of_nodes_tolerance: float = None
    """
	Try to keep names of outgoing nodes during replace tolerance. 
	(Keyword: "Replace_Parts_Keep_Names_of_Nodes_with_Tolerance" - Default Value: 1.0)

	"""

    paste_cons_bounds: bool = None
    """
	Paste Cons between old and new parts (True) or not (False). 
	(Keyword: "rp_paste_bounds" - Default Value: True)

	"""

    paste_cons_tolerance: float = None
    """
	Paste Cons between old and new parts tolerance. 
	(Keyword: "paste_bounds_to_neib_parts_tol" - Default Value: 0.2)

	"""

    reconstruct_cons_bounds: str = None
    """
	Paste Cons between old and new parts, when mesh incompatibility is detected which side's mesh will be kept. Accepted values: 'keep_old', 'keep_old_without_joining_perimeters', 'keep_new', 'keep_new_without_joining_perimeters', 'do not paste'. (Keyword: "rp_reconstruct_bounds" - Default Value: 'keep_old')

	"""

    try_to_paste_all_red_cons: bool = None
    """
	Paste Cons between old and new parts, try to paste all single Cons of old and new parts, even if they do not belong to Interface Boundaries (True) or not (False).

	"""

    allow_reconstruct_on_frozen_perims: bool = None
    """
	Paste Cons between old and new parts, allow local reconstruct on frozen perimeters (True) or not (False).

	"""

    on_node_conflicts: str = None
    """
	Define what to do with node conflicts during merge of incoming db. Accepted values: 'offset', 'keep_old', 'keep_new'.  (Keyword: "DM>Change Representation Options>Nodes" - Default Value: offset)

	"""

    on_property_conflicts: str = None
    """
	Define what to do with property conflicts during merge of incoming db. Accepted values: 'offset', 'keep_old', 'keep_new'.  (Keyword: "DM>Change Representation Options>Properties" - Default Value: keep_new)

	"""

    on_material_conflicts: str = None
    """
	Define what to do with material conflicts during merge of incoming db. Accepted values: 'offset', 'keep_old', 'keep_new'.  (Keyword: "DM>Change Representation Options>Materials" - Default Value: keep_new)

	"""

    on_set_conflicts: str = None
    """
	Define what to do with set conflicts during merge of incoming db. Accepted values: 'offset', 'keep_old', 'keep_new'.  (Keyword: "DM>Change Representation Options>Sets" - Default Value: offset)

	"""

    on_coords_conflicts: str = None
    """
	Define what to do with coord systems conflicts during merge of incoming db. Accepted values: 'offset', 'keep_old', 'keep_new'.  (Keyword: "DM>Change Representation Options>Coords" - Default Value: offset)

	"""

    on_bc_set_conflicts: str = None
    """
	Define what to do with Bc set conflicts during merge of incoming db. Accepted values: 'offset', 'keep_old', 'keep_new'.  (Keyword: "DM>Change Representation Options>Bc Sets" - Default Value: offset)

	"""

    execute_pre_post_replace_funs: bool = None
    """
	Execute(True) or not (False) pre/post replace script functions, defined in ANSA defaults.  ( Default Value: False)
	This member is applicable only in Replace MB containers.

	"""

    release_joined_perims_option: str = None
    """
	Define what improve method will be used in case of meshed macro release. Accepted values: 'improve_off', 'erase_mesh', 'smooth_str', 'reconstruct', 'remesh', 'keep_mesh'. Default Value: improve_off)

	"""

    def __init__(
        self, outgoing_mbcontainers: object, incoming_mbcontainers_file_path: str
    ):
        """

        ReplaceTool constructor


        Parameters
        ----------
        outgoing_mbcontainers : object
                A list with MB containers that are going to be replaced

        incoming_mbcontainers_file_path : str
                The full path to the database which will replace the specified MB containers.

        """

    def run(self) -> bool:
        """

        Executes the specified replacement.


        Returns
        -------
        bool
                Returns true in case of succesful replacement and false in case were an error occured.

        """

    def get_results(self) -> object:
        """

        Returns the replacement report


        Returns
        -------
        object
                REturn a python dictionary with all elements that were affected during replacement per type

        """


class NodesToElementsI:
    """

    Given some nodes, NodesToElementsIter finds the elements that use these nodes.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                nodes = base.CollectEntities(constants.NASTRAN, None, "GRID")

                # Use as iterator
                for node, elements in zip(nodes, base.NodesToElementsI(nodes)):
                    print("{} : {}".format(node, sorted(elements)))
                # Find the elements from a Node
                nodes_it = base.NodesToElementsI(nodes)
                print(nodes_it.get_elements(nodes[0]))
                del nodes_it

    """

    def __init__(
        self,
        nodes: List[int] | List[Entity] | int | Entity,
        sources: list = ["entities"],
    ) -> Iterable:
        """


        Parameters
        ----------
        nodes : List[int]|List[Entity]|int|Entity
                Can be one of the following:
                1) A list with node ids.
                2) A list containing node references.
                3) A specific node id.
                4) A specific reference to a node object.

        sources : list, optional
                A list with values 'entities' and 'bcs'. 'entities' (default) returns the
                elements that use the nodes and 'bcs' returns the boundary conditions
                that use the nodes.

        Returns
        -------
        Iterable
                A new iterable object will be returned which can be used to iterate through all those lists. This way only a list will be returned to the user in each iteration.

        """

    def get_elements(self, node: Entity) -> list:
        """

        Get the elements that are used by the given node


        Parameters
        ----------
        node : Entity
                The node object

        Returns
        -------
        list
                A list of the elements that use the given node

        """


class FastenersLibraryTool:
    """
    .. deprecated:: 20.1.0
            Use :py:class:`FeatureHandler` instead.


    The object which is created through this class provides access to the "Detect Fasteners From Library" functionality.The user is able to:

    - detect any fasteners (pressed or standalone) matching the ones stored in DM
    - create parts containing the detected fasteners
    - detach pressed Fasteners from the geometry they are connected to

    See Also
    --------
    dm.AddFile

    Examples
    --------
    ::

            import ansa
            from ansa import base

            FASTENER_LIBRARY_PATH = "path_to_the_DM_fasteners_library"


            def main():
                base.SetDMRoot(FASTENER_LIBRARY_PATH)

                tool = base.FastenersLibraryTool()

                # Keep existing Parts hierarchy
                tool.create_parts = False

                # search only for standalone fasteners
                tool.detect_and_handle_pressed_fasteners = False

                # run detection on the entire loaded ANSA Model
                results = tool.detect()

                if results:
                    print("Detected " + str(len(results)) + " Fasteners in current Model")

                counter = 0
                for fastener in results:
                    counter = counter + 1
                    matched_module_id = fastener["names_values"]["Module Id"]
                    num_faces = len(fastener["entities"])
                    if "axis" in fastener:
                        has_axis = True
                    else:
                        has_axis = False

                    print(
                        "Fastener is matched with Library Item "
                        + matched_module_id
                        + ", contains "
                        + str(num_faces)
                        + " faces."
                    )

    """

    create_parts: bool = None
    """
	If set to True, one Part per detected Fastener is created. If set to False, the existing Parts hierarchy remains unchanged. Default value is True.

	"""

    detect_and_treat_pressed_fasteners: bool = None
    """
	If set to True, the object will try to detect and detach Fasteners that are pressed (connected) to the main geometry. The detachment of the Fasteners maintains the hole on the main geometry and heals any red bounds. If set to False, only standalone Fasteners will be detected. Default value is False.

	"""

    connectivity_separate_at_blue_bounds: bool = None
    """
	If True, input entity regions connected by blue bounds are placed into different connectivity groups. Default value is False.

	"""

    connectivity_separate_at_pid_bounds: bool = None
    """
	If True, input entities regions belonging to different PIDs are placed into different connectivity groups. If False, one connectivity group may have multiple PIDs. Default value is False.

	"""

    connectivity_feature_angle: float = None
    """
	Accepted values: 0 (disabled) - 180. The feature angle limit in degrees. If this value is exceeded, the groups get separated at this feature line. Default value is 0.

	"""

    connectivity_feature_type: str = None
    """
	Accepted values: "convex", "concave", "convex_and_concave". This option  is considered only when separation by feature angle is enabled. Groups get separated at the examined bound only if feature_angle is exceeded and the feature type is of the specified type. Default value is "convex_and_concave".

	"""

    @classmethod
    def detect(cls, entities: object) -> object:
        """

        Detects Fasteners on the input entities and handles pressed Fasteners, if the "detect_and_handle_pressed_fasteners" option is enabled on the object. Parts with the detection results are created, if the "create_parts" option has been set.


        Parameters
        ----------
        entities : object, optional
                The input entities to detect Fasteners on. Iterables of Faces or ANSA containers (Parts, Sets, Props) can be provided. If no input entities are given, then detect() will run on the entire current ANSA Model.

        Returns
        -------
        object
                Returns a List with Dict objects. Each Dict object corresponds to one detected Fastener from the input entities. The following keys are available in the Dict object:- 'entities': a list with the detected Fastener Faces- 'names_values': the properties of the DM Library Fastener that matched best the detected one- 'similarity': the similarity factor between the DM Library Fastener and the detected one- 'is pressed': set to True if the Fastener was connected and detached from the main geometry- 'axis': (optional) the rotation axis vector of the Fastener, if one exists- 'part': (optional) the created Part, if "create_parts" is enabled

        """


class CollectEntitiesI:
    """

    Creates an iterable with the entities of specific types, contained in the containers. It offers better speed and less memory usage when it is just needed to iterate the result of CollectEntities.

    Examples
    --------
    ::

            import ansa
            from ansa import *


            def main():
                for entity in base.CollectEntitiesI(constants.ABAQUS, None, "SHELL"):
                    print(entity)


            if __name__ == "__main__":
                main()

    """

    def __init__(
        self,
        deck: int,
        containers: object,
        search_types: object,
        recursive: bool,
        filter_visible: bool,
        prop_from_entities: bool,
        mat_from_entities: bool,
        model_browser_filter: object,
        no_expand_types: object,
        hidden_entities: bool,
    ) -> Iterable[Entity]:
        """


        Parameters
        ----------
        deck : int
                The deck for which the collection will take place.

        containers : object
                A reference to a container  entity or list with references to  containers.
                Some of the containers can be of type ANSAGROUP, ANSAPART, SET,
                property, material, face,  volume, elements, task manager items etc
                If the container is None, CollectEntitiesI will search the entire
                ANSA database.

        search_types : object
                A string or list of strings with "ansa keywords" of the types to be
                collected. Such types can be SHELL, SOLID, GRID etc.
                Additionally, the following keywords can be used:
                "__PROPERTIES__": returns all properties in the "containers".
                "__MATERIALS__": returns all materials in the "containers".
                "__ELEMENTS__": returns all standard elements in the "containers".
                "__ALL_ENTITIES__": returns all entities in the "containers".
                "__CONNECTIONS__": returns all connections in the "containers".
                "__MBCONTAINERS__": returns the model browser containers of the model if
                used with containers=None or the model browser containers of the containers.
                "__COORD_SYSTEMS__": returns all the coordinate systems in the "containers".
                "__CONNECTION_TEMPLATES__": returns all the connection templates in the "containers".

        recursive : bool, optional
                Recursively search any containers contained in a higher level container
                for any of the search_types. (Default: False).

        filter_visible : bool, optional
                Return only the entities that satisfy all the collection criteria,
                have visibility status, and the status is active.
                In all other cases the parameter is ignored.
                (Default: False).

        prop_from_entities : bool, optional
                In case search_type is a property, this argument controls if the property
                must be acquired from the entities referenced by the entities in the
                container or not. For example, if search_type is "PSHELL", container is
                "PART", and prop_from_entities is True, if the part contains shells, the
                corresponding PSHELL will be returned.
                Otherwise, if prop_from_entities is False, None will be returned.
                (Default: False).

        mat_from_entities : bool, optional
                In case search_type is a material, this argument controls if the material
                must be acquired from the entities referenced by the entities in the
                container or not. For example, if search_type is "MAT1", container is
                "PART", and mat_from_entities is "yes", if the part  contains elements
                with MAT1 material, the corresponding material will be returned.
                Otherwise, if mat_from_entities is False, None will be returned.
                (Default: False).

        model_browser_filter : object, optional
                In case search_types is None, this argument controls which entities to
                collect from a Part, a Group, a Subsystem, a Simulation Model or a
                Simulation Run. 'model_browser_filter' is a dictionary with two keys
                'container' and 'collect_mode'. 'container' value and 'collect_mode' value
                vary according to the entity they are applied on.

                -When collecting entities from a Part or a Group:
                { 'container' : 'all', 'collect_mode' : 'contents' | 'contents_related' | 'contents_affected' }

                'container' values:
                -'all' returns entities of any type

                'collect_mode' values:
                -'contents' returns entities that strictly belong to the Part or the Group.
                -'contents_related' returns the 'contents' plus their properties and
                materials.
                -'contents_affected' returns the 'contents_related' plus all entities that
                are geometrically related to it (use same nodes or are otherwise connected).

                -When collecting entities from a Subsystem, a Simulation Model or a
                Simulation Run:
                { 'container': 'all' | 'geometry' | 'connections' | 'model_setup_entities' | 'interfaces',
                'collect_mode': 'contents' | 'missing' | 'misplaced' }

                'container' values:
                -'all' returns entities of any type.
                -'geometry' returns geometry entities.
                -'connections' returns Connections & Connectors.
                -'model_setup_entities' returns Model Setup Entities
                (like RBE3s directly connected to geometry)
                -'interfaces' returns Interfaces (like A_POINTs).

                'collect_mode' values:
                -'contents' returns entities that directly belong to the 'container'.
                -'missing' returns entities that don't belo

        no_expand_types : object, optional
                A list with ANSA types which won't be expanded while collecting their
                entities. Currently it works only for SETs with recursive = False,
                no_expand_types = ('SET',) in order to get the first level SET contents.

        hidden_entities : bool, optional
                If hidden_entities = False the hidden entities will not be collected. Default is True.

        Returns
        -------
        Iterable[Entity]
                Returns an iterable with all the collected entities.

        """


class MBParametersController:
    """

    The MBParametersController object gives control to the MBParameters. You can get information about parameters, define, edit or remove a parameter from a Model Browser container.

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import *


            def print_parameter(param):
                print("Name:  %s" % param.name)
                print("Value:  %s" % param.value)
                print("Is Locked:  %r" % param.is_locked)
                print("Is Defined: %s" % param.is_defined)
                print("Defined At: %s" % param.defined_at)
                print("Used In : %s" % param.used_in)
                print("")


            def main():
                simrun = base.GetPartFromName("xxxx", type="ANSA_SIMULATION_RUN")

                controller = base.MBParametersController(simrun)
                print(controller.target_mbcontainer)

                list = controller.get_parameters()
                print("Total parameters: %d" % len(list))
                print("")

                for param in list:
                    if param.name == "xxx":
                        controller.define(param, "5", simrun)
                    print_parameter(param)
                    print("")


            if __name__ == "__main__":
                main()

    """

    target_mbcontainer: object = None
    """
	The target_mbcontainer member allows setting/getting the target MBContainer of a MBParametersController.

	"""

    def __init__(self, mbcontainer: object):
        """

        MBParametersProcess object constructor


        Parameters
        ----------
        mbcontainer : object
                A Model Browser container e.g. ANSA_SUBSYSTEM, ANSA_SIMULATION_MODEL, ANSA_SIMULATION_RUN

        """

    def get_parameters(self, mbcontainer: object) -> object:
        """

        All parameters of the target or the given MBContainer


        Parameters
        ----------
        mbcontainer : object, optional
                A Model Browser container

        Returns
        -------
        object
                Returns a list with all parameters of the Model Browser container as named tuples.

        """

    def define(self, parameter: object, value: str, mbcontainer: object):
        """

        Define or Edit a parameter in a Model Browser container


        Parameters
        ----------
        parameter : object
                A Parameter object.

        value : str, optional
                Value

        mbcontainer : object, optional
                A Model Browser container. If no container provided then the target_mbcontainer will be used.

        """

    def remove_definition(self, parameter: object):
        """

        Remove definition of a parameter from Model Browser containers.


        Parameters
        ----------
        parameter : object
                A Parameter object.

        """


class FlangesCompatibleTool:
    """

    FlangesCompatibleTool - a class to define fully compatible faces to be treated as flanges. This is implemented through automatic detection of compatibility of flanges given a certain proximity and a tolerance angle, among input faces. Faces are trimmed accordingly at non-compatible areas. Afterwards, it is possible to apply either (i) Topology and link faces, (ii) Topology, or (iii) Fusion (valid only for volumes).

    See Also
    --------
    FlangesCompatible, FlangesCompatibleFuse, FlangesCompatibleTopo, FlangesCompatibleLink, FlangesCompatibleIdentify.

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            import datetime
            from ansa import *


            def FlangeCompatibleTool():
                # Construct Flanges obj in visible faces
                # \tnamed_arguments :: { "faces", "distance", "angle_tolerance", "minimum_overlap", "allow_same_property" }
                flanges = ansa.base.FlangesCompatibleTool()
                # Identify Flanges
                ret = flanges.identify()
                print("identify flanges :: ", ret)

                if ret == None:
                    return

                # Reverse all identified flanges
                # \treversed_all = flanges.reverse()
                # \tprint("reversed_all ", reversed_all)

                print("identify flanges len :: ", len(ret))

                # Run flanges
                for flg in ret:
                    # Reverse input flange
                    # \t\tflg = flanges.reverse(flg)
                    # \t\tprint("reversed flg", flg)

                    # Get master faces from flange
                    master_faces = flanges.masterFaces(flg)
                    print("master_faces = ", master_faces)

                    # Get slave faces from flange
                    slave_faces = flanges.slaveFaces(flg)
                    print("slave_faces = ", slave_faces)

                    # Get flange from id
                    # flg2 = flanges.getflange(1)

                    # Get original faces
                    faces = flanges.faces
                    print("original_faces = ", faces)

                    # Get original distance
                    distance = flanges.distance
                    print("original_distance = ", distance)

                    # Get common overlap from flange
                    common_overlap = flanges.commonOverlap(flg)
                    print("common_overlap", common_overlap)

                    # Get master overlap from flange
                    master_overlap = flanges.masterOverlap(flg)
                    print("master_overlap", master_overlap)

                    # Get slave overlap from flange
                    slave_overlap = flanges.slaveOverlap(flg)
                    print("slave_overlap", slave_overlap)

                    # Get master property from flange
                    master_pid = flanges.masterPID(flg)
                    print("master_pid", master_pid)

                    # Get slave property from flange
                    slave_pid = flanges.slavePID(flg)
                    print("slave_pid", slave_pid)

                    # Get flanges property treatment
                    property = flanges.property
                    print("property = ", property)

                    # Get flanges part treatment
                    part = flanges.part
                    print("part = ", part)

                    # Set flanges part treatment
                    flanges.part = "slave"
                    print("part2 = ", flanges.part)

                    # Get flanges keep_faces treatment
                    keep_faces = flanges.keepFaces
                    print("keep_faces = ", keep_faces)

                    # Apply type on identified flange
                    # *** In case no flange object is passed, all identified flanges will be modified !!
                    # \t\tresulted_faces = flanges.link(flg)
                    # \t\tresulted_faces = flanges.topo(flg)
                    resulted_faces = flanges.fuse(flg)

                    # \t\t# Get flanges results
                    if resulted_faces != None:
                        print("len resulted flanges DONE = ", len(resulted_faces))
                    print("resulted_faces = ", resulted_faces)

                    state = flanges.state(flg)
                    print("RESULT :: Flange(%d) has STATE(%s)" % (_id, state))


            # \t\talt_ret = ansa.base.FlangesCompatibleTopo(master_faces, slave_faces)
            # \t\tif alt_ret != None :  print("len alt_ret flanges DONE = ",len(alt_ret))
            # \t\tprint("alt_ret = ", alt_ret)


            def Flanges():
                # Start time
                tik = datetime.datetime.now()
                # Flange Compatible methods
                FlangeCompatibleTool()
                # Draw all
                ansa.base.RedrawAll()
                # End time
                tok = datetime.datetime.now()
                TIME = tok - tik
                print("TIME :: ", divmod(TIME.total_seconds(), 60))


            def FlangesAll():
                # Start time
                tik = datetime.datetime.now()

                # Construct Flanges obj in visible faces
                flanges = ansa.base.FlangesCompatibleTool()
                # Identify Flanges
                ret = flanges.identify()
                print("identify flanges :: ", ret)
                if ret == None:
                    return
                print("identify flanges len :: ", len(ret))

                # Apply type on all identified flange
                resulted_faces = flanges.link()
                if resulted_faces != None:
                    print("len resulted flanges DONE = ", len(resulted_faces))

                # End time
                tok = datetime.datetime.now()

                TIME = tok - tik
                print("TIME :: ", divmod(TIME.total_seconds(), 60))


            def main():
                Flanges()


            # def main(): FlangesAll()


            if __name__ == "__main__":
                main()

    """

    angle_tolerance: float = None
    """
	A float defining angle degree deviation between two flanges. (setter / getter)

	"""

    minimum_overlap: float = None
    """
	A float defining minimum overlap (%) on both master and slave areas. (setter / getter)

	"""

    allow_same_property: bool = None
    """
	If True, allows definition of flanges among faces that have the same property. (setter / getter)

	"""

    property: str = None
    """
	A string defining resulted flanges property among a "master", "slave", "interface". (setter / getter)
	If string equals to "master", created flanges have the same property as master faces.
	If string equals to "slave", created flanges have the same property as slave faces.
	If string equals to "interface", created flanges have the interface property.

	"""

    part: str = None
    """
	A string defining resulted flanges part among a "master", "slave", "interface". (setter / getter)
	If string equals to "master", created flanges have the same part as master faces.
	If string equals to "slave", created flanges have the same part as slave faces.
	If string equals to "interface", created flanges have the interface part.

	"""

    keepFaces: str = None
    """
	A string defining, in case of fuse , which faces will be deleted among ,
	"delete_caps", "keep_master_caps", "keep_slave_caps", "keep_both_caps". (setter / getter)
	if string equals to "delete_caps", both caps will be deleted.
	if string equals to "keep_master_caps", master caps will be kept and slave will be deleted.
	if string equals to "keep_slave_caps", slave caps will be kept and master will be deleted.
	if string equals to "keep_both_caps", both will be kept.

	"""

    @classmethod
    def __init__(
        cls,
        faces: object,
        distance: float,
        angle_tolerance: float,
        minimum_overlap: float,
        allow_same_property: bool,
    ):
        """

        Constructor of class FlangesCompatibleTool.


        Parameters
        ----------
        faces : object, optional
                A list of faces, a string with value 'visible' or a string with value 'all'. If it is called with 'visible', it works with all the visible faces. If it is called with 'all', it works with all the faces.
                Default value visible faces.

        distance : float, optional
                A float defining maximum distance concerning identification of flanges, after taking into consideration property thickness, using a distance D = distance - ((thickness1 + thickness2) / 2.) .
                Default value 1.

        angle_tolerance : float, optional
                A float defining angle degree deviation between two flanges.
                Default value 10.

        minimum_overlap : float, optional
                A float defining minimum overlap (%) on both master and slave areas.
                Default value 5.

        allow_same_property : bool, optional
                If True, allows definition of flanges among faces that have the same property.
                Dedault value False.

        """

    @classmethod
    def identify(cls) -> object:
        """

        Automaticaly identifies flanges among input faces defined on constructor.


        Returns
        -------
        object
                Returns a list with flange objects.

        """

    @classmethod
    def getflange(cls, flange: int) -> object:
        """

        A flange from input id of the return identified flanges


        Parameters
        ----------
        flange : int
                id from identified flanfes

        Returns
        -------
        object
                Returns willing flange.

        """

    @classmethod
    def commonOverlap(cls, flange: object) -> float:
        """

        Returns common area amongst faces of input flange.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        float
                Common area amongst faces of input flange.

        """

    @classmethod
    def masterFaces(cls, flange: object) -> object:
        """

        Returns a list with master faces amongst faces of input flange.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        object
                A list with master faces of input flange.

        """

    @classmethod
    def slaveFaces(cls, flange: object) -> object:
        """

        Returns a list with slave faces amongst faces of input flange.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        object
                A list with slave faces of input flange.

        """

    @classmethod
    def masterOverlap(cls, flange: object) -> float:
        """

        Returns master overlap(%) of input flange.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        float
                master overlap(%) of input flange.

        """

    @classmethod
    def slaveOverlap(cls, flange: object) -> float:
        """

        Returns slave overlap(%) of input flange.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        float
                slave overlap(%) of input flange.

        """

    @classmethod
    def minProximity(cls, flange: object) -> float:
        """

        Returns minimum proximity distance from input identified flange.


        Parameters
        ----------
        flange : object
                Input identified fllange.

        Returns
        -------
        float
                minimum proximity distance from input identified flange.

        """

    @classmethod
    def maxProximity(cls, flange: object) -> float:
        """

        Returns maximum proximity distance from input identified flange.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        float
                maximum proximity distance from input identified flange.

        """

    @classmethod
    def masterPID(cls, flange: object) -> object:
        """

        Returns master faces` property.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        object
                master faces` property.

        """

    @classmethod
    def slavePID(cls, flange: object) -> object:
        """

        Returns slave faces` property.


        Parameters
        ----------
        flange : object
                Input idenitfied flange.

        Returns
        -------
        object
                slave faces` property.

        """

    @classmethod
    def state(cls, flange: object) -> str:
        """

        Returns a string of flange state after calling link, topo or fuse.Available strings :1. 'DONE', in case of success.2. 'PARTIAL_DONE', in case not all faces defining flange have beem modified.3. 'FAILED', in case of failure.


        Parameters
        ----------
        flange : object
                Input identified flange.

        Returns
        -------
        str
                a string of flange state after calling link, topo or fuse.Available strings : { 'DONE', 'PARTIAL_DONE', 'FAILED' }.

        """

    @classmethod
    def link(cls, flange: object) -> object:
        """

        The faces are cut to create the compatible faces. Faces found compatible, are automatically converted to linked Faces.


        Parameters
        ----------
        flange : object, optional
                In case input flange, final result will take place upon faces of input flange.
                In case nothing passed final result will take place upon faces of all identified flanges.

        Returns
        -------
        object
                A list with the created faces.

        """

    @classmethod
    def topo(cls, flange: object) -> object:
        """

        Cuts and deletes the compatible faces of the one side, i.e. the "slave" compatible faces and connects the remaining.


        Parameters
        ----------
        flange : object, optional
                In case input flange, final result will take place upon faces of input flange.
                In case nothing passed final result will take place upon faces of all identified flanges.

        Returns
        -------
        object
                A list with the created faces.

        """

    @classmethod
    def fuse(cls, flange: object) -> object:
        """

        The function will not only cut to create the compatible faces, but will also fuse them together.The faces that will be kept and will not be deleted during this process can be specified through the "keepFaces" option.


        Parameters
        ----------
        flange : object, optional
                In case input flange, final result will take place upon faces of input flange.
                In case nothing passed final result will take place upon faces of all identified flanges.

        Returns
        -------
        object
                A list with the created faces.

        """

    @classmethod
    def reverse(cls, flange: object) -> object:
        """

        The function reverses master faces with slave faces.


        Parameters
        ----------
        flange : object, optional
                In case input flange, final result will take place upon faces of input flange.
                In case nothing passed final result will take place upon faces of all identified flanges.

        Returns
        -------
        object
                In case input flange, will return an updated flange object.In case nothing passed , will return a list with all the updated flanges

        """


class TransferInfoFromSubsystemTool:
    """

    The TransferInfoFromSubsystemTool object, which is created through this class, provides access to transfer from subsystem functionality through script. For instance we have a newer version of a subsystem(receiver) and we would like to transfer the Connection entities from an older version of subsystem(source).

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import session


            def main():
                session.New("discard")
                run_transfer()


            def run_transfer():
                base.Open("a_file_path_to_a_db_contains_the_receiver_subsystem.ansa")
                receiver_subsystem = base.GetPartFromName(
                    "the_receiver_subsystem", "ANSA_SUBSYSTEM"
                )

                vals = {"Project": "hoho", "Module Id": "lala", "Iteration": "002"}
                server_id = base.GetDMObjectId("Subsystems", vals)

                engine = base.TransferInfoFromSubsystemTool(receiver_subsystem)
                engine.source_subsystem_server_id = server_id
                engine.transfer_connections = "no"
                engine.transfer_connectors = "no"
                engine.transfer_interfaces = "yes"
                engine.transfer_gebs = "no"
                engine.reapply_transferred_ents = "yes"

                engine.run()

                results = engine.get_transferred_entities()
                for ents_type, ents_list in results.items():
                    print("-----------------------------------")
                    print(ents_type + ": " + str(len(ents_list)))
                    print(ents_list)


            if __name__ == "__main__":
                main()

    """

    source_subsystem_filepath: str = None
    """
	A filepath to an ANSA db which contains a single subsystem from which we will retrieve information to transfer in the selected subsystem.

	"""

    source_subsystem_server_id: str = None
    """
	A server id which corresponds to a subsystem saved in DM from which we will retrieve information to transfer in the selected subsystem.

	"""

    transfer_connections: str = None
    """
	Defines whether the Connector items found in specified source subsystem will be transferred to receiver subsystem.
	Accepted values: 'yes' and 'no'.

	"""

    transfer_interfaces: str = None
    """
	Defines whether the Interface items found in specified source subsystem will be transferred to receiver subsystem.
	Accepted values: 'yes' and 'no'.

	"""

    transfer_gebs: str = None
    """
	Defines whether the GEB items found in specified source subsystem will be transferred to receiver subsystem.
	Accepted values: 'yes' and 'no'.

	"""

    reapply_transferred_ents: str = None
    """
	Defines whether the transfered items from specified source subsystem will be reapplied to receiver subsystem.
	Accepted values: 'yes' and 'no'.

	"""

    def __init__(self, receiver_subsystem: object) -> object:
        """

        TransferInfoFromSubsystemTool object constructor.Returns the created TransferInfoFromSubsystemTool object.


        Parameters
        ----------
        receiver_subsystem : object
                The receiver subsystem in which we would like to transfer entities from another subsystem.

        Returns
        -------
        object

        """

    def run(self) -> bool:
        """

        Executes the transfer procedure.


        Returns
        -------
        bool
                Returns true if transfer procedure has been executed succesfully.Otherwise it returns false.

        """

    def get_transferred_entities(self) -> object:
        """

        Returns the entities that have succesfully transferred to receiver subsystem.


        Returns
        -------
        object
                A dictionary with the the entities that have succesfully transferred to receiver subsystem per type.

        """


class ChangesetManager:
    """

    The ChangesetManager object gives control to the Changeset of a Model Browser container. You can get information about the actions or summary of the changgeset.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def print_action(action):
                print("Name:  %s" % action.name)
                print("Entity:  %s" % action.entity_info)
                print("Timestamp:  %s" % action.timestamp)
                print("User:  %s" % action.user)
                print("Comment: %s" % action.comment)

                print("")


            def main():
                sub = base.GetPartFromName("xxxx", type="ANSA_SUBSYSTEM")
                changeset = base.ChangesetManager(sub)

                changeset.summary = "My summary"
                print(changeset.summary)

                actions = changeset.get_actions()
                print("Total actions: %d" % len(actions))
                print("")
                for index, action in enumerate(actions):
                    print("Index: %d" % (index + 1))
                    print_action(action)
                    print("")
                changeset.add_action(name="My custom action", comment="My comment")

                run_action = actions[0]
                run_action.name = "New action name"
                run_action.comment = "New comment"
                changeset.update_action(index=1, action=run_action)

                changeset.delete_actions(2)

                actions = changeset.get_actions()
                for index, action in enumerate(actions):
                    print("Index: %d" % (index + 1))
                    print_action(action)
                    print("")
                ret = changeset.clear(actions=False, summary=True)
                ret = changeset.delete()


            if __name__ == "__main__":
                main()

    """

    target_mbcontainer: object = None
    """
	The target_mbcontainer member allows setting/getting the target MBContainer of a ChangesetManager.

	"""

    summary: str = None
    """
	The summary member allows setting/getting the summary of a Changeset.

	"""

    def __init__(self, mbcontainer: object):
        """

        ChangesetManager object constructor


        Parameters
        ----------
        mbcontainer : object
                A Model Browser container which supports Changeset management.

                - ANSAPART
                - ANSA_SUBSYSTEM

        """

    def clear(self, actions: bool, summary: bool) -> bool:
        """

        Clear a Changeset.


        Parameters
        ----------
        actions : bool, optional
                define if actions will be cleared

        summary : bool, optional
                define if summary will be cleared

        Returns
        -------
        bool
                Returns True on success, False otherwise.

        """

    def delete(self) -> bool:
        """

        Delete a Changeset.


        Returns
        -------
        bool
                Returns True on success, False otherwise.

        """

    def get_actions(self):
        """

        Get all actions of Changeset.


        """

    def delete_actions(self, actions_indices: object) -> bool:
        """

        Delete a list of actions.


        Parameters
        ----------
        actions_indices : object
                A list with the indices of actions to be deleted

        Returns
        -------
        bool
                Returns True on success, False otherwise.

        """

    def add_action(self, name: str, entity_info: str, comment: str) -> bool:
        """

        Record a new action in Changeset


        Parameters
        ----------
        name : str
                Name of action

        entity_info : str, optional
                Information related to the Entity affected by the action

        comment : str, optional
                Comment of action

        Returns
        -------
        bool
                Returns True on success, False otherwise.

        """

    def update_action(self, index: int, action: object) -> bool:
        """

        Update an action


        Parameters
        ----------
        index : int
                Index of the action to be updated.

        action : object
                An action object as provided by the get_actions method.

                The fields of actions that can be updated are
                - name
                - entity_info
                - comment

        Returns
        -------
        bool
                Returns True on sucess, False otherwise.

        """


class IgaPatch:
    """

    IgaPatch is an object that provides the whole functionality of the IGA Patch module.
    It can be used via script in both GUI and no-GUI mode.

    Examples
    --------
    ::

            # The first example is when you create new iga patches
            import sys
            import os
            from os import path
            import ansa
            from ansa import base, constants, session


            def main():
                deck = constants.LSDYNA
                base.SetCurrentDeck(deck)
                ents = base.CollectEntities(deck, None, "FACE")

                # option list for default creation
                OptionList = {
                    "Mode": 0,
                    "Distortion distance": False,
                    "Distortion distance value": 0.05,
                    "Min Span": True,
                    "Min Span value": 2.00,
                    "Max Span": False,
                    "Max Span value": 5.0,
                    "Uniform": False,
                    "Extend": False,
                    "Join": "All",
                    "Order": 4,
                }

                igaPatch = base.IgaPatch()
                result = igaPatch.create(ents, OptionList)


            if __name__ == "__main__":
                main()

            # The second example is when you have iga patches and you want to parse them.
            import os
            from os import path
            import ansa
            import sys
            from ansa import base, constants, session


            def main():
                iga_faces_list = base.CollectEntities(
                    ansa.constants.LSDYNA, None, "IGA_SHELL", recursive=True
                )
                if len(iga_faces_list) == 0:
                    iga_faces_list = base.CollectEntities(
                        ansa.constants.LSDYNA, None, "ELEMENT_SHELL_NURBS_PATCH", recursive=True
                    )

                igaPatch = base.IgaPatch()
                for i in range(len(iga_faces_list)):
                    igaPatch.set(iga_faces_list[i])
                    loops_list = igaPatch.get_loops()

                    for j in range(len(loops_list)):
                        edge_list = igaPatch.get_edges(loops_list[j])

                        for k in range(len(edge_list)):
                            edge_sense = igaPatch.get_edge_data(edge_list[k], "IGA_EDGE_SENSE")
                            edge_order = igaPatch.get_edge_data(edge_list[k], "IGA_EDGE_ORDER")
                            edge_ctrl_pnts = igaPatch.get_edge_data(
                                edge_list[k], "IGA_EDGE_CONTROL_POINTS"
                            )
                            edge_weights = igaPatch.get_edge_data(edge_list[k], "IGA_EDGE_WEIGHTS")
                            edge_knots = igaPatch.get_edge_data(edge_list[k], "IGA_EDGE_KNOTS")
                            edge_mult = igaPatch.get_edge_data(
                                edge_list[k], "IGA_EDGE_MULTIPLICITIES"
                            )
                            if base.GetEntityType(constants.LSDYNA, edge_list[k]) == "IGA_SHELL":
                                # IGA_EDGE_XYZ is valid only for IGA_EDGE_SHELL entity
                                edge_xyz = igaPatch.get_edge_data(edge_list[k], "IGA_EDGE_XYZ")

                    surf_order_s = igaPatch.get_surface_data("IGA_SURFACE_ORDER_S")
                    surf_order_t = igaPatch.get_surface_data("IGA_SURFACE_ORDER_T")
                    surf_ctrl_pnts = igaPatch.get_surface_data("IGA_SURFACE_CONTROL_POINTS")
                    surf_weights = igaPatch.get_surface_data("IGA_SURFACE_WEIGHTS")
                    surf_knots_s = igaPatch.get_surface_data("IGA_SURFACE_KNOTS_S")
                    surf_knots_t = igaPatch.get_surface_data("IGA_SURFACE_KNOTS_T")
                    surf_mult_s = igaPatch.get_surface_data("IGA_SURFACE_MULTIPLICITIES_S")
                    surf_mult_t = igaPatch.get_surface_data("IGA_SURFACE_MULTIPLICITIES_T")


            if __name__ == "__main__":
                main()

            # The third example is when you want to project nodes or points to a list of iga faces.
            import os
            from os import path
            import ansa
            import sys
            from ansa import base, constants, session


            def main():
                iga_faces_list = base.CollectEntities(
                    constants.LSDYNA, None, "IGA_SHELL", recursive=True
                )
                if len(iga_faces_list) == 0:
                    iga_faces_list = base.CollectEntities(
                        constants.LSDYNA, None, "ELEMENT_SHELL_NURBS_PATCH", recursive=True
                    )

                igaPatch = base.IgaPatch()
                for i in range(len(iga_faces_list)):
                    igaPatch.add(iga_faces_list[i])

                nodes_list = base.CollectEntities(constants.NASTRAN, None, "GRID", recursive=True)

                # gaPatch.project("NODES", nodes_list, True)

                points_list = []
                for node in nodes_list:
                    res = base.GetEntityCardValues(constants.LSDYNA, node, ("X", "Y", "Z"))
                    point = [res["X"], res["Y"], res["Z"]]
                    points_list.append(point)

                res = igaPatch.project("POINTS", points_list, False, 0.5)


            if __name__ == "__main__":
                main()

    """

    def create(self, entities: object, optionlist: object) -> object:
        """

        Create IGA patch


        Parameters
        ----------
        entities : object
                A list of faces

        optionlist : object
                A list of options. The available options are:

                Mode: integer indicates how to create an new patch and takes value 0 to Create a new                                     underlying NURBS or 1 to Convert the implicit underlying surface into NURBS .

                Distortion distance: boolean indicates if the algorithm will take into account                                           the corresponding value.

                Distortion distance value: float indicates the average distortion distance between the                                     original geometry and the resulting patch.

                Min Span: boolean indicates if the algorithm will take into account the corresponding                                     value.

                Min Span value: float indicates the minimum span value between two consequent knot                                       vector values.

                Max Span: boolean indicates if the algorithm will take into account the corresponding                                     value.

                Max Span value: float indicates the maximum span value between two consequent knot                                       vector values.

                Uniform: boolean indicates if the knot vector of the patch is uniform in both                                            directions.

                Extend: boolean indicates if the underlying NURBS is extended compared with the                                           corresponding perimeter bounds.

                Join: boolean indicates if the selection will be joined in one or more macros.
                Join: String ("All", "Feature", "Off"). "All" joins user selection in one macro. "Feature" joins user selection by feature. "Off" disables Join of macros. It is adviced to use the string values for Join since the boolean values are to be deprecated.

                Order: Integer indicates the polynomial order of the patch in both directions.

        Returns
        -------
        object
                Returns a list of 2 lists. The first contains the results info and the second the failed faces.

        """

    def set(self, iga_face: object) -> int:
        """

        Set an iga face to the IgaPatch object.


        Parameters
        ----------
        iga_face : object
                The Iga face.

        Returns
        -------
        int

        """

    def get_loops(self) -> object:
        """

        Get the loops of the iga face.


        Returns
        -------
        object
                Returns a list with the iga loops

        """

    def get_edges(self, iga_loop: object) -> object:
        """

        Get the edges of a loop


        Parameters
        ----------
        iga_loop : object
                The iga loop

        Returns
        -------
        object
                Returns a list with the iga edges

        """

    def get_edge_data(self, iga_edge: object, data_type: str) -> object:
        """

        Get the data of an iga edge.


        Parameters
        ----------
        iga_edge : object
                The iga edge

        data_type : str
                Available data types:
                IGA_EDGE_SENSE
                IGA_EDGE_ORDER
                IGA_EDGE_CONTROL_POINTS
                IGA_EDGE_WEIGHTS
                IGA_EDGE_KNOTS
                IGA_EDGE_MULTIPLICITIES
                IGA_EDGE_XYZ

        Returns
        -------
        object
                Returns based on the data type used:                IGA_EDGE_SENSE returns integer indicates if the edge should be flipped                IGA_EDGE_ORDER returns integer which is the order of the NURBS parametric curve                IGA_EDGE_CONTROL_POINTS returns a list of lists of doubles, which are the control points of the NURBS parametric curve                 IGA_EDGE_WEIGHTS returns list of doubles which are the weights of the control points of the NURBS parametric curve                IGA_EDGE_KNOTS returns list of doubles which form the knot vector of the NURBS parametric curve                IGA_EDGE_MULTIPLICITIES returns list of integers which form the multiplicities of the knot vector of the NURBS parametric curve                IGA_EDGE_XYZ returns the spatial edge

        """

    def get_surface_data(self, data_type: str) -> object:
        """

        Get iga Surface Data


        Parameters
        ----------
        data_type : str
                available data types:
                IGA_SURFACE_ORDER_S
                IGA_SURFACE_ORDER_T
                IGA_SURFACE_CONTROL_POINTS
                IGA_SURFACE_WEIGHTS
                IGA_SURFACE_KNOTS_S
                IGA_SURFACE_KNOTS_T
                IGA_SURFACE_MULTIPLICITIES_S
                IGA_SURFACE_MULTIPLICITIES_T

        Returns
        -------
        object
                Returns based on the data type used:                IGA_SURFACE_ORDER_S returns integer which is the order of the NURBS surface in s direction                IGA_SURFACE_ORDER_T returns integer which is the order of the NURBS surface in t direction                 IGA_SURFACE_CONTROL_POINTS returns a list of lists of doubles which are the control points of the NURBS surface                IGA_SURFACE_WEIGHTS returns list of doubles which are the weights of the control points of the NURBS surface                IGA_SURFACE_KNOTS_S returns list of doubles which form the knot vector of the NURBS surface in s direction                IGA_SURFACE_KNOTS_T returns list of doubles which form the knot vector of the NURBS surface in t direction                IGA_SURFACE_MULTIPLICITIES_S returns list of integers which form the multiplicities of the knot vector of the NURBS surface in s direction                IGA_SURFACE_MULTIPLICITIES_T returns list of integers which form the multiplicities of the knot vector of the NURBS surface in t direction

        """

    def export_ibra(self, iga_faces: object, output_path: str) -> int:
        """

        Create an IBRA json file compatible with Kratos software, from IGA elements


        Parameters
        ----------
        iga_faces : object
                A list of IGA faces

        output_path : str
                a full path name to save the json file

        Returns
        -------
        int
                Returns 0 on success otherwise an exception

        """

    def add(self, iga_face: object):
        """

        Add an iga face to IgaPatch object.


        Parameters
        ----------
        iga_face : object
                the iga face

        """

    def project(
        self,
        nodes_list: object,
        points_list: object,
        update_nodes: bool,
        out_of_patch_tolerance: float,
    ) -> object:
        """

        Projects a list of nodes or points to the nearest iga face


        Parameters
        ----------
        nodes_list : object, optional
                A list of nodes.

        points_list : object, optional
                A list of points.

        update_nodes : bool, optional
                Update XYZ coordinates of the input node with the projected point.

        out_of_patch_tolerance : float
                Tolerance value indicating whether the projection of the point should be inside the material of the patch.

        Returns
        -------
        object
                A warning message list with the points/nodes that failed to project.

        """

    def report(self) -> str:
        """

        A formatted report of the igaPatch.create() result


        Returns
        -------
        str
                The report string

        """

    def get_create_options(self) -> dict:
        """

        Get the current iga patch create options.


        Returns
        -------
        dict
                Returns a dictionary with the current iga patch create options.

        """


class ActiveModularEnvironmentProfile:
    """

    A class that provides interface to manage the active profile of Modular Environment

    Examples
    --------
    ::

            import ansa
            from ansa import base

            active_profile = base.ActiveModularEnvironmentProfile()

            # getting the active discipline and target solver
            discipline = active_profile.discipline
            target_solver = active_profile.target_solver
            print("Discipline = " + discipline)
            print("Target Solver = " + target_solver)

            # Changing target solver and discipline
            active_profile.discipline = "crash"
            active_profile.target_solver = "LsDyna"

            # Getting key of active profile
            profile_key = active_profile.get_key()
            print("Profile Key:")
            print(profile_key)

            # Saving profile in beta home
            # active_profile.save_in_beta_home()

            # Saving profile in dm
            # server_id = active_profile.save_in_dm(conflicts_option = "spinup")
            # print(server_id)

            # Load a profile from predefined locations
            profile_key = {"Discipline": "nvh", "Target Solver": "Nastran"}
            success = active_profile.load(profile_key)
            if success:
                print("Modular Environment Profile was successfully loaded")
            else:
                print("Failed to load Modular Environment Profile")

    """

    target_solver: str = None
    """
	Sets/Gets the Target Solver of the active profile.
	Accepted values: all available decks, i.e. "Nastran", "LsDyna" etc.

	"""

    discipline: str = None
    """
	Sets/Gets the Discipline of the active profile.
	Accepted values: "nvh", "crash", "durability", "cfd", or
	any other value defined in dm_structrure.xml of the connected DM

	"""

    @staticmethod
    def get_key() -> object:
        """

        Method to obtain the key of the active Modular Environment profile


        Returns
        -------
        object
                Returns a dictionary that contains the active key

        """

    @staticmethod
    def save_in_beta_home() -> bool:
        """

        Saves the active profile in BETA Home


        Returns
        -------
        bool
                Returns a boolean value to indicate success or failure

        """

    @staticmethod
    def save_in_dm(conflicts_option: str, spin_up_attribute: str) -> str:
        """

        Saves the active profile in the connected DM


        Parameters
        ----------
        conflicts_option : str, optional
                Defines how to handle any conflicts with profiles that might preexist in DM.
                Accepted values:
                - "Spin Up" : (default value)
                - "Overwrite"

        spin_up_attribute : str, optional
                In case that conflicts_option is set to "Spin Up", this argument controls
                which attribute is going to be spinned up in case of a DM conflict
                - Default value: 'Version'

        Returns
        -------
        str
                Returns the server id of the saved Modular Environment profile, in case that save in DM was successfully completed

        """

    @staticmethod
    def load(profile_key: object) -> bool:
        """

        Loads a profile from the prefefined location which is higher in priority


        Parameters
        ----------
        profile_key : object
                A dictionary that contains the key of the profile that is going to be loaded

        Returns
        -------
        bool
                Returns a boolean value to indicate success or failure

        """

    @staticmethod
    def import_from_custom_location(location: str) -> bool:
        """

        Imports definition and settings of a profile that is found in a custom location


        Parameters
        ----------
        location : str
                Filepath of the profie to import

        Returns
        -------
        bool
                Returns a boolean value to indicate success or failure

        """

    @staticmethod
    def set_output_parameters(fields: object, mbcontainer_type: str) -> int:
        """

        Sets values of output parameters for a specified Model Browser Container type


        Parameters
        ----------
        fields : object
                A dictionary which contains the keywords of output
                parameters mapped to their new values

        mbcontainer_type : str
                The type of Model Browser Container that corresponds
                to the output parameters under modification. Can be:
                - "ANSA_LIBRARY_ITEM"
                - "ANSA_SUBSYSTEM"
                - "ANSA_SIMULATION_MODEL"
                - "ANSA_LOADCASE"
                - "ANSA_SIMULATION_RUN"

        Returns
        -------
        int
                Returns the number of any encountered errors

        """

    @staticmethod
    def get_output_parameters(fields: object, mbcontainer_type: str) -> object:
        """

        Returns the values of the specified output parameters of a Model Browser Container type


        Parameters
        ----------
        fields : object
                A list of the requested keywords of output parameters

        mbcontainer_type : str
                The type of Model Browser Container that holds the output parameters. Can be:
                - "ANSA_LIBRARY_ITEM"
                - "ANSA_SUBSYSTEM"
                - "ANSA_SIMULATION_MODEL"
                - "ANSA_LOADCASE"
                - "ANSA_SIMULATION_RUN"

        Returns
        -------
        object
                A dictionary that contains the values of the requested output parameters

        """

    @staticmethod
    def set_properties(properties: object) -> bool:
        """

        Set values of properties of the active profile


        Parameters
        ----------
        properties : object
                dictionary which contains key-value pairs of the profile properties

        Returns
        -------
        bool

        """


class IPImpact:
    """

    Class that handles all the IP Impact tool functionality (Marking and Positioning).

    Examples
    --------
    ::

            # PYTHON script
            import os
            import ansa
            from ansa import base, constants


            def main():
                obj = base.IPImpact(
                    regulation="FMVSS201",
                    instr_panel=1,
                    steer_wheel=2,
                    header=3,
                    windscreen=4,
                    lhs_sgrp=(3030, -374, 696),
                    rhs_sgrp=(3129, 374, 681),
                    targets_distance=50,
                    headform=5,
                    cid=1,
                )

                collector = base.CollectNewModelEntities()
                obj.mark()
                items = collector.report()
                targets = []
                del collector
                for item in items:
                    if item.ansa_type(constants.LSDYNA) == "TARGET_POINT":
                        targets.append(item)
                ret = obj.multi_position(
                    targets=targets,
                    master_file="/home/user/fem_g/FMVSS201/ip_master.key",
                    include_files_prefix="IP_Points",
                    include_files_extension=".k",
                    directory="/home/user/fem_g/FMVSS201/script_multi/",
                    velocity=7.0,
                    use_id_sequence=True,
                )


            #        in case only the transformation values are needed singe_position can be used
            #        for trgt in targets:
            #                ret = obj.single_position(target = trgt, move_back = 0.5)
            #                print(ret)


            if __name__ == "__main__":
                main()

    """

    regulation: str = None
    """
	Apply the ECER21 or FMVSS201 regulation.  Accepted values ("ECER21", "FMVSS201"). Default value is "ECER21".

	"""

    instr_panel: Entity = None
    """
	The set or set ID of the Instrument Panel.

	"""

    lhs_sgrp: list = None
    """
	The LHS seating reference point. A list containing the (x, y, z) coordinates is required.

	"""

    rhs_sgrp: list = None
    """
	The RHS seating reference point. A list containing the (x, y, z) coordinates is required.

	"""

    steer_wheel: Entity = None
    """
	The set or set ID of the Steering Wheel.

	"""

    windscreen: Entity = None
    """
	The set or set ID of the Windscreen (used only in FMVSS201).

	"""

    header: Entity = None
    """
	The set or set ID of the Header.

	"""

    roof: Entity = None
    """
	The set or set ID of the Roof (used only in ECER21).

	"""

    h_point_offset: str = None
    """
	The type of H-P offset . Accepted values are ("X-Z Offset", "Vector Offset", "No Offset"). Default value is "X-Z Offset".

	"""

    target_points: str = None
    """
	The 'Target Points' option. Accepted values are ("for each contact", "on specific distance"). Default value is "for each contact".

	"""

    lhs_area_limit: float = None
    """
	The LHS area exemption zone distance from steering wheel. Default value is 127 for ECER21 and 0.5*headform_diameter for FMVSS201.

	"""

    rhs_area_limit: float = None
    """
	The RHS area exemption zone distance from rightmost point of IP. Default value is 127 for both ECER21 and FMVSS201.

	"""

    min_length: float = None
    """
	Pendulum minimum length used in a combination with SgRP that has no offset (rearmost). Default value is 736.

	"""

    max_length: float = None
    """
	Pendulum maximum length used in a combination with SgRP that has offset (forward-most). Default value is 840.

	"""

    headform_diameter: float = None
    """
	Headform diameter used for marking. Default value is 165.

	"""

    stepsize: float = None
    """
	Pendulum rotational stepsize in degrees. Default value is 3 degrees.

	"""

    pos_arm_length: float = None
    """
	Fixed arm length measured to the top of the head that will be used for calculating the pivot nodes  of the positioning. Default value is 800.

	"""

    targets_distance: float = None
    """
	Distance between target points measured along curve, in case 'Target Points : on specific distance' is selected. Default value is 50.

	"""

    min_distance: float = None
    """
	Minimum distance between the target points in case 'Target Points : for each contact' is selected. If the distance between a target point and each neighbors is less than this value, it will be deleted. Default value is 0.

	"""

    intermediate_stepsize: float = None
    """
	The stepsize that will be used for calculating the pivot points and the arm lengths of the intermediate curves between rearmost and forward-most SgRp(offset). Active only if 'intermediate_curves' option is enabled. Default value is 20.

	"""

    offset_x: float = None
    """
	In case of sliding seats, the offset magnitude along Travel Vector of the SgRP. If the Offset mode is X-Z the vector is the global -X axis.  Default value is 127.

	"""

    offset_z: float = None
    """
	In case of sliding seats, the offset along z-axis of the SgRP. Default value is 19.

	"""

    travel_vec: list = None
    """
	In case of sliding seats the Travel Vector for the offset of SgRP. A list containing the (x, y, z) coordinates is required. Default value is (-1, 0, 0).

	"""

    intermediate_curves: bool = None
    """
	Enable the creation of intermediate curves between the front and rear curve. Default value is False.

	"""

    debug_spheres_for_all: bool = None
    """
	Enable the creation of Debug Spheres for all the intermediate curves. Default value is False.

	"""

    headform: Entity = None
    """
	The Headform set or set ID. Needed for the single_position and multi_position methods.

	"""

    cid: Entity = None
    """
	The Coordinate System or Coordinate System ID. Needed for the single_position and multi_position methods.

	"""

    create_new_pivot_nodes: bool = None
    """
	Create a new Pivot Node for each Target Point, based on the Pos. Arm Length and the Headform's COG at the marking position. Default value is True.

	"""

    targets_pos_method: str = None
    """
	The positioning method that will be assigned to each Target Point that will be created. Available values ("PENDULUM_Z_LEVEL", "FIXED_ARM_LENGTH", "NORMAL_TO_SURFACE", "TANGENT_TO_TRAJECTORY", "AUTOMATIC", "NORMAL_TO_LINE"). Default value is "FIXED_ARM_LENGTH".

	"""

    excluded: Entity = None
    """
	Select a set that contains the excluded IP parts. If the projection of the created Target Points falls onto these parts, they will be exclude.

	"""

    @classmethod
    def mark(cls):
        """

        Performs the marking of the Instrument Panel based on class member values.


        """

    @classmethod
    def single_position(
        cls,
        target: object,
        move_back: float,
        z_level: float,
        point_type: str,
        pivot_node: object,
        method: str,
    ) -> object:
        """

        Performs positioning on a single target point based on the internal values of the target point entity or based on the argument values, in case something is not defined in the target point entity. The 'headform' and 'cid' class members must be already defined.


        Parameters
        ----------
        target : object
                The target point entity.

        move_back : float, optional
                The move back angle in degrees. The headform will be rotated around pivot node backwards using this angle.

        z_level : float, optional
                The z level of the initial rotation . Used only if the method  is "PENDULUM_Z_LEVEL".

        point_type : str, optional
                The type of positioning that will be used. Available values are ("TARGET", "CONTACT").

        pivot_node : object, optional
                The Pivot node.

        method : str, optional
                Select the positioning method. Available values are ("PENDULUM_Z_LEVEL", "FIXED_ARM_LENGTH",
                "90_DEGREES", "TANGENT_TO_TRAJECTORY", "NORMAL_TO_SURFACE", "AUTOMATIC", "NORMAL_TO_LINE").  Default value is "PENDULUM_Z_LEVEL".

        Returns
        -------
        object
                Returns an array a[] of 10 entries that define the transformation in an LS_DYNA way. Specifically rotation through an angle a[6], about a line with direction cosines a[0], a[1] and a[2], passing through the point a[3], a[4] and a[5].Translation vector is a[7],a[8] and a[9].

        """

    @classmethod
    def multi_position(
        cls,
        targets: object,
        master_file: str,
        include_files_prefix: str,
        include_files_extension: str,
        directory: str,
        list_name: str,
        meta_file_name: str,
        velocity: float,
        dyna_transform_mode: str,
        headform_include: object,
        write_out_set: bool,
        use_point_names: bool,
        use_relative_name_includes: bool,
        copy_files_in_each_dir: bool,
        use_id_sequence: bool,
        create_vel_ref_cid: bool,
        move_back: float,
        z_level: float,
        point_type: str,
        pivot_node: object,
        method: str,
        mode: str,
        write_inline: bool,
        skip_subfolders: bool,
    ) -> int:
        """

        Performs positioning on a list of target points and creates all the necessary files containing the transformation/velocity keywords, for setting up a complete IP load case.


        Parameters
        ----------
        targets : object
                A list containing the target points.

        master_file : str, optional
                Define the master file that will be used to create the load case file of each target point. If it is not defined only the include files that contain the transformation/velocity keywords will be created.

        include_files_prefix : str, optional
                Define the prefix name of the include files. If the flag                                  'Use point name for files and directories' is enabled, the prefix will be added to the name of the target point. Otherwise each include file will be named according the defined prefix plus a counter. Default value is "IPanel_Shot".

        include_files_extension : str, optional
                Define the preferred extension of all the include files that will be created (e.g .inc). If left blank the default extension of the current deck, will be used.

        directory : str, optional
                The output directory.

        list_name : str, optional
                Define the name of transformations list file that will be created. Default value is 'TransfList.csv'.

        meta_file_name : str, optional
                Define the name of the META file that will be created. Default value is 'MetaList.txt'.

        velocity : float, optional
                Define the velocity of the headform. In case the target point entity has a defined 'IMPACT VELOCITY' this value will be overridden.  Default value is blank.

        dyna_transform_mode : str, optional
                Define the type of TRANSFORMATION keywords that will be created. Available values are "NODE_TRANSFORM",
                "INCLUDE_TRANSFORM". Default value is
                "NODE_TRANSFORM". It is valid only for LSDYNA.

        headform_include : object, optional
                The Include of the Headform. Valid only if the dyna_transform_mode is "INCLUDE_TRANSFORM".

        write_out_set : bool, optional
                If this flag is enabled the definition of headform set will be written out in the include file. Default value is True.

        use_point_names : bool, optional
                Use the target points names for naming the created
                include files. Default value is False.

        use_relative_name_includes : bool, optional
                Use relative names for includes. This option enables
                the writing of relative paths instead of absolute. Default value is False.

        copy_files_in_each_dir : bool, optional
                This option enables the copy of the referenced includes that are contained in master file, in each target point's directory. Default value is False.

        use_id_sequence : bool, optional
                The sequence for creating the files will depend on Target Point IDs. Default value is False.

        create_vel_ref_cid : bool, optional
                Option for creating the Initial Velocity keywords with reference to impactor's Coordinate System (CID). Default value is False. Valid only in LS-DYNA, RADIOSS.

        move_back : float, optional
                The move back angle in degrees. The headform will be rotated around pivot node backwards using this angle. Default value is zero.

        z_level : float, optional
                The z level of the initial rotation . Used only if the method is "PENDULUM_Z_LEVEL".

        point_type : str, optional
                The type of positioning that will be used. Available values are ("TARGET", "CONTACT").

        pivot_node : object, optional
                The Pivot node.

        method : str, optional
                Select the positioning method. Available values are ("PENDULUM_Z_LEVEL", "FIXED_ARM_LENGTH",
                "90_DEGREES", "TANGENT_TO_TRAJECTORY", "NORMAL_TO_SURFACE", "AUTOMATIC", "NORMAL_TO_LINE").  Default value is PENDULUM_Z_LEVEL.

        mode : str, optional
                Output files option mode ("master_file_and_folders", "include_files_only").
                "master_file_and_folders" will use the master file and create file for each Target Point containing a modified master file and include current position,
                "include_files_only" will create only the extra include files for each position.

        write_inline : bool, optional
                Option for writing the Transformation/Velocity keywords inside the Master file.

        skip_subfolders : bool, optional
                Option to skip the creation of a sub-folder for each Target Point.

        Returns
        -------
        int
                Returns 1 in success.

        """


class DesignParameters:
    """

    The DesignParameters object gives access to the design parameters that are defined on ANSAPART level. By using this object you are able to manage (add/remove/clear) design parameters of a specific part.

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def print_param(param):
                print("Name:  %s" % param.name)
                print("Value:  %s" % param.value)
                print("Units:  %s" % param.units)
                print("Type:  %s" % param.type)
                print("Active:  %s" % param.active)


            def main():
                part = base.GetPartFromName("Part_1", type="ANSAPART")
                if part == None:
                    print("No part found")
                    return
                # Get the design parameters py object
                params = base.DesignParameters(part)

                # Clear previous params
                params.clear()

                # Add parameters
                params.add(
                    name="Front Panel\\Hole Diameter",
                    value="40",
                    units="mm",
                    type="Real",
                    active=True,
                )
                params.add(name="Front Panel\\Flange Angle", value="10", units="deg")
                params.add(name="Rear Panel\\Hole Diameter", value="30", units="mm")
                params.add(name="Rear Panel\\Flange Angle", value="15", units="deg")

                # Get all parameters
                parameters = params.get()
                for index, param in enumerate(parameters):
                    print("Index: %d" % (index + 1))
                    print_param(param)
                    print("")
                # Get all active parameters
                parameters = params.get(active=True)

                # Get a specific parameter by its name
                param = params.get(name="Diameter")
                if param == None:
                    print("No 'Diameter' parameter found!")


            if __name__ == "__main__":
                main()

    """

    part: object = None
    """
	The ANSAPART entity for which we want to manage the design parameters.

	"""

    @classmethod
    def __init__(cls, part: object):
        """

        DesignParameters object constructor.


        Parameters
        ----------
        part : object
                The ANSAPART entity

        """

    @classmethod
    def add(cls, name: str, value: str, units: str, type: str, active: bool):
        """

        Add a new design parameter.


        Parameters
        ----------
        name : str
                The design parameter name.

        value : str, optional
                The value that holds the ANSAPART for this design parameter.

        units : str, optional
                The units of the design parameter.

        type : str, optional
                Define the value type: Real, Integer, String
                By default the 'Real' type is used.

        active : bool, optional
                Define if the parameter is currently active or not. Active parameters can take part in the optimization process.

        """

    @classmethod
    def remove(cls, name: str):
        """

        Removes a parameter.


        Parameters
        ----------
        name : str
                The parameter name.

        """

    @classmethod
    def clear(cls):
        """

        Clears all parameters.


        """

    @classmethod
    def get(cls, name: str, active: bool) -> object:
        """

        Get all or a specific (by its name) design parameter.


        Parameters
        ----------
        name : str, optional
                The specific parameter name to be returned.

        active : bool, optional
                Set active=True if only the active parameters should be returned.

        Returns
        -------
        object
                In general it returns a list of all existing parameters but if a specific name is given as argument (optional) then only this specific parameter is returned as a single object (no list).

        """


class LowSpeed:
    """

    Class that handles all the Low Speed tool functionality (Target Points and Positioning).

    Examples
    --------
    ::

            # example 1
            import ansa
            from ansa import base


            def main():
                low_speed_obj = base.LowSpeed(
                    regulation="ECER42",
                    front_bumper=62000350,
                    rear_bumper=62000351,
                    plane_angle=60.0,
                    ground_p1=(0, 0, 0),
                    impactor=6,
                    ref_cid=6,
                    bumpers=62000353,
                )

                low_speed_obj.target_points(create_debug_planes=True)

                low_speed_obj.single_position(target=1)


            if __name__ == "__main__":
                main()
            # example 2
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                low_speed_obj = base.LowSpeed(
                    regulation="ECER42",
                    front_bumper=62000350,
                    rear_bumper=62000351,
                    plane_angle=60.0,
                    ground_p1=(0, 0, 0),
                    impactor=6,
                    ref_cid=6,
                    bumpers=62000353,
                )

                low_speed_obj.target_points()

                targs = []
                for i in range(1, 4):
                    tp = base.GetEntity(constants.LSDYNA, "TARGET_POINT", i)
                    targs.append(tp)
                low_speed_obj.multi_position(targs, directory="/home/user/Desktop")


            if __name__ == "__main__":
                main()

    """

    regulation: str = None
    """
	Apply the regulation.  Accepted values ("ECER42", "USPART581"). Default value is "ECER42".

	"""

    front_bumper: object = None
    """
	The set or set ID of the Front Bumper.

	"""

    rear_bumper: object = None
    """
	The set or set ID of the Rear Bumper.

	"""

    plane_angle: float = None
    """
	The angle between the global X-Z plane and the vertical plane that will come in contact with the vehicle.  Default for both  regulations is 60 deg.

	"""

    inclined_ground: bool = None
    """
	Use inclined ground according ground_point_1 and ground_point_2.
	Default value is False.

	"""

    ground_p1: object = None
    """
	First Ground Point. A tupple containing the (x,y,z) coordinates of the point.

	"""

    ground_p2: object = None
    """
	Second Ground Point. A tupple containing the (x,y,z) coordinates of the point.

	"""

    impactor: object = None
    """
	The include or include ID of the Impactor (for Radioss the submodel or submodel ID). Needed for the single_position and multi_position methods.

	"""

    ref_cid: object = None
    """
	The coordinate system or coordinate system ID of the Impactor. Needed for the single_position and multi_position methods.

	"""

    bumpers: object = None
    """
	The set or set ID of the Bumpers. Needed for the single_position and multi_position methods.

	"""

    z_offset: float = None
    """
	The distance along global Z axis between the Ground and the Ref. Coord. System at the final position.  Default for 'ECER42' is 445mm and for 'USPART581' is 508. (It will be written inside the target entity)

	"""

    @classmethod
    def target_points(cls, create_debug_planes: bool, is_half_car: bool):
        """

        Performs the creation of target points Low Speed based on class member values.


        Parameters
        ----------
        create_debug_planes : bool, optional
                Create the debug planes as geometric faces. Default is False.

        is_half_car : bool, optional
                In case the car model is half (from 0 to max Y or to min Y). Default is False.

        """

    @classmethod
    def single_position(cls, target: object, move_back: float, z_offset: float) -> bool:
        """

        Performs positioning on a single target point based on the internal values of the target point entity. The argument values can overpower the target point entity values. The 'impactor', 'ref_cid' and 'bumpers' class members must be already defined.


        Parameters
        ----------
        target : object
                The target point entity.

        move_back : float, optional
                The distance from target point that the test item will be
                moved back. Default value is 5 mm.

        z_offset : float, optional
                The distance along global Z axis between the Ground and the Ref. Coord. System at the final position.  This argument can overpower the target point entity value of z_offset.

        Returns
        -------
        bool
                True on success, False on failure.

        """

    @classmethod
    def multi_position(
        cls,
        targets: object,
        move_back: float,
        z_offset: float,
        mode: str,
        master_file: str,
        include_files_prefix: str,
        include_files_extension: str,
        directory: str,
        list_name: str,
        meta_file_name: str,
        use_point_names: bool,
        use_relative_name_includes: bool,
        copy_files_in_each_dir: bool,
        use_id_sequence: bool,
        write_inline: bool,
        skip_subfolders: bool,
    ) -> bool:
        """

        Performs positioning on a list of target points based on the internal values of the target point entity or based on the argument values, only in case something is not defined in the target point entity. Also creates all the necessary files, for setting up a complete Low Speed load case.The 'impactor', 'ref_cid' and 'bumpers' class members must be already defined.


        Parameters
        ----------
        targets : object
                A list containing the target points.

        move_back : float, optional
                The distance from target point that the test item will be
                moved back. Default value is 5 mm.

        z_offset : float, optional

        mode : str, optional
                Output files option mode ("master_file_and_folders", "include_files_only").
                "master_file_and_folders" will use the master file and create file for each Target Point containing a modified master file and include current position,
                "include_files_only" will create only the extra include files for each position. Default is master_file_and_folders.

        master_file : str, optional
                Define the master file that will be used to create the load case file of each target point. If it is not defined only the include files that contain the transformation/velocity keywords will be created.

        include_files_prefix : str, optional
                Define the prefix name of the include files. If the flag                                  'Use point name for files and directories' is enabled, the prefix will be added to the name of the target point. Otherwise each include file will be named according the defined prefix plus a counter. Default value is "LowSpeed_Impactor".

        include_files_extension : str, optional
                Define the preferred extension of all the include files that will be created (e.g .inc). If left blank the default extension of the current deck, will be used.

        directory : str, optional
                The output directory.

        list_name : str, optional
                Define the name of transformations list file that will be created. Default value is 'LowSpeed_TransfList.csv'.

        meta_file_name : str, optional
                Define the name of the META file that will be created. Default value is 'LowSpeed_MetaList.txt'.

        use_point_names : bool, optional
                Use the target points names for naming the created
                include files. Default value is False.

        use_relative_name_includes : bool, optional
                Use relative names for includes. This option enables
                the writing of relative paths instead of absolute. Default value is False.

        copy_files_in_each_dir : bool, optional
                This option enables the copy of the referenced includes that are contained in master file, in each target point's directory. Default value is True.

        use_id_sequence : bool, optional
                The sequence for creating the files will depend on Target Point IDs. Default value is False.

        write_inline : bool, optional
                Option for writing the Transformation/Velocity keywords inside the Master file.

        skip_subfolders : bool, optional
                Option to skip the creation of a sub-folder for each Target Point.

        Returns
        -------
        bool
                True on success, False on failure.

        """


def GetDMRoot() -> str:
    """

    Returns the path that currently points to DM.

    Returns
    -------
    str
            The function returns a string containing the current DM root.
            A string of length 0 is returned if no DM path is currently set.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dm_root = base.GetDMRoot()
                print(dm_root)


    """


def NewPTInstance(
    tree: object,
    child_identifier: Any,
    part_identifier: Any,
    parent_identifier: Any,
    position_matrix: object,
    instance_attributes: object,
) -> int:
    """

    Defines a new Product Tree Instance in the created product tree element.

    Parameters
    ----------
    tree : object
            The object returned from a previous call to 'NewProductTree'
            function.

    child_identifier : Any
            (string/integer) A unique id that will be used only internally from
            the function for the interpretation of "parent-child" relationships
            (i.e. part in group, group in group)

    part_identifier : Any
            (string/integer) The part_identifier must be equal to the unique
            part_identifier of the master part.

    parent_identifier : Any
            (string/integer) The parent identifier must be equal to the unique
            child_identifier of the parent (as declared in NewPTInstance).
            It is used internally for the interpretation of "parent-child"relationships
            (i.e. part in group, group in group). If the instance is in the root of the
            hierarchy (top-level item) then the parent identifier will be None.

    position_matrix : object
            It is the relative 4x3 transformation list that will be assigned to
            the part/group.

    instance_attributes : object, optional
            The instance_attributes list can contain any other information
            regarding the part instance like target mass, mesh type etc.
            The list contains other lists which specify the name and the value of
            each attribute e.g.
            instance_attributes[0] = ["TARGET MASS","5"]
            instance_attributes[1] = ["MESH TYPE","coarse"]

    Returns
    -------
    int
            Returns 0 on success and -1 on failure.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create the product tree
                tree = base.NewProductTree()

                # Create a group
                pos_matrix_group = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = 0  # no parent for the top level group
                child_identifier = 1
                base.NewPTPart(tree, "group", "MID A", "Version A", "Top Level Group")
                base.NewPTInstance(
                    tree, child_identifier, "group", parent_identifier, pos_matrix_group
                )

                # Create a part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = child_identifier  # the part belongs to the previous group
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "1.5"]]
                part_file_attr = [
                    ["PID", 1000],
                    ["Property Name", "Front Part"],
                    ["Material", "ES200"],
                ]
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "Part MI", part_attr)
                inst_attr = [["Position", "Left"]]
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part, inst_attr
                )
                base.NewPTModel(tree, "part1", "/home/demo/FrontPart.CATPart", part_file_attr)

                # Create an instance to the previously created part
                pos_matrix_instance = [[1, 0, 0], [0, -1, 0], [0, 0, 1], [0, 0, 0]]
                inst_attr = [["Position", "Right"]]
                child_identifier += 1
                base.NewPTInstance(
                    tree,
                    child_identifier,
                    "part1",
                    parent_identifier,
                    pos_matrix_instance,
                    inst_attr,
                )
                # Add a PID offset of 100 to the new instance
                base.SetPTInstancePidOffset(tree, child_identifier, 100)

                # Create a new tailorblanked part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "3.4"]]
                part_file_attr = [
                    ["PID", 2000],
                    ["Property Name", "Front TB Part"],
                    ["Material", "ES220"],
                ]
                base.NewPTPart(tree, "part2", "MID 2", "Version AB", "Part TB", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part2", parent_identifier, pos_matrix_part
                )
                # Add the first CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/FrontTBPart.CATPart", part_file_attr)

                part_file_attr = [
                    ["PID", 2001],
                    ["Property Name", "Rear TB Part"],
                    ["Material", "ES200"],
                ]
                # Add the second CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/RearTBPart.CATPart", part_file_attr)

                # Launch the editor.
                my_settings = base.InputProductTreeSettings()
                my_settings.should_open_window = True
                base.InputModelDefinition(product_tree=tree, settings=my_settings)


    """


def NewPTModel(
    tree: object,
    part_identifier: Any,
    cad_file: str,
    part_file_attributes: object,
    part_file_position_matrix: object,
) -> int:
    """

    Adds CAD or other file references to an existing Product Tree Part.

    Parameters
    ----------
    tree : object
            It is the element returned from a previous call to 'NewProductTree'
            function.

    part_identifier : Any
            (string/integer) The unique part_identifier of the part/group that
            references the CAD files (as declared in NewPTPart).

    cad_file : str
            The filename of the CAD.

    part_file_attributes : object, optional
            The part_file_attributes list can contain any other information
            regarding the part file attributes like property id, material id etc.
            The list contains other lists which specify the name and the value of
            each attribute e.g.
            part_file_attributes[0] = ["PID","5"]
            part_file_attributes[1] = ["MID","50"]
            If no part_file_attributes are given, then a zero value can be
            assigned.

    part_file_position_matrix : object, optional
            Exported in the download list in order to be used for the application
            of a geometric transformation on the referenced file (e.g CAD file
            during translation). This list is different than the one defined in
            NewPTInstance since the latter is passed automatically to the ANSAPART
            created upon confirmation.

    Returns
    -------
    int
            Returns 0 on success and -1 on failure.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create the product tree
                tree = base.NewProductTree()

                # Create a group
                pos_matrix_group = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = 0  # no parent for the top level group
                child_identifier = 1
                base.NewPTPart(tree, "group", "MID A", "Version A", "Top Level Group")
                base.NewPTInstance(
                    tree, child_identifier, "group", parent_identifier, pos_matrix_group
                )

                # Create a part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = child_identifier  # the part belongs to the previous group
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "1.5"]]
                part_file_attr = [
                    ["PID", 1000],
                    ["Property Name", "Front Part"],
                    ["Material", "ES200"],
                ]
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "Part MI", part_attr)
                inst_attr = [["Position", "Left"]]
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part, inst_attr
                )
                base.NewPTModel(tree, "part1", "/home/demo/FrontPart.CATPart", part_file_attr)

                # Create an instance to the previously created part
                pos_matrix_instance = [[1, 0, 0], [0, -1, 0], [0, 0, 1], [0, 0, 0]]
                inst_attr = [["Position", "Right"]]
                child_identifier += 1
                base.NewPTInstance(
                    tree,
                    child_identifier,
                    "part1",
                    parent_identifier,
                    pos_matrix_instance,
                    inst_attr,
                )
                # Add a PID offset of 100 to the new instance
                base.SetPTInstancePidOffset(tree, child_identifier, 100)

                # Create a new tailorblanked part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "3.4"]]
                part_file_attr = [
                    ["PID", 2000],
                    ["Property Name", "Front TB Part"],
                    ["Material", "ES220"],
                ]
                base.NewPTPart(tree, "part2", "MID 2", "Version AB", "Part TB", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part2", parent_identifier, pos_matrix_part
                )
                # Add the first CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/FrontTBPart.CATPart", part_file_attr)

                part_file_attr = [
                    ["PID", 2001],
                    ["Property Name", "Rear TB Part"],
                    ["Material", "ES200"],
                ]
                # Add the second CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/RearTBPart.CATPart", part_file_attr)

                # Launch the editor.
                my_settings = base.InputProductTreeSettings()
                my_settings.should_open_window = True
                base.InputModelDefinition(product_tree=tree, settings=my_settings)


    """


def NewPTPart(
    tree: object,
    part_identifier: Any,
    module_id: str,
    version: str,
    name: str,
    part_attributes: object,
    is_group: bool,
) -> int:
    """

    Defines a new Product Tree Part in the created product tree.

    Parameters
    ----------
    tree : object
            It is the element returned from a previous call to 'NewProductTree'
            function.

    part_identifier : Any
            (string/integer) The part_identifier is a unique id that characterizes a product
            tree structure item. This unique id will be later used for the
            generation of "parent-child"relationships
            (i.e. part in group, group in group) and the creation of multiple
            instances (through NewPTInstance) and the addition of file
            references(through NewPTModel).

    module_id : str
            The string that will correspond to the module id of the group/part

    version : str
            The string that will correspond to the version of the group/part.

    name : str
            The string that will correspond to the name of the group/part.

    part_attributes : object, optional
            The part_attributes list can contain any other information
            regarding the part like target mass, mesh type etc.The list
            contains other lists which specify the name and the value of
            each attribute e.g.
            part_attributes[0] = ["TARGET MASS","5"]
            part_attributes[1] = ["MESH TYPE","coarse"]

    is_group : bool, optional
            Flag that determines whether the created item is a part or a group. Default value is False.

    Returns
    -------
    int
            Returns 0 on success and -1 on failure.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create the product tree
                tree = base.NewProductTree()

                # Create a group
                pos_matrix_group = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = 0  # no parent for the top level group
                child_identifier = 1
                base.NewPTPart(tree, "group", "MID A", "Version A", "Top Level Group")
                base.NewPTInstance(
                    tree, child_identifier, "group", parent_identifier, pos_matrix_group
                )

                # Create a part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = child_identifier  # the part belongs to the previous group
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "1.5"]]
                part_file_attr = [
                    ["PID", 1000],
                    ["Property Name", "Front Part"],
                    ["Material", "ES200"],
                ]
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "Part MI", part_attr)
                inst_attr = [["Position", "Left"]]
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part, inst_attr
                )
                base.NewPTModel(tree, "part1", "/home/demo/FrontPart.CATPart", part_file_attr)

                # Create an instance to the previously created part
                pos_matrix_instance = [[1, 0, 0], [0, -1, 0], [0, 0, 1], [0, 0, 0]]
                inst_attr = [["Position", "Right"]]
                child_identifier += 1
                base.NewPTInstance(
                    tree,
                    child_identifier,
                    "part1",
                    parent_identifier,
                    pos_matrix_instance,
                    inst_attr,
                )
                # Add a PID offset of 100 to the new instance
                base.SetPTInstancePidOffset(tree, child_identifier, 100)

                # Create a new tailorblanked part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "3.4"]]
                part_file_attr = [
                    ["PID", 2000],
                    ["Property Name", "Front TB Part"],
                    ["Material", "ES220"],
                ]
                base.NewPTPart(tree, "part2", "MID 2", "Version AB", "Part TB", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part2", parent_identifier, pos_matrix_part
                )
                # Add the first CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/FrontTBPart.CATPart", part_file_attr)

                part_file_attr = [
                    ["PID", 2001],
                    ["Property Name", "Rear TB Part"],
                    ["Material", "ES200"],
                ]
                # Add the second CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/RearTBPart.CATPart", part_file_attr)

                # Launch the editor.
                my_settings = base.InputProductTreeSettings()
                my_settings.should_open_window = True
                base.InputModelDefinition(product_tree=tree, settings=my_settings)


    """


def NewProductTree() -> object:
    """

    Defines a new product tree.

    Returns
    -------
    object
            Returns a reference to the newly created product tree object.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create the product tree
                tree = base.NewProductTree()

                # Create a group
                pos_matrix_group = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = 0  # no parent for the top level group
                child_identifier = 1
                base.NewPTPart(tree, "group", "MID A", "Version A", "Top Level Group")
                base.NewPTInstance(
                    tree, child_identifier, "group", parent_identifier, pos_matrix_group
                )

                # Create a part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = child_identifier  # the part belongs to the previous group
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "1.5"]]
                part_file_attr = [
                    ["PID", 1000],
                    ["Property Name", "Front Part"],
                    ["Material", "ES200"],
                ]
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "Part MI", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part
                )
                base.NewPTModel(tree, "part1", "/home/demo/FrontPart.CATPart", part_file_attr)

                # Create an instance to the previously created part
                pos_matrix_instance = [[1, 0, 0], [0, -1, 0], [0, 0, 1], [0, 0, 0]]
                child_identifier += 1
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_instance
                )
                # Add a PID offset of 100 to the new instance
                base.SetPTInstancePidOffset(tree, child_identifier, 100)

                # Create a new tailorblanked part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "3.4"]]
                part_file_attr = [
                    ["PID", 2000],
                    ["Property Name", "Front TB Part"],
                    ["Material", "ES220"],
                ]
                base.NewPTPart(tree, "part2", "MID 2", "Version AB", "Part TB", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part2", parent_identifier, pos_matrix_part
                )
                # Add the first CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/FrontTBPart.CATPart", part_file_attr)

                part_file_attr = [
                    ["PID", 2001],
                    ["Property Name", "Rear TB Part"],
                    ["Material", "ES200"],
                ]
                # Add the second CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/RearTBPart.CATPart", part_file_attr)

                # Launch the editor.
                my_settings = base.InputProductTreeSettings()
                my_settings.should_open_window = True
                base.InputModelDefinition(product_tree=tree, settings=my_settings)


    """


def SetDMRoot(dm_root: str, username: str, password: str, role: str) -> int:
    """

    Sets the current DM root to the path DM_PATH.

    Parameters
    ----------
    dm_root : str
            A string that describes the path of the DM root directory.

    username : str, optional
            Username (For login in the SPDRM vault).

    password : str, optional
            Password (For login in the SPDRM vault).

    role : str, optional
            User role (For setting the user's role to SPDRM).

    Returns
    -------
    int
            Returns 1 if the new DM root has been set successfully and 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            # Ex.1
            def main():
                base.SetDMRoot("C:/Users/Local_Work_files/")


            # Ex.2: Set SPDRM vault as DM Root
            def main():
                base.SetDMRoot(
                    "http://magneto.localdomain:8080/", username="user1", password="pass1"
                )
                # when we want to change the user's role(when supported):
                base.SetDMRoot(
                    "http://magneto.localdomain:8080/",
                    username="user1",
                    password="pass1",
                    role="Administrator",
                )


    """


def SetPTInstancePidOffset(tree: object, child_identifier: Any, pid_offset: int) -> int:
    """

    Defines PID offset to an existing Product Tree Instance.

    Parameters
    ----------
    tree : object
            The object returned from a previous call to the 'NewProductTree' function.

    child_identifier : Any
            (string/integer) The unique id of an already defined part item.

    pid_offset : int
            The offset value of the PID for the specific instance. It can be
            a positive or negative integer. This information will be passed to
            the ANSAPART created upon confirmation.

    Returns
    -------
    int
            Returns 0 on success and -1 on failure.

    See Also
    --------
    base.InputModelDefinition

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                # Create the product tree
                tree = base.NewProductTree()

                # Create a group
                pos_matrix_group = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = 0  # no parent for the top level group
                child_identifier = 1
                base.NewPTPart(tree, "group", "MID A", "Version A", "Top Level Group")
                base.NewPTInstance(
                    tree, child_identifier, "group", parent_identifier, pos_matrix_group
                )

                # Create a part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = child_identifier  # the part belongs to the previous group
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "1.5"]]
                part_file_attr = [
                    ["PID", 1000],
                    ["Property Name", "Front Part"],
                    ["Material", "ES200"],
                ]
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "Part MI", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part
                )
                base.NewPTModel(tree, "part1", "/home/demo/FrontPart.CATPart", part_file_attr)

                # Create an instance to the previously created part
                pos_matrix_instance = [[1, 0, 0], [0, -1, 0], [0, 0, 1], [0, 0, 0]]
                child_identifier += 1
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_instance
                )
                # Add a PID offset of 100 to the new instance
                base.SetPTInstancePidOffset(tree, child_identifier, 100)

                # Create a new tailorblanked part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                child_identifier += 1
                part_attr = [["Mesh Type", "Fine"], ["Target Mass", "3.4"]]
                part_file_attr = [
                    ["PID", 2000],
                    ["Property Name", "Front TB Part"],
                    ["Material", "ES220"],
                ]
                base.NewPTPart(tree, "part2", "MID 2", "Version AB", "Part TB", part_attr)
                base.NewPTInstance(
                    tree, child_identifier, "part2", parent_identifier, pos_matrix_part
                )
                # Add the first CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/FrontTBPart.CATPart", part_file_attr)

                part_file_attr = [
                    ["PID", 2001],
                    ["Property Name", "Rear TB Part"],
                    ["Material", "ES200"],
                ]
                # Add the second CAD file to the TB part
                base.NewPTModel(tree, "part2", "/home/demo/RearTBPart.CATPart", part_file_attr)

                # Launch the editor.
                my_settings = base.InputProductTreeSettings()
                my_settings.should_open_window = True
                base.InputModelDefinition(product_tree=tree, settings=my_settings)


    """


def LoadProductTreeStatus(tree: object, status_name: str, color_name: str) -> int:
    """

    Loads a user defined status that can be shown in Tree Editor under the column "Status".
    A new status is defined with a name and a color.
    After loading a user defined status use the function SetPTPartStatus in order to mark this part with this status.

    Parameters
    ----------
    tree : object
            The element returned from a previous call to the 'NewProductTree' function.

    status_name : str
            The uique name of the new status.

    color_name : str
            The color index of the new status. Currently, accepted values are:
            "white", "green", "gray", "red", "orange", "blue", "magenta", "yellow".

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                tree = base.NewProductTree()

                # Load here user defined status
                base.LoadProductTreeStatus(tree, "My Orange Flag", "orange")
                base.LoadProductTreeStatus(tree, "My Blue Flag", "blue")

                # Create a group
                pos_matrix_group = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = 0  # has no parent
                child_identifier = 1
                group1_id = child_identifier
                base.NewPTPart(tree, "group1", "MID A", "Version A", "My Group 1")
                base.NewPTInstance(
                    tree, child_identifier, "group1", parent_identifier, pos_matrix_group
                )
                base.SetPTPartStatus(tree, "group1", "My Orange Flag")

                # Create a part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = group1_id  # the part belongs to the previous group
                child_identifier += 1
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "My Part 1")
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part
                )
                base.NewPTModel(tree, "part1", "/../../test.CATPart")
                base.SetPTPartStatus(tree, "part1", "My Blue Flag")

                res = base.EditProductTree(tree, "")


    """


def SetPTPartStatus(tree: object, part_identifier: Any, status: str) -> int:
    """

    Marks a part (created with NewPTPart) with a user defined status (created with LoadProductTreeStatus).
    When opening the Tree Editor the column "Status" will be show the set status for this part.

    Parameters
    ----------
    tree : object
            The element returned from a previous call to 'NewProductTree' function.

    part_identifier : Any
            (string/integer) The unique id that characterizes a product tree structure item.

    status : str
            The unique name of the loaded user defined status.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                tree = base.NewProductTree()

                # Load here user defined status
                base.LoadProductTreeStatus(tree, "My Orange Flag", "orange")
                base.LoadProductTreeStatus(tree, "My Blue Flag", "blue")

                # Create a group
                pos_matrix_group = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = 0  # has no parent
                child_identifier = 1
                group1_id = child_identifier
                base.NewPTPart(tree, "group1", "MID A", "Version A", "My Group 1")
                base.NewPTInstance(
                    tree, child_identifier, "group1", parent_identifier, pos_matrix_group
                )
                base.SetPTPartStatus(tree, "group1", "My Orange Flag")

                # Create a part
                pos_matrix_part = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]]
                parent_identifier = group1_id  # the part belongs to the previous group
                child_identifier += 1
                base.NewPTPart(tree, "part1", "MID 1", "Version AA", "My Part 1")
                base.NewPTInstance(
                    tree, child_identifier, "part1", parent_identifier, pos_matrix_part
                )
                base.NewPTModel(tree, "part1", "/../../test.CATPart")
                base.SetPTPartStatus(tree, "part1", "My Blue Flag")

                res = base.EditProductTree(tree, "")


    """


def ResolveFilePathAliases(path: str) -> str:
    """

    Resolves any directory aliases used in "path" like DM or Include Path aliases.

    Parameters
    ----------
    path : str
            The path to be resolved

    Returns
    -------
    str
            Returns a path with the aliases expanded (replaced with their value), or the same path if no aliases exist.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                entity = base.GetEntity(constants.NASTRAN, "INCLUDE", 5)
                ret = base.GetEntityCardValues(constants.NASTRAN, entity, ("FullPathName"))
                include_fname = ret["FullPathName"]
                resolved_fname = base.ResolveFilePathAliases(include_fname)
                print("resolved (unaliased) filename: ", resolved_fname)


    """


def IsDMRootConnectionValid(dm_root: str, reconnect: bool) -> int:
    """

    The function is used to check if the connection to the url-based DM root is actually valid.
    If no arguments are given, the current DM is checked.
    If a "dm_root" argument pair is given, then that url will be checked.

    Parameters
    ----------
    dm_root : str, optional
            When this argument is given, then that url will be checked.

    reconnect : bool, optional
            Set to True, if you automatically wish to try and reconnect if the connection is invalid.

    Returns
    -------
    int
            Returns 1 if the connection is valid, or 0 if it is invalid or no DM root has been defined.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                if base.IsDMRootConnectionValid():
                    print("Connection to current DM is valid.")
                else:
                    print("Connection to current DM is lost.")
                # OR:
                if base.IsDMRootConnectionValid(dm_root="http://ektoras:8080/"):
                    print("Connection to http://ektoras:8080/ is valid.")
                else:
                    print("Connection to http://ektoras:8080/ is lost.")


    """


def RemoveDMRoot(dm_root: str) -> int:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`RemoveRoot` instead.


    Removes the specified DM path or url from the "Set DM Paths" window list.

    Parameters
    ----------
    dm_root : str
            The path to the DM to remove.

    Returns
    -------
    int
            Returns 1 if the specified DM root has been removed successfully and 0 otherwise.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                base.RemoveDMRoot("C:/Users/Local_Work_files/")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: RemoveRoot instead.",
        DeprecationWarning,
    )


def AddFileInDM(
    file_name: str,
    type: str,
    attributes: object,
    server_id: str,
    dm_root: str,
    target_dm_root: str,
    add_attachments: bool,
    add_component_children: bool,
) -> int:
    """

    Adds a file in the current DM.

    Parameters
    ----------
    file_name : str
            The file path of the file to be added in DM.

    type : str
            Accepted values: 'parts', 'includes', 'Subsystems'.
            For parts an .ansa file must be provided.

    attributes : object
            A dictionary with the key DM attributes of the file.
            The module id, version, study version, file type and representation
            must be provided. The names of the attributes must be
            provided as they appear in Part Manager and DM Browser.

    server_id : str, optional
            Instead of the file, a server id from a source dm root can be
            provided as source. 'file_name' and 'server_id' are mutually
            exclusive arguments.

    dm_root : str, optional
            The  dm root server_id refers to. if not provided, the current dm is assumed.
            This option is used only if server_id is provided.

    target_dm_root : str, optional
            The dm root where the file will be added. If not provided, the current dm
            root is assumed. This option is used only if server_id is provided.

    add_attachments : bool, optional
            Default: false. If true, any attachments of the server_id will also
            be added in dm. This option is used only if server_id is provided.

    add_component_children : bool, optional
            This option is used only if the server_id of a Subsystem is provided.
            If True: the parts of the subsystem will also be added in target dm.
            (Default: False)

    Returns
    -------
    int
            The function returns an integer:
                    0: Success.
                    1: Add in DM failed.
                    2: Invalid dm root.
                    3: Invalid input type.
                    4: Incomplete input dictionary.
                    5: Conflict between the input dictionary and the values in the provided file.
                    6: The file has not been produced with Save Representation.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dict1 = {}
                dict1["Module Id"] = "23"
                dict1["Version"] = "0"
                dict1["Study Version"] = "0"
                dict1["Representation"] = ""  # empty for common representation
                dict1["File Type"] = "ANSA"

                ret = base.AddFileInDM("/home/user/my_file.ansa", "parts", dict1)


    """


def GetDMRootsList() -> object:
    """

    Returns the whole DM Roots list, with all the info about which DM is current or
    is enabled for "Check DM Updates".

    Returns
    -------
    object
            Returns None in case no DM paths found or a list of dictionaries containing the information of each DM Root.
            The keys in each dictionary are shown in the following example:

            [{'updates_enabled': True, 'is_current': True, 'dm_root': '//mnt/DM1/'},
             {'updates_enabled': True, 'is_current': False, 'dm_root': '//mnt/DM2/'},
             {'updates_enabled': False, 'is_current': False, 'dm_root': 'http://dm3:8989/'}]

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                print(base.GetDMRootsList())


    """


def AddDMObject(type: str, names_values: object, overwrite: bool, link: bool) -> str:
    """
    .. deprecated:: 19.0.0
            Use `DMObject.add_new` instead.


    This function adds an object to the DM, if it does not already exist.

    Parameters
    ----------
    type : str
            The type of the object to be added.

    names_values : object
            A dictionary which holds the object's property and attribute values.

    overwrite : bool, optional
            Set to True if the object should be overwritten, if it already exists in the DM.

    link : bool, optional
            Set to True if you wish create a link to the file that corresponds to the object.

    Returns
    -------
    str
            Returns the server id, as a string, on success, or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                # Adds a component to the DM

                # All properties MUST be present in the object's names_values dictionaries
                names_values = {}
                names_values["Module Id"] = "Module1"
                names_values["Version"] = "Version1"
                names_values["Study Version"] = "Study1"
                names_values["Representation"] = "Representation1"
                names_values["Name"] = "Name1"  # Attribute

                component_server_id = base.AddDMObject("Component", names_values)

                if component_server_id:
                    print("Component server_id: " + component_server_id)
                else:
                    print("AddDMObject failed.")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 19.0.0. Use  DMObject.add_new instead.",
        DeprecationWarning,
    )


def GetDMObjectAttributeValues(
    type: str, names_values: object, server_id: str, attributes: object
) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`DMObject` instead.


    This function can return some specified Attribute values of a dm object. The
    object can be identified by either its server is, or its property values.

    Parameters
    ----------
    type : str
            The type of the object (required, if the names_values argument is present).

    names_values : object, optional
            A dictionary which holds the object's property values
            (all property values must be present for the object's identification).

    server_id : str, optional
            The server id of the object, if it is already known.
            If present, the type and names_values arguments can be omitted.

    attributes : object, optional
            A list in which the user can specify Attribute names, for their values to be returned.
            If this arguments is not present, all the object's values will be returned.

    Returns
    -------
    object
            If the object was found, a dictionary will be returned with the specified attribute values.
            If the function fails, "None" will be returned.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                property_values = {}
                property_values["Name"] = "MyName"
                property_values["Version"] = "A"
                print(
                    base.GetDMObjectAttributeValues(
                        "Simulation_Model", names_values=property_values, attributes=["SM_Attr"]
                    )
                )

                # if the server id of this simulation model was already known to be "5472", the function could be called like this:
                print(base.GetDMObjectAttributeValues("Simulation_Model", server_id="5472"))
                # or if we are just looking for a specific Attribtue:
                print(
                    base.GetDMObjectAttributeValues(
                        "Simulation_Model", server_id="5472", attributes=["Last_Edit"]
                    )
                )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: DMObject instead.",
        DeprecationWarning,
    )


def SetDMObjectAttributeValues(
    type: str,
    names_values: dict,
    server_id: str,
    attribute_names_values: dict,
    attribute_names_types: dict,
) -> bool:
    """
    .. deprecated:: 19.0.0
            Use :py:class:`DMObject` instead.


    This function can change Attribute values for a dm object. If an Attribute
    doesn't exist, then this function can also trigger its creation.
    The object can be identified by either its server id, or its property values.

    Parameters
    ----------
    type : str
            The type of the object (required, if the names_values argument is present).

    names_values : dict, optional
            A dictionary which holds the object's property values
            (all property values must be present for the object's identification).

    server_id : str, optional
            The server id of the object, if it is already known.
            If present, the type and names_values arguments can be omitted.

    attribute_names_values : dict, optional
            A dictionary which specifies the Attributes to change, in a names-values format.

    attribute_names_types : dict, optional
            A dictionary mapping Attribute names to types. This information will be used
            in case new Attributes will be created and the DM supports typed Attributes.

    Returns
    -------
    bool
            True : If the at least one values was set successfully.
            False: If the function failed to set any value.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                all_values = {}
                all_values["Name"] = "MyName"
                all_values["Version"] = "A"
                all_values["SM_Attr"] = "SM_Attr_Value"  # Attribute
                base.AddDMObject("Simulation_Model", all_values)

                property_values = {}
                property_values["Name"] = "MyName"
                property_values["Version"] = "A"

                base.SetDMObjectAttributeValues(
                    "Simulation_Model",
                    names_values=property_values,
                    attribute_names_values={"SM_Attr": "New_Val"},
                )
                # if the server id of this simulation model was already known to be "1", the function could be called like this:
                # base.GetDMObjectAttributeValues("Simulation_Model", ref_server_id="1", attribute_names_values={"SM_Attr":"New_Val"})

                print(
                    base.GetDMObjectAttributeValues(
                        "Simulation_Model", names_values=property_values, attributes=["SM_Attr"]
                    )
                )


    """

    import warnings

    warnings.warn(
        "Deprecated since version 19.0.0. Use :py:class: DMObject instead.",
        DeprecationWarning,
    )


def ConnectDMObjectToDMObjects(server_id: str, references: object) -> bool:
    """

    This function connects dm objects, by referencing. After its execution,
    the object whose server_id is given as argument, will reference
    the objects specified in the "references" dict.

    Parameters
    ----------
    server_id : str
            If the server id of the first object is known, the type and names_values arguments can be ommited.

    references : object
            A dictionary which holds server_id->reference-type pairs.

    Returns
    -------
    bool
            True:  If the new references were made successfully.
            False: If the function failed to make one of the connections.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                dict1 = {}
                dict1["Name"] = "MyName"
                dict1["Version"] = "A"
                dict1["SM_Attr"] = "SM_Attr_Value"  # Attribute
                sim_model_server_id = base.AddDMObject("Simulation_Model", dict1)

                dict2 = {}
                dict2["Module Id"] = "Module1"
                dict2["Version"] = "Version1"
                dict2["Study Version"] = "Study1"
                dict2["Representation"] = "Representation1"
                dict2["Variant"] = "Variant1"
                dict2["Name"] = "Name1"  # Attribute
                comp_server_id = base.AddDMObject("Component", dict2)

                print(
                    base.ConnectDMObjectToDMObjects(
                        sim_model_server_id, {comp_server_id: "my_component"}
                    )
                )


    """


def GetComponentsAllValues(server_id: str, server_ids: object, type: str) -> object:
    """
    .. deprecated:: 16.2.0
            Use :py:func:`GetDMObjectAllValues` instead.


    Deprecated: use ansa.base.GetDMObjectAllValues instead!!

    When connected to a DM, this function returns all the Properties and Attributes
    for a DM Object in the form of a dictionary.

    Parameters
    ----------
    server_id : str, optional
            The DM Object's server id.

    server_ids : object, optional
            A list with DM Object server ids.

    type : str, optional
            If the DM Object's type is known, use this argument to define it.
            Otherwise, the function will try to find the type itself.

    Returns
    -------
    object
            A list with dictionaries for each DM Object that is actually found in DM.

    See Also
    --------
    base.GetDMObjectAllValues

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                list_of_names_values = base.GetComponentsAllValues(
                    server_id="294", type="Subsystem"
                )
                for names_values in list_of_names_values:
                    print(names_values)
                list_of_server_ids = []
                list_of_server_ids.append("56875")
                list_of_server_ids.append("56867")
                list_of_names_values = base.GetComponentsAllValues(server_ids=list_of_server_ids)
                for names_values in list_of_names_values:
                    print(names_values)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 16.2.0. Use :py:func: GetDMObjectAllValues instead.",
        DeprecationWarning,
    )


def GetDMObjectAllValues(server_id: str, server_ids: object, type: str) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`DMObject` instead.


    When connected to a DM, this function returns all the Properties and Attributes
    for a DM Object in the form of a dictionary.

    Parameters
    ----------
    server_id : str, optional
            The DM Object's server id.

    server_ids : object, optional
            A list with DM Object server ids.

    type : str, optional
            If the DM Object's type is known, use this argument to define it.
            Otherwise, the function will try to find the type itself.

    Returns
    -------
    object
            A list with dictionaries for each DM Object that is actually found in DM.

    See Also
    --------
    base.GetAllAttrsFromUniqueRepresentations

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                list_of_names_values = base.GetDMObjectAllValues(server_id="294", type="Subsystem")
                for names_values in list_of_names_values:
                    print(names_values)
                list_of_server_ids = []
                list_of_server_ids.append("56875")
                list_of_server_ids.append("56867")
                list_of_names_values = base.GetDMObjectAllValues(server_ids=list_of_server_ids)
                for names_values in list_of_names_values:
                    print(names_values)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: DMObject instead.",
        DeprecationWarning,
    )


def GetAvailableLibraryItemsInDM(folder_name: str, search_for: str) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`GetAvailableLibraryItems` instead.


    This function can be used to get a list with all the items in a library in DM,
    e.g. all "batch_mesh_sessions" or specific "batch_mesh_sessions" that match a
    search pattern.

    Parameters
    ----------
    folder_name : str
            The library's name.

    search_for : str, optional
            This can be a search pattern that will be used for the query.

    Returns
    -------
    object
            Returns a list with all the library item names.

    See Also
    --------
    dm.DownloadLibraryItem

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                results = base.GetAvailableLibraryItemsInDM(
                    "batch_mesh_sessions", search_for="*.ansa"
                )
                if results:
                    for result in results:
                        print("Found batch_mesh_session: ", result)
                all_results = base.GetAvailableLibraryItemsInDM("batch_mesh_sessions")
                if all_results:
                    for result in all_results:
                        print("Found batch_mesh_session: ", result)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: GetAvailableLibraryItems instead.",
        DeprecationWarning,
    )


def GetDMObjectId(type: str, names_values: object) -> str:
    """

    Search in DM for a DM Object with specific properties and return its server id.
    The specified properties should describe a unique DM Object. If none or more than
    one DM Object are defined from the specified properties, None is returned.

    Parameters
    ----------
    type : str
            the type of the DM Object as it is defined in the dm_structure.xml
            (e.g. 'parts', includes', 'Subsystem', etc.).

    names_values : object
            a {'Property':'Value'} dictionary which describes a unique DM Object.

    Returns
    -------
    str
            Returns the server id of the DM Object on success and None on failure.

    See Also
    --------
    ExportDMObjectHierarchy, ExportDMObject, DeleteDMObject, SetDMObjectAttributeValues, GetDMObjectAttributeValues, ConnectDMObjectToDMObjects, dm.CheckForUpdates

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = {"Module Id": "100", "Version": "0", "Representation": "common"}
                ret = base.GetDMObjectId("parts", vals)
                if ret:
                    print(ret)


            if __name__ == "__main__":
                main()


    """


def SetAttributeValueString(
    names_values: object,
    type: str,
    server_id: str,
    attribute_name: str,
    attribute_value: str,
) -> bool:
    """

    This function can be used to set an attribute value to a DM Object.

    Parameters
    ----------
    names_values : object, optional
            A dictionary defining the DM Object. When the server_id argument isn't given,
            the function will search for the DM Object using this set of Properties/Values.

    type : str, optional
            The DM Object's type.
            Although it's an optional argument, it needs to be defined.

    server_id : str, optional
            The DM Object's server id. It can be used if already known.

    attribute_name : str, optional
            The Attribute's name.
            Although it's an optional argument, it needs to be defined.

    attribute_value : str, optional
            The value that will be set to the Attribute.
            Although it's an optional argument, it needs to be defined.

    Returns
    -------
    bool

    See Also
    --------
    ExportDMObjectHierarchy, ExportDMObject, DeleteDMObject, GetDMObjectId, SetDMObjectAttributeValues, GetDMObjectAttributeValues, ConnectDMObjectToDMObjects

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = {"Project": "L1", "Discipline": "Crash"}
                ret = base.GetDMObjectId("parts", vals)
                if ret:
                    base.SetAttributeValueString(
                        server_id=ret, type="parts", attribute_name="Big_part", attribute_value="NO"
                    )


    """


def ExportDMObjectHierarchy(
    output_directory: str, names_values: object, type: str, server_id: str
) -> str:
    """
    .. deprecated:: 17.0.0
            Use :py:class:`DMObject` instead.


    When a DM Object can be defined by a DM Object hierarchy, e.g. a Subsystem,
    use this function to download the hierarchy and afterwards read it into ANSA.

    Parameters
    ----------
    output_directory : str
            Specifies where the xml will be downloaded.

    names_values : object, optional
            A dictionary defining the DM Object. When the server_id argument isn't given,
            the function will search for the DM Object using this set of Properties/Values.

    type : str, optional
            The DM Object's type.
            Although it's an optional argument, it needs to be defined when the
            names_values argument is used.

    server_id : str, optional
            The DM Object's server id. It can be used if already known.

    Returns
    -------
    str
            Returns the resulting directory on success.

    See Also
    --------
    ExportDMObject, DeleteDMObject, GetDMObjectId

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = {"Project": "L1", "Discipline": "Crash"}
                ret = ansa.base.GetDMObjectId("parts", vals)
                print(ret)
                if ret:
                    base.ExportDMObjectHierarchy("C:/home/demo/tmp", server_id=ret)


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: DMObject instead.",
        DeprecationWarning,
    )


def ExportDMObject(
    output_directory: str, names_values: object, type: str, server_id: str, action: str
) -> str:
    """

    This function can be used to download a DM Object's Representation File from DM.

    Parameters
    ----------
    output_directory : str
            Specify where the file/files will be downloaded.

    names_values : object, optional
            A dictionary defining the DM Object. When the server_id argument isn't given,
            the function will search for the DM Object using this set of Properties/Values.

    type : str, optional
            The DM Object's type.
            Although it's an optional argument, it needs to be defined when
            the names_values argument is used.

    server_id : str, optional
            The DM Object's server id. It can be used if already known.

    action : str, optional
            The exported file from the server will be copied to the target directory by default.
            It is possible to create a hard link in the target directory when this argument has the value "link" and the output_folder is relative to the NodeExec directory.
            Note that this is only possible when connected to a SPDRM DM and the application is launched through a Process Node and works for Subsystems, parts, Rich Library Items and Library Files.

    Returns
    -------
    str
            Returns the resulting directory on success.

    See Also
    --------
    ExportDMObjectHierarchy, DeleteDMObject, GetDMObjectId

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = {"Project": "L1", "Discipline": "Crash"}
                ret = base.GetDMObjectId("parts", vals)
                print(ret)
                if ret:
                    base.ExportDMObject("C:/home/demo/tmp", server_id=ret)


    """


def DeleteDMObject(
    names_values: object, type: str, server_id: str, only_representation_file: str
) -> int:
    """
    .. deprecated:: 19.0.0
            Use :py:class:`DMObject` instead.


    Deletes an Object from DM using this function.

    Parameters
    ----------
    names_values : object, optional
            A dictionary defining the DM Object.
            When the server_id argument isn't given, the function will search
            for the DM Object using this set of Properties/Values.

    type : str, optional
            The DM Object's type.
            Although it's an optional argument, it needs to be defined when the
            names_values argument is used.

    server_id : str, optional
            The DM Object's server id. It can be used if already known.

    only_representation_file : str, optional
            Use "YES" when only the Representation File should be deleted and the
            Object should be kept in the database.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    See Also
    --------
    ExportDMObject, ExportDMObjectHierarchy, GetDMObjectId

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = {"Project": "L1", "Discipline": "Crash"}
                ret = base.GetDMObjectId("Subsystems", vals)
                print(ret)
                if ret:
                    base.DeleteDMObject(server_id=ret, type="Subsystems")


    """

    import warnings

    warnings.warn(
        "Deprecated since version 19.0.0. Use :py:class: DMObject instead.",
        DeprecationWarning,
    )


def GetAllAttrsFromUniqueRepresentations(
    server_id: str,
    server_ids: object,
    type: str,
    values: object,
    ask_sdm: bool,
    object_id: str,
    object_ids: object,
) -> object:
    """
    .. deprecated:: 17.0.0
            Use :py:func:`GetAttributesFromUniqueRepresentations` instead.


    This function will return all Properties/Attributes for a specific input,
    either server ids, a filter or a DM Browser window item.

    Parameters
    ----------
    server_id : str, optional
            The server id of the object, if it is already known.
            When specified, it will be used to query DM.

    server_ids : object, optional
            A list with server ids. When specified, it will be used to query DM.

    type : str, optional
            The type of the object (required, even though it's optional).

    values : object, optional
            A dictionary which holds a filter (names - values)
            that will be used when no server ids or object ids are defined.

    ask_sdm : bool, optional
            In case of SDM CONSOLE, we can query the already downloaded values
            instead of querying DM.
            It should be used in cases where the query is expected to be very slow.

    object_id : str, optional
            When this function is called through an action in DM Browser or SDM CONSOLE,
            object_id is the GUI item's id. It can be used when we don't know the server_id.

    object_ids : object, optional
            A list with object ids, as described above.

    Returns
    -------
    object
            Returns a list with dictionaries, with the specified attribute values.
            If the function fails, the list will be empty.

    See Also
    --------
    GetDMObjectAllValues

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                vals = {"Project": "L1", "Discipline": "Crash"}
                ret = base.GetDMObjectId("parts", vals)
                if ret:
                    list_of_dicts = base.GetAllAttrsFromUniqueRepresentations(
                        server_id=ret, type="parts"
                    )
                    len_of_list_of_dicts = len(list_of_dicts)
                    for each_dict in list_of_dicts:
                        print("Representation: ", each_dict["Representation"])


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:func: GetAttributesFromUniqueRepresentations instead.",
        DeprecationWarning,
    )


def BCSettingsGetUserDefinedValue(keyword: str):
    """

    Returns the string value of user defined keyword with name keyword
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup.

    See Also
    --------
    BCSettingsSetUserDefinedValue

    """


def BCSettingsSetUserDefinedValue(keyword: str, value: str):
    """

    Sets value value to user defined keyword keyword.
    If keyword a\ keyword doesn't exist it will be created.
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup and set the new value.

    value : str
            the new string value of the keyword

    See Also
    --------
    BCSettingsGetUserDefinedValue

    """


def BCSettingsUserDefinedKeywordExists(name: str):
    """

    Checks if a user defined key with name name exists in BCSettingsHandler structure
    It will only search for a keyword not for a value.
    This function is not supported under VR mode.

    Parameters
    ----------
    name : str
            the keyword's name to look up.

    See Also
    --------
    BCSettingsSetUserDefinedValue

    """


def BCSettingsReadFile(filePath: str) -> int:
    """

    Reads a defaults file, from path filePath.

    Settings that will be read from the file, will be applied
    to the running application.
    This function is not supported under VR mode.

    Parameters
    ----------
    filePath : str
            The path of the defaults file.

    Returns
    -------
    int
            1 if reading was succesfull, 0 otherwise.

    See Also
    --------
    BCSettingsWriteGroup

    """


def BCSettingsWriteFile(filePath: str) -> int:
    """

    Writes a defaults file, at path filePath. If a filePath is not given,
    \the defaults file will be written in .BETA folder according to which
    \layout ANSA was launched (e.g. ANSA.defaults, CFD.defaults)
    If the file already exists, it will be overwritten.
    This function is not supported under VR mode.

    Parameters
    ----------
    filePath : str, optional
            the path where the defaults file will be written.

    Returns
    -------
    int
            1 if save was succesfull, 0 otherwise.

    See Also
    --------
    BCSettingsWriteGroup

    """


def BCSettingsWriteGroup(filePath: str, groupName: str) -> int:
    """

    Writes the settings of Group named groupName, at path filePath.
    \If filePath is empty, the group will be written in defaults file located in .BETA folder
    \according to which layout ANSA was launched (e.g. ANSA.defaults, CFD.defaults)
    If file already exists, then the settings of the corresponding group will be updated.
    The rest of the file will remain intact.
    This function is not supported under VR mode.

    Parameters
    ----------
    filePath : str
            the path where the defaults file will be written.

    groupName : str
            the group name, to write.

    Returns
    -------
    int
            1 if save was succesfull, 0 otherwise.

    See Also
    --------
    BCSettingsWriteFile

    """


def ExportDMObjectSubHierarchy():
    """
    .. deprecated:: 17.0.0
            Use :py:class:`DMObject` instead.


    """

    import warnings

    warnings.warn(
        "Deprecated since version 17.0.0. Use :py:class: DMObject instead.",
        DeprecationWarning,
    )


def InputModelDefinition(
    file_name: str, file_type: str, product_tree: object, settings: object
) -> int:
    """

    Imports a model definition in ANSA.

    Parameters
    ----------
    file_name : str, optional
            The name of the file to import. It can be an empty string.
            In this case, the file manager opens to select a file.

    file_type : str, optional
            The type of the file to open.
            Valid types are: "VPM", "PLMXML", "CATProduct", "AP242", "STEP", "ProE", "JT", "NX", "3DXML", "Solidworks".

    product_tree : object, optional
            A product tree created from script with the function base.NewProductTree().

    settings : object, optional
            An object of type "base.InputProductTreeSettings()" for defining the settings
            when reading the file.

    Returns
    -------
    int
            Returns 1 on success, 0 on failure.

    See Also
    --------
    base.InputProductTreeSettings, base.ProductTree

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                my_settings = base.InputProductTreeSettings()
                my_settings.post_actions_script_function = "MyFun"
                my_settings.post_actions_script_path = "//home/post_actions_script.py"
                my_settings.should_open_window = True

                filename = "//home/file.xml"

                base.InputModelDefinition(
                    file_name=filename, file_type="PLMXML", settings=my_settings
                )


            # example of post_actions_script.py:
            def MyFun(product_tree, *args, **kwargs):
                all_part_ids = product_tree.get_all_part_ids()

                print("Total number of parts in product_tree: " + str(len(all_part_ids)))

                for part_id in all_part_ids:
                    name = product_tree.get_part_attribute_value(part_id, "Name")
                    module_id = product_tree.get_part_attribute_value(part_id, "Module Id")
                    version = product_tree.get_part_attribute_value(part_id, "Version")
                    is_group = product_tree.get_part_attribute_value(part_id, "Is Group")
                    print("----------------------------------------------------------------")
                    print("Part with id: " + part_id)
                    print("   Name: " + name)
                    print("   Module Id: " + module_id)
                    print("   Version: " + version)
                    print("   Is Group: " + is_group)
                    print(
                        "   All Attributes: "
                        + str(product_tree.get_all_part_attribute_values(part_id))
                    )
                    print("----------------------------------------------------------------")

                    # fix empty versions:
                    if version == "A":
                        product_tree.set_part_attribute_value(part_id, "Version", "test")
                        print("Changed Version to Part with id: " + part_id)
                    # totally remove some parts:
                    if "SCREW" in name:
                        product_tree.remove_part(part_id)
                        print("Removed Part with id :" + part_id)


    """


def BCSettingsGetDefaultValue(keyword: str):
    """

    Returns the default value of keyword with name keyword as string
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup.

    See Also
    --------
    BCSettingsGetStartupValue

    """


def BCSettingsGetStartupValue(keyword: str):
    """

    Returns the startup value of keyword with name keyword as string
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup.

    See Also
    --------
    BCSettingsGetDefaultValue

    """


def BCSettingsGetValues(fields: object) -> object:
    """

    This function returns the values of any keyword supported by .defaults file(s).

    Parameters
    ----------
    fields : object
            A tuple of keywords, supported by the .default file(s), whose values will be retrieved.

    Returns
    -------
    object
            On success it returns a dictionary where the keys are the .defaults keywords,
            provided as arguments, and the values are their current application values.
            On failure it returns None.
            NOTE: A value can be either a single string or a list of strings, if the keyword supports multiple instances, i.e. can be set more than once.

    Examples
    --------
    ::

            import ansa
            from ansa import base

            ret = base.BCSettingsGetValues(
                (
                    "Perimeter Corner Angle",
                    "BeforeCompareScriptFunctionName",
                    "free_generator",
                    "NAS_MAT_DBASE",
                    "CalcThickness_target_selection_mode",
                )
            )
            print("Perimeter Corner Angle  is: ", ret["Perimeter Corner Angle"])


    """


def BCSettingsSetValues(fields: object) -> int:
    """

    This function changes values supported by the .defaults file(s) (settings).

    Parameters
    ----------
    fields : object
            A dictionary with keys any valid keyword supported by the .defaults file(s) and values a single string or a list of string values.

    Returns
    -------
    int
            Returns 0 on success and 1 on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import base

            base.BCSettingsSetValues(
                {
                    "Perimeter Corner Angle": "35.0",
                    "BeforeCompareScriptFunctionName": "testFunctionName",
                    "free_generator": "true, 1",
                    "NAS_MAT_DBASE": ["my_path1", "my_path2"],
                    "CalcThickness_target_selection_mode": "select_curves",
                }
            )


    """


def AddDOEStudy(
    names_values: object,
    design_variables: object,
    responses: object,
    experiments_object_ids: object,
) -> str:
    """

    This function adds a DOE_Study object to the DM.

    Parameters
    ----------
    names_values : object
            A dictionary which holds the object's property and attribute values.

    design_variables : object, optional
            A dictionary with key the experiment id and value another dictionary which holds the design variables as name-value pairs.

    responses : object, optional
            A dictionary with key the experiment id and value another dictionary which holds the responses as name-value pairs.

    experiments_object_ids : object, optional
            A dictionary which holds the experiments server ids in DM.

    Returns
    -------
    str
            Returns the server id, as a string, on success, or None on failure.

    Examples
    --------
    ::

            import ansa
            from ansa import dm


            def main():
                dvs = {"1": {"Thickness": "1.2"}, "2": {"Thickness": "1.3"}}
                resps = {"1": {"Displacement": "2.5"}, "2": {"Displacement": "1.2"}}
                attributes = {"Optimization Task Name": "My_task"}

                server_id = dm.AddDOEStudy(
                    names_values=attributes, design_variables=dvs, responses=resps
                )

                if server_id:
                    print("DOE_Study server_id: " + server_id)
                else:
                    print("AddDOEStudy failed.")


    """


class InputProductTreeSettings:
    """

    InputProductTreeSettings is a module for defining the Product Tree Editor settings when importing a model definition with ansa.base.InputModelDefinition.

    See Also
    --------
    base.InputModelDefinition, base.ProductTree, base.GetCurrentInputProductTreeSettings

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                my_settings = base.InputProductTreeSettings()
                my_settings.post_actions_script_function = "MyFun"
                my_settings.post_actions_script_path = "//home/post_actions_script.py"
                my_settings.should_open_window = True

                filename = "//home/file.xml"

                base.InputModelDefinition(
                    file_name=filename, file_type="PLMXML", settings=my_settings
                )


            # example of post_actions_script.py:
            def MyFun(product_tree, *args, **kwargs):
                all_part_ids = product_tree.get_all_part_ids()

                print("Total number of parts in product_tree: " + str(len(all_part_ids)))

                for part_id in all_part_ids:
                    name = product_tree.get_part_attribute_value(part_id, "Name")
                    module_id = product_tree.get_part_attribute_value(part_id, "Module Id")
                    version = product_tree.get_part_attribute_value(part_id, "Version")
                    is_group = product_tree.get_part_attribute_value(part_id, "Is Group")
                    print("----------------------------------------------------------------")
                    print("Part with id: " + part_id)
                    print("   Name: " + name)
                    print("   Module Id: " + module_id)
                    print("   Version: " + version)
                    print("   Is Group: " + is_group)
                    print(
                        "   All Attributes: "
                        + str(product_tree.get_all_part_attribute_values(part_id))
                    )
                    print("----------------------------------------------------------------")

                    # fix empty versions:
                    if version == "A":
                        product_tree.set_part_attribute_value(part_id, "Version", "test")
                        print("Changed Version to Part with id: " + part_id)
                    # totally remove some parts:
                    if "SCREW" in name:
                        product_tree.remove_part(part_id)
                        print("Removed Part with id :" + part_id)

    """

    check_for_representations: str = None
    """
	Sets more representation names to be checked in DM, in addition to 'common'.
	For example: 'crash, nvh, dura'.
	Note that the representation 'common' will always be checked.

	"""

    relative_path: str = None
    """
	Defines the relative path that will be used for locating relative part file 
	paths that start with '.' or './'.

	"""

    directory_of_cad_files: str = None
    """
	Defines an additional directory path that will be used for locating 
	the part files.

	"""

    post_actions_script_path: str = None
    """
	Defines the path of the python file that contains the post actions 
	script function.

	"""

    post_actions_script_function: str = None
    """
	Defines a post actions script function to be applied on the input model 
	with the following prototype:
	MyFun(product_tree, *args, **kwargs),
	where product_tree is a python object of type ansa.base.ProductTree()

	"""

    use_plmxml_parser: str = None
    """
	Selects the PLMXML parser. Valid values:
	- 'Auto': ANSA will try to recognize the correct parser according to 
	  the file format (default).
	- 'Vismockup': Force using the Vismockup parser (always the ProductDef 
	  is parsed).
	- 'Teamcenter': Force using the Teamcenter parser (ProductDef or 
	  ProductView is parsed).

	"""

    read_plmxml_structure: str = None
    """
	Defines where to read the parts structure from, when parsing PLMXML files.
	Valid values:
	- 'ProductView': Read the parts structure from ProductView > Occurrence
	  (absolute transformation matrices) (default).
	- 'ProductDef': Read the parts structure from ProductDef > InstanceGraph 
	  > ProductInstance (relative transformation matrices).

	"""

    read_plmxml_attributes: str = None
    """
	Defines which attributes (UserData->UserValue) should be read when 
	parsing PLMXML files. Valid values:
	- 'None': No attribute will be read (default).
	- 'All': All attributes will be read from any xml node.
	- 'Specific': Only attributes defined in 
	  'plmxml_specific_attributes_to_read' will be read.

	"""

    plmxml_specific_attributes_to_read: str = None
    """
	Defines the attribute names that will be read when parsing PLMXML files.
	- Add attribute names with prefix (will be searched only in specific mode).
	  Example: 'Form/SubType/MyAttribute1, Occurrence/MyAttribute2, 
	  Product/MyAttribute3'.
	- Add attribute names without any prefix (will be searched in any xml node).
	  Example: 'MyAttribute1, MyAttribute2, MyAttribute3'.
	- Add only the prefix. All attributes inside these xml nodes will be read.
	  Example: 'Form/*, Form/subType/*, Occurrence/*, Product/*'.

	"""

    read_plmxml_related_properties: str = None
    """
	In  PLMXML files some relations exist where one item points to another.
	For example: <GeneralRelation relatedRefs="#id10 #id20"> where the original item is #id10 and the related #id20.
	This member defines which property values (name, part number, version) should be kept. Valid values:
	- 'Keep original'
	- 'Keep related' (default)

	"""

    read_plmxml_related_part_files: str = None
    """
	In  PLMXML files some relations exist where one item points to another.
	For example: <GeneralRelation relatedRefs="#id10 #id20"> where the original item is #id10 and the related #id20.
	This member defines which part files (e.g. jt) should be kept. Valid values:
	- 'Keep original'
	- 'Keep related' (default)
	- 'All'

	"""

    read_plmxml_related_attributes: str = None
    """
	In  PLMXML files some relations exist where one item points to another.
	For example: <GeneralRelation relatedRefs="#id10 #id20"> where the original item is #id10 and the related #id20.
	This member defines which attribute values should be kept. Valid values:
	- 'Keep original'
	- 'Keep related' (default)
	- 'All'

	"""

    part_name_convert: bool = None
    """
	If set to True, converts the part names when importing structure from 
	Product Tree Editor to ANSA. Prepends the part number and the part 
	version: PartNumber_PartVersion_PartName.
	(Default: True)

	"""

    should_open_window: bool = None
    """
	If set to True, opens the Product Tree Editor window.
	(Default: True)

	"""

    read_part_name_from_keys: str = None
    """
	Defines the exact xml keys with specific priority to read 'Name'. 
	e.g. 'name, Name'

	"""

    read_part_number_from_keys: str = None
    """
	Defines the exact xml keys with specific priority to read 'Part Number'. 
	e.g. 'part number, PartNumber'

	"""

    read_part_version_from_keys: str = None
    """
	Defines the exact xml keys with specific priority to read 'Version'.
	e.g. 'Version, version, revision'

	"""

    compress_parts: bool = None
    """
	Delete from hierarchy all parts that have no part files.
	(Default: False)

	"""

    keep_different_versions_per_part_number: bool = None
    """
	When the ANSA setting 'Allow Multi Version Parts' is not selected, use this setting to show in Product Tree Editor hierarchy parts with same Part Number and different Versions. 
	(Default: False)

	"""

    handle_jt_files_as_monolithic: bool = None
    """
	Handle the attached JT files as Monolithic JT files during CAD to AnSA translation.
	(Default: True)

	"""

    ignore_part_files_on_groups: bool = None
    """
	Remove all attached part files from groups.
	(Default: False)

	"""

    define_groups_on_empty_occurrenceRefs_value: bool = None
    """
	When parsing Teamcenter plmxmls, if the value of the occurrenceRefs field is the empty string the Occurrence will be considered a group instead of a part.
	(Default: False)

	"""

    compress_groups: bool = None
    """
	Delete from hierarchy all groups that have no parts and no part files. 
	(Default: False)

	"""

    merge_nested_plmxml_files: bool = None
    """
	Merge all nested plmxml files into the main structure.
	(Default: False)

	"""

    should_open_window_in_central_tab: bool = None
    """
	If set to True, opens the window in a tab of the central area of KOMVOS.
	(Default: False) This member is valid only in KOMVOS.

	"""


def ReplaceShellReinforcements(
    entities: list,
    proposed_paths_mode: str = "With distortion angle",
    angle: float = 5.0,
    radius: float = 0.0,
    delete_entities: bool = False,
) -> list:
    """

    Creates beam elements that can replace shell reinforcements.

    Parameters
    ----------
    entities : list
            A list of the shell elements that describe the reinforcements.

    proposed_paths_mode : str, optional
            The mode that will be used for the extraction of the proposed path.
            The beam elements are created on the proposed path.
            Accepted values: "Auto", "With distortion angle".

    angle : float, optional
            The distortion angle (in degrees) used for the extraction of the proposed path.
            Applicable only in "With distortion angle" mode.

    radius : float, optional
            Limits the reinforcement structure to the entities within a radius from the proposed path.

    delete_entities : bool, optional
            Delete the shell reinforcements.

    Returns
    -------
    list
            A list of the created beam elements.

    See Also
    --------
    CrossSectionsMulticut

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import base
            from ansa import constants


            def main():
                shells = base.CollectEntities(constants.NASTRAN, None, "SHELL")
                beams = base.ReplaceShellReinforcements(shells, delete_entities=True)


            if __name__ == "__main__":
                main()


    """


def CreateCurve(total: int, x: list, y: list, z: list) -> object:
    """

    Creates a smooth 3D-curve that passes from a number of points.
    'total' is the number and 'x', 'y', 'z' are the coordinates of the points.

    Parameters
    ----------
    total : int
            The number of the points that the curve will pass.

    x : list
            A list with the x coordinates.

    y : list
            A list with the y coordinates.

    z : list
            A list with the z coordinates.

    Returns
    -------
    object
            Returns a reference to the created 3D-curve.

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                x = [1, 1.1, 2]
                y = [1.5, 3.2, 2.7]
                z = [1.8, 3, 2.6]
                base.CreateCurve(3, x, y, z)


    """


def RefreshList(deck: int = None, keyword: str = None) -> object:
    """

    Schedules a refresh of all open ANSA lists when called with no arguments or a specific ANSA list when arguments are specified.

    Parameters
    ----------
    deck : int, optional
            The deck constant.

    keyword : str, optional
            The keyword of the specified ANSA list that is to be refreshed.
            Additionally, the following keywords can be used:

            "__VISIBLE__"
            "__PROPERTIES__"
            "__MATERIALS__"
            "__ELEMENTS__"
            "__ALL_ENTITIES__"
            "__CONNECTIONS__"
            "__KINEMATIC__"
            "__KINETIC__"
            "__MBCONTAINERS__"
            "__FEATURES__"
            "__COORD_SYSTEMS__"
            "__CONNECTION_TEMPLATES__"

    Returns
    -------
    object
            Always returns None.

    See Also
    --------
    ShowEntitiesList

    Examples
    --------
    ::

            import os
            from ansa import base, constants


            def main():
                props = base.CollectEntities(constants.NASTRAN, None, "__PROPERTIES__")

                # Append "_refreshed" to all Property names
                for prop in props:
                    new_name = prop._name + "_refreshed"
                    base.SetEntityCardValues(constants.NASTRAN, prop, {"Name": new_name})

                # Refresh all open lists
                base.RefreshList()


    """


def ChangeStackDirection(elements: object, mode: str, axis: str) -> object:
    """

    This function will change the stack orientation for solid-like elements, such as COHESIVEs, GASKETs and CSHELLs.

    Parameters
    ----------
    elements : object
            A list of solid-like elements (COHESIVEs, GASKETs or CSHELLs ) or "all", "visible", 0.
            If set to 0 or "all", runs for all solid-like elements of the database.
            If set to "visible," runs for visible solid-like elements.

    mode : str
            Defines how stack direction should change. Accepted values are "rotate" or "invert".
            "rotate": Rotates the stack direction along a given axis.
            "invert": Inverts the stack direction.

    axis : str, optional
            Defines the axis in case of rotation.
            "N1-N2": rotation axis is defined by node 1 and node 2 of the element.
            "N1-N4": rotation axis is defined by node 1 and node 4 of the element.

    Returns
    -------
    object
            This function always returns None.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                cohesives = base.CollectEntities(constants.ABAQUS, None, "COHESIVE")
                ret = base.ChangeStackDirection(mode="rotate", axis="N1-N4", elements=cohesives)


    """


class Curve:
    """

    Curve is an object that will encapsulate the functionality of the ANSA curves.
    It can be used via script in both GUI and no-GUI mode.

    Examples
    --------
    ::

            import ansa
            from ansa import base
            from ansa import constants


            def main():
                curves = base.CollectEntities(constants.NASTRAN, None, "CURVE")
                curve = base.Curve()
                curve.set(curves[0])

                # Get the tangent and curvature vectors at the middle of the curve
                point = base.EvaluateCurvePoint(curves[0], 0.5)
                print(curve.tangent(point))
                print(curve.curvature(point))


            if __name__ == "__main__":
                main()

    """

    def set(self, curve: object) -> int:
        """

        Set an ANSA curve to the Curve object.


        Parameters
        ----------
        curve : object
                The ANSA curve

        Returns
        -------
        int

        """

    def tangent(self, xyz: list) -> tuple:
        """

        Get the tangent of the curve at the given 3D point.


        Parameters
        ----------
        xyz : list
                The 3D point

        Returns
        -------
        tuple
                Returns the tangent vector

        """

    def curvature(self, xyz: list) -> tuple:
        """

        Get the curvature of the curve at the given 3D point.


        Parameters
        ----------
        xyz : list
                The 3D point

        Returns
        -------
        tuple
                Returns the curvature vector

        """


def GetInterfaceBoundariesFromEntities(entities: object) -> object:
    """

    This function collects all Interface Boundary entities that have been defined on input elements.

    Parameters
    ----------
    entities : object
            A list of entities. Entities could be Faces, Cons, Shells or ShellEdges

    Returns
    -------
    object
            A list of Interface Boundary entities that have been defined on input elements

    See Also
    --------
    DefineInterfaceBoundary, GetInterfaceBoundaryContents

    Examples
    --------
    ::

            import os
            import ansa
            from ansa import *


            def main():
                shells = base.CollectEntities(1, None, "SHELL")
                ents = base.GetInterfaceBoundariesFromEntities(shells)
                print(ents)


    """


def DeleteUserDefinedAction(entity_type: str, name: str) -> bool:
    """

    This function deletes a user action from Model Browser for a specific Model Browser Container.

    Parameters
    ----------
    entity_type : str
            The ANSA keyword of the entities the user action affects.
            Currently only Model Browser container entities are supported.

    name : str
            The user action name.

    Returns
    -------
    bool
            Returns 'True' on success, 'False' on failure.

    See Also
    --------
    CreateUserDefinedAction

    Examples
    --------
    ::

            import ansa
            from ansa import base, utils


            def main():
                ua_name = "My Action"
                ua_script_path = "C:/my_user_action_script.py"
                ua_function = "my_function_name"
                ua_icon = "C:/action_icon.png"
                # ua_restriction = "my_restriction_function_name"
                # ua_overload = "Save in DM"
                # ua_comment = "This is my comment..."

                # Create the user action
                ret = base.CreateUserDefinedAction(
                    entity_type="ANSAPART",
                    name=ua_name,
                    script=ua_script_path,
                    function=ua_function,
                    icon=ua_icon,
                )
                print(ret)

                # Open the parts tab in order to see the new user action in gui (context menu & toolbar)
                utils.OpenModelBrowser(entity_type="Parts")

                # Delete the user action
                del_ret = base.DeleteUserDefinedAction(entity_type="ANSAPART", name=ua_name)
                print(del_ret)

                # The action is removed from the parts tab (context menu & toolbar)


    """


def SetAnsaWindowName(window: object, name: str) -> None:
    """

    Changes the name of the given ANSA window.

    Parameters
    ----------
    window : object
            A reference to the ANSA Window.

    name : str
            The new name of the window.

    Returns
    -------
    None

    See Also
    --------
    CreateNewAnsaWindow, GetAnsaWindow, GetAnsaWindowName

    Examples
    --------
    ::

            import ansa
            from ansa import base


            def main():
                my_win = base.GetAnsaWindow("Main Window")
                base.SetAnsaWindowName(my_win, "mywindow_new_name")
                base.GetAnsaWindowName(my_win)


            if __name__ == "__main__":
                main()


    """


def RecoverAlignConstraints(
    shells: list, faces: list, distance_tol: float = 5, thickness_tol: float = 5
) -> list:
    """

    Creates Align Constraints on shells using the input faces.

    Parameters
    ----------
    shells : list
            Shells where the Align Constraints are created.

    faces : list
            The faces used to create the Align Constraints.

    distance_tol : float, optional
            Distance tolerance as a percentage of thickness. Cannot be more than 10%.

    thickness_tol : float, optional
            Thickness tolerance as a percentage of thickness. Cannot be more than 10%.

    Returns
    -------
    list
            A list of the newly created Align Constraints

    Examples
    --------
    ::

            from ansa import base


            def main():
                search_face = ("FACE",)
                faces = base.CollectEntities(0, None, search_face, False)

                search_shell = ("SHELL",)
                shells = base.CollectEntities(0, None, search_shell, False)

                result = base.RecoverAlignConstraints(
                    shells=shells, faces=faces, distance_tol=5, thickness_tol=5
                )


    """


def BCSettingsGetUserDefinedValue(keyword: str) -> str:
    """

    Returns the string value of user defined keyword with name keyword
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup.

    Returns
    -------
    str
            the value of the keyword, if keyword was found, otherwise returns  None.

    See Also
    --------
    BCSettingsSetUserDefinedValue

    """


def BCSettingsSetUserDefinedValue(keyword: str, value: str) -> int:
    """

    Sets value value to user defined keyword keyword.
    If keyword a\ keyword doesn't exist it will be created.
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup and set the new value.

    value : str
            the new string value of the keyword

    Returns
    -------
    int
            1 if value was set successfully to keyword keyword, 0 otherwise.

    See Also
    --------
    BCSettingsGetUserDefinedValue

    """


def BCSettingsUserDefinedKeywordExists(name: str) -> int:
    """

    Checks if a user defined key with name name exists in BCSettingsHandler structure
    It will only search for a keyword not for a value.
    This function is not supported under VR mode.

    Parameters
    ----------
    name : str
            the keyword's name to look up.

    Returns
    -------
    int
            1 if user defined keyword is found, 0 otherwise.

    See Also
    --------
    BCSettingsSetUserDefinedValue

    """


def BCSettingsReadFile(filePath: str) -> int:
    """

    Reads a defaults file, from path filePath.

    Settings that will be read from the file, will be applied
    to the running application.
    This function is not supported under VR mode.

    Parameters
    ----------
    filePath : str
            the path of defaults file

    Returns
    -------
    int
            1 if reading was succesfull, 0 otherwise.

    See Also
    --------
    BCSettingsWriteGroup

    """


def BCSettingsWriteFile(filePath: str) -> int:
    """

    Writes a defaults file, at path filePath. If a filePath is not given,
    \the defaults file will be written in .BETA folder according to which
    \layout ANSA was launched (e.g. ANSA.defaults, CFD.defaults)
    If the file already exists, it will be overwritten.
    This function is not supported under VR mode.

    Parameters
    ----------
    filePath : str, optional
            the path where the defaults file will be written.

    Returns
    -------
    int
            1 if save was succesfull, 0 otherwise.

    See Also
    --------
    BCSettingsWriteGroup

    """


def BCSettingsWriteGroup(filePath: str, groupName: str) -> int:
    """

    Writes the settings of Group named groupName, at path filePath.
    \If filePath is empty, the group will be written in defaults file located in .BETA folder
    \according to which layout ANSA was launched (e.g. ANSA.defaults, CFD.defaults)
    If file already exists, then the settings of the corresponding group will be updated.
    The rest of the file will remain intact.
    This function is not supported under VR mode.

    Parameters
    ----------
    filePath : str
            the path where the defaults file will be written.

    groupName : str
            the group name, to write.

    Returns
    -------
    int
            1 if save was succesfull, 0 otherwise.

    See Also
    --------
    BCSettingsWriteFile

    """


def BCSettingsGetDefaultValue(keyword: str) -> str:
    """

    Returns the default value of keyword with name keyword as string
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup.

    Returns
    -------
    str
            the value of the keyword, if keyword was found, otherwise returns  None.

    See Also
    --------
    BCSettingsGetStartupValue

    """


def BCSettingsGetStartupValue(keyword: str) -> str:
    """

    Returns the startup value of keyword with name keyword as string
    This function is not supported under VR mode.

    Parameters
    ----------
    keyword : str
            the keyword name to lookup.

    Returns
    -------
    str
            the value of the keyword, if keyword was found, otherwise returns  None.

    See Also
    --------
    BCSettingsGetDefaultValue

    """


class checks:
    class geometry:
        def Cracks() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.Cracks()
                        obj.execute()


            """

        def NeedleFaces() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.NeedleFaces()
                        obj.execute()


            """

        def OverlapFaces() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.OverlapFaces()
                        obj.execute()


            """

        def SingleCons() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.SingleCons()
                        obj.execute()


            """

        def TripleCons() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.TripleCons()
                        obj.execute()


            """

        def UncheckedFaces() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.UncheckedFaces()
                        obj.execute()


            """

        def unmeshedMacros() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.unmeshedMacros()
                        obj.execute()


            """

        def CollapsedCons() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.geometry.CollapsedCons()
                        obj.execute()


            """

    class general:
        def AbaqusDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.AbaqusDependency()
                        obj.execute()


            """

        def AbaqusLoop() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.AbaqusLoop()
                        obj.execute()


            """

        def AmplitudesAxes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -axis2: 1
            -axis1: 1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.AmplitudesAxes()
                        obj.execute()


            """

        def AmplitudesEndTime() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.AmplitudesEndTime()
                        obj.execute()


            """

        def CFasts() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CFasts()
                        obj.execute()


            """

        def CWelds() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            dratio     = 1.0
            freegagb   = 1
            gsproj     = 20.0
            projtol    = 0.02

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CWelds()
                        obj.execute()


            """

        def ClosedTieLoops() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ClosedTieLoops()
                        obj.execute()


            """

        def CohesiveOrientation() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CohesiveOrientation()
                        obj.execute()


            """

        def CohesiveSolidOrientation() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CohesiveSolidOrientation()
                        obj.execute()


            """

        def ConstrRB_LongChain() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -distance: 100.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ConstrRB_LongChain()
                        obj.execute()


            """

        def ConstrRB_PIDM_PIDS_Distance() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -distance: 100.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ConstrRB_PIDM_PIDS_Distance()
                        obj.execute()


            """

        def ContactOrientation() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ContactOrientation()
                        obj.execute()


            """

        def Contacts() -> Check:
            """

            This function creates an appropriate Check object, that when executed,
            will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - detect_intersections_only = False
            - min_depth = None
            - search_domain_length = None
            - search_domain_radius = None
            - tie_success_criterion = None

            Fix Attributes and default values:

            - depth_limit = None

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Contacts()
                        obj.execute()


            """

        def Coupling() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Coupling()
                        obj.execute()


            """

        def CurvesAxes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -check_y: 1
            -check_x: 1
            -check_mode: of all database
            -max_yield_stress   : 2.5
            -max_plastic_strain : 3.0
            -max_scale_factor   : 2.0
            -max_strain_rate    : 20.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CurvesAxes()
                        obj.execute()


            """

        def CurvesEndTime() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -read_from_control: 1
            -end_time: 0.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CurvesEndTime()
                        obj.execute()


            """

        def DBCrossSection() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DBCrossSection()
                        obj.execute()


            """

        def DBHistories() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DBHistories()
                        obj.execute()


            """

        def DuplicateElements() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            -report_material_null_elements : False
            -separate_by: 'GEOM/FE'
            -report_semi_dupl_solids : False
            -report_only_elements_with_same_pid : False

            valid values for `separate_by': 'GEOM/FE', 'Max IDs', 'Min IDs'

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DuplicateElements()
                        obj.separate_by = "Max IDs"  # other values 'GEOM/FE', 'Min IDs'
                        obj.report_material_null_elements = False
                        obj.report_only_elements_with_same_pid = False

                        # execute() returns a list of CheckReport objects. For each of these objects,
                        # we can use the 'try_fix()' function to "fix" their issues:
                        report_list = obj.execute()

                        # try to fix the issues
                        for item in report_list:
                            print("Header (invisible): {}".format(item.description))
                            print("Header issues: {}".format(item.issues))

                            for header in item.issues:
                                print("Header Description: {}".format(header.description))
                                header.try_fix()


            """

        def DuplicatePermasIDs() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DuplicatePermasIDs()
                        obj.execute()


            """

        def DuplicateSetNames() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DuplicateSetNames()
                        obj.execute()


            """

        def ExternalConsWithoutBCs() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ExternalConsWithoutBCs()
                        obj.execute()


            """

        def FastenersConnectivity() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.FastenersConnectivity()
                        obj.execute()


            """

        def FastenersEccentricity() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -max_eccentricity: 0.5
            -min_eccentricity:
            -max_number_of_nodes:
            -min_number_of_nodes:

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.FastenersEccentricity()
                        obj.execute()


            """

        def FlangesWeldSpots() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -angle_tolerance: 10.0
            -min_weld_spots: 5
            -identify: Identify Flanges
            -factor: 2.0
            -min_weld_spot_distance: 10.0
            -wanted_weld_spot_distance: 40.0
            -max_weld_spot_distance: 40.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.FlangesWeldSpots()
                        obj.execute()


            """

        def FunctAxes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -check_y: 1
            -check_x: 1
            -check_mode: of all database

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.FunctAxes()
                        obj.execute()


            """

        def FunctEndTime() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -end_time: 0.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.FunctEndTime()
                        obj.execute()


            """

        def Incomplete() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Incomplete()
                        obj.execute()


            """

        def InitialVelocity() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.InitialVelocity()
                        obj.execute()


            """

        def Joints() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Joints()
                        obj.execute()


            """

        def Kinematics() -> Check:
            """

            (Warning: This check is deprecated in favour of Kinetics: ansa.base.checks.general.Kinetics())

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Kinematics()
                        obj.execute()


            """

        def LaminateMappedData() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            -is_tol_absolute 1 / 0: 1
            -thickness_tolerance double: 15.0
            -theta_tolerance double: 15.0
            -functionality string: 'Thickness' (other allowable values: 'Theta', 'Thickness & Theta')

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.LaminateMappedData()
                        obj.is_tol_absolute = 0
                        obj.theta_tolerance = 10.0
                        obj.functionality = "Thickness & Theta"
                        obj.execute()


            """

        def Length() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -upper_limit: 1.5
            -lower_limit: 0.1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Length()
                        obj.execute()


            """

        def LsDynaRigidDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.LsDynaRigidDependency()
                        obj.execute()


            """

        def MPDATA_EndTime() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -end_time: 0.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MPDATA_EndTime()
                        obj.execute()


            """

        def MassScaleRatio() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default parameters:
            -To: BLANK
            -From:  1.5

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MassScaleRatio()
                        obj.From = 1.5
                        obj.To = 10.0
                        obj.execute()


            """

        def Massless() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -beam_orient_nodes: 1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Massless()
                        obj.execute()


            """

        def MaterialTheta() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -tolerance double : 15.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MaterialTheta()
                        obj.execute()


            """

        def ModelData() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ModelData()
                        obj.execute()


            """

        def MultiDampingGlobal() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MultiDampingGlobal()
                        obj.execute()


            """

        def MultipleBCs() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MultipleBCs()
                        obj.execute()


            """

        def NastranDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.NastranDependency()
                        obj.execute()


            """

        def NastranLoop() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.NastranLoop()
                        obj.execute()


            """

        def OpenFOAM_CheckMesh() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -topological_cell_zip_up:   1
            -non_orthogonality:         1
            -skewness:                  1
            -closed_cells:              1
            -aspect_ratio:              1
            -face_face_connectivity:    1
            -empty_patch_faces:         1
            -non_aligned_edges:         1
            -upper_triangular_ordering: 1
            -warping:                   1
            -face_vertices:             1
            -symmetry_plane:            1
            -concave_cells:             1
            -face_tetquality:           1
            -concave_faces:             1
            -determinant:               1
            -report_semi_dupl_solids    1
            -negative_volume_cells      1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.OpenFOAM_CheckMesh()
                        obj.execute()


            """

        def PBxSECT() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.PBxSECT()
                        obj.execute()


            """

        def PLinks() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.PLinks()
                        obj.execute()


            """

        def PamcrashDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.PamcrashDependency()
                        obj.execute()


            """

        def PermasDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -apply_on_situation: 0
            -situation_id:

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.PermasDependency()
                        obj.execute()


            """

        def RadiossRigidDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.RadiossRigidDependency()
                        obj.execute()


            """

        def Range() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Range()
                        obj.execute()


            """

        def RangesOfIDsWithinIncludes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.RangesOfIDsWithinIncludes()
                        obj.execute()


            """

        def Rbe3Definition() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -tolerance:

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Rbe3Definition()
                        obj.execute()


            """

        def SPCsOnRigidBodyNodes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.SPCsOnRigidBodyNodes()
                        obj.execute()


            """

        def SenptSearchDistance() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.SenptSearchDistance()
                        obj.execute()


            """

        def SestraDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.SestraDependency()
                        obj.execute()


            """

        def SolidFormulation() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.SolidFormulation()
                        obj.execute()


            """

        def SpotWelds() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            on_neigh_shell         = 0
            on_same_shell          = 1
            degrees                = 20.0
            conflicts_with_rigids  = 1
            angle_to_normal        = 1
            invalid_spotweld_beams = 1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.SpotWelds()
                        obj.execute()


            """

        def THLOC() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.THLOC()
                        obj.execute()


            """

        def Tables() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Tables()
                        obj.execute()


            """

        def ThickShellOrientation() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ThickShellOrientation()
                        obj.execute()


            """

        def UnclosedPolyhedra() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.UnclosedPolyhedra()
                        obj.execute()


            """

        def UnconnectedRegions() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.Attributes and default values:

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.UnconnectedRegions()
                        obj.execute()


            """

        def UnconnectedRegionsRigids() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.UnconnectedRegionsRigids()
                        obj.execute()


            """

        def UndefinedMaterials() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.UndefinedMaterials()
                        obj.execute()


            """

        def UndefinedProperties() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.UndefinedProperties()
                        obj.execute()


            """

        def Materials() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            tolerance = 0.0
            case_sensitive: 1

            The 'case_sensitive' attribute will be taken into account only if names
            are considered for the check.

            compare_by: 'Ids'
            Appropriate values for attribute 'compare_by' are:
            1. 'Ids'
            2. 'Names'
            3. 'Most similar'

            If compare_by is 'Most similar', you can also set the
            following two attributes:
            -consider_names: 0
            -consider_ids: 0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Materials()
                        obj.execute()


            """

        def FreeNodes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - consider_nodes_with_mass_free = True
            - do_not_report_free_nodes_attached_to_non_visible_entities = True
            - do_not_report_master_nodes_of_rigid_bodies = True
            - consider_auxiliary_nodes_as_free = True
            - report_scalar_nodes = True

            Fix Attributes and default values:

            - rigids_fix_option = 0
            - autopaste_search_dist = 0.2

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.FreeNodes()
                        obj.consider_nodes_with_mass_free = False
                        obj.execute()


            """

        def IDsSpecialNumberingRules(types: str) -> Check:
            """
            .. deprecated:: 20.0.0
                    Use :py:func:`IDsNumberingRules` instead.


            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Parameters
            ----------
            types : str
                    a string with comma separated group names

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.IDsSpecialNumberingRules()

                        # types must be a string with comma separated group types. Do not
                        # leave any spaces inside the string.
                        obj.types = "SET,PROPERTY,NASTRAN MATERIAL,NODE,ELEMENT"
                        results = obj.execute()


            """

        def IDsSpecialNumberingRules(types: str) -> Check:
            """
            .. deprecated:: 20.0.0
                    Use :py:func:`IDsNumberingRules` instead.


            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Parameters
            ----------
            types : str
                    a string with comma separated group names

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.IDsSpecialNumberingRules()

                        # types must be a string with comma separated group types. Do not
                        # leave any spaces inside the string.
                        obj.types = "SET,PROPERTY,NASTRAN MATERIAL,NODE,ELEMENT"
                        results = obj.execute()


            """

            import warnings

            warnings.warn(
                "Deprecated since version 20.0.0. Use :py:func: IDsNumberingRules instead.",
                DeprecationWarning,
            )

        def Geometry() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            unmeshed_macros   = 0
            needle_faces      = 1
            single_cons       = 0
            collapsed_cons    = 1
            unchecked_faces   = 1
            triple_cons       = 1
            sharp_edges       = 0
            cracks            = 1
            sharp_edges_angle = 120.0
            overlap_faces     = 1
            sharp_edges_type  = 0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Geometry()
                        obj.unmeshed_macros = 0  # do not check this
                        obj.needle_faces = 0  # do not check for needle faces also
                        results = obj.execute()

                        if results:
                            results[0].try_fix()


            """

        def FromDescription(description: CheckDescription) -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            run a user-defined check given as a CheckDescription object.

            Parameters
            ----------
            description : CheckDescription
                    The user-defined CheckDecription object.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport, CheckDescription

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        check_descr = base.CheckDescription(name="my check")
                        # perform setup of the `check_descr object, like setting
                        # deck, execution funs, fix funs, required types etc. For more information
                        # see ansa.base.CheckDescription
                        # for example, create a param named 'length', with a default value of 10.0
                        check_descr.add_float_param("length", 10.0)

                        # Check is a class defined in ansa.base
                        # Now, instantiate an check object from the `check_descr' object
                        obj = base.checks.general.FromDescription(check_descr)
                        obj.length = 20.0  # change the `length' param value
                        obj.execute()


            """

        def Rbe2gsConflictingIds() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Rbe2gsConflictingIds()
                        obj.execute()


            """

        def MultiReferencedNodes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            min_number_of_referers = 3

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MultiReferencedNodes()
                        obj.execute()


            """

        def Frozen() -> Check:
            """

            This function creates a check object that will perform the "Frozen Entities"
            check when executed. This check reports all entities that have at least one
            of FROZEN, FROZEN_DELETE, FROZEN_ID set to YES.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Frozen()
                        obj.execute()


            """

        def Connections() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            The returned check object has the following attributes and default values:

            -check_num_of_parts: False
            -check_max_distance: True
            -check_min_distance: True
            -check_flanges_angle: True
            -check_projections_proximity: False
            -check_total_thickness: True
            -check_double_connections: False
            -check_spider_positioning: True
            -check_intersecting_parts: True
            -check_connections_outside_flange: True
            -projection_tolerance: 10.0
            -max_allowed_angle: 20.0
            -min_allowed_distance: 1.0
            -max_allowed_total_thickness: 5.0
            -equivalent_connectivity: False
            -spot_distance: 5.0
            -similarity: 75.0
            -curve_face_distance: 5.0
            -equal_types: True
            -diameter: 10.0
            -feature_angle: 20.0
            -feature_distance: 0.5
            -perimeter_distance: 0.5
            -min_average_thickness_factor: 0.5
            -min_absolute_distance: 5.0
            -max_average_thickness_factor: 1.5
            -max_absolute_distance: 10.0
            -double_connections_average_thick_factor: 0.5
            -zone1_width: 5.0
            -zone2_width: 0.0
            -zone1_definition_method: '' (other choices: '*diam', '*thickness', 'by script')
            -zone2_definition_method: '' (other choices: '*diam', '*thickness', 'by script')
            -checkPartialConnLineRealization: False
            -minPercentageOfRealizedLine: 80
            -max_distance_method: 'By average thickness'
            -min_distance_method: 'By average thickness'
            -double_connections_method: 'By average thickness'
            -projection_center_distance = 5.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check, CheckReport

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        connections = base.checks.general.Connections()
                        connections.check_num_of_parts = False
                        connections.check_connections_outside_flange = False
                        connections.check_intersecting_parts = False

                        connections.check_spider_positioning = 1  # instead of True
                        connections.zone1_definition_method = "*thickness"
                        connections.zone1_width = 4.84

                        connections.check_total_thickness = 0  # instead of False

                        connections.check_min_distance = True
                        connections.min_distance_method = "By absolute distance"
                        connections.min_absolute_distance = 32.8

                        connections.check_max_distance = False
                        connections.check_flanges_angle = True

                        results = connections.execute()

                        if results:
                            header = results[0]
                        for issue in header.issues:
                            print(issue.description)


            """

        def Connectivity() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Connectivity()
                        obj.abort_if_too_many_unconnected_assemblies = True
                        obj.execute()


            """

        def DuplicatePIDNames() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will search for duplicate PID names and report them. It will perform the same with the relevant ANSA check "Duplicate PID names".

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DuplicatePIDNames()
                        obj.execute()


            """

        def ContactsSegments() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ContactsSegments()
                        obj.execute()


            """

        def Auxiliaries() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Auxiliaries()
                        obj.execute()


            """

        def RigidMasterNodes() -> Check:
            """

            This function creates an appropiate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.RigidMasterNodes()
                        obj.execute()


            """

        def InitialConditionsIntegrationPoints() -> Check:
            """

            This function creates an appropiate Check object which, when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.InitialConditionsIntegrationPoints()
                        obj.execute()


            """

        def SeatBelts() -> Check:
            """

            This function creates an appropiate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.SeatBelts()
                        obj.execute()


            """

        def CohesiveSolidConnectivity() -> Check:
            """

            This function creates an appropiate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CohesiveSolidConnectivity()
                        obj.execute()


            """

        def GEBStatus() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.GEBStatus()
                        obj.execute()


            """

        def ContactsOverlap() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ContactsOverlap()
                        obj.execute()


            """

        def Loadcase() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the
            same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -apply_referenced_ents = False

            Returns
            -------
            Check
                    Returns the newly created 'base.Check' object

            Examples
            --------
            ::

                    import ansa
                    from ansa import bsae


                    def main():
                        obj = base.checks.general.Loadcase()
                        obj.execute()


            """

        def Rbe2ConflictingIds() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Rbe2ConflictingIds()
                        obj.execute()


            """

        def CheckCracks() -> Check:
            """
            .. deprecated:: 20.0.0
                    Use :py:func:`CrackTipElements` instead.


            This function creates a Check object, which when executed, will perform the checks listed below, on all CRAC2D/CRAC3D Nastran elements, as performed by the relevant ANSA Check.

            1. Element planarity:

            - CRAC2D: All nodes defining this element should reside on the same plane.
            - CRAC3D: All nodes defining the outer faces and midplane, perpendicular to the crack plane, should all reside in their corresponding planes. This means that the grid point groups: [G2 through G18], [G20 through G36] and [G37 through G46], should each reside in a specific plane.

            2. Element sizing ratio:
            The ratio y to x axis in the element coordinate system should be in the range 2.0 to 0.5. The x-axis of the element coordinate system is defined by nodes G1 and G6 and the y-axis is defined by nodes G1 and G4 (this check holds for elements of either type CRAC2D or CRAC3D).

            3. Crack tip nodes coincidence:

            - CRAC2D: The crack tip nodes pair [G2, G10] should coincide.
            - CRAC3D: The crack tip node pairs [G2, G10], [G20, G28] and (if included) [G38, G46] should coincide.

            4. Midside location (CRAC3D only):

            - All the midplane nodes (G37 through G46) should be located within the middle third of the perpendicular edges.


            Attributes and default values:
            check_coincident_crack_tip_nodes     = 1
            check_side_ratio                     = 1
            check_planar_tolerance               = 0.05
            check_mid_plane                      = 1
            check_coincident_crack_tip_tolerance = 0.05
            check_planar_nodes                   = 1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CheckCracks()
                        obj.execute()


            """

        def CheckCracks() -> Check:
            """
            .. deprecated:: 20.0.0
                    Use :py:func:`CrackTipElements` instead.


            This function creates a Check object, which when executed, will perform the checks listed below, on all CRAC2D/CRAC3D Nastran elements, as performed by the relevant ANSA Check.

            1. Element planarity:

            - CRAC2D: All nodes defining this element should reside on the same plane.
            - CRAC3D: All nodes defining the outer faces and midplane, perpendicular to the crack plane, should all reside in their corresponding planes. This means that the grid point groups: [G2 through G18], [G20 through G36] and [G37 through G46], should each reside in a specific plane.

            2. Element sizing ratio:
            The ratio y to x axis in the element coordinate system should be in the range 2.0 to 0.5. The x-axis of the element coordinate system is defined by nodes G1 and G6 and the y-axis is defined by nodes G1 and G4 (this check holds for elements of either type CRAC2D or CRAC3D).

            3. Crack tip nodes coincidence:

            - CRAC2D: The crack tip nodes pair [G2, G10] should coincide.
            - CRAC3D: The crack tip node pairs [G2, G10], [G20, G28] and (if included) [G38, G46] should coincide.

            4. Midside location (CRAC3D only):

            - All the midplane nodes (G37 through G46) should be located within the middle third of the perpendicular edges.


            Attributes and default values:
            check_coincident_crack_tip_nodes     = 1
            check_side_ratio                     = 1
            check_planar_tolerance               = 0.05
            check_mid_plane                      = 1
            check_coincident_crack_tip_tolerance = 0.05
            check_planar_nodes                   = 1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CheckCracks()
                        obj.execute()


            """

            import warnings

            warnings.warn(
                "Deprecated since version 20.0.0. Use :py:func: CrackTipElements instead.",
                DeprecationWarning,
            )

        def UnconnectedCrossSectionFlanges() -> Check:
            """

            This function creates a Check object, which when executed, will detect Cross Sections with unconnected flanges, as performed by the relevant ANSA Check.

            Attributes and default values:
            -tolerance_t_fac : 1.2
            -widthwise_step  : 0.0
            -parallel_limit  : 10.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.UnconnectedCrossSectionFlanges()
                        obj.execute()


            """

        def IncludeTransformRangeIds() -> Check:
            """

            This function creates a Check object, which when executed, will perform the checks listed below,
            on all *INCLUDE_TRANSFORM LS-DYNA entities, as performed by the relevant ANSA Check.

            1. *INCLUDE_TRANSFORM has no NumberingRule specified for it:
               *INCLUDE_TRANSFORM should not contain entities that have id smaller than specified offset.
               Fix assigns id bigger than the specified offset to these entities.

            2. *INCLUDE_TRANSFORM has NumberingRule specified for it:
               a. *INCLUDE_TRANSFORM should not have conflicting Numbering Rules specified for it, e.g. a General Numbering Rule,
                  start_id = 5 and *INCLUDE_TRANSFORM has IDNOFF = 10, regardles if any of the *INCLUDE_TRANSFORM contents have
                  id smaller than the specified offset.
                  Fix will update the NumberingRule's start_id.

               b. *INCLUDE_TRANSFORM should not contain entities with ids smaller than the specified offset while
                  a conflicting NumberingRule is specified for it.
                  Fix will apply the NumberingRules, assuming that this is the fault.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.IncludeTransformRangeIds()
                        obj.execute()


            """

        def FluidNodes() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.FluidNodes()
                        obj.execute()


            """

        def DuplicatePropertySetNames() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DuplicatePropertySetNames()
                        obj.execute()


            """

        def Kinetics() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Kinetics()
                        obj.execute()


            """

        def SetRegions() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.SetRegions()
                        obj.execute()


            """

        def ExtraNodesConnectivity() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ExtraNodesConnectivity()
                        obj.distance = 0.5
                        obj.execute()


            """

        def Undefined() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Undefined()
                        obj.execute()


            """

        def CommonNodes() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CommonNodes()
                        obj.check_vis_props = True
                        obj.check_non_vis_elems = False
                        obj.execute()


            """

        def ContactsFromSolver() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ContactsFromSolver()
                        obj.files = "first_file;second_file"
                        obj.execute()


            """

        def EmptySets() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.EmptySets()
                        obj.execute()


            """

        def AnsysDependency() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            report_organization : 0

            Appropriate values for attribute 'report_organization' are 0 and 1.
            On 0 report is organized per entity error.
            On 1 report is organized per step (same error might appear in multiple steps).

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.AnsysDependency()
                        obj.execute()


            """

        def Sonate() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.Sonate()
                        obj.execute()


            """

        def RadiossSubmodelSelfContained() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.RadiossSubmodelSelfContained()
                        obj.execute()


            """

        def DBCheckPS() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by "Database: Check CS" ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DBCheckPS()
                        obj.execute()


            """

        def DBCheckCS() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by "Database: Check Part Set" ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.DBCheckCS()
                        obj.oversize = 10.0
                        obj.distance = 5.0
                        obj.execute()


            """

        def IncludeSelfContained() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.IncludeSelfContained()
                        obj.execute()


            """

        def TAU_CheckMesh() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.TAU_CheckMesh()
                        obj.face_face_connectivity = True
                        obj.solid_tauquality = False
                        obj.upper_triangular_ordering = True
                        obj.execute()


            """

        def CrackTipElements() -> Check:
            """

            This function creates a Check object, which when executed, will perform the checks listed below, on all CRAC2D/CRAC3D Nastran elements, as performed by the relevant ANSA Check.

            1. Element planarity:

            - CRAC2D: All nodes defining this element should reside on the same plane.
            - CRAC3D: All nodes defining the outer faces and midplane, perpendicular to the crack plane, should all reside in their corresponding planes. This means that the grid point groups: [G2 through G18], [G20 through G36] and [G37 through G46], should each reside in a specific plane.

            2. Element sizing ratio:
            The ratio y to x axis in the element coordinate system should be in the range 2.0 to 0.5. The x-axis of the element coordinate system is defined by nodes G1 and G6 and the y-axis is defined by nodes G1 and G4 (this check holds for elements of either type CRAC2D or CRAC3D).

            3. Crack tip nodes coincidence:

            - CRAC2D: The crack tip nodes pair [G2, G10] should coincide.
            - CRAC3D: The crack tip node pairs [G2, G10], [G20, G28] and (if included) [G38, G46] should coincide.

            4. Midside location (CRAC3D only):

            - All the midplane nodes (G37 through G46) should be located within the middle third of the perpendicular edges.


            Attributes and default values:
            check_coincident_crack_tip_nodes     = 1
            check_side_ratio                     = 1
            check_planar_tolerance               = 0.05
            check_mid_plane                      = 1
            check_coincident_crack_tip_tolerance = 0.05
            check_planar_nodes                   = 1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.CrackTipElements()
                        obj.execute()


            """

        def IDsNumberingRules() -> Check:
            """

            Checks if entities' IDs of selected groups fulfill the existing numbering rules.

            Attributes and default values:
            types                    = ""
            check_only_special_rules = False

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.IDsNumberingRules()
                        obj.execute()


            """

        def Llinks() -> Check:
            """

            Checks definitions of LLINKs.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = ansa.base.checks.general.Llinks()
                        obj.execute()


            """

        def UniqueDefinitionEntities() -> Check:
            """

            Checks for multiple keywords definitions (*DAMPING_GLOBAL, *TERMINATION_SENSOR, *INITIAL_VELOCITY_GENERATION_START_TIME)

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.UniqueDefinitionEntities()
                        obj.execute()


            """

        def ThinCrossSectionToSolid() -> Check:
            """

            This function creates a Check object, which when executed, will detect thin Cross Sections that cannot be converted to solid ones, as performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ThinCrossSectionToSolid()
                        obj.execute()


            """

        def MpcIsurfaces() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MpcIsurfaces()
                        obj.execute()


            """

        def MeltEntrance() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.MeltEntrance()
                        obj.execute()


            """

        def LaminateLayerContinuity() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.LaminateLayerContinuity()
                        obj.execute()


            """

        def ActranFSCoupling() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            common_nodes          = True
            referenced_components = True

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ActranFSCoupling()
                        obj.referenced_components = False
                        obj.execute()


            """

    class mesh:
        def FreeOppositeEdges() -> Check:
            """

            (Warning: This check is deprecated in favour of Hourglass Effect check --> ansa.base.checks.mesh.HourglassEffect())

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            oppos_edges  = 1
            corner_quads = 0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.FreeOppositeEdges()
                        obj.execute()


            """

        def HangingEdges() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            This check will identify all Hanging edges in the model from Solids and Shells.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.HangingEdges()
                        obj.execute()


            """

        def IsolatedSolids() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.IsolatedSolids()
                        obj.execute()


            """

        def MeshCompatibility() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            tolerance = 0.1

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.MeshCompatibility()
                        obj.execute()


            """

        def MeshQuality() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - quality_criteria = ""
            - read_f11_values = False

            Fix Attributes and default values:

            - fix_method = 2

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.MeshQuality()
                        ret = obj.execute()
                        result = ret[0]
                        result.fix_method = 1
                        result.try_fix()


            """

        def NegativeVolume() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            -calculation_method : "PARTIAL"

            valid values for `calculation_method': 'PARTIAL', 'TOTAL'


            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.NegativeVolume()
                        obj.execute()


            """

        def Pyramids() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.Pyramids()
                        obj.execute()


            """

        def SharpEdges() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - sharp_edges_type = 0
            - angle = 120.0
            - exclude_edges = 0

            Fix Attributes and default values:

            - expand_level = 3
            - reshape_violating = 0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.SharpEdges()
                        obj.execute()


            """

        def ShellsWithoutSolids() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.general.ShellsWithoutSolids()
                        obj.execute()


            """

        def SingleBounds() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.SingleBounds()
                        obj.execute()


            """

        def TriasAttachedOnBoundary() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.TriasAttachedOnBoundary()
                        obj.execute()


            """

        def TriasAttachedOnHoles() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -check_zone_shells               : 1
            -check_manual_zones              : 1
            -max_number_of_zones             : 1
            -check_by_node                   : 1
            -check_by_edge                   : 1
            -check_on_perimeters             : 1
            -max_hole_diameter               : 100.0
            -check_auto_zones                : 1
            -include_connection_filled_holes : 0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.TriasAttachedOnHoles()
                        obj.execute()


            """

        def TriasOnCorner() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.TriasOnCorner()
                        obj.execute()


            """

        def TripleBounds() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.TripleBounds()
                        obj.execute()


            """

        def VoidAreas() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.VoidAreas()
                        obj.execute()


            """

        def UncoveredFaces() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.UncoveredFaces()
                        obj.execute()


            """

        def SolidsOnShells() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            check for solids on shells. The connectivity can be based on facets or nodes.

            Attributes and default values:
            -connected_by : "Facets" or "Nodes"

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        solids_on_shells = base.checks.mesh.SolidsOnShells()

                        solids_on_shells.connected_by = "Facets"
                        # solids_on_shells.connected_by = 'Nodes'

                        results_list = (
                            solids_on_shells.execute()
                        )  # `results' is a list of CheckReport objects, usually it contains only one object
                        # results_list = solids_on_shells.execute(report=base.Check.REPORT_NONE) # does not open the Checks Manager

                        entities = []
                        if results_list:
                            header = results_list[0]
                            for issue in header.issues:
                                for entity in issue.entities:
                                    entities.append(entity)
                        print("entities: ", len(entities))


            """

        def SolidCracks() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            mode      = 0
            tolerance = 0.15

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.SolidCracks()
                        obj.execute()


            """

        def UnreferencedShells() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            check for shells that do not coincide with any solid facet.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.UnreferencedShells()
                        obj.execute()


            """

        def FreeSolidFaces() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            check for solid faces that are not attached to any shell.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.FreeSolidFaces()
                        obj.execute()


            """

        def ShellsAndFacesOrientation() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.ShellsAndFacesOrientation()
                        obj.shells_faces_orient_direction = "yellow outside"
                        obj.execute()


            """

        def TetrasOnBoundary() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = checks.mesh.TetrasOnBoundary()
                        obj.execute()


            """

        def OneRowTetras() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = checks.mesh.OneRowTetras()
                        obj.execute()


            """

        def Symmetry_Plane() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.Symmetry_Plane()
                        obj.execute()


            """

        def MacroInternalBounds() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.MacroInternalBounds()
                        obj.execute()


            """

        def SymmetryPlane() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.SymmetryPlane()
                        obj.execute()


            """

        def ConcaveAreas() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.ConcaveAreas()
                        obj.search_distance = 10.0
                        obj.search_distance_mode = "absolute"
                        obj.search_direction = "yellow"
                        obj.execute()


            """

        def UnclosedVolumeElements() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.UnclosedVolumeElements()
                        obj.execute()


            """

        def NonManifoldNodes() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.Attributes and default values:

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.NonManifoldNodes()
                        obj.execute()


            """

        def HourglassEffect() -> Check:
            """

            This function creates an appropriate checks object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            obj.oppos_edges  = True
            obj.corner_quads = True

            Fix Attributes and default values:
            split_method = 0

            Returns
            -------
            Check
                    Returns the requested 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.HourglassEffect()
                        obj.execute()


            """

        def SolidsWithSingleCommonEdge() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform the same checks that are performed by the relevant ANSA Check.

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.mesh.SolidsWithSingleCommonEdge()
                        obj.execute()


            """

    class penetration:
        def DistanceRange() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            upper_limit: 1.0
            lower_limit: 0.5

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.DistanceRange()
                        obj.execute()


            """

        def InteriorIntersections() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.


            Attributes and default values:

            -check_same_pids : 1


            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.InteriorIntersections()
                        obj.execute()


            """

        def Intersections() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform
            the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - check_same_pids = 1

            Fix Attributes and default values:

            - method = 1
            - allow_edges_swap = 1
            - expand_zones = 5
            - max_movement = None


            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.Intersections()
                        results = obj.execute()

                        if results:
                            header = results[0]
                            try:
                                header.try_fix()
                            except RuntimeException as e:
                                print("something went wrong")


            """

        def PropertyThickness() -> Check:
            """

            This function creates an appropriate Check object, that when executed,
            will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - factor = 1.0
            - allow_samepart_proximities = 0
            - check_same_pids = 1
            - round_edges = 1

            Fix Attributes and default values:

            - frozen_properties = None

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.PropertyThickness()
                        obj.execute()


            """

        def Proximities() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will
            perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -factor: 0.25
            -check_orient_mode: 'Check grey-grey' (other allowable values: "Check yellow-yellow", "Check both orientations")
            -search_by: 'Search by element length factor'
            -check_same_pids: 1
            -check_orientation_angle: 30.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.Proximities()
                        obj.check_orient_mode = "Check yellow-yellow"
                        obj.execute(exec_mode=Check.EXEC_ON_ALL)


            """

        def RepositionFlanges() -> Check:
            """

            This function creates an appropriate Check object, that when executed, willperform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:
            -search_angle    : 20.0
            -search_distance : 2.5
            -desired_distance: 0.4
            -desired_factor  : 1.0

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.RepositionFlanges()
                        obj.execute()


            """

        def UserThickness() -> Check:
            """

            This function creates an appropriate Check object, that when executed,
            will perform the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - user_thickness = 1.0
            - allow_samepart_proximities = 0
            - check_same_pids = 1
            - round_edges = 1

            Fix Attributes and default values:

            - frozen_properties = None

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.UserThickness()
                        obj.execute()


            """

        def PenParametric() -> Check:
            """

            This function creates an appropriate Check object, that when executed, will perform
            the same checks that are performed by the relevant ANSA Check.

            Attributes and default values:

            - actor_distance = 1.0
            - check_same_pids = True
            - allow_samepart_proximities = False
            - round_edges = True
            - edge_to_edge = "Check single edges" (other options: "Check all edges", "Check no edges")
            - quad_projection = "Preserve" (other options: "Split to 2 trias", "Split to 4 trias")
            - thickness_definition = "Segment thickness" (other options: "Nodal thickness", "UserThickness")
            - common_nodes_thickness = "Use minimum" (other options: "Use maximum", "Use average")
            - calculate_thickness_from = "Model" (other options: "All")
            - solver_options = "None" (other options: "LS-DYNA", "PAM-CRASH")
            - consider_optt = False
            - emulate_ssthk = False
            - consider_tcont = False
            - emulate_iomit = False
            - move_on_plane = False

            Fix Attributes and default values:

            - frozen_properties = None

            Returns
            -------
            Check
                    Returns the created 'base.Check' object.

            See Also
            --------
            Check

            Examples
            --------
            ::

                    import ansa
                    from ansa import base


                    def main():
                        obj = base.checks.penetration.PenParametric()
                        results = obj.execute()


            """


class constants:
    LINE_ANGLE_SELECTION: int = None

    """
	Pick line elements with the Feature Selection>Feature Line method.
	
	"""

    LOOP_SELECTION: int = None

    """
	Pick line elements with the Feature Selection>Loop method.
	
	"""

    PID_NEIGHB_SELECTION: int = None

    """
	Pick line elements with the Feature Selection>PID Neighbs method.
	
	"""

    OPPOSITE_SELECTION: int = None

    """
	Pick line elements with the Feature Selection>Opposite method.
	
	"""

    POLY_LINE_NODE_SELECTION: int = None

    """
	Pick line elements with the Feature Selection>Path method.
	
	"""

    POLY_LINE_OPPOSITE_SELECTION: int = None

    """
	Pick line elements with the Feature Selection>Opposite Path method.
	
	"""

    AREA_ANGLE_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>Feature Area method.
	
	"""

    PID_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>PID method.
	
	"""

    PID_REGION_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>PID Region method.
	
	"""

    MID_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>MID method.
	
	"""

    VOL_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>VOL method.
	
	"""

    PART_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>PART method.
	
	"""

    CFD_BC_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>BC method.
	
	"""

    INCLUDE_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>Include method.
	
	"""

    HBOX_FACE_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>Hexa Box Face Area method.
	
	"""

    MACRO_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>Macro method.
	
	"""

    POLY_AREA_AREA_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>Poly Area method.
	
	"""

    POLY_LINE_AREA_SELECTION: int = None

    """
	Pick area elements with the Feature Selection>Poly Line method.
	
	"""

    ENT_SELECTION: int = None

    """
	Pick line or area elements with the Feature Selection>ENT method.
	
	"""
