from __future__ import annotations
from typing import *

import sys
guitk = sys.modules[__name__]

class constants:

	BCAlignAuto: int = None

	BCAlignLeft: int = None

	BCAlignRight: int = None

	BCAlignHCenter: int = None

	BCAlignJustify: int = None

	BCAlignHorizontal_Mask: int = None

	BCAlignTop: int = None

	BCAlignBottom: int = None

	BCAlignVCenter: int = None

	BCAlignVJustify: int = None

	BCAlignVertical_Mask: int = None

	BCAlignCenter: int = None

	BCTty: int = None

	BCGuiClient: int = None

	BCGuiServer: int = None

	BCBorder: int = None

	BCNoBorder: int = None

	BCTopBorder: int = None

	BCNoBorderNoMargin: int = None

	BCNoButton: int = None

	BCLeftButton: int = None

	BCRightButton: int = None

	BCMiddleButton: int = None

	BCMouseButtonMask: int = None

	BCShiftButton: int = None

	BCControlButton: int = None

	BCAltButton: int = None

	BCMetaButton: int = None

	BCKeypad: int = None

	BCKeyButtonMask: int = None

	BCNoColumn: int = None

	BCAllColumns: int = None

	BCLastColumn: int = None

	BCCommitDataOtherReason: int = None

	BCCommitDataKeyEnterReason: int = None

	BCCommitDataKeyTabReason: int = None

	BCCommitDataKeyBackTabReason: int = None

	BCCaseSensitive: int = None

	BCBeginsWith: int = None

	BCEndsWith: int = None

	BCContains: int = None

	BCExactMatch: int = None

	BCCursorInvalid: int = None

	BCCursorCross: int = None

	BCCursorBlank: int = None

	BCCursorWhatsThis: int = None

	BCCursorWait: int = None

	BCCursorMouse: int = None

	BCCursorExclamation: int = None

	BCCursorArrow: int = None

	BCCursorSizeVer: int = None

	BCCursorSizeHor: int = None

	BCCursorSizeBDiag: int = None

	BCCursorSizeFDiag: int = None

	BCCursorSizeAll: int = None

	BCCursorSplitV: int = None

	BCCursorSplitH: int = None

	BCCursorPointingHand: int = None

	BCCursorForbidden: int = None

	BCCursorOpenHand: int = None

	BCCursorClosedHand: int = None

	BCCursorBusy: int = None

	BCCursorZoomIn: int = None

	BCCursorZoomOut: int = None

	BCCursorIBeam: int = None

	BCCursorUpArrow: int = None

	BCCursorRotate: int = None

	BCCursorZoomRect: int = None

	BCCursorZoom: int = None

	BCCursorPanRotateZoom: int = None

	BCInt: int = None

	BCFloat: int = None

	BCDouble: int = None

	BCString: int = None

	BCStringList: int = None

	BCBool: int = None

	BCInvalid: int = None

	BCDate: int = None

	BCLeftToRight: int = None

	BCRightToLeft: int = None

	BCTopToBottom: int = None

	BCBottomToTop: int = None

	BCDown: int = None

	BCUp: int = None

	BCDockAuto: int = None

	BCDockHorizontal: int = None

	BCDockVertical: int = None

	BCDockNone: int = None

	BCDockLeft: int = None

	BCDockRight: int = None

	BCDockTop: int = None

	BCDockBottom: int = None

	BCNoDrag: int = None

	BCCopy: int = None

	BCMove: int = None

	BCAuto: int = None

	BCInvalidPosition: int = None

	BCAboveTarget: int = None

	BCBelowTarget: int = None

	BCOnTarget: int = None

	BCBoth: int = None

	BCNone: int = None

	BCNormalEchoMode: int = None

	BCNoEchoMode: int = None

	BCPasswordMode: int = None

	BCEventNone: int = None

	BCEventTimer: int = None

	BCEventMouseButtonPress: int = None

	BCEventMouseButtonRelease: int = None

	BCEventMouseButtonDblClick: int = None

	BCEventMouseMove: int = None

	BCEventKeyPress: int = None

	BCEventKeyRelease: int = None

	BCEventFocusIn: int = None

	BCEventFocusOut: int = None

	BCEventEnter: int = None

	BCEventLeave: int = None

	BCEventPaint: int = None

	BCEventMove: int = None

	BCEventResize: int = None

	BCEventCreate: int = None

	BCEventDestroy: int = None

	BCEventShow: int = None

	BCEventHide: int = None

	BCEventClose: int = None

	BCEventQuit: int = None

	BCEventReparent: int = None

	BCEventShowMinimized: int = None

	BCEventShowNormal: int = None

	BCEventWindowActivate: int = None

	BCEventWindowDeactivate: int = None

	BCEventShowToParent: int = None

	BCEventHideToParent: int = None

	BCEventShowMaximized: int = None

	BCEventShowFullScreen: int = None

	BCEventWheel: int = None

	BCEventAccelerator: int = None

	BCEventShortcut: int = None

	BCEventShortcutOverride: int = None

	BCEventWindowEnabled: int = None

	BCEventWindowDisabled: int = None

	BCEventQuitAll: int = None

	BCOnExitHide: int = None

	BCOnExitDestroy: int = None

	BCEquals: int = None

	BCNotEquals: int = None

	BCContain: int = None

	BCNotContain: int = None

	BCLess: int = None

	BCLessOrEqual: int = None

	BCGreater: int = None

	BCGreaterOrEqual: int = None

	BCBetween: int = None

	BCOpen: int = None

	BCSave: int = None

	BCSelect: int = None

	BCDefaultOptions: int = None

	BCNoOverwriteWarning: int = None

	BCShowModal: int = None

	BCSelectFilesAndDirs: int = None

	BCSelectExistingFiles: int = None

	BCCheckForPermissions: int = None

	BCCheckForReadAccess: int = None

	BCCheckForWriteAccess: int = None

	BCMultiSelection: int = None

	BCSingleSelection: int = None

	BCAnyFile: int = None

	BCFilesOnly: int = None

	BCDirectory: int = None

	BCFilesAndDirs: int = None

	BCDirsOnly: int = None

	BCNoFocus: int = None

	BCTabFocus: int = None

	BCClickFocus: int = None

	BCStrongFocus: int = None

	BCWheelFocus: int = None

	BCLeftSide: int = None

	BCRightSide: int = None

	BCHorizontalCenter: int = None

	BCIconsFixed: int = None

	BCAdjust: int = None

	BCAutomatic: int = None

	BCSmall: int = None

	BCLarge: int = None

	BCOffState: int = None

	BCOnState: int = None

	BCShowIndicator: int = None

	BCDontShowIndicator: int = None

	BCDontShowIndicatorWhenChildless: int = None

	BCIterateAll: int = None

	BCIterateSelected: int = None

	BCIterateUnselected: int = None

	BCIterateVisible: int = None

	BCIterateHidden: int = None

	BCIterateFirstLevel: int = None

	BCBesideIcon: int = None

	BCBelowIcon: int = None

	BCHistoryOpen: int = None

	BCHistorySaveAs: int = None

	BCHistorySelect: int = None

	BCHistoryFolders: int = None

	BCHistoryFiles: int = None

	BCHistoryAnything: int = None

	BCDelayedOnSelectedClicked: int = None

	BCDirectOnClicked: int = None

	BCManagedEnable: int = None

	BCManagedDisable: int = None

	BCManagedShow: int = None

	BCManagedHide: int = None

	BCMsgWinIgnore: int = None

	BCMsgWinAccept: int = None

	BCMsgWinReject: int = None

	BCMsgWinCustom: int = None

	BCQuitAll: int = None

	BCEscKey: int = None

	BCRetKey: int = None

	BCNormalMode: int = None

	BCDisabledMode: int = None

	BCActiveMode: int = None

	BCSelectedMode: int = None

	BCClick: int = None

	BCPress: int = None

	BCNotOpen: int = None

	BCReadOnly: int = None

	BCWriteOnly: int = None

	BCReadWrite: int = None

	BCAppend: int = None

	BCTruncate: int = None

	BCText: int = None

	BCUnbuffered: int = None

	BCVertical: int = None

	BCHorizontal: int = None

	BCInDock: int = None

	BCOutsideDock: int = None

	BCPlot3DX: int = None

	BCPlot3DY: int = None

	BCPlot3DZ: int = None

	BCIdlePriority: int = None

	BCLowestPriority: int = None

	BCLowPriority: int = None

	BCNormalPriority: int = None

	BCHighPriority: int = None

	BCHighestPriority: int = None

	BCTimeCriticalPriority: int = None

	BCInheritPriority: int = None

	BCRecordingManagerFilterIncoming: int = None

	BCRecordingManagerFilterOutgoing: int = None

	BCRecursive: int = None

	BCNonRecursive: int = None

	BCRenameType_None: int = None

	BCRenameType_Double: int = None

	BCRenameType_Int: int = None

	BCRenameType_String: int = None

	BCResizeAuto: int = None

	BCResizeStretch: int = None

	BCResizeKeepSize: int = None

	BCResizeFollowSizeHint: int = None

	BCMoveModeNoRestriction: int = None

	BCMoveModeSameDepth: int = None

	BCMulti: int = None

	BCSingle: int = None

	BCNoSelection: int = None

	BCPlain: int = None

	BCSunken: int = None

	BCRaised: int = None

	BCNoFrame: int = None

	BCBox: int = None

	BCPanel: int = None

	BCStyledPanel: int = None

	BCHLine: int = None

	BCVLine: int = None

	BCGroupBoxPanel: int = None

	BCWinPanel: int = None

	BCToolBarPanel: int = None

	BCMenuBarPanel: int = None

	BCPopupPanel: int = None

	BCLineEditPanel: int = None

	BCTabWidgetPanel: int = None

	BCSizeAuto: int = None

	BCSizeSmall: int = None

	BCSizeMedium: int = None

	BCSizeLarge: int = None

	BCSizeExtraLarge: int = None

	BCFixed: int = None

	BCMinimum: int = None

	BCMaximum: int = None

	BCPreferred: int = None

	BCExpanding: int = None

	BCMinimumExpanding: int = None

	BCIgnored: int = None

	BCMessageBoxWarning: int = None

	BCMessageBoxCritical: int = None

	BCMessageBoxInformation: int = None

	BCMessageBoxQuestion: int = None

	BCNoMenu: int = None

	BCInsertRow: int = None

	BCInsertColumn: int = None

	BCDeleteRow: int = None

	BCDeleteColumn: int = None

	BCClipboardFunctions: int = None

	BCAll: int = None

	BCTableNoSelection: int = None

	BCTableMulti: int = None

	BCTableSingle: int = None

	BCTableContiguous: int = None

	BCTableSingleRow: int = None

	BCTableMultiRow: int = None

	BCPlainText: int = None

	BCRichText: int = None

	BCAutoText: int = None

	BCLogText: int = None

	BCTicksNoMarks: int = None

	BCTicksAbove: int = None

	BCTicksLeft: int = None

	BCTicksBelow: int = None

	BCTicksRight: int = None

	BCTicksBoth: int = None

	BCNothing: int = None

	BCCloseButton: int = None

	BCMaximizeButton: int = None

	BCMinimizeButton: int = None

	BCValidatorNone: int = None

	BCValidatorInt: int = None

	BCValidatorDouble: int = None

	BCWidgetStateNone: int = None

	BCWidgetStateInformation: int = None

	BCWidgetStateWarning: int = None

	BCWidgetStateError: int = None

	BCWidgetStateReadOnly: int = None

	BCManualMode: int = None

	BCMaximumMode: int = None

	BCNoWrap: int = None

	BCWidgetWidth: int = None

	BCFixedPixelWidth: int = None

	BCFixedColumnWidth: int = None

	BCManualWrap: int = None

	BCWordWrap: int = None

	BCWrapAnywhere: int = None

	BCWrapAtWordBoundaryOrAnywhere: int = None

	blank: int = None

def BCVBoxCreate(p: object) -> object:

	"""

	Creates a Box in parent p having vertical orientation.
	NOTE: BCVBox is actually a widget not a layout, so for example, it cannot be inserted directly into a BCFrame.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created Box with vertical orientation.

	See Also
	--------
	BCBoxLayoutCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "H/VBoxCreate Example", guitk.constants.BCOnExitDestroy
		    )
		
		    checkBoxReverse = guitk.BCCheckBoxCreate(window, "Reverse Main Layout")
		    guitk.BCCheckBoxSetToggledFunction(checkBoxReverse, reverseToggled, window)
		
		    vBox = guitk.BCVBoxCreate(window)
		    guitk.BCLabelCreate(vBox, "Vertical Label 1")
		    guitk.BCLabelCreate(vBox, "Vertical Label 2")
		    guitk.BCLabelCreate(vBox, "Vertical Label 3")
		
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox, "Horizontal Label 1")
		    guitk.BCLabelCreate(hBox, "Horizontal Label 2")
		
		    vBox2 = guitk.BCVBoxCreate(hBox)
		    guitk.BCLabelCreate(vBox2, "H-V label 1")
		    guitk.BCLabelCreate(vBox2, "H-V label 2")
		    btnFlash = guitk.BCPushButtonCreate(vBox2, "Flash Box", btnFlashClicked, vBox2)
		
		    guitk.BCShow(window)
		
		
		def reverseToggled(checkBOx, state, window):
		    layMain = guitk.BCLayout(window)
		    guitk.BCBoxLayoutSetDirection(
		        layMain,
		        guitk.constants.BCBottomToTop if state else guitk.constants.BCTopToBottom,
		    )
		    return 0
		
		
		def btnFlashClicked(btn, box):
		    guitk.BCFlash(box)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCHBoxCreate(p: object) -> object:

	"""

	Creates a Box in parent p having horizontal orientation.
	NOTE: BCHBox is actually a widget not a layout, so for example, it cannot be inserted directly into a BCFrame.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created Box with horizontal orientation.

	See Also
	--------
	BCBoxLayoutCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "H/VBoxCreate Example", guitk.constants.BCOnExitDestroy
		    )
		
		    checkBoxReverse = guitk.BCCheckBoxCreate(window, "Reverse Main Layout")
		    guitk.BCCheckBoxSetToggledFunction(checkBoxReverse, reverseToggled, window)
		
		    vBox = guitk.BCVBoxCreate(window)
		    guitk.BCLabelCreate(vBox, "Vertical Label 1")
		    guitk.BCLabelCreate(vBox, "Vertical Label 2")
		    guitk.BCLabelCreate(vBox, "Vertical Label 3")
		
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox, "Horizontal Label 1")
		    guitk.BCLabelCreate(hBox, "Horizontal Label 2")
		
		    vBox2 = guitk.BCVBoxCreate(hBox)
		    guitk.BCLabelCreate(vBox2, "H-V label 1")
		    guitk.BCLabelCreate(vBox2, "H-V label 2")
		    btnFlash = guitk.BCPushButtonCreate(vBox2, "Flash Box", btnFlashClicked, vBox2)
		
		    guitk.BCShow(window)
		
		
		def reverseToggled(checkBOx, state, window):
		    layMain = guitk.BCLayout(window)
		    guitk.BCBoxLayoutSetDirection(
		        layMain,
		        guitk.constants.BCBottomToTop if state else guitk.constants.BCTopToBottom,
		    )
		    return 0
		
		
		def btnFlashClicked(btn, box):
		    guitk.BCFlash(box)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPushButtonCreate(p: object, text: str, funct: Callable, data: Any=None) -> object:

	"""

	Creates a new BCPushButton in parent p.

	Parameters
	----------
	p : object
		the parent widget or layout.

	text : str
		the text shown on the button.

	funct : Callable
		the function that will be called when BCPushButton b is activated.
		See BC_BUTTON_CLICKED_FUNCTION for details.
		integer BC_BUTTON_CLICKED_FUNCTION(b, data)
		The function to be called when the BCButton is clicked.
		Note the difference between click and press. Click means first pressed down and then released 
		when the mouse cursor is inside the button. Press operates when button is pressed down.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * b : object
		                    the BCPushButton, or BCToolButton.
		          * data : Any
		                    anything that may be required by the function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	object
		the created BCPushButton.

	See Also
	--------
	BCButtonSetClickedFunction

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		
		    # ToolButtons occupy only the space they need
		    tbut = guitk.BCToolButtonCreate(w, "file_open.svg", "Open", clickFunction, None)
		
		    # whereas PushButtons tend to occupy all available width
		    pbut = guitk.BCPushButtonCreate(w, "Open", clickFunction, None)
		    guitk.BCButtonSetIconFileName(pbut, "file_open.svg")
		
		    guitk.BCShow(w)
		
		
		def clickFunction(b, data):
		    print("Button clicked")
		    return 0
		
		
		main()


	"""

def BCToolButtonCreate(p: object, iconName: str, label: str, funct: Callable, data: Any=None) -> object:

	"""

	Creates a new BCToolButton with parent p.
	BCToolButtons are usually created inside toolbars. BCToolButtons have not been designed to 
	replace BCPushButtons. With a BCToolButton you can have a button operating with a 
	popupMenu without losing its click function. All properties and functions
	of BCPushButtons are valid in BCToolButtons as well. BCToolButtons also support 
	icon with a text beside.

	Parameters
	----------
	p : object
		the parent widget or layout.

	iconName : str
		the filename of the icon.

	label : str
		the label of the BCToolButton.

	funct : Callable
		the function that will be called when BCToolButton b is activated.
		See BC_BUTTON_CLICKED_FUNCTION for details.
		integer BC_BUTTON_CLICKED_FUNCTION(b, data)
		The function to be called when the BCButton is clicked.
		Note the difference between click and press. Click means first pressed down and then released 
		when the mouse cursor is inside the button. Press operates when button is pressed down.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * b : object
		                    the BCPushButton, or BCToolButton.
		          * data : Any
		                    anything that may be required by the function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		another pointer to anything that may be required in funct.

	Returns
	-------
	object
		the created BCToolButton.

	See Also
	--------
	BCButtonSetClickedFunction

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		
		    # ToolButtons occupy only the space they need
		    tbut = guitk.BCToolButtonCreate(w, "file_open.svg", "Open", clickFunction, None)
		
		    # whereas PushButtons tend to occupy all available width
		    pbut = guitk.BCPushButtonCreate(w, "Open", clickFunction, None)
		    guitk.BCButtonSetIconFileName(pbut, "file_open.svg")
		
		    guitk.BCShow(w)
		
		
		def clickFunction(b, data):
		    print("Button clicked")
		    return 0
		
		
		main()


	"""

def BCToolButtonSetDownArrowEnabled(b: object, enabled: bool) -> None:

	"""

	Function is obsolete. Use BCListViewGetSelectedItem() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the BCToolButton.

	enabled : bool
		set True to show or False to hide the down arrow.

	Returns
	-------
	None

	"""

def BCToolButtonDownArrowEnabled(b: object) -> bool:

	"""

	Function is obsolete. Use BCToolButtonIsSideArrowEnabled() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the BCToolButton.

	Returns
	-------
	bool

	"""

def BCToolButtonSetPopupIndicator(b: object, draw: bool) -> None:

	"""

	Sets the appearance of BCToolButton b when a popup is used and the down-arrow has not been enabled.
	When popup is used, the appearance of tool button can be seen with a small triangle at the bottom right corner of the BCToolButton.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the BCToolButton.

	draw : bool
		set True to show (the default) or False to hide the popup indicator.

	Returns
	-------
	None

	See Also
	--------
	BCButtonSetPopup

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SideArrow and PopupIndicator Example", guitk.constants.BCOnExitDestroy
		    )
		
		    popupMenu = guitk.BCPopupMenuCreate(window)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Item 1", None, None)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Item 2", None, None)
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "Default")
		    toolButtonDefault = guitk.BCToolButtonCreate(
		        hBox0, "filter.svg", "ToolButton", None, None
		    )
		    print(
		        "ToolButtonSideArrow Default = "
		        + str(guitk.BCToolButtonIsSideArrowEnabled(toolButtonDefault))
		    )
		    guitk.BCButtonSetPopup(toolButtonDefault, popupMenu)
		
		    hBox1 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox1, "No Side Arrow")
		    toolButtonNoSideArrow = guitk.BCToolButtonCreate(
		        hBox1, "filter.svg", "ToolButton", None, None
		    )
		    guitk.BCToolButtonSetSideArrowEnabled(toolButtonNoSideArrow, False)
		    guitk.BCButtonSetPopup(toolButtonNoSideArrow, popupMenu)
		
		    hBox2 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox2, "No Popup Indicator")
		    toolButtonNoPopupIndicator = guitk.BCToolButtonCreate(
		        hBox2, "filter.svg", "ToolButton", None, None
		    )
		    # False Popup Indicator has no Effect with Side Arrow Enabled
		    guitk.BCToolButtonSetSideArrowEnabled(toolButtonNoPopupIndicator, False)
		    guitk.BCToolButtonSetPopupIndicator(toolButtonNoPopupIndicator, False)
		    guitk.BCButtonSetPopup(toolButtonNoPopupIndicator, popupMenu)
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonSetClickedFunction(b: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function called when an existing button is pressed.

	Parameters
	----------
	b : object
		the BCPushButton.

	funct : Callable
		the function that will be called when BCPushButton b is activated.
		See BC_BUTTON_CLICKED_FUNCTION for details.
		integer BC_BUTTON_CLICKED_FUNCTION(b, data)
		The function to be called when the BCButton is clicked.
		Note the difference between click and press. Click means first pressed down and then released 
		when the mouse cursor is inside the button. Press operates when button is pressed down.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * b : object
		                    the BCPushButton, or BCToolButton.
		          * data : Any
		                    anything that may be required by the function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		another pointer to anything that may be required in funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonAddManagedWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Button", guitk.constants.BCOnExitDestroy)
		    pushBtn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    # Change BCPushbutton's function to call on click.
		    guitk.BCButtonSetClickedFunction(pushBtn, clickFunction, None)
		    label = guitk.BCLabelCreate(window, "Appeared after click")
		    guitk.BCPushButtonSetFlat(pushBtn, True)
		    # BCPushbutton manages BCLabel automatically when clicked
		    guitk.BCButtonAddManagedWidget(
		        pushBtn, label, guitk.constants.BCManagedShow, guitk.constants.BCManagedHide
		    )
		
		    funct_found = guitk.BCButtonRunClickFunction(pushBtn)
		    if funct_found == -1:
		        print("Button's callback function not found.")
		    else:
		        print("Callback function called.")
		
		    guitk.BCShow(window)
		
		
		def clickFunction(button, data):
		    print("Button clicked.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonSetToggleButton(b: object, toggle: bool) -> None:

	"""

	Makes BCPushButton b a toggle button.
	Toggle buttons are BCPushButtons or BCToolButtons that once pressed, remain pressed until the user depresses them.
	It can be seen as On/Off states.

	Parameters
	----------
	b : object
		the button as returned by BCPushButtonCreate() or BCToolButtonCreate()

	toggle : bool
		if True, the BCPushButton becomes a toggle button, otherwise it becomes a normal button.
		
		NOTE: Any BCButtonSetClickedFunction() set will be disabled by this function. You should also use BCButtonSetToggledFunction().

	Returns
	-------
	None

	See Also
	--------
	BCButtonToggle

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		
		    # Although all Buttons can display a PopupMenu...
		    lay_menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 1x1", "mdi_windows_layout_1x1.svg", itemFunction
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 2x1", "mdi_windows_layout_2x1.svg", itemFunction
		    )
		
		    menu_pbut = guitk.BCPushButtonCreate(w, "Layouts", None)
		    guitk.BCButtonSetIconFileName(menu_pbut, "mdi_windows_layout_2x2.svg")
		    guitk.BCButtonSetPopup(menu_pbut, lay_menu)
		
		    menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItem(menu, "Item 1", itemFunction)
		    guitk.BCPopupMenuInsertItem(menu, "Item 2", itemFunction)
		
		    menu_tbut = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCToolButtonSetSideArrowEnabled(menu_tbut, False)
		    guitk.BCButtonSetPopup(menu_tbut, menu)
		
		    # Only BCToolButtons can display a PopupMenu through a separate sub-button,
		    # thus keeping their clicking / toggling functionality
		    toggling_but = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCButtonSetToggleButton(toggling_but, True)
		    guitk.BCButtonSetToggledFunction(toggling_but, toggledFunction)
		    guitk.BCButtonSetPopup(toggling_but, menu)
		
		    guitk.BCShow(w)
		
		
		def itemFunction(pm, id, data):
		    print("Item " + str(id) + " clicked")
		    return 0
		
		
		def toggledFunction(b, state, data):
		    s = "off"
		    if state:
		        s = "on"
		    print("The button is now " + s)
		    return 0
		
		
		main()


	"""

def BCButtonToggle(b: object) -> None:

	"""

	Toggles a toggle BCPushButton b.
	This means that the button's state will change (if button b was pressed it
	depresses it, otherwise it presses it).

	Parameters
	----------
	b : object
		the toggle button to be toggled.
		NOTE: This function should only be called after a call to BCButtonSetToggleButton().

	Returns
	-------
	None

	See Also
	--------
	BCButtonSetToggleButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Toggle Button", guitk.constants.BCOnExitDestroy)
		    btn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    cbox = guitk.BCCheckBoxCreate(window, "Make Button Toggle")
		    cboxToggle = guitk.BCCheckBoxCreate(window, "Check me to toggle the Button")
		    guitk.BCSetEnabled(cboxToggle, False)
		    guitk.BCCheckBoxSetToggledFunction(cbox, setButtonFunct, [btn, cboxToggle])
		    guitk.BCCheckBoxSetToggledFunction(cboxToggle, toggleButtonFunct, btn)
		
		    guitk.BCShow(window)
		
		
		def setButtonFunct(cb, state, data):
		    if state:
		        guitk.BCButtonSetToggleButton(data[0], True)
		        guitk.BCButtonSetToggledFunction(data[0], toggledFunct)
		        guitk.BCButtonToggle(data[0])
		        guitk.BCSetEnabled(data[1], True)
		    else:
		        guitk.BCButtonSetToggleButton(data[0], False)
		        guitk.BCSetEnabled(data[1], False)
		
		    if guitk.BCButtonIsToggleButton(data[0]):
		        guitk.BCButtonSetText(data[0], "Toggle Button")
		    else:
		        guitk.BCButtonSetText(data[0], "No Toggle Button")
		    return 0
		
		
		def toggleButtonFunct(cb, state, btn):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetOn(btn, False)
		    else:
		        guitk.BCButtonSetOn(btn, True)
		    return 0
		
		
		def toggledFunct(btn, state, data):
		    if state:
		        guitk.BCButtonSetText(btn, "Toggled state")
		    else:
		        guitk.BCButtonSetText(btn, "Non Toggled state")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonIsOn(b: object) -> bool:

	"""

	Returns True if the BCPushButton b is toggled, otherwise returns False.

	Parameters
	----------
	b : object
		the BCPushButton or BCToolButton.

	Returns
	-------
	bool
		True if the button b is toggled, otherwise returns False.

	See Also
	--------
	BCButtonSetOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Toggle Button", guitk.constants.BCOnExitDestroy)
		    btn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    cbox = guitk.BCCheckBoxCreate(window, "Make Button Toggle")
		    cboxToggle = guitk.BCCheckBoxCreate(window, "Check me to toggle the Button")
		    guitk.BCSetEnabled(cboxToggle, False)
		    guitk.BCCheckBoxSetToggledFunction(cbox, setButtonFunct, [btn, cboxToggle])
		    guitk.BCCheckBoxSetToggledFunction(cboxToggle, toggleButtonFunct, btn)
		
		    guitk.BCShow(window)
		
		
		def setButtonFunct(cb, state, data):
		    if state:
		        guitk.BCButtonSetToggleButton(data[0], True)
		        guitk.BCButtonSetToggledFunction(data[0], toggledFunct)
		        guitk.BCButtonToggle(data[0])
		        guitk.BCSetEnabled(data[1], True)
		    else:
		        guitk.BCButtonSetToggleButton(data[0], False)
		        guitk.BCSetEnabled(data[1], False)
		
		    if guitk.BCButtonIsToggleButton(data[0]):
		        guitk.BCButtonSetText(data[0], "Toggle Button")
		    else:
		        guitk.BCButtonSetText(data[0], "No Toggle Button")
		    return 0
		
		
		def toggleButtonFunct(cb, state, btn):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetOn(btn, False)
		    else:
		        guitk.BCButtonSetOn(btn, True)
		    return 0
		
		
		def toggledFunct(btn, state, data):
		    if state:
		        guitk.BCButtonSetText(btn, "Toggled state")
		    else:
		        guitk.BCButtonSetText(btn, "Non Toggled state")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonIsToggleButton(b: object) -> bool:

	"""

	Returns True if the BCPushButton b is a toggle button, otherwise(normal button) returns False.

	Parameters
	----------
	b : object
		the BCPushButton.

	Returns
	-------
	bool
		True if the BCPushButton b is a toggle button, otherwise(normal button) returns False.

	See Also
	--------
	BCButtonSetToggleButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Toggle Button", guitk.constants.BCOnExitDestroy)
		    btn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    cbox = guitk.BCCheckBoxCreate(window, "Make Button Toggle")
		    cboxToggle = guitk.BCCheckBoxCreate(window, "Check me to toggle the Button")
		    guitk.BCSetEnabled(cboxToggle, False)
		    guitk.BCCheckBoxSetToggledFunction(cbox, setButtonFunct, [btn, cboxToggle])
		    guitk.BCCheckBoxSetToggledFunction(cboxToggle, toggleButtonFunct, btn)
		
		    guitk.BCShow(window)
		
		
		def setButtonFunct(cb, state, data):
		    if state:
		        guitk.BCButtonSetToggleButton(data[0], True)
		        guitk.BCButtonSetToggledFunction(data[0], toggledFunct)
		        guitk.BCButtonToggle(data[0])
		        guitk.BCSetEnabled(data[1], True)
		    else:
		        guitk.BCButtonSetToggleButton(data[0], False)
		        guitk.BCSetEnabled(data[1], False)
		
		    if guitk.BCButtonIsToggleButton(data[0]):
		        guitk.BCButtonSetText(data[0], "Toggle Button")
		    else:
		        guitk.BCButtonSetText(data[0], "No Toggle Button")
		    return 0
		
		
		def toggleButtonFunct(cb, state, btn):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetOn(btn, False)
		    else:
		        guitk.BCButtonSetOn(btn, True)
		    return 0
		
		
		def toggledFunct(btn, state, data):
		    if state:
		        guitk.BCButtonSetText(btn, "Toggled state")
		    else:
		        guitk.BCButtonSetText(btn, "Non Toggled state")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonSetOn(b: object, on: bool) -> None:

	"""

	Sets whether toggle button b is on (toggled) or not.
	It is meaningful only for toggling buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the button.

	on : bool
		set this parameter to True for the button to be toggled, or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCButtonIsOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Toggle Button", guitk.constants.BCOnExitDestroy)
		    btn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    cbox = guitk.BCCheckBoxCreate(window, "Make Button Toggle")
		    cboxToggle = guitk.BCCheckBoxCreate(window, "Check me to toggle the Button")
		    guitk.BCSetEnabled(cboxToggle, False)
		    guitk.BCCheckBoxSetToggledFunction(cbox, setButtonFunct, [btn, cboxToggle])
		    guitk.BCCheckBoxSetToggledFunction(cboxToggle, toggleButtonFunct, btn)
		
		    guitk.BCShow(window)
		
		
		def setButtonFunct(cb, state, data):
		    if state:
		        guitk.BCButtonSetToggleButton(data[0], True)
		        guitk.BCButtonSetToggledFunction(data[0], toggledFunct)
		        guitk.BCButtonToggle(data[0])
		        guitk.BCSetEnabled(data[1], True)
		    else:
		        guitk.BCButtonSetToggleButton(data[0], False)
		        guitk.BCSetEnabled(data[1], False)
		
		    if guitk.BCButtonIsToggleButton(data[0]):
		        guitk.BCButtonSetText(data[0], "Toggle Button")
		    else:
		        guitk.BCButtonSetText(data[0], "No Toggle Button")
		    return 0
		
		
		def toggleButtonFunct(cb, state, btn):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetOn(btn, False)
		    else:
		        guitk.BCButtonSetOn(btn, True)
		    return 0
		
		
		def toggledFunct(btn, state, data):
		    if state:
		        guitk.BCButtonSetText(btn, "Toggled state")
		    else:
		        guitk.BCButtonSetText(btn, "Non Toggled state")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonSetToggledFunction(b: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when toggle button b is toggled.
	NOTE: this function should only be called after a call to BCButtonSetToggleButton().

	Parameters
	----------
	b : object
		the toggle button.

	funct : Callable
		the function that will be called when toggle button b is toggled.
		See BC_BUTTON_TOGGLED_FUNCTION for details.
		integer BC_BUTTON_TOGGLED_FUNCTION(b, state, data)
		The function to be called when the BCButton is toggled.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * b : object
		                    the BCPushButton, or BCToolButton.
		          * state : int
		                    the toggle state information: 1 when the button is on (i.e. toggled); 0 otherwise.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonToggle

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		
		    # Although all Buttons can display a PopupMenu...
		    lay_menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 1x1", "mdi_windows_layout_1x1.svg", itemFunction
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 2x1", "mdi_windows_layout_2x1.svg", itemFunction
		    )
		
		    menu_pbut = guitk.BCPushButtonCreate(w, "Layouts", None)
		    guitk.BCButtonSetIconFileName(menu_pbut, "mdi_windows_layout_2x2.svg")
		    guitk.BCButtonSetPopup(menu_pbut, lay_menu)
		
		    menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItem(menu, "Item 1", itemFunction)
		    guitk.BCPopupMenuInsertItem(menu, "Item 2", itemFunction)
		
		    menu_tbut = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCToolButtonSetSideArrowEnabled(menu_tbut, False)
		    guitk.BCButtonSetPopup(menu_tbut, menu)
		
		    # Only BCToolButtons can display a PopupMenu through a separate sub-button,
		    # thus keeping their clicking / toggling functionality
		    toggling_but = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCButtonSetToggleButton(toggling_but, True)
		    guitk.BCButtonSetToggledFunction(toggling_but, toggledFunction)
		    guitk.BCButtonSetPopup(toggling_but, menu)
		
		    guitk.BCShow(w)
		
		
		def itemFunction(pm, id, data):
		    print("Item " + str(id) + " clicked")
		    return 0
		
		
		def toggledFunction(b, state, data):
		    s = "off"
		    if state:
		        s = "on"
		    print("The button is now " + s)
		    return 0
		
		
		main()


	"""

def BCButtonSetAllowColorChange(b: object, allow: bool) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the BCToolButton.

	allow : bool
		set this variable to True if you want the toggled button to become red when pressed or to False (the default) if you do not want a color change to take place.

	Returns
	-------
	None

	"""

def BCButtonSetText(b: object, text: str) -> None:

	"""

	Sets the text displayed on BCPushButton or BCToolButton b.
	If you have set an icon with BCButtonSetIconFileName(), it will be removed.

	Parameters
	----------
	b : object
		the button of which the text will be set.

	text : str
		the new text.

	Returns
	-------
	None

	See Also
	--------
	BCButtonSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Toggle Button", guitk.constants.BCOnExitDestroy)
		    btn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    cbox = guitk.BCCheckBoxCreate(window, "Make Button Toggle")
		    cboxToggle = guitk.BCCheckBoxCreate(window, "Check me to toggle the Button")
		    guitk.BCSetEnabled(cboxToggle, False)
		    guitk.BCCheckBoxSetToggledFunction(cbox, setButtonFunct, [btn, cboxToggle])
		    guitk.BCCheckBoxSetToggledFunction(cboxToggle, toggleButtonFunct, btn)
		
		    guitk.BCShow(window)
		
		
		def setButtonFunct(cb, state, data):
		    if state:
		        guitk.BCButtonSetToggleButton(data[0], True)
		        guitk.BCButtonSetToggledFunction(data[0], toggledFunct)
		        guitk.BCButtonToggle(data[0])
		        guitk.BCSetEnabled(data[1], True)
		    else:
		        guitk.BCButtonSetToggleButton(data[0], False)
		        guitk.BCSetEnabled(data[1], False)
		
		    if guitk.BCButtonIsToggleButton(data[0]):
		        guitk.BCButtonSetText(data[0], "Toggle Button")
		    else:
		        guitk.BCButtonSetText(data[0], "No Toggle Button")
		    return 0
		
		
		def toggleButtonFunct(cb, state, btn):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetOn(btn, False)
		    else:
		        guitk.BCButtonSetOn(btn, True)
		    return 0
		
		
		def toggledFunct(btn, state, data):
		    if state:
		        guitk.BCButtonSetText(btn, "Toggled state")
		    else:
		        guitk.BCButtonSetText(btn, "Non Toggled state")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonSetIconFileName(b: object, fileName: str) -> None:

	"""

	Sets the icon that is displayed on the button to be the one specified by fileName.
	This allows an icon to be displayed next to the button's label, as well as to change the button's size.

	Parameters
	----------
	b : object
		the button.

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCButtonSetText

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		
		    # ToolButtons occupy only the space they need
		    tbut = guitk.BCToolButtonCreate(w, "file_open.svg", "Open", clickFunction, None)
		
		    # whereas PushButtons tend to occupy all available width
		    pbut = guitk.BCPushButtonCreate(w, "Open", clickFunction, None)
		    guitk.BCButtonSetIconFileName(pbut, "file_open.svg")
		
		    guitk.BCShow(w)
		
		
		def clickFunction(b, data):
		    print("Button clicked")
		    return 0
		
		
		main()


	"""

def BCButtonAddIconFileName(b: object, fileName: str, mode: int, state: int) -> None:

	"""

	Adds an icon to the button's iconSet that will be displayed when the button is in mode mode and state state.
	This function will operate ONLY on buttons for which an icon file has already been set via BCButtonSetIconFileName() or BCToolButtonCreate().

	Parameters
	----------
	b : object
		the toggle button.

	fileName : str
		the filename of the icon, that will be displayed under mode and state.

	mode : int
		the mode for which a pixmap is intended to be used. See BCEnumMode property for more details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	state : int
		the state for which a pixmap is intended to be used. See BCEnumIconState property for more details.
		
		guitk.constants BCEnumIconState
		This enum describes the state for which a pixmap is intended to be used.
		 - guitk.constants.BCOffState
		Display the pixmap when a toggle button is in an "off" state (unpressed)
		 - guitk.constants.BCOnState
		Display the pixmap when a toggle buttons is in an "on" state (pressed)

	Returns
	-------
	None

	See Also
	--------
	BCButtonSetToggleButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		    toolBtn = guitk.BCToolButtonCreate(window, "file_open.svg", "Open", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, toggledFunction, None)
		    guitk.BCButtonAddIconFileName(
		        toolBtn,
		        "cancel_small.svg",
		        guitk.constants.BCNormalMode,
		        guitk.constants.BCOnState,
		    )
		
		    guitk.BCShow(window)
		
		
		def toggledFunction(button, state, data):
		    btnState = "off"
		    if state:
		        btnState = "on"
		    print("The button is now " + btnState)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonSetPopup(b: object, pm: object) -> None:

	"""

	Binds a BCMenu pm to the BCPushButton or BCToolButton b.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the button.

	pm : object
		the BCMenu.

	Returns
	-------
	None

	See Also
	--------
	BCButtonPopup

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		
		    # Although all Buttons can display a PopupMenu...
		    lay_menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 1x1", "mdi_windows_layout_1x1.svg", itemFunction
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 2x1", "mdi_windows_layout_2x1.svg", itemFunction
		    )
		
		    menu_pbut = guitk.BCPushButtonCreate(w, "Layouts", None)
		    guitk.BCButtonSetIconFileName(menu_pbut, "mdi_windows_layout_2x2.svg")
		    guitk.BCButtonSetPopup(menu_pbut, lay_menu)
		
		    menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItem(menu, "Item 1", itemFunction)
		    guitk.BCPopupMenuInsertItem(menu, "Item 2", itemFunction)
		
		    menu_tbut = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCToolButtonSetSideArrowEnabled(menu_tbut, False)
		    guitk.BCButtonSetPopup(menu_tbut, menu)
		
		    # Only BCToolButtons can display a PopupMenu through a separate sub-button,
		    # thus keeping their clicking / toggling functionality
		    toggling_but = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCButtonSetToggleButton(toggling_but, True)
		    guitk.BCButtonSetToggledFunction(toggling_but, toggledFunction)
		    guitk.BCButtonSetPopup(toggling_but, menu)
		
		    guitk.BCShow(w)
		
		
		def itemFunction(pm, id, data):
		    print("Item " + str(id) + " clicked")
		    return 0
		
		
		def toggledFunction(b, state, data):
		    s = "off"
		    if state:
		        s = "on"
		    print("The button is now " + s)
		    return 0
		
		
		main()


	"""

def BCButtonRunClickFunction(b: object) -> int:

	"""

	Runs the callback function of the button.
	WARNING: Do not use -1 as a valid return value in your callback function. 
	This return value indicates that the function does not exist.

	Parameters
	----------
	b : object
		the button whose function we want to activate.

	Returns
	-------
	int
		the result of the button's clickedFunction or -1 if the function was not set.

	See Also
	--------
	BCButtonSetClickedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Button", guitk.constants.BCOnExitDestroy)
		    pushBtn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    # Change BCPushbutton's function to call on click.
		    guitk.BCButtonSetClickedFunction(pushBtn, clickFunction, None)
		    label = guitk.BCLabelCreate(window, "Appeared after click")
		    guitk.BCPushButtonSetFlat(pushBtn, True)
		    # BCPushbutton manages BCLabel automatically when clicked
		    guitk.BCButtonAddManagedWidget(
		        pushBtn, label, guitk.constants.BCManagedShow, guitk.constants.BCManagedHide
		    )
		
		    funct_found = guitk.BCButtonRunClickFunction(pushBtn)
		    if funct_found == -1:
		        print("Button's callback function not found.")
		    else:
		        print("Callback function called.")
		
		    guitk.BCShow(window)
		
		
		def clickFunction(button, data):
		    print("Button clicked.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonAddManagedWidget(b: object, w: object, oddClick: int, evenClick: int) -> None:

	"""

	This function adds a widget w to a list of widgets that are automatically managed
	when the button b is activated.
	This function operates like the corresponding function of BCCheckBox. Use this function
	if you want, for example, to show/hide a widget using a simple BCPushButton. On first
	button activation, oddClick action will operate, on second evenClick action will operate etc.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the button.

	w : object
		the widget to manage.

	oddClick : int
		the action to perform when button b activated odd times. See BCEnumManagedAction property for more details.
		
		guitk.constants BCEnumManagedAction
		This enum type defines the action to be taken. The managed action is used with BCCheckBoxAddManagedWidget for example.
		 - guitk.constants.BCManagedEnable
		enables the widget.
		 - guitk.constants.BCManagedDisable
		disables the widget.
		 - guitk.constants.BCManagedHide
		hides the widget.
		 - guitk.constants.BCManagedShow
		shows the widget.

	evenClick : int
		the action to perform when button b activated even times. See BCEnumManagedAction property for more details.
		
		guitk.constants BCEnumManagedAction
		This enum type defines the action to be taken. The managed action is used with BCCheckBoxAddManagedWidget for example.
		 - guitk.constants.BCManagedEnable
		enables the widget.
		 - guitk.constants.BCManagedDisable
		disables the widget.
		 - guitk.constants.BCManagedHide
		hides the widget.
		 - guitk.constants.BCManagedShow
		shows the widget.

	Returns
	-------
	None

	See Also
	--------
	BCButtonSetClickedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Button", guitk.constants.BCOnExitDestroy)
		    pushBtn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    # Change BCPushbutton's function to call on click.
		    guitk.BCButtonSetClickedFunction(pushBtn, clickFunction, None)
		    label = guitk.BCLabelCreate(window, "Appeared after click")
		    guitk.BCPushButtonSetFlat(pushBtn, True)
		    # BCPushbutton manages BCLabel automatically when clicked
		    guitk.BCButtonAddManagedWidget(
		        pushBtn, label, guitk.constants.BCManagedShow, guitk.constants.BCManagedHide
		    )
		
		    funct_found = guitk.BCButtonRunClickFunction(pushBtn)
		    if funct_found == -1:
		        print("Button's callback function not found.")
		    else:
		        print("Callback function called.")
		
		    guitk.BCShow(window)
		
		
		def clickFunction(button, data):
		    print("Button clicked.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPushButtonSetFlat(b: object, f: bool) -> None:

	"""

	Makes a button flat or 3D.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the BCPushButton whose flat condition we want to change.

	f : bool
		set this to True if you want the button b to look flat or to False for a 3D look.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Button", guitk.constants.BCOnExitDestroy)
		    pushBtn = guitk.BCPushButtonCreate(window, "Button", None, None)
		    # Change BCPushbutton's function to call on click.
		    guitk.BCButtonSetClickedFunction(pushBtn, clickFunction, None)
		    label = guitk.BCLabelCreate(window, "Appeared after click")
		    guitk.BCPushButtonSetFlat(pushBtn, True)
		    # BCPushbutton manages BCLabel automatically when clicked
		    guitk.BCButtonAddManagedWidget(
		        pushBtn, label, guitk.constants.BCManagedShow, guitk.constants.BCManagedHide
		    )
		
		    funct_found = guitk.BCButtonRunClickFunction(pushBtn)
		    if funct_found == -1:
		        print("Button's callback function not found.")
		    else:
		        print("Callback function called.")
		
		    guitk.BCShow(window)
		
		
		def clickFunction(button, data):
		    print("Button clicked.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonText(b: object) -> str:

	"""

	Returns the label of button b.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the button.

	Returns
	-------
	str
		the button's label.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Message Window Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCPushButtonCreate(window, "Click Me!", buttonPressedFunct, window)
		    guitk.BCPushButtonCreate(window, "Don't Click Me!", buttonPressedFunct, window)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		
		    guitk.BCShow(window)
		
		
		def buttonPressedFunct(b, window):
		    text = guitk.BCButtonText(b)
		    message = "You Pressed button: " + text
		    if text == "Don't Click Me!":
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxCritical, message, False
		        )
		    else:
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxInformation, message, False
		        )
		    guitk.BCMessageWindowSetExtraButton(msgWindow, "Accept All", 10)
		    guitk.BCMessageWindowSetAcceptButtonVisible(msgWindow, False)
		    guitk.BCMessageWindowSetRejectButtonVisible(msgWindow, False)
		    answer = guitk.BCMessageWindowExecute(msgWindow)
		    if answer == 10:
		        print("Message Window: Accept All")
		        guitk.BCWindowAccept(window)
		    elif answer == guitk.constants.BCRetKey:
		        print("Message Window: Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Message Window: Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Message Window: Quit All")
		    return 0
		
		
		def acceptFunction(window, data):
		    print("Main Window: Accept")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonPopup(b: object) -> object:

	"""

	Returns the associated popup menu, or 0 if no popup menu has been set.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the button.

	Returns
	-------
	object
		the button's menu.

	See Also
	--------
	BCButtonSetPopup

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    addNewPopupItem(listView)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addNewPopupItem(listView):
		    btn = guitk.BCListViewFilterButton(listView)
		    if not btn == None:
		        popup = guitk.BCButtonPopup(btn)
		        guitk.BCPopupMenuInsertItem(popup, "Load ListView", loadFilterFunct, listView)
		
		
		def loadFilterFunct(popupMenu, id, listView):
		    print("Load ListView")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonComboBoxCreate(p: object, val: object) -> object:

	"""

	Creates a new BCButtonComboBox.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent Widget or Layout.

	val : object
		a list of strings with which the BCButtonComboBox will be populated.

	Returns
	-------
	object
		the created BCButtonComboBox.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    comboVals = ["Option 1", "Option 2", "Option 3"]
		
		    window = guitk.BCWindowCreate(
		        "Editable - Buttons ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "Button")
		    buttonCombo = guitk.BCButtonComboBoxCreate(hl, comboVals)
		    bRight = guitk.BCToolButtonCreate(
		        buttonCombo, "info_small.svg", "", buttonInfoClickedFunction, None
		    )
		    guitk.BCButtonComboBoxAddRightButton(buttonCombo, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonCombo, "search_small.svg", "", buttonSearchMenuClickedFunction, None
		    )
		    guitk.BCButtonComboBoxAddLeftButton(buttonCombo, bLeft)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonInfoClickedFunction(tb, data):
		    print("Info right button of ButtonComboBox Clicked")
		    return 0
		
		
		def buttonSearchMenuClickedFunction(tb, data):
		    print("Search Menu left button of ButtonComboBox Clicked")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonComboBoxAddLeftButton(bcomb: object, button: object) -> None:

	"""

	Adds a user created tool button, at the left side of the BCButtonLineEdit which is contained at the BCButtonComboBox bcomb
	This function is not supported under VR mode.

	Parameters
	----------
	bcomb : object
		the BCButtonComboBox.

	button : object
		the Toolbutton which will be added at left side of BCButtonLineEdit.

	Returns
	-------
	None

	See Also
	--------
	BCButtonComboBoxAddRightButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    comboVals = ["Option 1", "Option 2", "Option 3"]
		
		    window = guitk.BCWindowCreate(
		        "Editable - Buttons ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "Button")
		    buttonCombo = guitk.BCButtonComboBoxCreate(hl, comboVals)
		    bRight = guitk.BCToolButtonCreate(
		        buttonCombo, "info_small.svg", "", buttonInfoClickedFunction, None
		    )
		    guitk.BCButtonComboBoxAddRightButton(buttonCombo, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonCombo, "search_small.svg", "", buttonSearchMenuClickedFunction, None
		    )
		    guitk.BCButtonComboBoxAddLeftButton(buttonCombo, bLeft)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonInfoClickedFunction(tb, data):
		    print("Info right button of ButtonComboBox Clicked")
		    return 0
		
		
		def buttonSearchMenuClickedFunction(tb, data):
		    print("Search Menu left button of ButtonComboBox Clicked")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonComboBoxAddRightButton(bcomb: object, button: object) -> None:

	"""

	Adds a user created tool button, at the right side of the BCButtonLineEdit which is contained at the BCButtonComboBox bcomb
	This function is not supported under VR mode.

	Parameters
	----------
	bcomb : object
		the BCButtonComboBox.

	button : object
		the Toolbutton which will be added at right side of BCButtonLineEdit.

	Returns
	-------
	None

	See Also
	--------
	BCButtonComboBoxAddLeftButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    comboVals = ["Option 1", "Option 2", "Option 3"]
		
		    window = guitk.BCWindowCreate(
		        "Editable - Buttons ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "Button")
		    buttonCombo = guitk.BCButtonComboBoxCreate(hl, comboVals)
		    bRight = guitk.BCToolButtonCreate(
		        buttonCombo, "info_small.svg", "", buttonInfoClickedFunction, None
		    )
		    guitk.BCButtonComboBoxAddRightButton(buttonCombo, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonCombo, "search_small.svg", "", buttonSearchMenuClickedFunction, None
		    )
		    guitk.BCButtonComboBoxAddLeftButton(buttonCombo, bLeft)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonInfoClickedFunction(tb, data):
		    print("Info right button of ButtonComboBox Clicked")
		    return 0
		
		
		def buttonSearchMenuClickedFunction(tb, data):
		    print("Search Menu left button of ButtonComboBox Clicked")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonComboBoxRemoveButton(bcomb: object, button: object) -> None:

	"""

	Removes a button from the BCButtonComboBox bcomb.
	Removes the button from the BCButtonComboBox's layout, while hiding it. To delete it, use BCDestroyLater() after removing it.
	WARNING: the buttons that are left or right of the removed button will change their index by -1 cause of the remove.
	This function is not supported under VR mode.

	Parameters
	----------
	bcomb : object
		the BCButtonComboBox.

	button : object
		the BCToolbutton which will be removed.

	Returns
	-------
	None

	See Also
	--------
	BCDestroyLater

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonComboBox LineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(bLayout, "Button")
		    btnCmb = guitk.BCButtonComboBoxCreate(bLayout, ["Option 1", "Option 2", "Option 3"])
		    btnAdd = guitk.BCToolButtonCreate(
		        btnCmb, "add_small.svg", "", btnAddClickedFunction, btnCmb
		    )
		    guitk.BCButtonComboBoxAddLeftButton(btnCmb, btnAdd)
		    guitk.BCShow(window)
		
		
		def btnAddClickedFunction(toolBtn, btnCmb):
		    cmbLineEdit = guitk.BCButtonComboBoxGetButtonLineEditWidget(btnCmb)
		    guitk.BCButtonLineEditSetText(cmbLineEdit, "Added a ToolButton to the left")
		    btnRemoveMe = guitk.BCToolButtonCreate(
		        btnCmb, "cancel_small.svg", "", removeMe, btnCmb
		    )
		    guitk.BCButtonComboBoxAddLeftButton(btnCmb, btnRemoveMe)
		    return 0
		
		
		def removeMe(toolBtn, btnCmb):
		    guitk.BCButtonComboBoxRemoveButton(btnCmb, toolBtn)
		    cmbLineEdit = guitk.BCButtonComboBoxGetButtonLineEditWidget(btnCmb)
		    guitk.BCButtonLineEditSetText(cmbLineEdit, "Removed clicked ToolButton")
		    guitk.BCDestroyLater(toolBtn)
		    return 0
		
		
		def acceptFunction(window, btnCmb):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonComboBoxGetLeftButtonAtIndex(bcomb: object, index: int) -> object:

	"""

	Returns a tool button which is located at the left side of the BCButtonLineEdit, which is contained at the BCButtonComboBox bcomb.
	This function is not supported under VR mode.

	Parameters
	----------
	bcomb : object
		the BCButtonComboBox.

	index : int
		the position of button in the left side of BCButtonLineEdit. 
		The button with index 0 is located at the left most edge of the BCButtonLineEdit.

	Returns
	-------
	object

	See Also
	--------
	BCButtonComboBoxGetRightButtonAtIndex

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonComboBox ButtonAtIndex example", guitk.constants.BCOnExitDestroy
		    )
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "ButtonCombo")
		    btnCmb = guitk.BCButtonComboBoxCreate(hBox0, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCButtonComboBoxAddLeftButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "a", None, None)
		    )
		    guitk.BCButtonComboBoxAddLeftButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "b", None, None)
		    )
		    guitk.BCButtonComboBoxAddLeftButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "c", None, None)
		    )
		    guitk.BCButtonComboBoxAddRightButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "d", None, None)
		    )
		    guitk.BCButtonComboBoxAddRightButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "e", None, None)
		    )
		
		    hBox1 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox1, "Print ToolButton at:")
		    cmbIndex = guitk.BCComboBoxCreate(
		        hBox1,
		        [
		            "Left Index 0",
		            "Left Index 1",
		            "Left Index 2",
		            "Right Index 0",
		            "Right Index 1",
		        ],
		    )
		    guitk.BCComboBoxSetActivatedFunction(cmbIndex, cmbIndexActivated, btnCmb)
		
		    guitk.BCShow(window)
		
		
		def cmbIndexActivated(cmb, index, btnCmb):
		    words = guitk.BCComboBoxCurrentText(cmb).split(" ")
		    if words[0] == "Left":
		        toolBtn = guitk.BCButtonComboBoxGetLeftButtonAtIndex(btnCmb, int(words[-1]))
		    else:
		        toolBtn = guitk.BCButtonComboBoxGetRightButtonAtIndex(btnCmb, int(words[-1]))
		    print(guitk.BCButtonText(toolBtn))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonComboBoxGetRightButtonAtIndex(bcomb: object, index: int) -> object:

	"""

	Returns a tool button which is located at the right side of the BCButtonLineEdit, which is contained at the BCButtonComboBox bcomb.
	This function is not supported under VR mode.

	Parameters
	----------
	bcomb : object
		the BCButtonComboBox.

	index : int
		the position of button in the right side of BCButtonLineEdit. 
		The button with index 0 is located at the right most edge of the BCButtonLineEdit.

	Returns
	-------
	object

	See Also
	--------
	BCButtonComboBoxGetLeftButtonAtIndex

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonComboBox ButtonAtIndex example", guitk.constants.BCOnExitDestroy
		    )
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "ButtonCombo")
		    btnCmb = guitk.BCButtonComboBoxCreate(hBox0, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCButtonComboBoxAddLeftButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "a", None, None)
		    )
		    guitk.BCButtonComboBoxAddLeftButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "b", None, None)
		    )
		    guitk.BCButtonComboBoxAddLeftButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "c", None, None)
		    )
		    guitk.BCButtonComboBoxAddRightButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "d", None, None)
		    )
		    guitk.BCButtonComboBoxAddRightButton(
		        btnCmb, guitk.BCToolButtonCreate(btnCmb, "", "e", None, None)
		    )
		
		    hBox1 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox1, "Print ToolButton at:")
		    cmbIndex = guitk.BCComboBoxCreate(
		        hBox1,
		        [
		            "Left Index 0",
		            "Left Index 1",
		            "Left Index 2",
		            "Right Index 0",
		            "Right Index 1",
		        ],
		    )
		    guitk.BCComboBoxSetActivatedFunction(cmbIndex, cmbIndexActivated, btnCmb)
		
		    guitk.BCShow(window)
		
		
		def cmbIndexActivated(cmb, index, btnCmb):
		    words = guitk.BCComboBoxCurrentText(cmb).split(" ")
		    if words[0] == "Left":
		        toolBtn = guitk.BCButtonComboBoxGetLeftButtonAtIndex(btnCmb, int(words[-1]))
		    else:
		        toolBtn = guitk.BCButtonComboBoxGetRightButtonAtIndex(btnCmb, int(words[-1]))
		    print(guitk.BCButtonText(toolBtn))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonComboBoxGetButtonLineEditWidget(bcomb: object) -> object:

	"""

	Returns the BCButtonLineEdit which is located in the BCButtonComboBox bcomb.
	This function is not supported under VR mode.

	Parameters
	----------
	bcomb : object
		the BCButtonComboBox.

	Returns
	-------
	object

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonComboBox LineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(bLayout, "Button")
		    btnCmb = guitk.BCButtonComboBoxCreate(bLayout, ["Option 1", "Option 2", "Option 3"])
		    btnAdd = guitk.BCToolButtonCreate(
		        btnCmb, "add_small.svg", "", btnAddClickedFunction, btnCmb
		    )
		    guitk.BCButtonComboBoxAddLeftButton(btnCmb, btnAdd)
		    guitk.BCShow(window)
		
		
		def btnAddClickedFunction(toolBtn, btnCmb):
		    cmbLineEdit = guitk.BCButtonComboBoxGetButtonLineEditWidget(btnCmb)
		    guitk.BCButtonLineEditSetText(cmbLineEdit, "Added a ToolButton to the left")
		    btnRemoveMe = guitk.BCToolButtonCreate(
		        btnCmb, "cancel_small.svg", "", removeMe, btnCmb
		    )
		    guitk.BCButtonComboBoxAddLeftButton(btnCmb, btnRemoveMe)
		    return 0
		
		
		def removeMe(toolBtn, btnCmb):
		    guitk.BCButtonComboBoxRemoveButton(btnCmb, toolBtn)
		    cmbLineEdit = guitk.BCButtonComboBoxGetButtonLineEditWidget(btnCmb)
		    guitk.BCButtonLineEditSetText(cmbLineEdit, "Removed clicked ToolButton")
		    guitk.BCDestroyLater(toolBtn)
		    return 0
		
		
		def acceptFunction(window, btnCmb):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupCreate(p: object, title: str, o: int) -> object:

	"""

	Constructs a box frame with a title at the top able to group buttons.
	The new BCButtonGroup provides a box frame with title in the top, grouping child
	widgets with vertical or horizontal orientation. BCButtonGroup can accept buttons
	as well as widgets. Note that if you insert non-button widgets you cannot apply
	functionality for buttons (for example exclusive property). The default button 
	group inserts buttons with exclusive property off (unless you insert BCRadioButtons). 
	BCButtonGroups with mixed buttons and non-buttons is not recommended.
	WARNING: It is highly recommended not to use in the same BCButtonGroup mixed types of
	buttons such as BCCheckBoxes, BCRadioButtons etc. A BCButtonGroup sets by default
	the exclusive property for a group with BCRadioButtons, but not for any other button type.
	BCButtonGroups with button types other than BCRadioButtons have to set the exclusive
	property if needed, it is by default set to off.
	In a case of a BCButtonGroup with mixed types of buttons (although this is not recommended)
	exclusive property does not work for buttons other than BCRadioButtons
	even if it has been set explicitly.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	title : str
		a text that will be displayed as the title of the BCButtonGroup.

	o : int
		the child orientation. See BCEnumOrientation property for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	Returns
	-------
	object
		the created BCButtonGroup.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Simple ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		
		    bgroup = guitk.BCButtonGroupCreate(
		        window, "Color Group", guitk.constants.BCVertical
		    )
		
		    # BCButtonGroups with RadioButtons as elements have the exclusive property set enabled by default
		    redRadioButton = guitk.BCRadioButtonCreate(bgroup, "Red", None, None)
		    greenRadioButton = guitk.BCRadioButtonCreate(bgroup, "Green", None, None)
		    blueRadioButton = guitk.BCRadioButtonCreate(bgroup, "Blue", None, None)
		    guitk.BCRadioButtonSetChecked(redRadioButton, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, buttonGroupPressed, None)
		    guitk.BCSpacerCreate(window)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupPressed(bg, index, data):
		    colors = guitk.BCButtonGroupCount(bg)
		    print("There are " + str(colors) + " colors in button group")
		    print("Index is: " + str(index))
		    print("You have picked: ")
		    selectedRadioButton = guitk.BCButtonGroupFind(bg, index)
		    if selectedRadioButton:
		        print(guitk.BCRadioButtonText(selectedRadioButton))
		
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupCreateHidden(p: object, title: str, o: int) -> object:

	"""

	Function is obsolete. Use BCButtonGroupHiddenCreate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	title : str
		the text will not be displayed as the title of the BCButtonGroup.

	o : int
		the child orientation. See BCEnumOrientation property for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	Returns
	-------
	object
		the created BCButtonGroup.

	"""

def BCButtonGroupSelected(bg: object) -> object:

	"""

	Returns the selected toggle button from BCButtonGroup bg if exactly one is selected; 
	otherwise returns None.
	WARNING: It is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	Returns
	-------
	object
		the selected toggle button if exactly one is selected; otherwise returns None.

	See Also
	--------
	BCButtonGroupFind

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Remove Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Mutually exclusive Buttons", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetExclusive(btnGroup, True)
		    btnsBg = [None] * 4
		    for i in range(4):
		        btnBg = guitk.BCPushButtonCreate(btnGroup, "Button " + str(i), None, None)
		        guitk.BCButtonSetToggleButton(btnBg, True)
		        guitk.BCButtonSetToggledFunction(btnBg, printMe, btnGroup)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, btnGroupPressed, None)
		    btnRemove = guitk.BCPushButtonCreate(
		        window, "Remove Selected from ButtonGroup", removeSelectedFromBtnGroup, btnGroup
		    )
		    guitk.BCShow(window)
		
		
		def btnGroupPressed(btnGroup, id, data):
		    print("\\nButton " + str(id) + " is a member of the ButtonGroup")
		    return 0
		
		
		def printMe(b, state, btnGroup):
		    btnText = guitk.BCButtonText(b)
		    if guitk.BCButtonGroupId(btnGroup, b) == -1:
		        print("\\nButton {} is NOT a member of the ButtonGroup".format(btnText))
		    print("{} state set to {}".format(btnText, state))
		    return 0
		
		
		def removeSelectedFromBtnGroup(b, btnGroup):
		    selectedBtn = guitk.BCButtonGroupSelected(btnGroup)
		    if selectedBtn:
		        guitk.BCButtonGroupRemove(btnGroup, selectedBtn)
		        print(
		            "\\nRemoved Button with Id = "
		            + str(guitk.BCButtonGroupGetSelectedId(btnGroup))
		        )
		    else:
		        print("\\nNo selected ButtonGroup Button")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupFind(bg: object, id: int) -> object:

	"""

	Returns the button from BCButtonGroup bg with the specified identifier id, 
	or None if the button was not found.
	WARNING: It is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	id : int
		the identifier of the button.

	Returns
	-------
	object
		the button with the specified identifier id, or None if the button was not found.

	See Also
	--------
	BCButtonGroupSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Exclusive ButtonGroup", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    exclusive = guitk.BCButtonGroupCreate(
		        hl, "Exclusive  Button Group", guitk.constants.BCHorizontal
		    )
		    list = guitk.BCPushButtonCreate(exclusive, "List View", None, None)
		    guitk.BCButtonSetToggleButton(list, True)
		    tree = guitk.BCPushButtonCreate(exclusive, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(tree, True)
		    icon = guitk.BCPushButtonCreate(exclusive, "Icon View", None, None)
		    guitk.BCButtonSetToggleButton(icon, True)
		
		    guitk.BCButtonGroupSetClickedFunction(exclusive, buttonGroupClicked, None)
		
		    guitk.BCButtonGroupSetButton(exclusive, guitk.BCButtonGroupId(exclusive, list))
		    print("Selected index: " + str(guitk.BCButtonGroupGetSelectedId(exclusive)))
		    # BCButtonGroups with elements other than RadioButtons have the exclusive property set off by default
		    guitk.BCButtonGroupSetExclusive(exclusive, True)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupClicked(bg, index, data):
		    button = guitk.BCButtonGroupFind(bg, index)
		    buttonText = guitk.BCButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(bg) == index:
		        print("Index is: " + str(index) + " and button text is: " + buttonText)
		    else:
		        print("I should not be here")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetExclusive(bg: object, exclusive: bool) -> None:

	"""

	Sets whether the button group is exclusive.
	If exclusive is set to True, then the buttons in the group are toggled, and to untoggle
	a button you must click on another button in the group. The default value is False.
	WARNING: It is only applicable to buttons. In case of a BCButtonGroup with BCRadioButtons this property is set by default.
	In a BCButtonGroup with button types other than BCRadioButtons (see BCPushButton etc) this property has to be set if needed
	(by default it is not set).
	In a BCButtonGroup with mixed types of buttons (which is not recommended) this property has been set for the BCRadioButtons of the group by default,
	but it is not for any other button type, even if this property has been set explicitly.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	exclusive : bool
		set this parameter to True to turn exclusive functionality on, or False to turn it off.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Exclusive ButtonGroup", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    exclusive = guitk.BCButtonGroupCreate(
		        hl, "Exclusive  Button Group", guitk.constants.BCHorizontal
		    )
		    list = guitk.BCPushButtonCreate(exclusive, "List View", None, None)
		    guitk.BCButtonSetToggleButton(list, True)
		    tree = guitk.BCPushButtonCreate(exclusive, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(tree, True)
		    icon = guitk.BCPushButtonCreate(exclusive, "Icon View", None, None)
		    guitk.BCButtonSetToggleButton(icon, True)
		
		    guitk.BCButtonGroupSetClickedFunction(exclusive, buttonGroupClicked, None)
		
		    guitk.BCButtonGroupSetButton(exclusive, guitk.BCButtonGroupId(exclusive, list))
		    print("Selected index: " + str(guitk.BCButtonGroupGetSelectedId(exclusive)))
		    # BCButtonGroups with elements other than RadioButtons have the exclusive property set off by default
		    guitk.BCButtonGroupSetExclusive(exclusive, True)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupClicked(bg, index, data):
		    button = guitk.BCButtonGroupFind(bg, index)
		    buttonText = guitk.BCButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(bg) == index:
		        print("Index is: " + str(index) + " and button text is: " + buttonText)
		    else:
		        print("I should not be here")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupInsert(bg: object, button: object, id: int) -> None:

	"""

	Inserts the button button with the identifier id into the BCButtonGroup bg.
	Buttons are normally inserted into a button group automatically by passing the button group as the parent when the button is constructed. 
	So it is not necessary to manually insert buttons that have this button group as their parent widget. 
	An exception is when you want custom identifiers instead of the default 0, 1, 2, etc., or if you want the buttons to have some other parent. Also, when you create a hidden BCButtonGroup (see BCButtonGroupCreateHidden() )
	The button is assigned the identifier id or an automatically generated identifier.
	It works as follows: If id &gt;= 0, this identifier is assigned. 
	If id == -1 (default), the identifier is equal to the number of buttons in the group. 
	If id is any other negative integer, for instance -2, a unique identifier (negative integer &lt;= -2) is generated. 
	No button has an id of -1.
	WARNING: Is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	button : object
		the button to insert.

	id : int
		the button identifier (set to -1 for default behaviour).

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupRemove

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Hidden ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		    hiddenGroup = guitk.BCButtonGroupHiddenCreate(window)
		    option1 = guitk.BCRadioButtonCreate(window, "Input 1", None, None)
		    guitk.BCButtonGroupInsert(hiddenGroup, option1, 0)
		    option2 = guitk.BCRadioButtonCreate(window, "Input 2", None, None)
		    guitk.BCButtonGroupInsert(hiddenGroup, option2, 1)
		    guitk.BCButtonGroupSetButton(
		        hiddenGroup, guitk.BCButtonGroupId(hiddenGroup, option2)
		    )
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupRemove(bg: object, button: object) -> None:

	"""

	Removes the button button from the BCButtonGroup bg. 
	WARNING: Is only applicable to buttons.
	NOTE: Does not destroy the button.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	button : object
		the button to remove.

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupInsert

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Remove Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Mutually exclusive Buttons", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetExclusive(btnGroup, True)
		    btnsBg = [None] * 4
		    for i in range(4):
		        btnBg = guitk.BCPushButtonCreate(btnGroup, "Button " + str(i), None, None)
		        guitk.BCButtonSetToggleButton(btnBg, True)
		        guitk.BCButtonSetToggledFunction(btnBg, printMe, btnGroup)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, btnGroupPressed, None)
		    btnRemove = guitk.BCPushButtonCreate(
		        window, "Remove Selected from ButtonGroup", removeSelectedFromBtnGroup, btnGroup
		    )
		    guitk.BCShow(window)
		
		
		def btnGroupPressed(btnGroup, id, data):
		    print("\\nButton " + str(id) + " is a member of the ButtonGroup")
		    return 0
		
		
		def printMe(b, state, btnGroup):
		    btnText = guitk.BCButtonText(b)
		    if guitk.BCButtonGroupId(btnGroup, b) == -1:
		        print("\\nButton {} is NOT a member of the ButtonGroup".format(btnText))
		    print("{} state set to {}".format(btnText, state))
		    return 0
		
		
		def removeSelectedFromBtnGroup(b, btnGroup):
		    selectedBtn = guitk.BCButtonGroupSelected(btnGroup)
		    if selectedBtn:
		        guitk.BCButtonGroupRemove(btnGroup, selectedBtn)
		        print(
		            "\\nRemoved Button with Id = "
		            + str(guitk.BCButtonGroupGetSelectedId(btnGroup))
		        )
		    else:
		        print("\\nNo selected ButtonGroup Button")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetButton(bg: object, id: int) -> None:

	"""

	Sets selected the toggle button (BCToolButton, BCPushButton, BCCheckBox or BCRadioButton) of BCButtonGroup bg with id id. 
	WARNING: It is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	id : int
		the identifier of the button to set.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Hidden ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		    hiddenGroup = guitk.BCButtonGroupHiddenCreate(window)
		    option1 = guitk.BCRadioButtonCreate(window, "Input 1", None, None)
		    guitk.BCButtonGroupInsert(hiddenGroup, option1, 0)
		    option2 = guitk.BCRadioButtonCreate(window, "Input 2", None, None)
		    guitk.BCButtonGroupInsert(hiddenGroup, option2, 1)
		    guitk.BCButtonGroupSetButton(
		        hiddenGroup, guitk.BCButtonGroupId(hiddenGroup, option2)
		    )
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetPressedFunction(bg: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when a button is pressed on BCButtonGroup bg (be carefull this function is not applicable to title's checkbox). 
	Pressed is used for radio buttons. If you have push buttons or check boxes use click function.
	Note the difference between click and press on a button. Click is generated when left mouse is pressed down and then released when the mouse cursor is inside the button. Press is generated when button is pressed down (with left mouse click).
	WARNING: It is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	funct : Callable
		the function that will be called when a button is pressed inside BCButtonGroup bg.
		See BC_BUTTONGROUP_PRESSED_FUNCTION for details.
		integer BC_BUTTONGROUP_PRESSED_FUNCTION(bg, id, data)
		The function to be called when a button is pressed on BCButtonGroup bg.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * bg : object
		                    the BCButtonGroup.
		          * id : int
		                    the id of the button activated.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupSetClickedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Simple ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		
		    bgroup = guitk.BCButtonGroupCreate(
		        window, "Color Group", guitk.constants.BCVertical
		    )
		
		    # BCButtonGroups with RadioButtons as elements have the exclusive property set enabled by default
		    redRadioButton = guitk.BCRadioButtonCreate(bgroup, "Red", None, None)
		    greenRadioButton = guitk.BCRadioButtonCreate(bgroup, "Green", None, None)
		    blueRadioButton = guitk.BCRadioButtonCreate(bgroup, "Blue", None, None)
		    guitk.BCRadioButtonSetChecked(redRadioButton, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, buttonGroupPressed, None)
		    guitk.BCSpacerCreate(window)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupPressed(bg, index, data):
		    colors = guitk.BCButtonGroupCount(bg)
		    print("There are " + str(colors) + " colors in button group")
		    print("Index is: " + str(index))
		    print("You have picked: ")
		    selectedRadioButton = guitk.BCButtonGroupFind(bg, index)
		    if selectedRadioButton:
		        print(guitk.BCRadioButtonText(selectedRadioButton))
		
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetClickedFunction(bg: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when a button is clicked on BCButtonGroup bg (be carefull this function is not applicable to title's checkbox). 
	Click is used for push buttons and check boxes. If you have radio buttons use press function instead.
	Note the difference between click and press on a button. Click is generated when left mouse is pressed down and then released when the mouse cursor is inside the button. Press is generated when left mouse button is pressed down.
	WARNING: It is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	funct : Callable
		the function that will be called when a button is clicked inside BCButtonGroup bg.
		See BC_BUTTONGROUP_CLICKED_FUNCTION for details.
		integer BC_BUTTONGROUP_CLICKED_FUNCTION(bg, id, data)
		The function to be called when a button is clicked on BCButtonGroup bg.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * bg : object
		                    the BCButtonGroup.
		          * id : int
		                    the id of the button clicked.
		          * data : Any
		                    anything that may be required by the function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupSetPressedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Exclusive ButtonGroup", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    exclusive = guitk.BCButtonGroupCreate(
		        hl, "Exclusive  Button Group", guitk.constants.BCHorizontal
		    )
		    list = guitk.BCPushButtonCreate(exclusive, "List View", None, None)
		    guitk.BCButtonSetToggleButton(list, True)
		    tree = guitk.BCPushButtonCreate(exclusive, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(tree, True)
		    icon = guitk.BCPushButtonCreate(exclusive, "Icon View", None, None)
		    guitk.BCButtonSetToggleButton(icon, True)
		
		    guitk.BCButtonGroupSetClickedFunction(exclusive, buttonGroupClicked, None)
		
		    guitk.BCButtonGroupSetButton(exclusive, guitk.BCButtonGroupId(exclusive, list))
		    print("Selected index: " + str(guitk.BCButtonGroupGetSelectedId(exclusive)))
		    # BCButtonGroups with elements other than RadioButtons have the exclusive property set off by default
		    guitk.BCButtonGroupSetExclusive(exclusive, True)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupClicked(bg, index, data):
		    button = guitk.BCButtonGroupFind(bg, index)
		    buttonText = guitk.BCButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(bg) == index:
		        print("Index is: " + str(index) + " and button text is: " + buttonText)
		    else:
		        print("I should not be here")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupCount(bg: object) -> int:

	"""

	Returns the number of Buttons in BCButtonGroup bg. 
	WARNING: Only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup bg.

	Returns
	-------
	int
		the number of buttons in BCButtonGroup bg.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Simple ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		
		    bgroup = guitk.BCButtonGroupCreate(
		        window, "Color Group", guitk.constants.BCVertical
		    )
		
		    # BCButtonGroups with RadioButtons as elements have the exclusive property set enabled by default
		    redRadioButton = guitk.BCRadioButtonCreate(bgroup, "Red", None, None)
		    greenRadioButton = guitk.BCRadioButtonCreate(bgroup, "Green", None, None)
		    blueRadioButton = guitk.BCRadioButtonCreate(bgroup, "Blue", None, None)
		    guitk.BCRadioButtonSetChecked(redRadioButton, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, buttonGroupPressed, None)
		    guitk.BCSpacerCreate(window)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupPressed(bg, index, data):
		    colors = guitk.BCButtonGroupCount(bg)
		    print("There are " + str(colors) + " colors in button group")
		    print("Index is: " + str(index))
		    print("You have picked: ")
		    selectedRadioButton = guitk.BCButtonGroupFind(bg, index)
		    if selectedRadioButton:
		        print(guitk.BCRadioButtonText(selectedRadioButton))
		
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupId(bg: object, button: object) -> int:

	"""

	Returns the identifier of button button from BCButtonGroup bg. 
	WARNING: Is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	button : object
		the button whose identifier is required.

	Returns
	-------
	int
		the identifier of button button from BCButtonGroup bg.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Exclusive ButtonGroup", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    exclusive = guitk.BCButtonGroupCreate(
		        hl, "Exclusive  Button Group", guitk.constants.BCHorizontal
		    )
		    list = guitk.BCPushButtonCreate(exclusive, "List View", None, None)
		    guitk.BCButtonSetToggleButton(list, True)
		    tree = guitk.BCPushButtonCreate(exclusive, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(tree, True)
		    icon = guitk.BCPushButtonCreate(exclusive, "Icon View", None, None)
		    guitk.BCButtonSetToggleButton(icon, True)
		
		    guitk.BCButtonGroupSetClickedFunction(exclusive, buttonGroupClicked, None)
		
		    guitk.BCButtonGroupSetButton(exclusive, guitk.BCButtonGroupId(exclusive, list))
		    print("Selected index: " + str(guitk.BCButtonGroupGetSelectedId(exclusive)))
		    # BCButtonGroups with elements other than RadioButtons have the exclusive property set off by default
		    guitk.BCButtonGroupSetExclusive(exclusive, True)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupClicked(bg, index, data):
		    button = guitk.BCButtonGroupFind(bg, index)
		    buttonText = guitk.BCButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(bg) == index:
		        print("Index is: " + str(index) + " and button text is: " + buttonText)
		    else:
		        print("I should not be here")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetBorderMode(bg: object, f: int) -> None:

	"""

	Sets the BCButtonGroup bg to be painted without frame if f is BCNoBorder, top frame
	if f is BCTopBorder or full frame mode if f is BCBorder.
	By default a BCButtonGroup has a surrounding frame, with the title being placed on the upper
	frame line. In flat mode (f = BCNoBorder) no frame is shown. In top frame mode (f = BCTopBorder) the right, left
	and bottom frame lines are omitted, and only the thin line at the top is drawn.
	If f is set to any value other than BCBorder, BCNoBorder, BCTopBorder, this function will behave as if BCBorder was set.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	f : int
		set this parameter to BCNoBorder for no frame, BCTopBorder for top frame mode, or BCBorder for full frame mode.
		See BCEnumButtonGroupBorderMode property for details.
		
		guitk.constants BCEnumButtonGroupBorderMode
		This enum type is used to indicate the BCButtonGroup's surrounding frame mode.
		 - guitk.constants.BCBorder
		Top, bottom, left, right border.
		 - guitk.constants.BCNoBorder
		No border
		 - guitk.constants.BCTopBorder
		Only top border.
		 - guitk.constants.BCNoBorderNoMargin
		Removes border and margin of BCButtonGroup.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Borders Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup1 = guitk.BCButtonGroupCreate(
		        window, "Default Button Group", guitk.constants.BCVertical
		    )
		    insertRadioColors(btnGroup1)
		    btnGroup2 = guitk.BCButtonGroupCreate(
		        window, "Top Border Button Group", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetBorderMode(btnGroup2, guitk.constants.BCTopBorder)
		    insertRadioColors(btnGroup2)
		    btnGroup3 = guitk.BCButtonGroupCreate(
		        window, "No Border Button Group", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetBorderMode(btnGroup3, guitk.constants.BCNoBorder)
		    insertRadioColors(btnGroup3)
		    btnGroup4 = guitk.BCButtonGroupCreate(
		        window, "No Border - No Margin Button Group", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetBorderMode(btnGroup4, guitk.constants.BCNoBorderNoMargin)
		    insertRadioColors(btnGroup4)
		    guitk.BCShow(window)
		
		
		# Insert 3 radio buttons function
		def insertRadioColors(btnGroup):
		    redRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Red", None, None)
		    greenRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Green", None, None)
		    blueRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Blue", None, None)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupGetSelectedId(bg: object) -> int:

	"""

	Returns the ID of the selected item of bg, or -1 if no item is selected.
	WARNING: Is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	Returns
	-------
	int
		the ID of the selected item.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Remove Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Mutually exclusive Buttons", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetExclusive(btnGroup, True)
		    btnsBg = [None] * 4
		    for i in range(4):
		        btnBg = guitk.BCPushButtonCreate(btnGroup, "Button " + str(i), None, None)
		        guitk.BCButtonSetToggleButton(btnBg, True)
		        guitk.BCButtonSetToggledFunction(btnBg, printMe, btnGroup)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, btnGroupPressed, None)
		    btnRemove = guitk.BCPushButtonCreate(
		        window, "Remove Selected from ButtonGroup", removeSelectedFromBtnGroup, btnGroup
		    )
		    guitk.BCShow(window)
		
		
		def btnGroupPressed(btnGroup, id, data):
		    print("\\nButton " + str(id) + " is a member of the ButtonGroup")
		    return 0
		
		
		def printMe(b, state, btnGroup):
		    btnText = guitk.BCButtonText(b)
		    if guitk.BCButtonGroupId(btnGroup, b) == -1:
		        print("\\nButton {} is NOT a member of the ButtonGroup".format(btnText))
		    print("{} state set to {}".format(btnText, state))
		    return 0
		
		
		def removeSelectedFromBtnGroup(b, btnGroup):
		    selectedBtn = guitk.BCButtonGroupSelected(btnGroup)
		    if selectedBtn:
		        guitk.BCButtonGroupRemove(btnGroup, selectedBtn)
		        print(
		            "\\nRemoved Button with Id = "
		            + str(guitk.BCButtonGroupGetSelectedId(btnGroup))
		        )
		    else:
		        print("\\nNo selected ButtonGroup Button")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetCheckable(bg: object, checkable: bool) -> None:

	"""

	Sets whether the BCButtonGroup bg has a checkbox in its title to checkable.
	NOTE: This function has no meaning for hidden BCButtonGroups.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	checkable : bool
		this property holds whether the BCButtonGroup bg has a checkbox in its title. If
		this property is True, the BCButtonGroup has a checkbox. If the checkbox is checked
		(which is the default), the BCButtonGroup's children are enabled.

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupIsCheckable, BCButtonGroupSetChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Radio Button Example", guitk.constants.BCOnExitDestroy
		    )
		
		    bgroup = guitk.BCButtonGroupCreate(
		        window, "Settings Group", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetCheckable(bgroup, True)
		    grid = guitk.BCGridLayoutCreate(bgroup, 2, 2)
		    guitk.BCSpacerCreate(window)
		
		    viewRadioButton = guitk.BCRadioButtonCreate(grid, "View", None, None)
		    configurationRadioButton = guitk.BCRadioButtonCreate(
		        grid, "Configuration", None, None
		    )
		    guitk.BCButtonGroupSetButton(bgroup, guitk.BCButtonGroupId(bgroup, viewRadioButton))
		
		    guitk.BCButtonGroupSetPressedFunction(bgroup, buttonGroupPressed)
		
		    pb1 = guitk.BCPushButtonCreate(grid, "Case 1", None, None)
		    pb2 = guitk.BCPushButtonCreate(grid, "Case 2", None, None)
		
		    guitk.BCGridLayoutAddWidget(
		        grid, viewRadioButton, 0, 0, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pb1, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, configurationRadioButton, 1, 0, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pb2, 1, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCRadioButtonAddManagedWidget(
		        viewRadioButton,
		        pb1,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCRadioButtonAddManagedWidget(
		        configurationRadioButton,
		        pb2,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    guitk.BCShow(window)
		
		
		def buttonGroupPressed(bg, index, data):
		    if index == 0:
		        print("View was selected")
		    elif index == 1:
		        print("Configuration was selected")
		    else:
		        print("I should not be here")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupIsCheckable(bg: object) -> bool:

	"""

	Returns True if the BCButtonGroup bg has a checkbox in its title, False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	Returns
	-------
	bool
		True if the BCButtonGroup bg has a checkbox in its title; otherwise returns False.

	See Also
	--------
	BCButtonGroupSetCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Checkable Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup1 = guitk.BCButtonGroupCreate(
		        window, "Default Button Group", guitk.constants.BCVertical
		    )
		    insertRadioColors(btnGroup1)
		    print("btnGroup1 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup1)))
		    btnGroup2 = guitk.BCButtonGroupCreate(
		        window, "Checkable ButtonGroup", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetCheckable(btnGroup2, True)
		    guitk.BCButtonGroupSetToggledFunction(btnGroup2, btnGroup2Toggled, None)
		    print("btnGroup2 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup2)))
		    insertRadioColors(btnGroup2)
		    print(
		        "btnGroup2 Is Checked Default=" + str(guitk.BCButtonGroupIsChecked(btnGroup2))
		    )
		    guitk.BCButtonGroupSetChecked(btnGroup2, False)
		    print("btnGroup2 Is Checked=" + str(guitk.BCButtonGroupIsChecked(btnGroup2)))
		    guitk.BCShow(window)
		
		
		# Insert 3 radio buttons function
		def insertRadioColors(btnGroup):
		    redRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Red", None, None)
		    greenRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Green", None, None)
		    blueRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Blue", None, None)
		
		
		def btnGroup2Toggled(btnGroup, state, data):
		    print("btnGroup2 toggled.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupIsChecked(bg: object) -> bool:

	"""

	Returns True if the BCButtonGroup's checkbox in its title is checked; otherwise returns False.
	NOTE: Use BCButtonGroupSetCheckable() before calling this function.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	Returns
	-------
	bool
		True if the BCButtonGroup's checkbox is checked; otherwise returns False.

	See Also
	--------
	BCButtonGroupSetChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Checkable Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup1 = guitk.BCButtonGroupCreate(
		        window, "Default Button Group", guitk.constants.BCVertical
		    )
		    insertRadioColors(btnGroup1)
		    print("btnGroup1 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup1)))
		    btnGroup2 = guitk.BCButtonGroupCreate(
		        window, "Checkable ButtonGroup", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetCheckable(btnGroup2, True)
		    guitk.BCButtonGroupSetToggledFunction(btnGroup2, btnGroup2Toggled, None)
		    print("btnGroup2 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup2)))
		    insertRadioColors(btnGroup2)
		    print(
		        "btnGroup2 Is Checked Default=" + str(guitk.BCButtonGroupIsChecked(btnGroup2))
		    )
		    guitk.BCButtonGroupSetChecked(btnGroup2, False)
		    print("btnGroup2 Is Checked=" + str(guitk.BCButtonGroupIsChecked(btnGroup2)))
		    guitk.BCShow(window)
		
		
		# Insert 3 radio buttons function
		def insertRadioColors(btnGroup):
		    redRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Red", None, None)
		    greenRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Green", None, None)
		    blueRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Blue", None, None)
		
		
		def btnGroup2Toggled(btnGroup, state, data):
		    print("btnGroup2 toggled.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetToggledFunction(bg: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the checkbox in the title of the BCButtonGroup bg is
	toggled.
	NOTE: Use BCButtonGroupSetCheckable() before calling this function!
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	funct : Callable
		the function that will be called when the bg 's checkbox is toggled. 
		See BC_BUTTONGROUP_TOGGLED_FUNCTION for details.
		integer BC_BUTTONGROUP_TOGGLED_FUNCTION(bg, state, data)
		The function to be called when the checkBox on the title of ButtonGroup bg is toggled.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * bg : object
		                    the BCButtonGroup.
		          * state : int
		                    the toggle state information: 1 when the checkBox is checked; 0 otherwise.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Checkable Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup1 = guitk.BCButtonGroupCreate(
		        window, "Default Button Group", guitk.constants.BCVertical
		    )
		    insertRadioColors(btnGroup1)
		    print("btnGroup1 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup1)))
		    btnGroup2 = guitk.BCButtonGroupCreate(
		        window, "Checkable ButtonGroup", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetCheckable(btnGroup2, True)
		    guitk.BCButtonGroupSetToggledFunction(btnGroup2, btnGroup2Toggled, None)
		    print("btnGroup2 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup2)))
		    insertRadioColors(btnGroup2)
		    print(
		        "btnGroup2 Is Checked Default=" + str(guitk.BCButtonGroupIsChecked(btnGroup2))
		    )
		    guitk.BCButtonGroupSetChecked(btnGroup2, False)
		    print("btnGroup2 Is Checked=" + str(guitk.BCButtonGroupIsChecked(btnGroup2)))
		    guitk.BCShow(window)
		
		
		# Insert 3 radio buttons function
		def insertRadioColors(btnGroup):
		    redRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Red", None, None)
		    greenRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Green", None, None)
		    blueRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Blue", None, None)
		
		
		def btnGroup2Toggled(btnGroup, state, data):
		    print("btnGroup2 toggled.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetChecked(bg: object, checked: bool) -> None:

	"""

	Sets the group box's checkbox in the title value to checked.
	NOTE: Use BCButtonGroupSetCheckable() before calling this function!
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	checked : bool
		set this parameter to True to set the check box checked; False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupIsChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Checkable Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroup1 = guitk.BCButtonGroupCreate(
		        window, "Default Button Group", guitk.constants.BCVertical
		    )
		    insertRadioColors(btnGroup1)
		    print("btnGroup1 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup1)))
		    btnGroup2 = guitk.BCButtonGroupCreate(
		        window, "Checkable ButtonGroup", guitk.constants.BCVertical
		    )
		    guitk.BCButtonGroupSetCheckable(btnGroup2, True)
		    guitk.BCButtonGroupSetToggledFunction(btnGroup2, btnGroup2Toggled, None)
		    print("btnGroup2 Is Checkable=" + str(guitk.BCButtonGroupIsCheckable(btnGroup2)))
		    insertRadioColors(btnGroup2)
		    print(
		        "btnGroup2 Is Checked Default=" + str(guitk.BCButtonGroupIsChecked(btnGroup2))
		    )
		    guitk.BCButtonGroupSetChecked(btnGroup2, False)
		    print("btnGroup2 Is Checked=" + str(guitk.BCButtonGroupIsChecked(btnGroup2)))
		    guitk.BCShow(window)
		
		
		# Insert 3 radio buttons function
		def insertRadioColors(btnGroup):
		    redRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Red", None, None)
		    greenRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Green", None, None)
		    blueRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Blue", None, None)
		
		
		def btnGroup2Toggled(btnGroup, state, data):
		    print("btnGroup2 toggled.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupSetTitle(bg: object, title: str) -> None:

	"""

	Sets the BCButtonGroup's bg title text to title.
	NOTE: This function is not meaningful for hidden BCButtonGroups.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	title : str
		the new title.

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupTitle

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Titles Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroupTitles = guitk.BCButtonGroupCreate(
		        window, "Initial Title", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(btnGroupTitles, "This Title", None, None)
		    guitk.BCRadioButtonCreate(btnGroupTitles, "That Title", None, None)
		    guitk.BCRadioButtonCreate(btnGroupTitles, "Other Title", None, None)
		    guitk.BCButtonGroupSetPressedFunction(btnGroupTitles, bGroupTitlesPressed, None)
		    guitk.BCShow(window)
		
		
		def bGroupTitlesPressed(btnGroup, index, data):
		    selectedRb = guitk.BCButtonGroupFind(btnGroup, index)
		    print("old Title = " + guitk.BCButtonGroupTitle(btnGroup))
		    guitk.BCButtonGroupSetTitle(btnGroup, guitk.BCRadioButtonText(selectedRb))
		    print("new Title = " + guitk.BCButtonGroupTitle(btnGroup))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonGroupTitle(bg: object) -> str:

	"""

	Returns the BCButtonGroup's bg title.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	Returns
	-------
	str
		the title of the BCButtonGroup.

	See Also
	--------
	BCButtonGroupSetTitle

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonGroup Titles Example", guitk.constants.BCOnExitDestroy
		    )
		    btnGroupTitles = guitk.BCButtonGroupCreate(
		        window, "Initial Title", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(btnGroupTitles, "This Title", None, None)
		    guitk.BCRadioButtonCreate(btnGroupTitles, "That Title", None, None)
		    guitk.BCRadioButtonCreate(btnGroupTitles, "Other Title", None, None)
		    guitk.BCButtonGroupSetPressedFunction(btnGroupTitles, bGroupTitlesPressed, None)
		    guitk.BCShow(window)
		
		
		def bGroupTitlesPressed(btnGroup, index, data):
		    selectedRb = guitk.BCButtonGroupFind(btnGroup, index)
		    print("old Title = " + guitk.BCButtonGroupTitle(btnGroup))
		    guitk.BCButtonGroupSetTitle(btnGroup, guitk.BCRadioButtonText(selectedRb))
		    print("new Title = " + guitk.BCButtonGroupTitle(btnGroup))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditCreateDouble(p: object, val: float=guitk.constants.blank) -> object:

	"""

	Creates a BCButtonLineEdit that only accepts doubles.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget.

	val : float, optional
		the double value that will be set to the BCButtonLineEdit.

	Returns
	-------
	object
		the created BCButtonLineEdit.

	See Also
	--------
	BCButtonLineEditCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double ButtonLineEdit")
		    doubleButtonLineEdit = guitk.BCButtonLineEditCreateDouble(hl, 0)
		    guitk.BCButtonLineEditSetDecimals(doubleButtonLineEdit, 2)
		
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        doubleButtonLineEdit, enterpressedFunction, None
		    )
		    bLeft = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit, "clean_small.svg", "", clearFunction, doubleButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(doubleButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit,
		        "apply_small.svg",
		        "",
		        validateFunction,
		        doubleButtonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(doubleButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(hl, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 84.5
		    else:
		        maxvalue = 1000000.0
		    guitk.BCButtonLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditCreateInt(p: object, val: int=guitk.constants.blank) -> object:

	"""

	Creates a BCButtonLineEdit that only accepts integers.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget.

	val : int, optional
		the integer value that will be set to the BCButtonLineEdit.

	Returns
	-------
	object
		the created BCButtonLineEdit.

	See Also
	--------
	BCButtonLineEditCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Integer Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer ButtonLineEdit")
		    intButtonLineEdit = guitk.BCButtonLineEditCreateInt(hl, 0)
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        intButtonLineEdit, enterpressedFunction, None
		    )
		
		    bLeft = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "clean_small.svg", "", clearFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(intButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "apply_small.svg", "", validateFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddRightButton(intButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumintCB = guitk.BCCheckBoxCreate(hl, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumintCB, maximumintFunction, intButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCButtonLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditCreate(p: object, val: str) -> object:

	"""

	Creates a BCButtonLineEdit that accepts any text.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget.

	val : str
		the string that will be set to the BCButtonLineEdit.

	Returns
	-------
	object
		the created BCButtonLineEdit.

	See Also
	--------
	BCButtonLineEditCreateInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "ButtonLineEdit")
		    buttonLineEdit = guitk.BCButtonLineEditCreate(hl, "Press F1")
		
		    bRight = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_right_small.svg",
		        "",
		        buttonAlignRightClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(buttonLineEdit, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_left_small.svg",
		        "",
		        buttonAlignLeftClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddLeftButton(buttonLineEdit, bLeft)
		    guitk.BCButtonLineEditSetF1Function(buttonLineEdit, f1functionPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(ble, data):
		    guitk.BCButtonLineEditSetText(ble, "F1 was pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetText(ble: object) -> str:

	"""

	Returns the text of BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	str
		the text of the BCButtonLineEdit.

	See Also
	--------
	BCButtonLineEditGetInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "This is the text of line edit. This is the selected text."
		    )
		    # On click the selected text will be removed and replaced
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "add_16.png", "Insert New Text", addNewTextFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    cBoxSelectAll = guitk.BCCheckBoxCreate(hBox, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(cBoxSelectAll, selectAllFunct, btnLe)
		    guitk.BCButtonLineEditSetTextChangeFunction(
		        btnLe, textChangedFunct, guitk.BCButtonLineEditGetText(btnLe)
		    )
		    guitk.BCButtonLineEditSetSelectionChangedFunction(
		        btnLe, selectionChangedFunct, None
		    )
		    guitk.BCButtonLineEditSetSelection(btnLe, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def addNewTextFunction(toolBtn, btnLe):
		    newTxt = "This is the new text! "
		    guitk.BCButtonLineEditInsertText(btnLe, newTxt)
		    return 0
		
		
		def textChangedFunct(btnLe, txt, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Text changed to: " + txt)
		    print("Previous text: " + data)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(btnLe, data):
		    print("Currently selected text: " + guitk.BCButtonLineEditGetSelectedText(btnLe))
		    print("Whole text: " + guitk.BCButtonLineEditGetText(btnLe))
		    return 0
		
		
		def selectAllFunct(cBox, state, btnLe):
		    if state:
		        print("Select all activated.")
		        guitk.BCButtonLineEditSelectAll(btnLe)
		    else:
		        print("Select all deactivated.")
		        guitk.BCButtonLineEditSetSelection(btnLe, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetSelectedText(ble: object) -> str:

	"""

	Returns the selected text of BCButtonLineEdit ble or None if nothing is selected.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	str
		the selected text of the BCButtonLineEdit or None if nothing is selected.

	See Also
	--------
	BCButtonLineEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "This is the text of line edit. This is the selected text."
		    )
		    # On click the selected text will be removed and replaced
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "add_16.png", "Insert New Text", addNewTextFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    cBoxSelectAll = guitk.BCCheckBoxCreate(hBox, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(cBoxSelectAll, selectAllFunct, btnLe)
		    guitk.BCButtonLineEditSetTextChangeFunction(
		        btnLe, textChangedFunct, guitk.BCButtonLineEditGetText(btnLe)
		    )
		    guitk.BCButtonLineEditSetSelectionChangedFunction(
		        btnLe, selectionChangedFunct, None
		    )
		    guitk.BCButtonLineEditSetSelection(btnLe, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def addNewTextFunction(toolBtn, btnLe):
		    newTxt = "This is the new text! "
		    guitk.BCButtonLineEditInsertText(btnLe, newTxt)
		    return 0
		
		
		def textChangedFunct(btnLe, txt, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Text changed to: " + txt)
		    print("Previous text: " + data)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(btnLe, data):
		    print("Currently selected text: " + guitk.BCButtonLineEditGetSelectedText(btnLe))
		    print("Whole text: " + guitk.BCButtonLineEditGetText(btnLe))
		    return 0
		
		
		def selectAllFunct(cBox, state, btnLe):
		    if state:
		        print("Select all activated.")
		        guitk.BCButtonLineEditSelectAll(btnLe)
		    else:
		        print("Select all deactivated.")
		        guitk.BCButtonLineEditSetSelection(btnLe, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetInt(ble: object) -> int:

	"""

	Returns the content of BCButtonLineEdit ble in int format.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	int
		the content of the BCButtonLineEdit in int format.

	See Also
	--------
	BCButtonLineEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Integer Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer ButtonLineEdit")
		    intButtonLineEdit = guitk.BCButtonLineEditCreateInt(hl, 0)
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        intButtonLineEdit, enterpressedFunction, None
		    )
		
		    bLeft = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "clean_small.svg", "", clearFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(intButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "apply_small.svg", "", validateFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddRightButton(intButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumintCB = guitk.BCCheckBoxCreate(hl, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumintCB, maximumintFunction, intButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCButtonLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetDouble(ble: object) -> float:

	"""

	Returns the content of BCButtonLineEdit ble in double format.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	float
		the content of the BCButtonLineEdit in double format.

	See Also
	--------
	BCButtonLineEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double ButtonLineEdit")
		    doubleButtonLineEdit = guitk.BCButtonLineEditCreateDouble(hl, 0)
		    guitk.BCButtonLineEditSetDecimals(doubleButtonLineEdit, 2)
		
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        doubleButtonLineEdit, enterpressedFunction, None
		    )
		    bLeft = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit, "clean_small.svg", "", clearFunction, doubleButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(doubleButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit,
		        "apply_small.svg",
		        "",
		        validateFunction,
		        doubleButtonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(doubleButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(hl, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 84.5
		    else:
		        maxvalue = 1000000.0
		    guitk.BCButtonLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetText(ble: object, text: str) -> None:

	"""

	Sets the content of BCButtonLineEdit ble to be the string text.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	text : str
		the new string that will be displayed in BCButtonLineEdit ble.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "ButtonLineEdit")
		    buttonLineEdit = guitk.BCButtonLineEditCreate(hl, "Press F1")
		
		    bRight = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_right_small.svg",
		        "",
		        buttonAlignRightClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(buttonLineEdit, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_left_small.svg",
		        "",
		        buttonAlignLeftClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddLeftButton(buttonLineEdit, bLeft)
		    guitk.BCButtonLineEditSetF1Function(buttonLineEdit, f1functionPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(ble, data):
		    guitk.BCButtonLineEditSetText(ble, "F1 was pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetInt(ble: object, val: int) -> None:

	"""

	Sets the integer value val as the content of BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	val : int
		the integer value that will be displayed in BCButtonLineEdit ble.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Int Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Int ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateInt(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorInt)
		    guitk.BCButtonLineEditSetInt(btnLe, 123)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1005)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1, 4999)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if not guitk.BCButtonLineEditGetValidator(btnLe) == guitk.constants.BCValidatorInt:
		        print("Wrong type of validator.")
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6)":
		            guitk.BCButtonLineEditSetMinLimitInt(btnLe, 6)
		        elif btnText == "Max (1005)":
		            guitk.BCButtonLineEditSetMaxLimitInt(btnLe, 1005)
		        elif btnText == "Both (1, 4999)":
		            guitk.BCButtonLineEditSetMinMaxLimitInt(btnLe, 1, 4999)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitInt(btnLe, -2147483648, 2147483647)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetDouble(ble: object, val: float) -> None:

	"""

	Sets the double value val to be the content of BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	val : float
		the double value that will be displayed in BCButtonLineEdit ble.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetQuestionMarkFunction(ble: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when a question mark (?) is entered in the BCButtonLineEdit.
	NOTE: If BCButtonLineEditSetF1Function() is not set, when pressing F1 the function funct will be called.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_QUESTIONMARK_FUNCTION for details.
		integer BC_LINEEDIT_QUESTIONMARK_FUNCTION(le, data)
		The function to be called when a questionmark (?) is entered in a BCLineEdit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetF1Function

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "Press Enter, F1 or Question mark (?)")
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "align_right_16.png", "", buttonAlignRightClickedFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "align_left_16.png", "", buttonAlignLeftClickedFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    guitk.BCButtonLineEditSetF1Function(btnLe, f1functionPressed, None)
		    guitk.BCButtonLineEditSetQuestionMarkFunction(
		        btnLe, questionMarkfunctionPressed, None
		    )
		    guitk.BCButtonLineEditSetEnterPressedFunction(btnLe, enterPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, btnLe):
		    guitk.BCButtonLineEditSetAlignment(btnLe, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, btnLe):
		    guitk.BCButtonLineEditSetAlignment(btnLe, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(btnLe, data):
		    guitk.BCButtonLineEditSetText(btnLe, "F1 pressed")
		    return 0
		
		
		def questionMarkfunctionPressed(btnLe, data):
		    guitk.BCButtonLineEditSetText(btnLe, "Question Mark (?) pressed")
		    return 0
		
		
		def enterPressed(btnLe, data):
		    guitk.BCButtonLineEditSetText(btnLe, "Enter pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetF1Function(ble: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when F1 key is pressed in the BCButtonLineEdit.
	NOTE: If BCButtonLineEditSetQuestionMarkFunction() is not set, when pressing question mark (?) the function funct will be called.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_F1_FUNCTION for details.
		integer BC_LINEEDIT_F1_FUNCTION(le, data)
		The function to be called when F1 key is pressed in BCLineEdit le.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetQuestionMarkFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "ButtonLineEdit")
		    buttonLineEdit = guitk.BCButtonLineEditCreate(hl, "Press F1")
		
		    bRight = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_right_small.svg",
		        "",
		        buttonAlignRightClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(buttonLineEdit, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_left_small.svg",
		        "",
		        buttonAlignLeftClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddLeftButton(buttonLineEdit, bLeft)
		    guitk.BCButtonLineEditSetF1Function(buttonLineEdit, f1functionPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(ble, data):
		    guitk.BCButtonLineEditSetText(ble, "F1 was pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetTextChangeFunction(ble: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the text changes in the BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_TEXT_CHANGED_FUNCTION for details.
		integer BC_LINEEDIT_TEXT_CHANGED_FUNCTION(le, text, data)
		The function to be called when the text changes in the BCLineEdit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * text : str
		                    the current text in the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetSelectionChangedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "This is the text of line edit. This is the selected text."
		    )
		    # On click the selected text will be removed and replaced
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "add_16.png", "Insert New Text", addNewTextFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    cBoxSelectAll = guitk.BCCheckBoxCreate(hBox, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(cBoxSelectAll, selectAllFunct, btnLe)
		    guitk.BCButtonLineEditSetTextChangeFunction(
		        btnLe, textChangedFunct, guitk.BCButtonLineEditGetText(btnLe)
		    )
		    guitk.BCButtonLineEditSetSelectionChangedFunction(
		        btnLe, selectionChangedFunct, None
		    )
		    guitk.BCButtonLineEditSetSelection(btnLe, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def addNewTextFunction(toolBtn, btnLe):
		    newTxt = "This is the new text! "
		    guitk.BCButtonLineEditInsertText(btnLe, newTxt)
		    return 0
		
		
		def textChangedFunct(btnLe, txt, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Text changed to: " + txt)
		    print("Previous text: " + data)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(btnLe, data):
		    print("Currently selected text: " + guitk.BCButtonLineEditGetSelectedText(btnLe))
		    print("Whole text: " + guitk.BCButtonLineEditGetText(btnLe))
		    return 0
		
		
		def selectAllFunct(cBox, state, btnLe):
		    if state:
		        print("Select all activated.")
		        guitk.BCButtonLineEditSelectAll(btnLe)
		    else:
		        print("Select all deactivated.")
		        guitk.BCButtonLineEditSetSelection(btnLe, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetSelectionChangedFunction(ble: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the selection changes in the BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_SELECTION_CHANGED_FUNCTION for details.
		integer BC_LINEEDIT_SELECTION_CHANGED_FUNCTION(le, data)
		The function to be called when selected text inside a BCLineEdit changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetTextChangeFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "This is the text of line edit. This is the selected text."
		    )
		    # On click the selected text will be removed and replaced
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "add_16.png", "Insert New Text", addNewTextFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    cBoxSelectAll = guitk.BCCheckBoxCreate(hBox, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(cBoxSelectAll, selectAllFunct, btnLe)
		    guitk.BCButtonLineEditSetTextChangeFunction(
		        btnLe, textChangedFunct, guitk.BCButtonLineEditGetText(btnLe)
		    )
		    guitk.BCButtonLineEditSetSelectionChangedFunction(
		        btnLe, selectionChangedFunct, None
		    )
		    guitk.BCButtonLineEditSetSelection(btnLe, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def addNewTextFunction(toolBtn, btnLe):
		    newTxt = "This is the new text! "
		    guitk.BCButtonLineEditInsertText(btnLe, newTxt)
		    return 0
		
		
		def textChangedFunct(btnLe, txt, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Text changed to: " + txt)
		    print("Previous text: " + data)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(btnLe, data):
		    print("Currently selected text: " + guitk.BCButtonLineEditGetSelectedText(btnLe))
		    print("Whole text: " + guitk.BCButtonLineEditGetText(btnLe))
		    return 0
		
		
		def selectAllFunct(cBox, state, btnLe):
		    if state:
		        print("Select all activated.")
		        guitk.BCButtonLineEditSelectAll(btnLe)
		    else:
		        print("Select all deactivated.")
		        guitk.BCButtonLineEditSetSelection(btnLe, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetEnterPressedFunction(ble: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when enter is pressed inside ble.
	If this function returns 1, the default behaviour is completely overridden.
	This means that if you return 0, the accept function of the window that ble belongs, will operate (window may close). If you return 1, the accept will NOT operate and it seems like you pressed a regular key inside BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	funct : Callable
		the function that will be called when enter is pressed. See BC_LINEEDIT_ENTER_PRESSED_FUNCTION for details.
		integer BC_LINEEDIT_ENTER_PRESSED_FUNCTION(le, data)
		The function to be called when enter/return key is pressed inside BCLineEdit le.
		If you return 0, the accept function of the window that le belongs, will
		operate (window may close). If you return 1, the accept will NOT operate and
		it seems like you pressed any regular key inside line edit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 0 if you want accept function of window to operate, otherwise return 1.

	data : Any, optional
		any user data required by funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "Press Enter, F1 or Question mark (?)")
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "align_right_16.png", "", buttonAlignRightClickedFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "align_left_16.png", "", buttonAlignLeftClickedFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    guitk.BCButtonLineEditSetF1Function(btnLe, f1functionPressed, None)
		    guitk.BCButtonLineEditSetQuestionMarkFunction(
		        btnLe, questionMarkfunctionPressed, None
		    )
		    guitk.BCButtonLineEditSetEnterPressedFunction(btnLe, enterPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, btnLe):
		    guitk.BCButtonLineEditSetAlignment(btnLe, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, btnLe):
		    guitk.BCButtonLineEditSetAlignment(btnLe, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(btnLe, data):
		    guitk.BCButtonLineEditSetText(btnLe, "F1 pressed")
		    return 0
		
		
		def questionMarkfunctionPressed(btnLe, data):
		    guitk.BCButtonLineEditSetText(btnLe, "Question Mark (?) pressed")
		    return 0
		
		
		def enterPressed(btnLe, data):
		    guitk.BCButtonLineEditSetText(btnLe, "Enter pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetMinMaxLimitInt(ble: object, minVal: int, maxVal: int) -> None:

	"""

	Sets the minimum and maximum integer values allowed in a BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	minVal : int
		the minimum value.

	maxVal : int
		the maximum value.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Int Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Int ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateInt(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorInt)
		    guitk.BCButtonLineEditSetInt(btnLe, 123)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1005)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1, 4999)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if not guitk.BCButtonLineEditGetValidator(btnLe) == guitk.constants.BCValidatorInt:
		        print("Wrong type of validator.")
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6)":
		            guitk.BCButtonLineEditSetMinLimitInt(btnLe, 6)
		        elif btnText == "Max (1005)":
		            guitk.BCButtonLineEditSetMaxLimitInt(btnLe, 1005)
		        elif btnText == "Both (1, 4999)":
		            guitk.BCButtonLineEditSetMinMaxLimitInt(btnLe, 1, 4999)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitInt(btnLe, -2147483648, 2147483647)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetMinMaxLimitDouble(ble: object, minVal: float, maxVal: float) -> None:

	"""

	Sets the minimum and maximum double values allowed in a BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	minVal : float
		the minimum value.

	maxVal : float
		the maximum value.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetMinMaxLimitInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSelectAll(ble: object) -> None:

	"""

	Selects all the content of a BCButtonLineEdit widget.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "This is the text of line edit. This is the selected text."
		    )
		    # On click the selected text will be removed and replaced
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "add_16.png", "Insert New Text", addNewTextFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    cBoxSelectAll = guitk.BCCheckBoxCreate(hBox, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(cBoxSelectAll, selectAllFunct, btnLe)
		    guitk.BCButtonLineEditSetTextChangeFunction(
		        btnLe, textChangedFunct, guitk.BCButtonLineEditGetText(btnLe)
		    )
		    guitk.BCButtonLineEditSetSelectionChangedFunction(
		        btnLe, selectionChangedFunct, None
		    )
		    guitk.BCButtonLineEditSetSelection(btnLe, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def addNewTextFunction(toolBtn, btnLe):
		    newTxt = "This is the new text! "
		    guitk.BCButtonLineEditInsertText(btnLe, newTxt)
		    return 0
		
		
		def textChangedFunct(btnLe, txt, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Text changed to: " + txt)
		    print("Previous text: " + data)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(btnLe, data):
		    print("Currently selected text: " + guitk.BCButtonLineEditGetSelectedText(btnLe))
		    print("Whole text: " + guitk.BCButtonLineEditGetText(btnLe))
		    return 0
		
		
		def selectAllFunct(cBox, state, btnLe):
		    if state:
		        print("Select all activated.")
		        guitk.BCButtonLineEditSelectAll(btnLe)
		    else:
		        print("Select all deactivated.")
		        guitk.BCButtonLineEditSetSelection(btnLe, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditTakeKeyboard(ble: object) -> None:

	"""

	Takes all the keyboard events from the drawing area and sends them to BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	None

	"""

def BCButtonLineEditSetSizePolicy(ble: object, sizepolicy_h: int, sizepolicy_v: int) -> None:

	"""

	Sets the default layout behavior of the widget.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	sizepolicy_h : int
		the horizontal size policy. See BCEnumSizePolicy for details.
		
		guitk.constants BCEnumSizePolicy
		This enum type holds the default layout behavior of the widget.
		If there is a BCBoxLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such BCBoxLayout, the result of this function is used.
		 - guitk.constants.BCFixed
		this is the default widget policy. The size hint is the only acceptable alternative, so the widget can never grow or shrink (e.g. the vertical direction of a push button).
		 - guitk.constants.BCMinimum
		the size hint is minimal, and sufficient. The widget can be expanded, but there is no advantage to it being larger (e.g. the horizontal direction of a push button). It cannot be smaller than the size provided by size hint.
		 - guitk.constants.BCMaximum
		the size hint is a maximum. The widget can be shrunk any amount without detriment if other widgets need the space (e.g. a separator line). It cannot be larger than the size provided by size hint.
		 - guitk.constants.BCPreferred
		the size hint is best, but the widget can be shrunk and still be useful. The widget can be expanded, but there is no advantage to it being larger than size hint.
		 - guitk.constants.BCExpanding
		the size hint is a sensible size, but the widget can be shrunk and still be useful. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCMinimumExpanding
		the size hint is minimal, and sufficient. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCIgnored
		the size hint is ignored. The widget will get as much space as possible.

	sizepolicy_v : int
		the vertical size policy. See BCEnumSizePolicy for
		details.
		
		guitk.constants BCEnumSizePolicy
		This enum type holds the default layout behavior of the widget.
		If there is a BCBoxLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such BCBoxLayout, the result of this function is used.
		 - guitk.constants.BCFixed
		this is the default widget policy. The size hint is the only acceptable alternative, so the widget can never grow or shrink (e.g. the vertical direction of a push button).
		 - guitk.constants.BCMinimum
		the size hint is minimal, and sufficient. The widget can be expanded, but there is no advantage to it being larger (e.g. the horizontal direction of a push button). It cannot be smaller than the size provided by size hint.
		 - guitk.constants.BCMaximum
		the size hint is a maximum. The widget can be shrunk any amount without detriment if other widgets need the space (e.g. a separator line). It cannot be larger than the size provided by size hint.
		 - guitk.constants.BCPreferred
		the size hint is best, but the widget can be shrunk and still be useful. The widget can be expanded, but there is no advantage to it being larger than size hint.
		 - guitk.constants.BCExpanding
		the size hint is a sensible size, but the widget can be shrunk and still be useful. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCMinimumExpanding
		the size hint is minimal, and sufficient. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCIgnored
		the size hint is ignored. The widget will get as much space as possible.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit:")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "Right-click inside ButtonLineEdit to show popup menu."
		    )
		    label = guitk.BCLabelCreate(window, "Size policy will be shown here.")
		    guitk.BCButtonLineEditSetAddItemsToPopupMenu(btnLe, createPopup, label)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def createPopup(btnLe, popup, label):
		    guitk.BCPopupMenuInsertSeparator(popup)
		    submenuPolicy = guitk.BCPopupMenuCreate(popup)
		    popupHor = guitk.BCPopupMenuCreate(submenuPolicy)
		    popupVer = guitk.BCPopupMenuCreate(submenuPolicy)
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Set Policy", submenuPolicy)
		    guitk.BCPopupMenuInsertPopupMenu(submenuPolicy, "Horizontal", popupHor)
		    guitk.BCPopupMenuInsertPopupMenu(submenuPolicy, "Vertical", popupVer)
		    policySubmenuCreation(submenuPolicy, popupHor, btnLe, label, "Horizontal")
		    policySubmenuCreation(submenuPolicy, popupVer, btnLe, label, "Vertical")
		    return 0
		
		
		def policySubmenuCreation(submenuPolicy, popupOrient, btnLe, label, txtOrient):
		    popupFixed = guitk.BCPopupMenuInsertItem(
		        popupOrient, "Fixed", sizePolicy, [btnLe, label, txtOrient]
		    )
		    popupMinimum = guitk.BCPopupMenuInsertItem(
		        popupOrient, "Minimum", sizePolicy, [btnLe, label, txtOrient]
		    )
		    popupMaximum = guitk.BCPopupMenuInsertItem(
		        popupOrient, "Maximum", sizePolicy, [btnLe, label, txtOrient]
		    )
		    popupPreferred = guitk.BCPopupMenuInsertItem(
		        popupOrient, "Preferred", sizePolicy, [btnLe, label, txtOrient]
		    )
		    popupExpanding = guitk.BCPopupMenuInsertItem(
		        popupOrient, "Expanding", sizePolicy, [btnLe, label, txtOrient]
		    )
		    popupMinimumExpanding = guitk.BCPopupMenuInsertItem(
		        popupOrient, "Minimum Expanding", sizePolicy, [btnLe, label, txtOrient]
		    )
		    popupIgnored = guitk.BCPopupMenuInsertItem(
		        popupOrient, "Ignored", sizePolicy, [btnLe, label, txtOrient]
		    )
		
		
		def sizePolicy(pm, id, data):
		    btnLe = data[0]
		    label = data[1]
		    txtOrient = data[2]
		    labelTxt = guitk.BCLabelText(label)
		    txts = labelTxt.split(", ")
		    defaultEnum = guitk.constants.BCFixed
		    if txtOrient == "Vertical":
		        if len(txts) == 1:
		            newTxt = "Horizontal: Fixed"
		            orientationFunction(btnLe, label, id, True, defaultEnum, newTxt)
		        else:
		            orientation = txts[0].split(": ")
		            hor = orientation[1]
		            newTxt = "Horizontal: " + str(hor)
		            horEnum = decodeOrientation(hor)
		            orientationFunction(btnLe, label, id, True, horEnum, newTxt)
		    else:
		        if len(txts) == 1:
		            newTxt = "Vertical: Fixed"
		            orientationFunction(btnLe, label, id, False, defaultEnum, newTxt)
		        else:
		            orientation = txts[1].split(": ")
		            ver = orientation[1]
		            newTxt = "Vertical: " + str(ver)
		            verEnum = decodeOrientation(ver)
		            orientationFunction(btnLe, label, id, False, verEnum, newTxt)
		    return 0
		
		
		def decodeOrientation(orientation):
		    if orientation == "Minimum":
		        orientEnum = guitk.constants.BCMinimum
		    elif orientation == "Maximum":
		        orientEnum = guitk.constants.BCMaximum
		    elif orientation == "Preferred":
		        orientEnum = guitk.constants.BCPreferred
		    elif orientation == "Expanding":
		        orientEnum = guitk.constants.BCExpanding
		    elif orientation == "Minimum Expanding":
		        orientEnum = guitk.constants.BCMinimumExpanding
		    elif orientation == "Ignored":
		        orientEnum = guitk.constants.BCIgnored
		    else:
		        orientEnum = guitk.constants.BCFixed
		    return orientEnum
		
		
		def orientationFunction(btnLe, label, id, isVer, orientEnum, newTxt):
		    if id == 1:
		        newOrientTxt = "Minimum"
		    elif id == 2:
		        newOrientTxt = "Maximum"
		    elif id == 3:
		        newOrientTxt = "Preferred"
		    elif id == 4:
		        newOrientTxt = "Expanding"
		    elif id == 5:
		        newOrientTxt = "Minimum Expanding"
		    elif id == 6:
		        newOrientTxt = "Ignored"
		    else:
		        newOrientTxt = "Fixed"
		    if isVer:
		        guitk.BCButtonLineEditSetSizePolicy(btnLe, orientEnum, id)
		        newLabelTxt = newTxt + ", Vertical: " + newOrientTxt
		    else:
		        guitk.BCButtonLineEditSetSizePolicy(btnLe, id, orientEnum)
		        newLabelTxt = "Horizontal: " + newOrientTxt + ", " + newTxt
		    guitk.BCLabelSetText(label, newLabelTxt)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetFixedWidth(ble: object, pixels: int) -> None:

	"""

	Function is obsolete. Use BCButtonLineEditSetFixedPixelWidth() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	pixels : int
		the pixels ble will occupy.

	Returns
	-------
	None

	"""

def BCButtonLineEditSetReadOnly(ble: object, readOnly: bool) -> None:

	"""

	Sets the read-only state of BCButtonLineEdit ble (i.e. if input by the user is allowed).
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit that will be affected.

	readOnly : bool
		set this parameter to True to make ble read only.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "Click button for read-only mode.")
		    cBoxMax = guitk.BCCheckBoxCreate(hBox, "Set Max Length to 20 characters")
		    guitk.BCCheckBoxSetToggledFunction(cBoxMax, setMaxFunct, btnLe)
		    btn = guitk.BCPushButtonCreate(window, "Read-Only", None, None)
		    guitk.BCButtonSetToggleButton(btn, True)
		    guitk.BCButtonSetToggledFunction(btn, readOnlyFunction, btnLe)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def setMaxFunct(checkBox, state, btnLe):
		    if state:
		        guitk.BCButtonLineEditSetMaxLength(btnLe, 20)
		    else:
		        guitk.BCButtonLineEditSetMaxLength(btnLe, 32767)
		    print(
		        "Maximum permitted content's length: "
		        + str(guitk.BCButtonLineEditMaxLength(btnLe))
		    )
		    return 0
		
		
		def readOnlyFunction(btn, state, btnLe):
		    guitk.BCButtonLineEditSetReadOnly(btnLe, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetValidator(ble: object, v: int) -> None:

	"""

	Set the validator for BCButtonLineEdit ble to v.
	NOTE: This function also clears the contents of the BCButtonLineEdit!
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	v : int
		the validator type. See BCEnumValidatorType for details.
		
		guitk.constants BCEnumValidatorType
		This enum type defines the types of valid input. It can be used with BCLineEditSetValidator for example.
		 - guitk.constants.BCValidatorNone
		free text input.
		 - guitk.constants.BCValidatorInt
		only integer values are permitted.
		 - guitk.constants.BCValidatorDouble
		double/float values are permitted.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditGetValidator

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetValidator(ble: object) -> int:

	"""

	Returns the validator type of BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	int
		the validator type of the BCButtonLineEdit. See BCEnumValidatorType for details.
		BCEnumValidatorType: This enum type defines the types of valid input. It can be used with BCLineEditSetValidator for example.
		guitk.constants.BCValidatorNone: free text input.
		guitk.constants.BCValidatorInt: only integer values are permitted.
		guitk.constants.BCValidatorDouble: double/float values are permitted.

	See Also
	--------
	BCButtonLineEditSetValidator

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetMinLimitInt(ble: object, minVal: int) -> None:

	"""

	Sets the minimum integer value allowed in a BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	minVal : int
		the minimum value.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Int Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Int ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateInt(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorInt)
		    guitk.BCButtonLineEditSetInt(btnLe, 123)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1005)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1, 4999)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if not guitk.BCButtonLineEditGetValidator(btnLe) == guitk.constants.BCValidatorInt:
		        print("Wrong type of validator.")
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6)":
		            guitk.BCButtonLineEditSetMinLimitInt(btnLe, 6)
		        elif btnText == "Max (1005)":
		            guitk.BCButtonLineEditSetMaxLimitInt(btnLe, 1005)
		        elif btnText == "Both (1, 4999)":
		            guitk.BCButtonLineEditSetMinMaxLimitInt(btnLe, 1, 4999)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitInt(btnLe, -2147483648, 2147483647)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetMaxLimitInt(ble: object, maxVal: int) -> None:

	"""

	Sets the maximum integer value allowed in a BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	maxVal : int
		the maximum value.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Integer Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer ButtonLineEdit")
		    intButtonLineEdit = guitk.BCButtonLineEditCreateInt(hl, 0)
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        intButtonLineEdit, enterpressedFunction, None
		    )
		
		    bLeft = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "clean_small.svg", "", clearFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(intButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "apply_small.svg", "", validateFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddRightButton(intButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumintCB = guitk.BCCheckBoxCreate(hl, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumintCB, maximumintFunction, intButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCButtonLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetMinLimitDouble(ble: object, minVal: float) -> None:

	"""

	Sets the minimum double value allowed in a BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	minVal : float
		the minimum value.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetMaxLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetMaxLimitDouble(ble: object, maxVal: float) -> None:

	"""

	Sets the maximum double value allowed in a BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	maxVal : float
		the maximum value.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditSetMinLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double ButtonLineEdit")
		    doubleButtonLineEdit = guitk.BCButtonLineEditCreateDouble(hl, 0)
		    guitk.BCButtonLineEditSetDecimals(doubleButtonLineEdit, 2)
		
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        doubleButtonLineEdit, enterpressedFunction, None
		    )
		    bLeft = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit, "clean_small.svg", "", clearFunction, doubleButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(doubleButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit,
		        "apply_small.svg",
		        "",
		        validateFunction,
		        doubleButtonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(doubleButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(hl, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 84.5
		    else:
		        maxvalue = 1000000.0
		    guitk.BCButtonLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetCursorPosition(ble: object, pos: int) -> None:

	"""

	Sets the current cursor position for BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	pos : int
		the position in the BCButtonLineEdit to set the cursor.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditGetCursorPosition

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "This is the text of line edit.")
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "align_right_16.png", "Move Right", moveCursorRightFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "align_left_16.png", "Move Left", moveCursorLeftFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    validIndex = 0
		    rBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetRightButtonAtIndex(btnLe, validIndex)
		    )
		    lBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetLeftButtonAtIndex(btnLe, validIndex)
		    )
		    print("Right button's name at index " + str(validIndex) + " is " + rBtnName)
		    print("Left button's name at index " + str(validIndex) + " is " + lBtnName)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def moveCursorRightFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) + 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) - 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetCursorPosition(ble: object) -> int:

	"""

	Returns the current cursor position for BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	int
		the current cursor position.

	See Also
	--------
	BCButtonLineEditSetCursorPosition

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "This is the text of line edit.")
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "align_right_16.png", "Move Right", moveCursorRightFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "align_left_16.png", "Move Left", moveCursorLeftFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    validIndex = 0
		    rBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetRightButtonAtIndex(btnLe, validIndex)
		    )
		    lBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetLeftButtonAtIndex(btnLe, validIndex)
		    )
		    print("Right button's name at index " + str(validIndex) + " is " + rBtnName)
		    print("Left button's name at index " + str(validIndex) + " is " + lBtnName)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def moveCursorRightFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) + 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) - 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetSelection(ble: object, start: int, length: int) -> None:

	"""

	Selects text from position start and for length characters.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	start : int
		the starting position.

	length : int
		the length of the text to be selected.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditGetSelectedText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "This is the text of line edit. This is the selected text."
		    )
		    # On click the selected text will be removed and replaced
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "add_16.png", "Insert New Text", addNewTextFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    cBoxSelectAll = guitk.BCCheckBoxCreate(hBox, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(cBoxSelectAll, selectAllFunct, btnLe)
		    guitk.BCButtonLineEditSetTextChangeFunction(
		        btnLe, textChangedFunct, guitk.BCButtonLineEditGetText(btnLe)
		    )
		    guitk.BCButtonLineEditSetSelectionChangedFunction(
		        btnLe, selectionChangedFunct, None
		    )
		    guitk.BCButtonLineEditSetSelection(btnLe, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def addNewTextFunction(toolBtn, btnLe):
		    newTxt = "This is the new text! "
		    guitk.BCButtonLineEditInsertText(btnLe, newTxt)
		    return 0
		
		
		def textChangedFunct(btnLe, txt, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Text changed to: " + txt)
		    print("Previous text: " + data)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(btnLe, data):
		    print("Currently selected text: " + guitk.BCButtonLineEditGetSelectedText(btnLe))
		    print("Whole text: " + guitk.BCButtonLineEditGetText(btnLe))
		    return 0
		
		
		def selectAllFunct(cBox, state, btnLe):
		    if state:
		        print("Select all activated.")
		        guitk.BCButtonLineEditSelectAll(btnLe)
		    else:
		        print("Select all deactivated.")
		        guitk.BCButtonLineEditSetSelection(btnLe, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetMaxLength(ble: object, length: int) -> None:

	"""

	Sets the maximum permitted content's length of the BCButtonLineEdit ble.
	If the text is too long, it is truncated to the limit. If truncation occurs any selected text will be deselected, the cursor position is set to 0 and the first part of the string is shown.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	length : int
		the maximum permitted content's length.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditMaxLength

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "Click button for read-only mode.")
		    cBoxMax = guitk.BCCheckBoxCreate(hBox, "Set Max Length to 20 characters")
		    guitk.BCCheckBoxSetToggledFunction(cBoxMax, setMaxFunct, btnLe)
		    btn = guitk.BCPushButtonCreate(window, "Read-Only", None, None)
		    guitk.BCButtonSetToggleButton(btn, True)
		    guitk.BCButtonSetToggledFunction(btn, readOnlyFunction, btnLe)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def setMaxFunct(checkBox, state, btnLe):
		    if state:
		        guitk.BCButtonLineEditSetMaxLength(btnLe, 20)
		    else:
		        guitk.BCButtonLineEditSetMaxLength(btnLe, 32767)
		    print(
		        "Maximum permitted content's length: "
		        + str(guitk.BCButtonLineEditMaxLength(btnLe))
		    )
		    return 0
		
		
		def readOnlyFunction(btn, state, btnLe):
		    guitk.BCButtonLineEditSetReadOnly(btnLe, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditMaxLength(ble: object) -> int:

	"""

	Returns the maximum permitted length of the content.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	int
		the maximum permitted length of the content.

	See Also
	--------
	BCButtonLineEditSetMaxLength

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "Click button for read-only mode.")
		    cBoxMax = guitk.BCCheckBoxCreate(hBox, "Set Max Length to 20 characters")
		    guitk.BCCheckBoxSetToggledFunction(cBoxMax, setMaxFunct, btnLe)
		    btn = guitk.BCPushButtonCreate(window, "Read-Only", None, None)
		    guitk.BCButtonSetToggleButton(btn, True)
		    guitk.BCButtonSetToggledFunction(btn, readOnlyFunction, btnLe)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def setMaxFunct(checkBox, state, btnLe):
		    if state:
		        guitk.BCButtonLineEditSetMaxLength(btnLe, 20)
		    else:
		        guitk.BCButtonLineEditSetMaxLength(btnLe, 32767)
		    print(
		        "Maximum permitted content's length: "
		        + str(guitk.BCButtonLineEditMaxLength(btnLe))
		    )
		    return 0
		
		
		def readOnlyFunction(btn, state, btnLe):
		    guitk.BCButtonLineEditSetReadOnly(btnLe, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditClear(ble: object) -> None:

	"""

	Clears the contents of the BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Integer Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer ButtonLineEdit")
		    intButtonLineEdit = guitk.BCButtonLineEditCreateInt(hl, 0)
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        intButtonLineEdit, enterpressedFunction, None
		    )
		
		    bLeft = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "clean_small.svg", "", clearFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(intButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "apply_small.svg", "", validateFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddRightButton(intButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumintCB = guitk.BCCheckBoxCreate(hl, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumintCB, maximumintFunction, intButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCButtonLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetAlignment(ble: object, alignment: int) -> None:

	"""

	Sets the alignment of the BCButtonLineEdit's content.
	By definition, numbers are aligned right while strings are aligned left. Use this function if you want for example to design a BCButtonLineEdit that accepts %, or characters for calculations and you want to align the content to the right to show that this is a number.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	alignment : int
		specifies the required alignment. See BCEnumAlignment for details.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "ButtonLineEdit")
		    buttonLineEdit = guitk.BCButtonLineEditCreate(hl, "Press F1")
		
		    bRight = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_right_small.svg",
		        "",
		        buttonAlignRightClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(buttonLineEdit, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_left_small.svg",
		        "",
		        buttonAlignLeftClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddLeftButton(buttonLineEdit, bLeft)
		    guitk.BCButtonLineEditSetF1Function(buttonLineEdit, f1functionPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(ble, data):
		    guitk.BCButtonLineEditSetText(ble, "F1 was pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditValidate(ble: object) -> int:

	"""

	Validates the input of BCButtonLineEdit ble about minimum and maximum value.
	ble is validated if it is created with BCButtonLineEditCreateInt()  or BCButtonLineEditCreateDouble(); otherwise returns 0.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	int
		1 if the value entered is a valid value, i.e., between minimum and maximum values (if any). In case value is not valid or ble accepts any text, 0 is returned.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Integer Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer ButtonLineEdit")
		    intButtonLineEdit = guitk.BCButtonLineEditCreateInt(hl, 0)
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        intButtonLineEdit, enterpressedFunction, None
		    )
		
		    bLeft = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "clean_small.svg", "", clearFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(intButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        intButtonLineEdit, "apply_small.svg", "", validateFunction, intButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddRightButton(intButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumintCB = guitk.BCCheckBoxCreate(hl, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumintCB, maximumintFunction, intButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCButtonLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditMaxLimitDouble(ble: object) -> float:

	"""

	Returns the maximum double value allowed in the BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	float
		the maximum double value allowed in a BCButtonLineEdit.

	See Also
	--------
	BCButtonLineEditMinLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditMinLimitDouble(ble: object) -> float:

	"""

	Returns the minimum double value allowed in the BCButtonLineEdit ble.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	float
		the minimum double value allowed in a BCButtonLineEdit.

	See Also
	--------
	BCButtonLineEditMaxLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetDecimals(ble: object, numDecimals: int) -> None:

	"""

	Sets the number of decimal digits to validate in a BCButtonLineEdit which accepts only  doubles.
	NOTE: The value set by this function will affect the number of digits that can be shown into a BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	numDecimals : int
		the number of decimal digits to validate.

	Returns
	-------
	None

	See Also
	--------
	BCButtonLineEditDecimals

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double ButtonLineEdit")
		    doubleButtonLineEdit = guitk.BCButtonLineEditCreateDouble(hl, 0)
		    guitk.BCButtonLineEditSetDecimals(doubleButtonLineEdit, 2)
		
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        doubleButtonLineEdit, enterpressedFunction, None
		    )
		    bLeft = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit, "clean_small.svg", "", clearFunction, doubleButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(doubleButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit,
		        "apply_small.svg",
		        "",
		        validateFunction,
		        doubleButtonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(doubleButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(hl, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 84.5
		    else:
		        maxvalue = 1000000.0
		    guitk.BCButtonLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditDecimals(ble: object) -> int:

	"""

	Returns the number of decimal digits to validate in a BCButtonLineEdit which accepts only  doubles.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	int
		the number of decimal digits to validate if BCButtonLineEdit accepts doubles ; -1 in case BCButtonLineEdit accepts any text or integers.

	See Also
	--------
	BCButtonLineEditSetDecimals

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hBox, "Double ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreateDouble(hBox, 0)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "clean_small.svg", "", clearFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "apply_small.svg", "Accept", validateFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    guitk.BCButtonLineEditSetValidator(btnLe, guitk.constants.BCValidatorDouble)
		    guitk.BCButtonLineEditSetDouble(btnLe, 32.24)
		    guitk.BCButtonLineEditSetDecimals(btnLe, 2)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, btnLe)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, btnLe):
		    guitk.BCButtonLineEditClear(btnLe)
		    return 0
		
		
		def validateFunction(toolBtn, btnLe):
		    if (
		        not guitk.BCButtonLineEditGetValidator(btnLe)
		        == guitk.constants.BCValidatorDouble
		    ):
		        print("Wrong type of validator.")
		    decimal = guitk.BCButtonLineEditDecimals(btnLe)
		    print("The number of decimal digits to validate is: " + str(decimal))
		    if guitk.BCButtonLineEditValidate(btnLe):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(btnLe)
		    return 0
		
		
		def limitsFunction(btnGroup, index, btnLe):
		    btn = guitk.BCButtonGroupFind(btnGroup, index)
		    btnText = guitk.BCRadioButtonText(btn)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if btnText == "Min (6.5)":
		            guitk.BCButtonLineEditSetMinLimitDouble(btnLe, 6.5)
		        elif btnText == "Max (1004.73)":
		            guitk.BCButtonLineEditSetMaxLimitDouble(btnLe, 1004.73)
		        elif btnText == "Both (1.23, 456.7)":
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(btnLe, 1.23, 456.7)
		        else:
		            guitk.BCButtonLineEditSetMinMaxLimitDouble(
		                btnLe, float("-inf"), float("inf")
		            )
		    currentMax = guitk.BCButtonLineEditMaxLimitDouble(btnLe)
		    currentMin = guitk.BCButtonLineEditMinLimitDouble(btnLe)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditApplyValidator(ble: object) -> None:

	"""

	Applies the validator (if any) of BCButtonLineEdit ble.
	If the BCButtonLineEdit has not any validator set, i.e. it accepts any text, this function does nothing.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double ButtonLineEdit")
		    doubleButtonLineEdit = guitk.BCButtonLineEditCreateDouble(hl, 0)
		    guitk.BCButtonLineEditSetDecimals(doubleButtonLineEdit, 2)
		
		    guitk.BCButtonLineEditSetEnterPressedFunction(
		        doubleButtonLineEdit, enterpressedFunction, None
		    )
		    bLeft = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit, "clean_small.svg", "", clearFunction, doubleButtonLineEdit
		    )
		    guitk.BCButtonLineEditAddLeftButton(doubleButtonLineEdit, bLeft)
		
		    bRight = guitk.BCToolButtonCreate(
		        doubleButtonLineEdit,
		        "apply_small.svg",
		        "",
		        validateFunction,
		        doubleButtonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(doubleButtonLineEdit, bRight)
		    guitk.BCAddToolTip(bRight, "Validate LineEdit value")
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(hl, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleButtonLineEdit
		    )
		
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 84.5
		    else:
		        maxvalue = 1000000.0
		    guitk.BCButtonLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def enterpressedFunction(le, data):
		    if guitk.BCButtonLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCButtonLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    guitk.BCButtonLineEditApplyValidator(le)
		    return 1
		
		
		def validateFunction(tb, data):
		    if guitk.BCButtonLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCButtonLineEditClear(data)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditInsertText(ble: object, text: str) -> None:

	"""

	Deletes any selected text and inserts text in cursor's position.
	It also validates the result. If it is valid, it sets it as the new contents of the BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	text : str
		the inserted text.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "This is the text of line edit. This is the selected text."
		    )
		    # On click the selected text will be removed and replaced
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "add_16.png", "Insert New Text", addNewTextFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    cBoxSelectAll = guitk.BCCheckBoxCreate(hBox, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(cBoxSelectAll, selectAllFunct, btnLe)
		    guitk.BCButtonLineEditSetTextChangeFunction(
		        btnLe, textChangedFunct, guitk.BCButtonLineEditGetText(btnLe)
		    )
		    guitk.BCButtonLineEditSetSelectionChangedFunction(
		        btnLe, selectionChangedFunct, None
		    )
		    guitk.BCButtonLineEditSetSelection(btnLe, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def addNewTextFunction(toolBtn, btnLe):
		    newTxt = "This is the new text! "
		    guitk.BCButtonLineEditInsertText(btnLe, newTxt)
		    return 0
		
		
		def textChangedFunct(btnLe, txt, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Text changed to: " + txt)
		    print("Previous text: " + data)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(btnLe, data):
		    print("Currently selected text: " + guitk.BCButtonLineEditGetSelectedText(btnLe))
		    print("Whole text: " + guitk.BCButtonLineEditGetText(btnLe))
		    return 0
		
		
		def selectAllFunct(cBox, state, btnLe):
		    if state:
		        print("Select all activated.")
		        guitk.BCButtonLineEditSelectAll(btnLe)
		    else:
		        print("Select all deactivated.")
		        guitk.BCButtonLineEditSetSelection(btnLe, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetAddItemsToPopupMenu(ble: object, funct: Callable, data: Any=None) -> None:

	"""

	Adds custom menu items or sub-popups above the default menu items of BCButtonLineEdit's right-mouse-click popup menu.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	funct : Callable
		the callback function which must be called to create the custom menu.
		See BC_LINEEDIT_ADD_ITEMS_TO_POPUPMENU_FUNCTION for details.
		integer BC_LINEEDIT_ADD_ITEMS_TO_POPUPMENU_FUNCTION(le, popup, data)
		The function to add items to the popup on a right mouse click over the le BCLineEdit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * popup : object
		                    the BCLineEdit's BCMenu with the default menu items to which you want to add extra items.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit:")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "Right-click inside ButtonLineEdit to show popup menu."
		    )
		    guitk.BCButtonLineEditSetAddItemsToPopupMenu(btnLe, createPopup, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def createPopup(btnLe, popup, data):
		    guitk.BCPopupMenuInsertSeparator(popup)
		    submenu = guitk.BCPopupMenuCreate(popup)
		    popup_20 = guitk.BCPopupMenuInsertItem(submenu, "20", widthFunction, btnLe)
		    popup_40 = guitk.BCPopupMenuInsertItem(submenu, "40", widthFunction, btnLe)
		    popup_60 = guitk.BCPopupMenuInsertItem(submenu, "60", widthFunction, btnLe)
		    popup_80 = guitk.BCPopupMenuInsertItem(submenu, "80", widthFunction, btnLe)
		    popup_100 = guitk.BCPopupMenuInsertItem(submenu, "100", widthFunction, btnLe)
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Set Width", submenu)
		    return 0
		
		
		def widthFunction(pm, id, btnLe):
		    if id == 0:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 20)
		    elif id == 1:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 40)
		    elif id == 2:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 60)
		    elif id == 3:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 80)
		    elif id == 4:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 100)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditAddLeftButton(ble: object, button: object) -> None:

	"""

	Adds a tool button, which must be created by the developer beforehand, to the left side of BCButtonLineEdit.
	\warning: The button must be created with parent the current BCButtonLineEdit and must be a BCToolButton.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	button : object
		the button that will be added to the left side of BCButtonLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "ButtonLineEdit")
		    buttonLineEdit = guitk.BCButtonLineEditCreate(hl, "Press F1")
		
		    bRight = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_right_small.svg",
		        "",
		        buttonAlignRightClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(buttonLineEdit, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_left_small.svg",
		        "",
		        buttonAlignLeftClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddLeftButton(buttonLineEdit, bLeft)
		    guitk.BCButtonLineEditSetF1Function(buttonLineEdit, f1functionPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(ble, data):
		    guitk.BCButtonLineEditSetText(ble, "F1 was pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditAddRightButton(ble: object, button: object) -> None:

	"""

	Adds a tool button, which must be created by the developer beforehand, to the right side of BCButtonLineEdit.
	\warning: The button must be created with parent the current BCButtonLineEdit and must be a BCToolButton.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	button : object
		the button that will be added to the right side of BCButtonLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "ButtonLineEdit")
		    buttonLineEdit = guitk.BCButtonLineEditCreate(hl, "Press F1")
		
		    bRight = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_right_small.svg",
		        "",
		        buttonAlignRightClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddRightButton(buttonLineEdit, bRight)
		    bLeft = guitk.BCToolButtonCreate(
		        buttonLineEdit,
		        "cell_align_left_small.svg",
		        "",
		        buttonAlignLeftClickedFunction,
		        buttonLineEdit,
		    )
		    guitk.BCButtonLineEditAddLeftButton(buttonLineEdit, bLeft)
		    guitk.BCButtonLineEditSetF1Function(buttonLineEdit, f1functionPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def buttonAlignRightClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    return 0
		
		
		def buttonAlignLeftClickedFunction(tb, data):
		    guitk.BCButtonLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def f1functionPressed(ble, data):
		    guitk.BCButtonLineEditSetText(ble, "F1 was pressed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetLeftButtonAtIndex(ble: object, index: int) -> object:

	"""

	Returns a button which is located at the left side of BCButtonLineEdit.
	\warning: The button must be created with parent the current BCButtonLineEdit and must be a BCToolButton.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	index : int
		the serial position of the button at the left side of BCButtonLineEdit. The button with 0 index is the button which is located at the left edge of the BCButtonLineEdit.

	Returns
	-------
	object

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "This is the text of line edit.")
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "align_right_16.png", "Move Right", moveCursorRightFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "align_left_16.png", "Move Left", moveCursorLeftFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    validIndex = 0
		    rBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetRightButtonAtIndex(btnLe, validIndex)
		    )
		    lBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetLeftButtonAtIndex(btnLe, validIndex)
		    )
		    print("Right button's name at index " + str(validIndex) + " is " + rBtnName)
		    print("Left button's name at index " + str(validIndex) + " is " + lBtnName)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def moveCursorRightFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) + 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) - 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditGetRightButtonAtIndex(ble: object, index: int) -> object:

	"""

	Returns a button which is located at the right side of BCButtonLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	index : int
		the serial position of button at the right side of BCButtonLineEdit. The button with 0 index is the button which is located at the right edge of the BCButtonLineEdit.

	Returns
	-------
	object

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit")
		    btnLe = guitk.BCButtonLineEditCreate(hBox, "This is the text of line edit.")
		    btnRight = guitk.BCToolButtonCreate(
		        btnLe, "align_right_16.png", "Move Right", moveCursorRightFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddRightButton(btnLe, btnRight)
		    btnLeft = guitk.BCToolButtonCreate(
		        btnLe, "align_left_16.png", "Move Left", moveCursorLeftFunction, btnLe
		    )
		    guitk.BCButtonLineEditAddLeftButton(btnLe, btnLeft)
		    validIndex = 0
		    rBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetRightButtonAtIndex(btnLe, validIndex)
		    )
		    lBtnName = guitk.BCButtonText(
		        guitk.BCButtonLineEditGetLeftButtonAtIndex(btnLe, validIndex)
		    )
		    print("Right button's name at index " + str(validIndex) + " is " + rBtnName)
		    print("Left button's name at index " + str(validIndex) + " is " + lBtnName)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def moveCursorRightFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) + 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(tb, btnLe):
		    newPos = guitk.BCButtonLineEditGetCursorPosition(btnLe) - 1
		    guitk.BCButtonLineEditSetCursorPosition(btnLe, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditRemoveButton(ble: object, button: object) -> None:

	"""

	Removes a button from the BCButtonLineEdit ble.
	WARNING: the buttons that are left or right of the removed button will change their index by -1 cause of the remove.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	button : object
		the BCToolbutton which will be removed.

	Returns
	-------
	None

	"""

def BCCalculatorCreate(p: object) -> object:

	"""

	Creates a scientific calculator which can be connected to a BCLineEdit and transfer the result of the calculation on it.
	WARNING: the return value is a BCFrame.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent of the BCCalculator, BCWindow recommended.

	Returns
	-------
	object
		the created BCCalculator as a BCFrame.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCCalculator example", guitk.constants.BCOnExitDestroy)
		
		    calc = guitk.BCCalculatorCreate(w)
		    guitk.BCCalculatorSetExpression(calc, "2+2")
		
		    guitk.BCWindowAddSeparator(w)
		    guitk.BCSpacerCreate(w)
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Result: ")
		    ble = guitk.BCButtonLineEditCreate(hl, "")
		
		    guitk.BCCalculatorConnectWithButtonLineEdit(calc, ble)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCalculatorGetResult(calc: object) -> str:

	"""

	Returns the result of a BCCalculator.
	This function is not supported under VR mode.

	Parameters
	----------
	calc : object
		the BCCalculator.

	Returns
	-------
	str
		the string of the calculated result.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCCalculatorGetResult Example", guitk.constants.BCOnExitDestroy
		    )
		    calc = guitk.BCCalculatorCreate(window)
		    guitk.BCCalculatorSetExpression(calc, "2+2")
		
		    guitk.BCWindowAddSeparator(window)
		    guitk.BCSpacerCreate(window)
		    guitk.BCPushButtonCreate(window, "Print Result to console", getResult, calc)
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBoxFooter, "Result:")
		    lineEditResult = guitk.BCButtonLineEditCreate(hBoxFooter, "")
		    guitk.BCCalculatorConnectWithButtonLineEdit(calc, lineEditResult)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def getResult(btn, calc):
		    print("Result = " + guitk.BCCalculatorGetResult(calc))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCalculatorSetExpression(calc: object, expr: str) -> None:

	"""

	Sets an expression as text to expression area of a BCCalculator.
	This function is not supported under VR mode.

	Parameters
	----------
	calc : object
		the BCCalculator.

	expr : str
		the string of the expression.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCCalculator example", guitk.constants.BCOnExitDestroy)
		
		    calc = guitk.BCCalculatorCreate(w)
		    guitk.BCCalculatorSetExpression(calc, "2+2")
		
		    guitk.BCWindowAddSeparator(w)
		    guitk.BCSpacerCreate(w)
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Result: ")
		    ble = guitk.BCButtonLineEditCreate(hl, "")
		
		    guitk.BCCalculatorConnectWithButtonLineEdit(calc, ble)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCalculatorConnectWithButtonLineEdit(calc: object, ble: object) -> None:

	"""

	With this function you can connect a BCCalculator to a BCButtonLineEdit.
	By pushing the transfer button a copy of the calculated result is set as text at the result area of the BCCalculator.
	This function is not supported under VR mode.

	Parameters
	----------
	calc : object
		the BCCalculator.

	ble : object
		the BCButtonLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCCalculator example", guitk.constants.BCOnExitDestroy)
		
		    calc = guitk.BCCalculatorCreate(w)
		    guitk.BCCalculatorSetExpression(calc, "2+2")
		
		    guitk.BCWindowAddSeparator(w)
		    guitk.BCSpacerCreate(w)
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Result: ")
		    ble = guitk.BCButtonLineEditCreate(hl, "")
		
		    guitk.BCCalculatorConnectWithButtonLineEdit(calc, ble)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxCreate(p: object, text: str) -> object:

	"""

	Creates a CheckBox with parent p and a text label text on the right.

	Parameters
	----------
	p : object
		the parent widget or layout.

	text : str
		the text that will be displayed.

	Returns
	-------
	object
		the created CheckBox.

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("CheckBox", guitk.constants.BCOnExitDestroy)
		
		    # Create check box
		    cbenable = guitk.BCCheckBoxCreate(w, "Enable Button")
		
		    # Set the initial state of checkbox
		    guitk.BCCheckBoxSetChecked(cbenable, False)
		
		    # Set the function to be called when the Check Box is toggled
		    guitk.BCCheckBoxSetToggledFunction(cbenable, CheckBoxEnableChangedState, None)
		
		    # PushButtons tend to occupy all available width
		    pb = guitk.BCPushButtonCreate(w, "OK", PushButtonClicked, None)
		
		    # Set the Corrensponding behaviour for PushButton when the Check box change states
		    guitk.BCCheckBoxAddManagedWidget(
		        cbenable, pb, guitk.constants.BCManagedEnable, guitk.constants.BCManagedDisable
		    )
		
		    guitk.BCShow(w)
		
		
		def PushButtonClicked(p, data):
		    print("Button was clicked")
		    return 0
		
		
		def CheckBoxEnableChangedState(cb, state, data):
		    str_state = "Off"
		    if guitk.BCCheckBoxIsChecked(cb):
		        str_state = "On"
		    print("State of '", guitk.BCCheckBoxText(cb), "' checkBox is ", str_state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxSetText(cb: object, text: str) -> None:

	"""

	Sets the text label of CheckBox cb to be text.

	Parameters
	----------
	cb : object
		the CheckBox.

	text : str
		the new text for cb.

	Returns
	-------
	None

	See Also
	--------
	BCCheckBoxText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "CheckBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hBox = guitk.BCHBoxCreate(window)
		    chkBoxEnabled = guitk.BCCheckBoxCreate(hBox, "")
		    guitk.BCCheckBoxSetText(chkBoxEnabled, "Enabled")
		
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Enabled LineEdit")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxEnabled, enableLineEdit, lineEdit)
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBoxEnabled, True)
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnToggleChkBox = guitk.BCPushButtonCreate(
		        hBoxFooter, "Toggle CheckBox", toggleChkBox, chkBoxEnabled
		    )
		    btnToggleNoCallback = guitk.BCPushButtonCreate(
		        hBoxFooter, "Toggle CheckBox No Callback", toggleChkBoxNoCallback, chkBoxEnabled
		    )
		    guitk.BCButtonSetIconFileName(btnToggleNoCallback, "warning_small.svg")
		
		    guitk.BCShow(window)
		
		
		def enableLineEdit(chkBox, state, lineEdit):
		    print("CheckBox Toggled Invoked!")
		    guitk.BCSetEnabled(lineEdit, state)
		    guitk.BCLineEditSetPlaceholderText(
		        lineEdit, ("En" if state else "Dis") + "abled LineEdit"
		    )
		    return 0
		
		
		def toggleChkBox(b, chkBoxEnabled):
		    guitk.BCCheckBoxToggle(chkBoxEnabled)
		    return 0
		
		
		def toggleChkBoxNoCallback(b, chkBoxEnabled):
		    state = guitk.BCCheckBoxIsChecked(chkBoxEnabled)
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBoxEnabled, not state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxIsChecked(cb: object) -> bool:

	"""

	Returns True if the CheckBox is checked or False otherwise.

	Parameters
	----------
	cb : object
		the CheckBox.

	Returns
	-------
	bool
		True if the cb is checked or False otherwise.

	See Also
	--------
	BCCheckBoxSetChecked

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("CheckBox", guitk.constants.BCOnExitDestroy)
		
		    # Create check box
		    cbenable = guitk.BCCheckBoxCreate(w, "Enable Button")
		
		    # Set the initial state of checkbox
		    guitk.BCCheckBoxSetChecked(cbenable, False)
		
		    # Set the function to be called when the Check Box is toggled
		    guitk.BCCheckBoxSetToggledFunction(cbenable, CheckBoxEnableChangedState, None)
		
		    # PushButtons tend to occupy all available width
		    pb = guitk.BCPushButtonCreate(w, "OK", PushButtonClicked, None)
		
		    # Set the Corrensponding behaviour for PushButton when the Check box change states
		    guitk.BCCheckBoxAddManagedWidget(
		        cbenable, pb, guitk.constants.BCManagedEnable, guitk.constants.BCManagedDisable
		    )
		
		    guitk.BCShow(w)
		
		
		def PushButtonClicked(p, data):
		    print("Button was clicked")
		    return 0
		
		
		def CheckBoxEnableChangedState(cb, state, data):
		    str_state = "Off"
		    if guitk.BCCheckBoxIsChecked(cb):
		        str_state = "On"
		    print("State of '", guitk.BCCheckBoxText(cb), "' checkBox is ", str_state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxSetChecked(cb: object, check: bool) -> None:

	"""

	Sets CheckBox cb to be checked or unchecked depending on the value of check.
	If a toggle function was set to cb, it will be called only if the new check state is different from the current one.

	Parameters
	----------
	cb : object
		the CheckBox.

	check : bool
		set this parameter to True to check cb or False to uncheck it.

	Returns
	-------
	None

	See Also
	--------
	BCCheckBoxIsChecked

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("CheckBox", guitk.constants.BCOnExitDestroy)
		
		    # Create check box
		    cbenable = guitk.BCCheckBoxCreate(w, "Enable Button")
		
		    # Set the initial state of checkbox
		    guitk.BCCheckBoxSetChecked(cbenable, False)
		
		    # Set the function to be called when the Check Box is toggled
		    guitk.BCCheckBoxSetToggledFunction(cbenable, CheckBoxEnableChangedState, None)
		
		    # PushButtons tend to occupy all available width
		    pb = guitk.BCPushButtonCreate(w, "OK", PushButtonClicked, None)
		
		    # Set the Corrensponding behaviour for PushButton when the Check box change states
		    guitk.BCCheckBoxAddManagedWidget(
		        cbenable, pb, guitk.constants.BCManagedEnable, guitk.constants.BCManagedDisable
		    )
		
		    guitk.BCShow(w)
		
		
		def PushButtonClicked(p, data):
		    print("Button was clicked")
		    return 0
		
		
		def CheckBoxEnableChangedState(cb, state, data):
		    str_state = "Off"
		    if guitk.BCCheckBoxIsChecked(cb):
		        str_state = "On"
		    print("State of '", guitk.BCCheckBoxText(cb), "' checkBox is ", str_state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxSetCheckedNoCallBack(cb: object, check: bool) -> None:

	"""

	Sets CheckBox cb to be checked or unchecked depending on the value of check without calling callback.

	Parameters
	----------
	cb : object
		the CheckBox.

	check : bool
		set this parameter to True to check cb or False to uncheck it.

	Returns
	-------
	None

	See Also
	--------
	BCCheckBoxToggle

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "CheckBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hBox = guitk.BCHBoxCreate(window)
		    chkBoxEnabled = guitk.BCCheckBoxCreate(hBox, "")
		    guitk.BCCheckBoxSetText(chkBoxEnabled, "Enabled")
		
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Enabled LineEdit")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxEnabled, enableLineEdit, lineEdit)
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBoxEnabled, True)
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnToggleChkBox = guitk.BCPushButtonCreate(
		        hBoxFooter, "Toggle CheckBox", toggleChkBox, chkBoxEnabled
		    )
		    btnToggleNoCallback = guitk.BCPushButtonCreate(
		        hBoxFooter, "Toggle CheckBox No Callback", toggleChkBoxNoCallback, chkBoxEnabled
		    )
		    guitk.BCButtonSetIconFileName(btnToggleNoCallback, "warning_small.svg")
		
		    guitk.BCShow(window)
		
		
		def enableLineEdit(chkBox, state, lineEdit):
		    print("CheckBox Toggled Invoked!")
		    guitk.BCSetEnabled(lineEdit, state)
		    guitk.BCLineEditSetPlaceholderText(
		        lineEdit, ("En" if state else "Dis") + "abled LineEdit"
		    )
		    return 0
		
		
		def toggleChkBox(b, chkBoxEnabled):
		    guitk.BCCheckBoxToggle(chkBoxEnabled)
		    return 0
		
		
		def toggleChkBoxNoCallback(b, chkBoxEnabled):
		    state = guitk.BCCheckBoxIsChecked(chkBoxEnabled)
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBoxEnabled, not state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxToggle(cb: object) -> None:

	"""

	Toggle (change state) for CheckBox cb.

	Parameters
	----------
	cb : object
		the CheckBox.

	Returns
	-------
	None

	See Also
	--------
	BCCheckBoxSetChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "CheckBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    hBox = guitk.BCHBoxCreate(window)
		    chkBoxEnabled = guitk.BCCheckBoxCreate(hBox, "")
		    guitk.BCCheckBoxSetText(chkBoxEnabled, "Enabled")
		
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Enabled LineEdit")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxEnabled, enableLineEdit, lineEdit)
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBoxEnabled, True)
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnToggleChkBox = guitk.BCPushButtonCreate(
		        hBoxFooter, "Toggle CheckBox", toggleChkBox, chkBoxEnabled
		    )
		    btnToggleNoCallback = guitk.BCPushButtonCreate(
		        hBoxFooter, "Toggle CheckBox No Callback", toggleChkBoxNoCallback, chkBoxEnabled
		    )
		    guitk.BCButtonSetIconFileName(btnToggleNoCallback, "warning_small.svg")
		
		    guitk.BCShow(window)
		
		
		def enableLineEdit(chkBox, state, lineEdit):
		    print("CheckBox Toggled Invoked!")
		    guitk.BCSetEnabled(lineEdit, state)
		    guitk.BCLineEditSetPlaceholderText(
		        lineEdit, ("En" if state else "Dis") + "abled LineEdit"
		    )
		    return 0
		
		
		def toggleChkBox(b, chkBoxEnabled):
		    guitk.BCCheckBoxToggle(chkBoxEnabled)
		    return 0
		
		
		def toggleChkBoxNoCallback(b, chkBoxEnabled):
		    state = guitk.BCCheckBoxIsChecked(chkBoxEnabled)
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBoxEnabled, not state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxSetToggledFunction(cb: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function funct that will be called when the CheckBox cb is toggled.

	Parameters
	----------
	cb : object
		the CheckBox.

	funct : Callable
		the function that will be called when the CheckBox cb is toggled. See
		BC_CHECKBOX_TOGGLED_FUNCTION for details.
		integer BC_CHECKBOX_TOGGLED_FUNCTION(cb, state, data)
		The function to be called when BCCheckBox cb is toggled.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * cb : object
		                    the BCCheckBox.
		          * state : int
		                    the toggle state information: 1 when the checkBox is checked; 0 otherwise.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct, or None.

	Returns
	-------
	None

	See Also
	--------
	BCCheckBoxToggle

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("CheckBox", guitk.constants.BCOnExitDestroy)
		
		    # Create check box
		    cbenable = guitk.BCCheckBoxCreate(w, "Enable Button")
		
		    # Set the initial state of checkbox
		    guitk.BCCheckBoxSetChecked(cbenable, False)
		
		    # Set the function to be called when the Check Box is toggled
		    guitk.BCCheckBoxSetToggledFunction(cbenable, CheckBoxEnableChangedState, None)
		
		    # PushButtons tend to occupy all available width
		    pb = guitk.BCPushButtonCreate(w, "OK", PushButtonClicked, None)
		
		    # Set the Corrensponding behaviour for PushButton when the Check box change states
		    guitk.BCCheckBoxAddManagedWidget(
		        cbenable, pb, guitk.constants.BCManagedEnable, guitk.constants.BCManagedDisable
		    )
		
		    guitk.BCShow(w)
		
		
		def PushButtonClicked(p, data):
		    print("Button was clicked")
		    return 0
		
		
		def CheckBoxEnableChangedState(cb, state, data):
		    str_state = "Off"
		    if guitk.BCCheckBoxIsChecked(cb):
		        str_state = "On"
		    print("State of '", guitk.BCCheckBoxText(cb), "' checkBox is ", str_state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxAddManagedWidget(cb: object, w: object, onCheck: int, onUnCheck: int) -> None:

	"""

	This function adds a widget w to a list of widgets that are automatically managed
	when the CheckBox cb is checked or unchecked. 
	The list of possible actions
	are: enable, disable, hide and show. Different actions can be connected 
	to the checked/unchecked state of the CheckBox cb.

	Parameters
	----------
	cb : object
		the CheckBox.

	w : object
		the widget to manage.

	onCheck : int
		the action to perform when CheckBox cb has been checked. See BCEnumManagedAction property for more details.
		
		guitk.constants BCEnumManagedAction
		This enum type defines the action to be taken. The managed action is used with BCCheckBoxAddManagedWidget for example.
		 - guitk.constants.BCManagedEnable
		enables the widget.
		 - guitk.constants.BCManagedDisable
		disables the widget.
		 - guitk.constants.BCManagedHide
		hides the widget.
		 - guitk.constants.BCManagedShow
		shows the widget.

	onUnCheck : int
		the action to perform when CheckBox cb has been unchecked. See BCEnumManagedAction property for more details.
		
		guitk.constants BCEnumManagedAction
		This enum type defines the action to be taken. The managed action is used with BCCheckBoxAddManagedWidget for example.
		 - guitk.constants.BCManagedEnable
		enables the widget.
		 - guitk.constants.BCManagedDisable
		disables the widget.
		 - guitk.constants.BCManagedHide
		hides the widget.
		 - guitk.constants.BCManagedShow
		shows the widget.

	Returns
	-------
	None

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("CheckBox", guitk.constants.BCOnExitDestroy)
		
		    # Create check box
		    cbenable = guitk.BCCheckBoxCreate(w, "Enable Button")
		
		    # Set the initial state of checkbox
		    guitk.BCCheckBoxSetChecked(cbenable, False)
		
		    # Set the function to be called when the Check Box is toggled
		    guitk.BCCheckBoxSetToggledFunction(cbenable, CheckBoxEnableChangedState, None)
		
		    # PushButtons tend to occupy all available width
		    pb = guitk.BCPushButtonCreate(w, "OK", PushButtonClicked, None)
		
		    # Set the Corrensponding behaviour for PushButton when the Check box change states
		    guitk.BCCheckBoxAddManagedWidget(
		        cbenable, pb, guitk.constants.BCManagedEnable, guitk.constants.BCManagedDisable
		    )
		
		    guitk.BCShow(w)
		
		
		def PushButtonClicked(p, data):
		    print("Button was clicked")
		    return 0
		
		
		def CheckBoxEnableChangedState(cb, state, data):
		    str_state = "Off"
		    if guitk.BCCheckBoxIsChecked(cb):
		        str_state = "On"
		    print("State of '", guitk.BCCheckBoxText(cb), "' checkBox is ", str_state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCheckBoxText(cb: object) -> str:

	"""

	Returns the label of the check button

	Parameters
	----------
	cb : object
		the CheckBox whose label we want to get.

	Returns
	-------
	str
		the CheckButton's label

	See Also
	--------
	BCCheckBoxSetText

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("CheckBox", guitk.constants.BCOnExitDestroy)
		
		    # Create check box
		    cbenable = guitk.BCCheckBoxCreate(w, "Enable Button")
		
		    # Set the initial state of checkbox
		    guitk.BCCheckBoxSetChecked(cbenable, False)
		
		    # Set the function to be called when the Check Box is toggled
		    guitk.BCCheckBoxSetToggledFunction(cbenable, CheckBoxEnableChangedState, None)
		
		    # PushButtons tend to occupy all available width
		    pb = guitk.BCPushButtonCreate(w, "OK", PushButtonClicked, None)
		
		    # Set the Corrensponding behaviour for PushButton when the Check box change states
		    guitk.BCCheckBoxAddManagedWidget(
		        cbenable, pb, guitk.constants.BCManagedEnable, guitk.constants.BCManagedDisable
		    )
		
		    guitk.BCShow(w)
		
		
		def PushButtonClicked(p, data):
		    print("Button was clicked")
		    return 0
		
		
		def CheckBoxEnableChangedState(cb, state, data):
		    str_state = "Off"
		    if guitk.BCCheckBoxIsChecked(cb):
		        str_state = "On"
		    print("State of '", guitk.BCCheckBoxText(cb), "' checkBox is ", str_state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxCreate(p: object, val: object) -> object:

	"""

	Creates a ComboBox with val as the list of options.

	Parameters
	----------
	p : object
		the parent Widget or Layout.

	val : object
		a list of strings with which the BCComboBox will be populated.

	Returns
	-------
	object
		the created ComboBox.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    currRow = 0
		    rows = 3
		    cols = 2
		
		    window = guitk.BCWindowCreate(
		        "Simple ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(window, rows, cols)
		
		    label = guitk.BCLabelCreate(grid, "Regular")
		    regularCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Colors CheckBox", -1)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Sizes CheckBox", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, regularCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(regularCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Colors")
		    colorsCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Red", 0)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_red_small.svg", 0)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Green", 1)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_green_small.svg", 1)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Blue", 2)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_blue_small.svg", 2)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, colorsCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(colorsCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Sizes")
		    sizesCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(sizesCombo, "16x16", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "32x32", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "64x64", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, sizesCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(sizesCombo, ComboActivated, None)
		    currRow += 1
		
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        colorsCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        0,
		    )
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        sizesCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        1,
		    )
		
		    guitk.BCShow(window)
		
		
		def ComboActivated(combo, index, data):
		    print("Index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxCurrentText(box: object) -> str:

	"""

	Returns the current text of BCComboBox box, or None if box is empty.

	Parameters
	----------
	box : object
		the BCComboBox.

	Returns
	-------
	str
		the current text of BCComboBox box, or None if box is empty.

	See Also
	--------
	BCComboBoxGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Activated Example", guitk.constants.BCOnExitDestroy
		    )
		
		    cmb1 = guitk.BCComboBoxCreate(window, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCComboBoxSetEditable(cmb1, True)
		    guitk.BCComboBoxSetActivatedTextFunction(cmb1, cmbActivatedText, None)
		    guitk.BCComboBoxSetCurrentItem(cmb1, 1)
		
		    cmb2 = guitk.BCComboBoxCreate(window, ["Item 1", "Item 2", "Item 3"])
		    guitk.BCComboBoxSetActivatedFunction(cmb2, cmb2Activated, None)
		    guitk.BCComboBoxSetCurrentItemExecuteActivatedCallBack(cmb2, 2)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cmbActivatedText(combo, text, data):
		    print("cmb1: ActivatedText triggered: CurrentText=" + text)
		    return 0
		
		
		def cmb2Activated(combo, index, data):
		    print(
		        "cmb2: Activated triggered: CurrentText=" + guitk.BCComboBoxCurrentText(combo)
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxCurrentItem(box: object) -> int:

	"""

	Returns the index of the current item of BCComboBox box.

	Parameters
	----------
	box : object
		the BCComboBox.

	Returns
	-------
	int
		the index of the current item of BCComboBox box.

	See Also
	--------
	BCComboBoxCurrentText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    currRow = 0
		    rows = 3
		    cols = 2
		
		    window = guitk.BCWindowCreate(
		        "Simple ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(window, rows, cols)
		
		    label = guitk.BCLabelCreate(grid, "Regular")
		    regularCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Colors CheckBox", -1)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Sizes CheckBox", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, regularCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(regularCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Colors")
		    colorsCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Red", 0)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_red_small.svg", 0)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Green", 1)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_green_small.svg", 1)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Blue", 2)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_blue_small.svg", 2)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, colorsCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(colorsCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Sizes")
		    sizesCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(sizesCombo, "16x16", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "32x32", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "64x64", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, sizesCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(sizesCombo, ComboActivated, None)
		    currRow += 1
		
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        colorsCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        0,
		    )
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        sizesCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        1,
		    )
		
		    guitk.BCShow(window)
		
		
		def ComboActivated(combo, index, data):
		    print("Index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetActivatedFunction(box: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when BCComboBox box is activated.
	If you have editable combo boxes use BCComboBoxSetActivatedTextFunction() instead.

	Parameters
	----------
	box : object
		the BCComboBox.

	funct : Callable
		the function that will be called when BCComboBox box is activated.
		See BC_COMBOBOX_ACTIVATED_FUNCTION for details.
		integer BC_COMBOBOX_ACTIVATED_FUNCTION(combo, index, data)
		The function to be called when BCComboBox combo is activated.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * combo : object
		                    the BCComboBox.
		          * index : int
		                    the index of the activated item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct. If data is not required, it should be set to None.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxSetActivatedTextFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    currRow = 0
		    rows = 3
		    cols = 2
		
		    window = guitk.BCWindowCreate(
		        "Simple ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(window, rows, cols)
		
		    label = guitk.BCLabelCreate(grid, "Regular")
		    regularCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Colors CheckBox", -1)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Sizes CheckBox", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, regularCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(regularCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Colors")
		    colorsCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Red", 0)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_red_small.svg", 0)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Green", 1)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_green_small.svg", 1)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Blue", 2)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_blue_small.svg", 2)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, colorsCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(colorsCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Sizes")
		    sizesCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(sizesCombo, "16x16", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "32x32", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "64x64", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, sizesCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(sizesCombo, ComboActivated, None)
		    currRow += 1
		
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        colorsCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        0,
		    )
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        sizesCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        1,
		    )
		
		    guitk.BCShow(window)
		
		
		def ComboActivated(combo, index, data):
		    print("Index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetActivatedTextFunction(box: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when BCComboBox box is activated. Use this function for editable combo boxes.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	funct : Callable
		the function that will be called when BCComboBox box is activated. 
		See BC_COMBOBOX_ACTIVATED_TEXT_FUNCTION for details.
		integer BC_COMBOBOX_ACTIVATED_TEXT_FUNCTION(combo, text, data)
		The function to be called when ComboBox combo is activated. Use this function for editable combo boxes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * combo : object
		                    the BCComboBox.
		          * text : str
		                    the text of the activated item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxSetActivatedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Activated Example", guitk.constants.BCOnExitDestroy
		    )
		
		    cmb1 = guitk.BCComboBoxCreate(window, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCComboBoxSetEditable(cmb1, True)
		    guitk.BCComboBoxSetActivatedTextFunction(cmb1, cmbActivatedText, None)
		    guitk.BCComboBoxSetCurrentItem(cmb1, 1)
		
		    cmb2 = guitk.BCComboBoxCreate(window, ["Item 1", "Item 2", "Item 3"])
		    guitk.BCComboBoxSetActivatedFunction(cmb2, cmb2Activated, None)
		    guitk.BCComboBoxSetCurrentItemExecuteActivatedCallBack(cmb2, 2)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cmbActivatedText(combo, text, data):
		    print("cmb1: ActivatedText triggered: CurrentText=" + text)
		    return 0
		
		
		def cmb2Activated(combo, index, data):
		    print(
		        "cmb2: Activated triggered: CurrentText=" + guitk.BCComboBoxCurrentText(combo)
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetTextChangedFunction(box: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the text changes in the BCComboBox.
	This function will operate only if combo box is editable.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the ComboBox.

	funct : Callable
		the function that will be called when text changes.
		See BC_COMBOBOX_TEXT_CHANGED_FUNCTION for details.
		integer BC_COMBOBOX_TEXT_CHANGED_FUNCTION(combo, text, data)
		The function to be called when the text changes in the BCComboBox combo.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * combo : object
		                    the BCComboBox.
		          * text : str
		                    the current text in the BCComboBox.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxSetEditable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox TextChanged Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCComboBoxSetTextChangedFunction(cmb, cmbTextChanged, None)
		    guitk.BCComboBoxSetEditable(cmb, True)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cmbTextChanged(combo, text, data):
		    print("TextChanged triggered: CurrentText=" + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetAboutToPopupFunction(box: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called just before the popup opens in the BCComboBox.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	funct : Callable
		the function that will be called when the popup opens. 
		See BC_COMBOBOX_POPUP_FUNCTION for details.
		integer BC_COMBOBOX_POPUP_FUNCTION(combo, data)
		The function to be called when the popup opens in the BCComboBox combo.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * combo : object
		                    the BCComboBox.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Popup example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCComboBoxSetAboutToPopupFunction(cmb, cmbAboutToPopup, None)
		    guitk.BCComboBoxSetPopupFunction(cmb, cmbPopup, None)
		    guitk.BCComboBoxSetEditable(cmb, True)
		    guitk.BCShow(window)
		
		
		def cmbAboutToPopup(cmb, data):
		    print("AboutToPopupFunction triggered!")
		    return 0
		
		
		def cmbPopup(cmb, data):
		    print("PopupFunction triggered!")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetPopupFunction(box: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the popup opens in the BCComboBox.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	funct : Callable
		the function that will be called when the popup opens. 
		See BC_COMBOBOX_POPUP_FUNCTION for details.
		integer BC_COMBOBOX_POPUP_FUNCTION(combo, data)
		The function to be called when the popup opens in the BCComboBox combo.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * combo : object
		                    the BCComboBox.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Popup example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCComboBoxSetAboutToPopupFunction(cmb, cmbAboutToPopup, None)
		    guitk.BCComboBoxSetPopupFunction(cmb, cmbPopup, None)
		    guitk.BCComboBoxSetEditable(cmb, True)
		    guitk.BCShow(window)
		
		
		def cmbAboutToPopup(cmb, data):
		    print("AboutToPopupFunction triggered!")
		    return 0
		
		
		def cmbPopup(cmb, data):
		    print("PopupFunction triggered!")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetCurrentIndexChangedFunction(box: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when the current index of BCComboBox box changes.
	NOTE: The function set by this function, in contrast with the function set with BCComboBoxSetActivatedFunction, will
	be called either through user interaction or programmatically! If you change the current index programmatically and you
	do not wish the callback to be called, block callback functions by calling BCBlockCallBackFunctions.
	NOTE: In case both BC_COMBOBOX_CURRENT_INDEX_CHANGED_FUNCTION and BC_COMBOBOX_ACTIVATED_FUNCTION are set
	for the same BCComboBox and the current index changes, BC_COMBOBOX_CURRENT_INDEX_CHANGED_FUNCTION will be called first and then
	the BC_COMBOBOX_ACTIVATED_FUNCTION.

	Parameters
	----------
	box : object
		the BCComboBox.

	funct : Callable
		the function that will be called when the current index of the BCComboBox changes. See
		BC_COMBOBOX_CURRENT_INDEX_CHANGED_FUNCTION for details.
		integer BC_COMBOBOX_CURRENT_INDEX_CHANGED_FUNCTION(combo, index, data)
		The function to be called when the current index of BCComboBox combo changes either through user interaction or programmatically.
		
		Arguments
		          * combo : object
		                    the BCComboBox.
		          * index : int
		                    the new current index. If combo becomes empty index will be -1.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxSetActivatedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    comboVals = ["Option 1", "Option 2", "Option 3"]
		
		    window = guitk.BCWindowCreate(
		        "Editable - Buttons ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "Editable")
		    editableCombo = guitk.BCComboBoxCreate(hl, comboVals)
		    guitk.BCComboBoxSetEditable(editableCombo, 1)
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(
		        editableCombo, ComboCurrentIndexChanged, None
		    )
		    guitk.BCComboBoxSetCurrentItem(editableCombo, 1)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def ComboCurrentIndexChanged(combo, index, data):
		    print("The new index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetCurrentItem(box: object, index: int) -> None:

	"""

	Sets the current item of the BCComboBox to be the item with index index.
	WARNING: this function doesn't trigger the activated callback set by the user.

	Parameters
	----------
	box : object
		the BCComboBox.

	index : int
		the index of the item which will be set to current.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxCurrentText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    comboVals = ["Option 1", "Option 2", "Option 3"]
		
		    window = guitk.BCWindowCreate(
		        "Editable - Buttons ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "Editable")
		    editableCombo = guitk.BCComboBoxCreate(hl, comboVals)
		    guitk.BCComboBoxSetEditable(editableCombo, 1)
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(
		        editableCombo, ComboCurrentIndexChanged, None
		    )
		    guitk.BCComboBoxSetCurrentItem(editableCombo, 1)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def ComboCurrentIndexChanged(combo, index, data):
		    print("The new index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxInsertItem(box: object, text: str, index: int) -> None:

	"""

	Inserts an item with text text, at position index. The item will be appended if index is negative.

	Parameters
	----------
	box : object
		the BCComboBox.

	text : str
		the text that will be inserted.

	index : int
		the index at which text will be inserted (-1 to append).

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxInsertStrList

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    currRow = 0
		    rows = 3
		    cols = 2
		
		    window = guitk.BCWindowCreate(
		        "Simple ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(window, rows, cols)
		
		    label = guitk.BCLabelCreate(grid, "Regular")
		    regularCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Colors CheckBox", -1)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Sizes CheckBox", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, regularCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(regularCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Colors")
		    colorsCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Red", 0)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_red_small.svg", 0)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Green", 1)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_green_small.svg", 1)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Blue", 2)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_blue_small.svg", 2)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, colorsCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(colorsCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Sizes")
		    sizesCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(sizesCombo, "16x16", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "32x32", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "64x64", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, sizesCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(sizesCombo, ComboActivated, None)
		    currRow += 1
		
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        colorsCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        0,
		    )
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        sizesCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        1,
		    )
		
		    guitk.BCShow(window)
		
		
		def ComboActivated(combo, index, data):
		    print("Index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxInsertItemIconFileName(box: object, fileName: str, text: str, index: int) -> None:

	"""

	Inserts an item with text text, at position index, with a pixmap on the left of text.
	The item will be appended if index is negative. Note that the editable property of the text is not affected.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	fileName : str
		the filename of the icon.

	text : str
		the text that will be inserted.

	index : int
		the index at which text will be inserted (-1 to append).

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxRemoveItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxInsertStrList(box: object, list: object, numStrings: int, index: int) -> None:

	"""

	Inserts the list of strings list at position index in the BCComboBox box.
	
	The numStrings argument is the number of strings.

	Parameters
	----------
	box : object
		the BCComboBox.

	list : object
		the list of strings that will be inserted.

	numStrings : int
		the number of strings in list.

	index : int
		the index at which list will be inserted (-1 to append).

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxAddManagedWidget(box: object, w: object, on: int, off: int, index: int) -> None:

	"""

	This function adds a widget w to a list of widgets that are automatically managed when BCComboBox box is activated.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	w : object
		the widget that will be managed by the box.

	on : int
		defines what will happen to w when index is selected.
		See BCEnumManagedAction property for details.
		
		guitk.constants BCEnumManagedAction
		This enum type defines the action to be taken. The managed action is used with BCCheckBoxAddManagedWidget for example.
		 - guitk.constants.BCManagedEnable
		enables the widget.
		 - guitk.constants.BCManagedDisable
		disables the widget.
		 - guitk.constants.BCManagedHide
		hides the widget.
		 - guitk.constants.BCManagedShow
		shows the widget.

	off : int
		defines what will happen to w when any item of box is selected except index. 
		See BCEnumManagedAction property for details.
		
		guitk.constants BCEnumManagedAction
		This enum type defines the action to be taken. The managed action is used with BCCheckBoxAddManagedWidget for example.
		 - guitk.constants.BCManagedEnable
		enables the widget.
		 - guitk.constants.BCManagedDisable
		disables the widget.
		 - guitk.constants.BCManagedHide
		hides the widget.
		 - guitk.constants.BCManagedShow
		shows the widget.

	index : int
		the number of the item when the on action will be performed on w.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    currRow = 0
		    rows = 3
		    cols = 2
		
		    window = guitk.BCWindowCreate(
		        "Simple ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(window, rows, cols)
		
		    label = guitk.BCLabelCreate(grid, "Regular")
		    regularCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Colors CheckBox", -1)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Sizes CheckBox", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, regularCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(regularCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Colors")
		    colorsCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Red", 0)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_red_small.svg", 0)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Green", 1)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_green_small.svg", 1)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Blue", 2)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_blue_small.svg", 2)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, colorsCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(colorsCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Sizes")
		    sizesCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(sizesCombo, "16x16", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "32x32", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "64x64", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, sizesCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(sizesCombo, ComboActivated, None)
		    currRow += 1
		
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        colorsCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        0,
		    )
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        sizesCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        1,
		    )
		
		    guitk.BCShow(window)
		
		
		def ComboActivated(combo, index, data):
		    print("Index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetEditable(box: object, editable: bool) -> None:

	"""

	Sets whether the combobox is editable.
	When a combobox becomes editable, when click on it, a line edit appears on its first line, so it is possible to add new items by simply entering text into that line edit.
	NOTE: By default a BCComboBox is NOT editable.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	editable : bool
		set this parameter to True to make box editable; False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxSetDuplicatesEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    comboVals = ["Option 1", "Option 2", "Option 3"]
		
		    window = guitk.BCWindowCreate(
		        "Editable - Buttons ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    label = guitk.BCLabelCreate(hl, "Editable")
		    editableCombo = guitk.BCComboBoxCreate(hl, comboVals)
		    guitk.BCComboBoxSetEditable(editableCombo, 1)
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(
		        editableCombo, ComboCurrentIndexChanged, None
		    )
		    guitk.BCComboBoxSetCurrentItem(editableCombo, 1)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def ComboCurrentIndexChanged(combo, index, data):
		    print("The new index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetLineEdit(box: object, le: object) -> None:

	"""

	Sets the BCLineEdit to use le instead of the current line edit.
	NOTE: This function should be used by editable BCComboBoxes only.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	le : object
		the BCLineEdit.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxGetLineEdit

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Switch LineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    stringList = ["Option 1", "Option 2", "Option 3", "Option 4", "Option 5"]
		    cmb = guitk.BCComboBoxCreate(window, stringList)
		    guitk.BCComboBoxSetEditable(cmb, True)
		    guitk.BCPushButtonCreate(window, "Change current LineEdit", changeLineEdit, cmb)
		    btnNewLeToCmb = guitk.BCPushButtonCreate(
		        window, "Set a new LineEdit", setNewLineEdit, cmb
		    )
		    guitk.BCShow(window)
		
		
		def changeLineEdit(b, cmb):
		    cmbLineEdit = guitk.BCComboBoxGetLineEdit(cmb)
		    guitk.BCSetBackgroundColor(cmbLineEdit, 0, 0, 0)
		    guitk.BCSetForegroundColor(cmbLineEdit, 255, 255, 255)
		    guitk.BCLineEditSetPlaceholderText(cmbLineEdit, "Write something...")
		    return 0
		
		
		def setNewLineEdit(b, cmb):
		    newLineEdit = guitk.BCLineEditCreate(cmb, "")
		    guitk.BCSetBackgroundColor(newLineEdit, 255, 255, 0)
		    guitk.BCSetForegroundColor(newLineEdit, 0, 0, 255)
		    guitk.BCLineEditSetPlaceholderText(newLineEdit, "Write something else...")
		    guitk.BCComboBoxSetLineEdit(cmb, newLineEdit)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxGetLineEdit(box: object) -> object:

	"""

	Returns the BCLineEdit, or 0 if there is no BCLineEdit.
	Only editable BCComboBoxes have a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	Returns
	-------
	object
		the BCLineEdit of box.

	See Also
	--------
	BCComboBoxSetLineEdit

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Switch LineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    stringList = ["Option 1", "Option 2", "Option 3", "Option 4", "Option 5"]
		    cmb = guitk.BCComboBoxCreate(window, stringList)
		    guitk.BCComboBoxSetEditable(cmb, True)
		    guitk.BCPushButtonCreate(window, "Change current LineEdit", changeLineEdit, cmb)
		    btnNewLeToCmb = guitk.BCPushButtonCreate(
		        window, "Set a new LineEdit", setNewLineEdit, cmb
		    )
		    guitk.BCShow(window)
		
		
		def changeLineEdit(b, cmb):
		    cmbLineEdit = guitk.BCComboBoxGetLineEdit(cmb)
		    guitk.BCSetBackgroundColor(cmbLineEdit, 0, 0, 0)
		    guitk.BCSetForegroundColor(cmbLineEdit, 255, 255, 255)
		    guitk.BCLineEditSetPlaceholderText(cmbLineEdit, "Write something...")
		    return 0
		
		
		def setNewLineEdit(b, cmb):
		    newLineEdit = guitk.BCLineEditCreate(cmb, "")
		    guitk.BCSetBackgroundColor(newLineEdit, 255, 255, 0)
		    guitk.BCSetForegroundColor(newLineEdit, 0, 0, 255)
		    guitk.BCLineEditSetPlaceholderText(newLineEdit, "Write something else...")
		    guitk.BCComboBoxSetLineEdit(cmb, newLineEdit)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxGetListBox(box: object) -> object:

	"""

	Returns the listBox of the BCComboBox box, or 0 if box has no listBox.
	If the BCComboBox is editable then it is assured that it has a listbox. If it is not editable,
	the listbox existence depends on the window style used.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	Returns
	-------
	object
		the listBox of box.

	"""

def BCComboBoxSetDuplicatesEnabled(box: object, enabled: bool) -> None:

	"""

	Allows or forbids duplicates if enabled is True or False respectively. It has sense only for editable BCComboBoxes (default  False).
	WARNING: It is safer to call this function before adding any item to box.
	NOTE: Cannot forbid duplicates that are inserted programmatically.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	enabled : bool
		set this parameter to True to enable duplicates, or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxSetEditable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox AutoCompletion Example", guitk.constants.BCOnExitDestroy
		    )
		    stringList = [
		        "AOption",
		        "BOption",
		        "COption",
		        "ASelection",
		        "BSelection",
		        "AItem",
		        "BItem ",
		    ]
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "AutoCompletion = True")
		    cmbAuto = comboBoxWithInfoCreate(hBox0, stringList, "Try typing A, B, or C")
		
		    hBox1 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox1, "AutoCompletion = False")
		    cmbNoAuto = comboBoxWithInfoCreate(hBox1, stringList, "Typing won't autocomplete")
		    guitk.BCComboBoxSetAutoCompletion(cmbNoAuto, False)
		
		    hBox2 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox2, "Duplicates Enabled")
		    cmbDuplicates = comboBoxWithInfoCreate(
		        hBox2, stringList, "Pressing Enter with existing option will duplicate it"
		    )
		    guitk.BCComboBoxSetDuplicatesEnabled(cmbDuplicates, True)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def comboBoxWithInfoCreate(p, stringList, info):
		    cmb = guitk.BCComboBoxCreate(p, stringList)
		    guitk.BCComboBoxSetEditable(cmb, True)
		    cmbLineEdit = guitk.BCComboBoxGetLineEdit(cmb)
		    guitk.BCLineEditSetPlaceholderText(cmbLineEdit, info)
		    guitk.BCLineEditSetText(cmbLineEdit, "")
		    return cmb
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetAutoCompletion(box: object, enabled: bool) -> None:

	"""

	Sets whether auto-completion is enabled.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	enabled : bool
		set this parameter to True to enable auto completion, or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxSetEditable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox AutoCompletion Example", guitk.constants.BCOnExitDestroy
		    )
		    stringList = [
		        "AOption",
		        "BOption",
		        "COption",
		        "ASelection",
		        "BSelection",
		        "AItem",
		        "BItem ",
		    ]
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "AutoCompletion = True")
		    cmbAuto = comboBoxWithInfoCreate(hBox0, stringList, "Try typing A, B, or C")
		
		    hBox1 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox1, "AutoCompletion = False")
		    cmbNoAuto = comboBoxWithInfoCreate(hBox1, stringList, "Typing won't autocomplete")
		    guitk.BCComboBoxSetAutoCompletion(cmbNoAuto, False)
		
		    hBox2 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox2, "Duplicates Enabled")
		    cmbDuplicates = comboBoxWithInfoCreate(
		        hBox2, stringList, "Pressing Enter with existing option will duplicate it"
		    )
		    guitk.BCComboBoxSetDuplicatesEnabled(cmbDuplicates, True)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def comboBoxWithInfoCreate(p, stringList, info):
		    cmb = guitk.BCComboBoxCreate(p, stringList)
		    guitk.BCComboBoxSetEditable(cmb, True)
		    cmbLineEdit = guitk.BCComboBoxGetLineEdit(cmb)
		    guitk.BCLineEditSetPlaceholderText(cmbLineEdit, info)
		    guitk.BCLineEditSetText(cmbLineEdit, "")
		    return cmb
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxContainsLabel(box: object, label: str) -> int:

	"""

	Returns 1 if label is contained in box, or 0 otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	label : str
		the string that will be checked.

	Returns
	-------
	int
		1 if label is contained in box, or 0 otherwise.

	See Also
	--------
	BCComboBoxLabelIndex

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxMaxCount(box: object) -> int:

	"""

	This function returns the maximum number of items allowed in the combobox.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	Returns
	-------
	int
		the maximum number of items allowed in the combobox.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxRemoveItem(box: object, index: int) -> None:

	"""

	Removes the item at index index of BCComboBox box.
	NOTE: Removing the current item does not trigger the BCComboBox callback functions.

	Parameters
	----------
	box : object
		the BCComboBox.

	index : int
		the index of the combobox item to remove.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxClear

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option " + str(i) for i in range(15)])
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "Max Visible:")
		    lineEditMaxVisible = guitk.BCLineEditCreateInt(hBox0, 10)
		    guitk.BCLineEditSetEnterPressedFunction(lineEditMaxVisible, changeMaxVisible, cmb)
		    chkBoxWheel = guitk.BCCheckBoxCreate(window, "Wheel Enabled")
		    guitk.BCCheckBoxSetChecked(chkBoxWheel, True)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxWheel, toggleWheel, cmb)
		    hBox1 = guitk.BCHBoxCreate(window)
		
		    btnRemoveCurrent = guitk.BCPushButtonCreate(
		        hBox1, "Remove Current Item", removeCurrent, cmb
		    )
		    btnClear = guitk.BCPushButtonCreate(hBox1, "Clear combo box", btnClearClicked, cmb)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def removeCurrent(btn, cmb):
		    index = guitk.BCComboBoxCurrentItem(cmb)
		    if index >= 0:
		        guitk.BCComboBoxRemoveItem(cmb, index)
		    return 0
		
		
		def btnClearClicked(btn, cmb):
		    guitk.BCComboBoxClear(cmb)
		    return 0
		
		
		def changeMaxVisible(lineEdit, data):
		    text = guitk.BCLineEditGetText(lineEdit)
		    if guitk.BCLineEditValidate(lineEdit):
		        guitk.BCComboBoxSetMaxVisibleItems(data, int(text))
		    return 0
		
		
		def toggleWheel(chkBox, state, cmb):
		    guitk.BCComboBoxSetMouseWheelEnabled(cmb, state)
		    print("WheelEnabled = " + str(guitk.BCComboBoxMouseWheelEnabled(cmb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxClear(box: object) -> None:

	"""

	Removes all combobox items.

	Parameters
	----------
	box : object
		the BCComboBox.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxRemoveItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option " + str(i) for i in range(15)])
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "Max Visible:")
		    lineEditMaxVisible = guitk.BCLineEditCreateInt(hBox0, 10)
		    guitk.BCLineEditSetEnterPressedFunction(lineEditMaxVisible, changeMaxVisible, cmb)
		    chkBoxWheel = guitk.BCCheckBoxCreate(window, "Wheel Enabled")
		    guitk.BCCheckBoxSetChecked(chkBoxWheel, True)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxWheel, toggleWheel, cmb)
		    hBox1 = guitk.BCHBoxCreate(window)
		
		    btnRemoveCurrent = guitk.BCPushButtonCreate(
		        hBox1, "Remove Current Item", removeCurrent, cmb
		    )
		    btnClear = guitk.BCPushButtonCreate(hBox1, "Clear combo box", btnClearClicked, cmb)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def removeCurrent(btn, cmb):
		    index = guitk.BCComboBoxCurrentItem(cmb)
		    if index >= 0:
		        guitk.BCComboBoxRemoveItem(cmb, index)
		    return 0
		
		
		def btnClearClicked(btn, cmb):
		    guitk.BCComboBoxClear(cmb)
		    return 0
		
		
		def changeMaxVisible(lineEdit, data):
		    text = guitk.BCLineEditGetText(lineEdit)
		    if guitk.BCLineEditValidate(lineEdit):
		        guitk.BCComboBoxSetMaxVisibleItems(data, int(text))
		    return 0
		
		
		def toggleWheel(chkBox, state, cmb):
		    guitk.BCComboBoxSetMouseWheelEnabled(cmb, state)
		    print("WheelEnabled = " + str(guitk.BCComboBoxMouseWheelEnabled(cmb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxCount(box: object) -> int:

	"""

	Returns the number of items in the combobox.

	Parameters
	----------
	box : object
		the BCComboBox.

	Returns
	-------
	int
		the number of items in the combobox.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxGetText(box: object, index: int) -> str:

	"""

	Returns the item's text of BCComboBox box at position index, or None if index does not exist.

	Parameters
	----------
	box : object
		the BCComboBox.

	index : int
		the index of the combobox item to remove.

	Returns
	-------
	str
		the text at position index, or None if item is not a string or index does not exist.

	See Also
	--------
	BCComboBoxCurrentText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    currRow = 0
		    rows = 3
		    cols = 2
		
		    window = guitk.BCWindowCreate(
		        "Simple ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(window, rows, cols)
		
		    label = guitk.BCLabelCreate(grid, "Regular")
		    regularCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Colors CheckBox", -1)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Sizes CheckBox", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, regularCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(regularCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Colors")
		    colorsCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Red", 0)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_red_small.svg", 0)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Green", 1)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_green_small.svg", 1)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Blue", 2)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_blue_small.svg", 2)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, colorsCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(colorsCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Sizes")
		    sizesCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(sizesCombo, "16x16", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "32x32", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "64x64", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, sizesCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(sizesCombo, ComboActivated, None)
		    currRow += 1
		
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        colorsCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        0,
		    )
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        sizesCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        1,
		    )
		
		    guitk.BCShow(window)
		
		
		def ComboActivated(combo, index, data):
		    print("Index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetSizePolicy(box: object, sizepolicy_h: int, sizepolicy_v: int) -> None:

	"""

	Sets the default layout behavior of the widget.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	sizepolicy_h : int
		the horizontal size policy. See BCEnumSizePolicy for details.
		
		guitk.constants BCEnumSizePolicy
		This enum type holds the default layout behavior of the widget.
		If there is a BCBoxLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such BCBoxLayout, the result of this function is used.
		 - guitk.constants.BCFixed
		this is the default widget policy. The size hint is the only acceptable alternative, so the widget can never grow or shrink (e.g. the vertical direction of a push button).
		 - guitk.constants.BCMinimum
		the size hint is minimal, and sufficient. The widget can be expanded, but there is no advantage to it being larger (e.g. the horizontal direction of a push button). It cannot be smaller than the size provided by size hint.
		 - guitk.constants.BCMaximum
		the size hint is a maximum. The widget can be shrunk any amount without detriment if other widgets need the space (e.g. a separator line). It cannot be larger than the size provided by size hint.
		 - guitk.constants.BCPreferred
		the size hint is best, but the widget can be shrunk and still be useful. The widget can be expanded, but there is no advantage to it being larger than size hint.
		 - guitk.constants.BCExpanding
		the size hint is a sensible size, but the widget can be shrunk and still be useful. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCMinimumExpanding
		the size hint is minimal, and sufficient. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCIgnored
		the size hint is ignored. The widget will get as much space as possible.

	sizepolicy_v : int
		the vertical size policy. See BCEnumSizePolicy for details.
		
		guitk.constants BCEnumSizePolicy
		This enum type holds the default layout behavior of the widget.
		If there is a BCBoxLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such BCBoxLayout, the result of this function is used.
		 - guitk.constants.BCFixed
		this is the default widget policy. The size hint is the only acceptable alternative, so the widget can never grow or shrink (e.g. the vertical direction of a push button).
		 - guitk.constants.BCMinimum
		the size hint is minimal, and sufficient. The widget can be expanded, but there is no advantage to it being larger (e.g. the horizontal direction of a push button). It cannot be smaller than the size provided by size hint.
		 - guitk.constants.BCMaximum
		the size hint is a maximum. The widget can be shrunk any amount without detriment if other widgets need the space (e.g. a separator line). It cannot be larger than the size provided by size hint.
		 - guitk.constants.BCPreferred
		the size hint is best, but the widget can be shrunk and still be useful. The widget can be expanded, but there is no advantage to it being larger than size hint.
		 - guitk.constants.BCExpanding
		the size hint is a sensible size, but the widget can be shrunk and still be useful. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCMinimumExpanding
		the size hint is minimal, and sufficient. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCIgnored
		the size hint is ignored. The widget will get as much space as possible.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Size Policy Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option 1", "Option 2.", "Option 3"])
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnGroupHorizontal = bgSizePolicyCreate(hBoxFooter, True)
		    btnGroupVertical = bgSizePolicyCreate(hBoxFooter, False)
		    data = [btnGroupHorizontal, btnGroupVertical, cmb]
		    guitk.BCButtonGroupSetPressedFunction(
		        btnGroupHorizontal, lambda bg, id, data: cmbSetSizePolicy(*data), data
		    )
		    guitk.BCButtonGroupSetPressedFunction(
		        btnGroupVertical, lambda bg, id, data: cmbSetSizePolicy(*data), data
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def bgSizePolicyCreate(p, horizontal):
		    bg = guitk.BCButtonGroupCreate(
		        p, "Horizontal" if horizontal else "Vertical", guitk.constants.BCVertical
		    )
		    options = [
		        "BCFixed",
		        "BCMinimum",
		        "BCMaximum",
		        "BCPreferred",
		        "BCExpanding",
		        "BCMinimumExpanding",
		        "BCIgnored",
		    ]
		    for opt in options:
		        guitk.BCRadioButtonCreate(bg, opt, None, None)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCButtonGroupFind(bg, 4 if horizontal else 2), True
		    )
		    return bg
		
		
		def cmbSetSizePolicy(btnGroupHorizontal, btnGroupVertical, cmb):
		    sizepolicy_h = eval(
		        "guitk.constants."
		        + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(btnGroupHorizontal))
		    )
		    sizepolicy_v = eval(
		        "guitk.constants."
		        + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(btnGroupVertical))
		    )
		    guitk.BCComboBoxSetSizePolicy(cmb, sizepolicy_h, sizepolicy_v)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxLabelIndex(box: object, label: str) -> int:

	"""

	Returns the index of the first combobox item of BCComboBox box having as label label.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	label : str
		the string that will be searched.

	Returns
	-------
	int
		the index of the first combobox item; -1 if it is not found.

	See Also
	--------
	BCComboBoxContainsLabel

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCName(w: object) -> str:

	"""

	Returns the name of w. 
	NOTE: Do not use this function for BCListViewItems.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose name is returned.

	Returns
	-------
	str
		the name of w.

	See Also
	--------
	BCSetName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCName Example", guitk.constants.BCOnExitDestroy)
		    print("Window Name = '" + guitk.BCName(window) + "'")
		    # By default most BC Widget do not have a name, but you can set one:
		    btn = guitk.BCPushButtonCreate(window, "A Button", printMyName, None)
		    print("Button Initial Name = '" + guitk.BCName(btn) + "'")
		    guitk.BCSetName(btn, "Button with Name")
		    print("Button New Name = '" + guitk.BCName(btn) + "'")
		    guitk.BCShow(window)
		
		
		def printMyName(b, data):
		    print(guitk.BCName(b))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCaption(w: object) -> str:

	"""

	Returns the caption name of w as set during its construction, e.g. the title of a window.
	
	It is not applicable to BCListViewItems, layouts, BCSpacers e.t.c. and it is meaningful only for windows.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose caption name is returned.

	Returns
	-------
	str
		the caption name of w.

	See Also
	--------
	BCSetCaption

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Caption Example", guitk.constants.BCOnExitDestroy)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Set Caption", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(btnGroup, "Caption 1", None, None)
		    guitk.BCRadioButtonCreate(btnGroup, "Caption 2", None, None)
		    guitk.BCRadioButtonCreate(btnGroup, "Caption 3", None, None)
		    guitk.BCButtonGroupSetPressedFunction(btnGroup, setCaption, window)
		    guitk.BCShow(window)
		
		
		def setCaption(btnGroup, id, window):
		    # Caption only works for window type:
		    guitk.BCSetCaption(
		        window, guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    )
		    print("Caption set to: '" + guitk.BCCaption(window) + "'")
		    print("Name stays the same: " + guitk.BCName(window))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetCaption(w: object, caption: str) -> None:

	"""

	Sets the caption for widget w.
	It is not applicable to BCListViewItems, layouts, BCSpacers e.t.c. and it is meaningful only for windows.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	caption : str
		the caption.

	Returns
	-------
	None

	See Also
	--------
	BCCaption

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("UserDataKey Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button1 = guitk.BCPushButtonCreate(blayout, "Set Caption 1", setCaption, w)
		    button2 = guitk.BCPushButtonCreate(blayout, "Set Caption 2", setCaption, w)
		    button3 = guitk.BCPushButtonCreate(blayout, "Set Caption 3", setCaption, w)
		    guitk.BCSetUserDataKey(button1, "key", "Caption 1")
		    guitk.BCSetUserDataKey(button2, "key", "Caption 2")
		    guitk.BCSetUserDataKey(button3, "key", "Caption 3")
		
		    guitk.BCBoxLayoutInsert(blayout, button1, -1)
		    guitk.BCBoxLayoutInsert(blayout, button2, -1)
		    guitk.BCBoxLayoutInsert(blayout, button3, -1)
		
		    guitk.BCShow(w)
		
		
		def setCaption(b, window):
		    caption = guitk.BCGetUserDataKey(b, "key")
		    guitk.BCSetCaption(window, caption)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetName(w: object, name: str) -> None:

	"""

	Sets the name for widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose name will be set by this function.

	name : str
		the name to set.

	Returns
	-------
	None

	See Also
	--------
	BCName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCName Example", guitk.constants.BCOnExitDestroy)
		    print("Window Name = '" + guitk.BCName(window) + "'")
		    # By default most BC Widget do not have a name, but you can set one:
		    btn = guitk.BCPushButtonCreate(window, "A Button", printMyName, None)
		    print("Button Initial Name = '" + guitk.BCName(btn) + "'")
		    guitk.BCSetName(btn, "Button with Name")
		    print("Button New Name = '" + guitk.BCName(btn) + "'")
		    guitk.BCShow(window)
		
		
		def printMyName(b, data):
		    print(guitk.BCName(b))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCParent(w: object) -> object:

	"""

	Returns the parent of widget w.
	NOTE: Do not use this function for BCListViewItems etc.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose parent is returned.

	Returns
	-------
	object
		the parent widget of widget w.

	"""

def BCSetEnabled(w: object, enabled: bool) -> None:

	"""

	Sets whether widget w is enabled or not. Widgets that are not enabled cannot be edited by the user.

	Parameters
	----------
	w : object
		the widget.

	enabled : bool
		set this parameter to True to enable widget w, or to False to disable it.

	Returns
	-------
	None

	See Also
	--------
	BCIsEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Common properties example", guitk.constants.BCOnExitDestroy
		    )
		
		    button1 = guitk.BCPushButtonCreate(w, "Disable", disableFunc, None)
		    guitk.BCAddToolTip(button1, "Disable the button widget")
		    button2 = guitk.BCPushButtonCreate(w, "Hide", hideFunc, None)
		    guitk.BCAddToolTip(button2, "Hide the button widget")
		    button3 = guitk.BCPushButtonCreate(w, "Hide later", hideLaterFunc, None)
		    guitk.BCAddToolTip(
		        button3, "Hide the button widget 1 second after the button press"
		    )
		    button4 = guitk.BCPushButtonCreate(w, "Foreground", foregroundFunc, None)
		    guitk.BCAddToolTip(button4, "Change the foreground color of the button widget")
		    button5 = guitk.BCPushButtonCreate(
		        w, "Reset Foreground", resetForegroundFunc, button4
		    )
		    guitk.BCAddToolTip(button5, "Change the foreground color of the button widget")
		    button6 = guitk.BCPushButtonCreate(w, "Background", backgroundFunc, None)
		    guitk.BCAddToolTip(button6, "Change the background color of the button widget")
		
		    guitk.BCShow(w)
		
		
		def disableFunc(b, data):
		    guitk.BCSetEnabled(b, False)
		    return 0
		
		
		def hideFunc(b, data):
		    guitk.BCSetVisible(b, False)
		    return 0
		
		
		def hideLaterFunc(b, data):
		    guitk.BCHideLater(b, 1000)
		    return 0
		
		
		def foregroundFunc(b, data):
		    guitk.BCSetForegroundColor(b, 255, 0, 0)
		    return 0
		
		
		def resetForegroundFunc(b, w):
		    guitk.BCResetForegroundColor(w)
		    return 0
		
		
		def backgroundFunc(b, data):
		    guitk.BCSetBackgroundColor(b, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCIsEnabled(w: object) -> bool:

	"""

	Checks if widget w is enabled or not. Widgets that are not enabled cannot be edited by the user.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	bool
		True if the widget w is enabled or False otherwise.

	See Also
	--------
	BCSetEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Button Colors and Enable example", guitk.constants.BCOnExitDestroy
		    )
		    btn1 = guitk.BCPushButtonCreate(window, "Disable me", disableFunc, None)
		    guitk.BCAddToolTip(btn1, "Disable the button widget")
		    btn2 = guitk.BCPushButtonCreate(window, "Toggle Above", toggleAboveEnabled, btn1)
		    guitk.BCAddToolTip(btn2, "Enabled above button widget")
		    btn3 = guitk.BCPushButtonCreate(
		        window, "Change my Foreground", foregroundFunc, None
		    )
		    guitk.BCAddToolTip(btn3, "Change the foreground color of the button widget")
		    btn4 = guitk.BCPushButtonCreate(
		        window, "Change my Background", backgroundFunc, guitk.BCGetBackgroundColor(btn3)
		    )
		    guitk.BCAddToolTip(btn4, "Change the background color of the button widget")
		    guitk.BCShow(window)
		
		
		def disableFunc(btn, data):
		    guitk.BCSetEnabled(btn, False)
		    return 0
		
		
		def toggleAboveEnabled(btn, btnAbove):
		    alreadyEnabled = guitk.BCIsEnabled(btnAbove)
		    guitk.BCSetEnabled(btnAbove, not alreadyEnabled)
		    print("Above button " + ("disabled" if alreadyEnabled else "enabled"))
		    return 0
		
		
		def foregroundFunc(btn, data):
		    currentForeground = guitk.BCGetForegroundColor(btn)
		    if currentForeground == (255, 0, 0):
		        guitk.BCResetForegroundColor(btn)
		    else:
		        guitk.BCSetForegroundColor(btn, 255, 0, 0)
		    return 0
		
		
		def backgroundFunc(btn, defaultColor):
		    currentBackground = guitk.BCGetBackgroundColor(btn)
		    if currentBackground == (255, 0, 0):
		        guitk.BCSetBackgroundColor(
		            btn, defaultColor[0], defaultColor[1], defaultColor[2]
		        )
		    else:
		        guitk.BCSetBackgroundColor(btn, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCHide(w: object) -> None:

	"""

	Hides the widget w.
	NOTE: if you want to hide a BCPopupMenu use BCPopupMenuClose() instead of BCHide()

	Parameters
	----------
	w : object
		the widget to hide.

	Returns
	-------
	None

	See Also
	--------
	BCShow

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    redLayout = guitk.BCBoxLayoutCreate(redTab, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        redLayout,
		        "The Visible and Shown status of the Button below are printed on TabChange",
		    )
		    btn = guitk.BCPushButtonCreate(redLayout, "Button", None, None)
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    yellowLayout = guitk.BCBoxLayoutCreate(yellowTab, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        yellowLayout,
		        "In this tab, Button's Visible status is 'False' regradless of Shown status.",
		    )
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, btn
		    )
		    guitk.BCTabWidgetSetCurrentTab(tabWidget, redTab)
		
		    hideChkBox = guitk.BCCheckBoxCreate(window, "Hide Button")
		    guitk.BCCheckBoxSetToggledFunction(hideChkBox, hideButton, btn)
		
		    guitk.BCShow(window)
		
		
		def hideButton(chkBox, state, btn):
		    guitk.BCHide(btn) if state else guitk.BCShow(btn)
		    printShownAndVisible(btn)
		    return 0
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, btn):
		    print("Tab Changed to '" + guitk.BCTabWidgetGetTabLabel(tabWidget, newTab) + "'")
		    printShownAndVisible(btn)
		    return 0
		
		
		def printShownAndVisible(btn):
		    print("Button IsVisible = '" + str(guitk.BCIsVisible(btn)) + "'")
		    print("Button IsShown = '" + str(guitk.BCIsShown(btn)) + "'")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCShow(w: object) -> None:

	"""

	Shows the widget w if it was hidden.
	 IMPORTANT: If w is a top-level widget (e.g. BCWindow or BCWizard), the code execution will 'wait' at this function, until w closes, either by 'OK' or 'Cancel'. 
	 If you have created the window with BCOnExitDestroy, it will be DESTROYED after the BCShow() execution, together with all its child widgets. 
	 Thus you MUST NOT try to access data through those widgets (e.g. BCLineEditGetText(le) where le is a BCLineEdit created inside w).

	Parameters
	----------
	w : object
		the widget to show.

	Returns
	-------
	None

	See Also
	--------
	BCHide

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCWindow Example", guitk.constants.BCOnExitDestroy)
		
		    # add some widgets
		    frame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(frame, "Value (Line edit for integers)")
		    guitk.BCLineEditCreateInt(frame, 0)
		    # the OK Cancel dialog
		    guitk.BCDialogButtonBoxCreate(window)
		
		    guitk.BCWindowSetInitSize(window, 400, 200)
		    guitk.BCWindowSetSaveSettings(window, False)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		
		    guitk.BCShow(window)
		
		
		def acceptFunc(win, data):
		    print("Window OK button clicked (Accept)")
		    return 1
		
		
		def rejectFunc(win, data):
		    print("Window cancel button clicked or Esc pressed (Reject)")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCIsShown(w: object) -> bool:

	"""

	Returns True if widget w is shown, otherwise False.
	Note the difference between BCIsShown() and BCIsVisible().
	BCIsVisible() will test whether a widget is currently visible or not. 
	BCIsShown() returns False if BCHide() was called for this particular widget and BCShow() has not been called yet. Otherwise, returns True. Thus you may have a widget which is shown but not visible if, for example, you have called BCHide() for its parent.

	Parameters
	----------
	w : object
		the widget that will be tested whether it is shown.

	Returns
	-------
	bool
		True if w is shown or False if it is not.

	See Also
	--------
	BCIsVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    redLayout = guitk.BCBoxLayoutCreate(redTab, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        redLayout,
		        "The Visible and Shown status of the Button below are printed on TabChange",
		    )
		    btn = guitk.BCPushButtonCreate(redLayout, "Button", None, None)
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    yellowLayout = guitk.BCBoxLayoutCreate(yellowTab, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        yellowLayout,
		        "In this tab, Button's Visible status is 'False' regradless of Shown status.",
		    )
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, btn
		    )
		    guitk.BCTabWidgetSetCurrentTab(tabWidget, redTab)
		
		    hideChkBox = guitk.BCCheckBoxCreate(window, "Hide Button")
		    guitk.BCCheckBoxSetToggledFunction(hideChkBox, hideButton, btn)
		
		    guitk.BCShow(window)
		
		
		def hideButton(chkBox, state, btn):
		    guitk.BCHide(btn) if state else guitk.BCShow(btn)
		    printShownAndVisible(btn)
		    return 0
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, btn):
		    print("Tab Changed to '" + guitk.BCTabWidgetGetTabLabel(tabWidget, newTab) + "'")
		    printShownAndVisible(btn)
		    return 0
		
		
		def printShownAndVisible(btn):
		    print("Button IsVisible = '" + str(guitk.BCIsVisible(btn)) + "'")
		    print("Button IsShown = '" + str(guitk.BCIsShown(btn)) + "'")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGetBackgroundColor(w: object) -> None:

	"""

	Returns the RGB color values of the background color of widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	None
		A tuple with the [int r, int g, int b] background color values of the widget w.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Button Colors and Enable example", guitk.constants.BCOnExitDestroy
		    )
		    btn1 = guitk.BCPushButtonCreate(window, "Disable me", disableFunc, None)
		    guitk.BCAddToolTip(btn1, "Disable the button widget")
		    btn2 = guitk.BCPushButtonCreate(window, "Toggle Above", toggleAboveEnabled, btn1)
		    guitk.BCAddToolTip(btn2, "Enabled above button widget")
		    btn3 = guitk.BCPushButtonCreate(
		        window, "Change my Foreground", foregroundFunc, None
		    )
		    guitk.BCAddToolTip(btn3, "Change the foreground color of the button widget")
		    btn4 = guitk.BCPushButtonCreate(
		        window, "Change my Background", backgroundFunc, guitk.BCGetBackgroundColor(btn3)
		    )
		    guitk.BCAddToolTip(btn4, "Change the background color of the button widget")
		    guitk.BCShow(window)
		
		
		def disableFunc(btn, data):
		    guitk.BCSetEnabled(btn, False)
		    return 0
		
		
		def toggleAboveEnabled(btn, btnAbove):
		    alreadyEnabled = guitk.BCIsEnabled(btnAbove)
		    guitk.BCSetEnabled(btnAbove, not alreadyEnabled)
		    print("Above button " + ("disabled" if alreadyEnabled else "enabled"))
		    return 0
		
		
		def foregroundFunc(btn, data):
		    currentForeground = guitk.BCGetForegroundColor(btn)
		    if currentForeground == (255, 0, 0):
		        guitk.BCResetForegroundColor(btn)
		    else:
		        guitk.BCSetForegroundColor(btn, 255, 0, 0)
		    return 0
		
		
		def backgroundFunc(btn, defaultColor):
		    currentBackground = guitk.BCGetBackgroundColor(btn)
		    if currentBackground == (255, 0, 0):
		        guitk.BCSetBackgroundColor(
		            btn, defaultColor[0], defaultColor[1], defaultColor[2]
		        )
		    else:
		        guitk.BCSetBackgroundColor(btn, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGetForegroundColor(w: object) -> None:

	"""

	Returns the RGB color values of the foreground color of widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	None
		A tuple with the [int r, int g, int b] foreground color values of the widget w.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Button Colors and Enable example", guitk.constants.BCOnExitDestroy
		    )
		    btn1 = guitk.BCPushButtonCreate(window, "Disable me", disableFunc, None)
		    guitk.BCAddToolTip(btn1, "Disable the button widget")
		    btn2 = guitk.BCPushButtonCreate(window, "Toggle Above", toggleAboveEnabled, btn1)
		    guitk.BCAddToolTip(btn2, "Enabled above button widget")
		    btn3 = guitk.BCPushButtonCreate(
		        window, "Change my Foreground", foregroundFunc, None
		    )
		    guitk.BCAddToolTip(btn3, "Change the foreground color of the button widget")
		    btn4 = guitk.BCPushButtonCreate(
		        window, "Change my Background", backgroundFunc, guitk.BCGetBackgroundColor(btn3)
		    )
		    guitk.BCAddToolTip(btn4, "Change the background color of the button widget")
		    guitk.BCShow(window)
		
		
		def disableFunc(btn, data):
		    guitk.BCSetEnabled(btn, False)
		    return 0
		
		
		def toggleAboveEnabled(btn, btnAbove):
		    alreadyEnabled = guitk.BCIsEnabled(btnAbove)
		    guitk.BCSetEnabled(btnAbove, not alreadyEnabled)
		    print("Above button " + ("disabled" if alreadyEnabled else "enabled"))
		    return 0
		
		
		def foregroundFunc(btn, data):
		    currentForeground = guitk.BCGetForegroundColor(btn)
		    if currentForeground == (255, 0, 0):
		        guitk.BCResetForegroundColor(btn)
		    else:
		        guitk.BCSetForegroundColor(btn, 255, 0, 0)
		    return 0
		
		
		def backgroundFunc(btn, defaultColor):
		    currentBackground = guitk.BCGetBackgroundColor(btn)
		    if currentBackground == (255, 0, 0):
		        guitk.BCSetBackgroundColor(
		            btn, defaultColor[0], defaultColor[1], defaultColor[2]
		        )
		    else:
		        guitk.BCSetBackgroundColor(btn, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetBackgroundColor(w: object, r: int, g: int, b: int) -> None:

	"""

	Sets the RGB values for the background color of widget w to be r, g and b.
	NOTE: This function may not work for certain widgets under some styles.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose background color will be set.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	See Also
	--------
	BCSetForegroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Common properties example", guitk.constants.BCOnExitDestroy
		    )
		
		    button1 = guitk.BCPushButtonCreate(w, "Disable", disableFunc, None)
		    guitk.BCAddToolTip(button1, "Disable the button widget")
		    button2 = guitk.BCPushButtonCreate(w, "Hide", hideFunc, None)
		    guitk.BCAddToolTip(button2, "Hide the button widget")
		    button3 = guitk.BCPushButtonCreate(w, "Hide later", hideLaterFunc, None)
		    guitk.BCAddToolTip(
		        button3, "Hide the button widget 1 second after the button press"
		    )
		    button4 = guitk.BCPushButtonCreate(w, "Foreground", foregroundFunc, None)
		    guitk.BCAddToolTip(button4, "Change the foreground color of the button widget")
		    button5 = guitk.BCPushButtonCreate(
		        w, "Reset Foreground", resetForegroundFunc, button4
		    )
		    guitk.BCAddToolTip(button5, "Change the foreground color of the button widget")
		    button6 = guitk.BCPushButtonCreate(w, "Background", backgroundFunc, None)
		    guitk.BCAddToolTip(button6, "Change the background color of the button widget")
		
		    guitk.BCShow(w)
		
		
		def disableFunc(b, data):
		    guitk.BCSetEnabled(b, False)
		    return 0
		
		
		def hideFunc(b, data):
		    guitk.BCSetVisible(b, False)
		    return 0
		
		
		def hideLaterFunc(b, data):
		    guitk.BCHideLater(b, 1000)
		    return 0
		
		
		def foregroundFunc(b, data):
		    guitk.BCSetForegroundColor(b, 255, 0, 0)
		    return 0
		
		
		def resetForegroundFunc(b, w):
		    guitk.BCResetForegroundColor(w)
		    return 0
		
		
		def backgroundFunc(b, data):
		    guitk.BCSetBackgroundColor(b, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetForegroundColor(w: object, r: int, g: int, b: int) -> None:

	"""

	Sets the RGB values for the foreground color of widget w to be r, g and b.
	NOTE: This function may not work for certain widgets under some styles.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose foreground color will be set.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	See Also
	--------
	BCSetBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Common properties example", guitk.constants.BCOnExitDestroy
		    )
		
		    button1 = guitk.BCPushButtonCreate(w, "Disable", disableFunc, None)
		    guitk.BCAddToolTip(button1, "Disable the button widget")
		    button2 = guitk.BCPushButtonCreate(w, "Hide", hideFunc, None)
		    guitk.BCAddToolTip(button2, "Hide the button widget")
		    button3 = guitk.BCPushButtonCreate(w, "Hide later", hideLaterFunc, None)
		    guitk.BCAddToolTip(
		        button3, "Hide the button widget 1 second after the button press"
		    )
		    button4 = guitk.BCPushButtonCreate(w, "Foreground", foregroundFunc, None)
		    guitk.BCAddToolTip(button4, "Change the foreground color of the button widget")
		    button5 = guitk.BCPushButtonCreate(
		        w, "Reset Foreground", resetForegroundFunc, button4
		    )
		    guitk.BCAddToolTip(button5, "Change the foreground color of the button widget")
		    button6 = guitk.BCPushButtonCreate(w, "Background", backgroundFunc, None)
		    guitk.BCAddToolTip(button6, "Change the background color of the button widget")
		
		    guitk.BCShow(w)
		
		
		def disableFunc(b, data):
		    guitk.BCSetEnabled(b, False)
		    return 0
		
		
		def hideFunc(b, data):
		    guitk.BCSetVisible(b, False)
		    return 0
		
		
		def hideLaterFunc(b, data):
		    guitk.BCHideLater(b, 1000)
		    return 0
		
		
		def foregroundFunc(b, data):
		    guitk.BCSetForegroundColor(b, 255, 0, 0)
		    return 0
		
		
		def resetForegroundFunc(b, w):
		    guitk.BCResetForegroundColor(w)
		    return 0
		
		
		def backgroundFunc(b, data):
		    guitk.BCSetBackgroundColor(b, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCHideLater(w: object, ms: int) -> None:

	"""

	Hides widget w, after ms milliseconds.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to hide.

	ms : int
		milliseconds.

	Returns
	-------
	None

	See Also
	--------
	BCHide

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Common properties example", guitk.constants.BCOnExitDestroy
		    )
		
		    button1 = guitk.BCPushButtonCreate(w, "Disable", disableFunc, None)
		    guitk.BCAddToolTip(button1, "Disable the button widget")
		    button2 = guitk.BCPushButtonCreate(w, "Hide", hideFunc, None)
		    guitk.BCAddToolTip(button2, "Hide the button widget")
		    button3 = guitk.BCPushButtonCreate(w, "Hide later", hideLaterFunc, None)
		    guitk.BCAddToolTip(
		        button3, "Hide the button widget 1 second after the button press"
		    )
		    button4 = guitk.BCPushButtonCreate(w, "Foreground", foregroundFunc, None)
		    guitk.BCAddToolTip(button4, "Change the foreground color of the button widget")
		    button5 = guitk.BCPushButtonCreate(
		        w, "Reset Foreground", resetForegroundFunc, button4
		    )
		    guitk.BCAddToolTip(button5, "Change the foreground color of the button widget")
		    button6 = guitk.BCPushButtonCreate(w, "Background", backgroundFunc, None)
		    guitk.BCAddToolTip(button6, "Change the background color of the button widget")
		
		    guitk.BCShow(w)
		
		
		def disableFunc(b, data):
		    guitk.BCSetEnabled(b, False)
		    return 0
		
		
		def hideFunc(b, data):
		    guitk.BCSetVisible(b, False)
		    return 0
		
		
		def hideLaterFunc(b, data):
		    guitk.BCHideLater(b, 1000)
		    return 0
		
		
		def foregroundFunc(b, data):
		    guitk.BCSetForegroundColor(b, 255, 0, 0)
		    return 0
		
		
		def resetForegroundFunc(b, w):
		    guitk.BCResetForegroundColor(w)
		    return 0
		
		
		def backgroundFunc(b, data):
		    guitk.BCSetBackgroundColor(b, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCIsVisible(w: object) -> bool:

	"""

	Returns True if widget w is visible, otherwise False.
	Note the difference between BCIsShown() and BCIsVisible().
	BCIsVisible() will test whether a widget is currently visible or not. 
	BCIsShown() returns False if BCHide() was called for this particular widget and BCShow() has not been called yet. Otherwise, returns True. Thus you may have a widget which is shown but not visible if, for example, you have called BCHide() for its parent.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose visibility is tested.

	Returns
	-------
	bool
		True if w is visible or False if it is not.

	See Also
	--------
	BCSetVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    redLayout = guitk.BCBoxLayoutCreate(redTab, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        redLayout,
		        "The Visible and Shown status of the Button below are printed on TabChange",
		    )
		    btn = guitk.BCPushButtonCreate(redLayout, "Button", None, None)
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    yellowLayout = guitk.BCBoxLayoutCreate(yellowTab, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        yellowLayout,
		        "In this tab, Button's Visible status is 'False' regradless of Shown status.",
		    )
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, btn
		    )
		    guitk.BCTabWidgetSetCurrentTab(tabWidget, redTab)
		
		    hideChkBox = guitk.BCCheckBoxCreate(window, "Hide Button")
		    guitk.BCCheckBoxSetToggledFunction(hideChkBox, hideButton, btn)
		
		    guitk.BCShow(window)
		
		
		def hideButton(chkBox, state, btn):
		    guitk.BCHide(btn) if state else guitk.BCShow(btn)
		    printShownAndVisible(btn)
		    return 0
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, btn):
		    print("Tab Changed to '" + guitk.BCTabWidgetGetTabLabel(tabWidget, newTab) + "'")
		    printShownAndVisible(btn)
		    return 0
		
		
		def printShownAndVisible(btn):
		    print("Button IsVisible = '" + str(guitk.BCIsVisible(btn)) + "'")
		    print("Button IsShown = '" + str(guitk.BCIsShown(btn)) + "'")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetVisible(w: object, visible: bool) -> None:

	"""

	Sets the widget to visible status if all its parent widgets up to the window are visible.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	visible : bool
		set this parameter to True to sets the widget to visible status, or to False to hides it.

	Returns
	-------
	None

	See Also
	--------
	BCIsVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Common properties example", guitk.constants.BCOnExitDestroy
		    )
		
		    button1 = guitk.BCPushButtonCreate(w, "Disable", disableFunc, None)
		    guitk.BCAddToolTip(button1, "Disable the button widget")
		    button2 = guitk.BCPushButtonCreate(w, "Hide", hideFunc, None)
		    guitk.BCAddToolTip(button2, "Hide the button widget")
		    button3 = guitk.BCPushButtonCreate(w, "Hide later", hideLaterFunc, None)
		    guitk.BCAddToolTip(
		        button3, "Hide the button widget 1 second after the button press"
		    )
		    button4 = guitk.BCPushButtonCreate(w, "Foreground", foregroundFunc, None)
		    guitk.BCAddToolTip(button4, "Change the foreground color of the button widget")
		    button5 = guitk.BCPushButtonCreate(
		        w, "Reset Foreground", resetForegroundFunc, button4
		    )
		    guitk.BCAddToolTip(button5, "Change the foreground color of the button widget")
		    button6 = guitk.BCPushButtonCreate(w, "Background", backgroundFunc, None)
		    guitk.BCAddToolTip(button6, "Change the background color of the button widget")
		
		    guitk.BCShow(w)
		
		
		def disableFunc(b, data):
		    guitk.BCSetEnabled(b, False)
		    return 0
		
		
		def hideFunc(b, data):
		    guitk.BCSetVisible(b, False)
		    return 0
		
		
		def hideLaterFunc(b, data):
		    guitk.BCHideLater(b, 1000)
		    return 0
		
		
		def foregroundFunc(b, data):
		    guitk.BCSetForegroundColor(b, 255, 0, 0)
		    return 0
		
		
		def resetForegroundFunc(b, w):
		    guitk.BCResetForegroundColor(w)
		    return 0
		
		
		def backgroundFunc(b, data):
		    guitk.BCSetBackgroundColor(b, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidth(w: object) -> int:

	"""

	Returns the width of widget w.
	CAUTION This functions returns the original width of the widget, unless it is a BCWindow.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose width will be examined.

	Returns
	-------
	int
		the width of widget w.

	See Also
	--------
	BCHeight

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Dimensions", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    btnDimensions = guitk.BCPushButtonCreate(hBox, "Calculate Dimensions", None, None)
		    label = guitk.BCLabelCreate(hBox, "Button Dimensions\t\t\\nWindow Dimensions\t\t")
		    guitk.BCButtonSetClickedFunction(
		        btnDimensions, lambda btn, data: showDimensions(btn, *data), [window, label]
		    )
		    guitk.BCTimerSingleShot(
		        0, lambda data: showDimensions(btnDimensions, *data), [window, label]
		    )
		    guitk.BCShow(window)
		
		
		def showDimensions(btn, window, label):
		    print("Old dimensions:\\n" + guitk.BCLabelText(label) + "\\n")
		    newDimensionsText = (
		        "Button Dimensions = "
		        + str(guitk.BCWidth(btn))
		        + "x"
		        + str(guitk.BCHeight(btn))
		    )
		    newDimensionsText += (
		        "\\nWindow Dimensions = "
		        + str(guitk.BCWidth(window))
		        + "x"
		        + str(guitk.BCHeight(window))
		    )
		    guitk.BCLabelSetText(label, newDimensionsText)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCHeight(w: object) -> int:

	"""

	Returns the height of widget w.
	CAUTION This functions returns the original height of the widget, unless it is a BCWindow.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose height will be examined.

	Returns
	-------
	int
		the height of widget w.

	See Also
	--------
	BCWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Dimensions", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    btnDimensions = guitk.BCPushButtonCreate(hBox, "Calculate Dimensions", None, None)
		    label = guitk.BCLabelCreate(hBox, "Button Dimensions\t\t\\nWindow Dimensions\t\t")
		    guitk.BCButtonSetClickedFunction(
		        btnDimensions, lambda btn, data: showDimensions(btn, *data), [window, label]
		    )
		    guitk.BCTimerSingleShot(
		        0, lambda data: showDimensions(btnDimensions, *data), [window, label]
		    )
		    guitk.BCShow(window)
		
		
		def showDimensions(btn, window, label):
		    print("Old dimensions:\\n" + guitk.BCLabelText(label) + "\\n")
		    newDimensionsText = (
		        "Button Dimensions = "
		        + str(guitk.BCWidth(btn))
		        + "x"
		        + str(guitk.BCHeight(btn))
		    )
		    newDimensionsText += (
		        "\\nWindow Dimensions = "
		        + str(guitk.BCWidth(window))
		        + "x"
		        + str(guitk.BCHeight(window))
		    )
		    guitk.BCLabelSetText(label, newDimensionsText)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDestroy(w: object) -> None:

	"""

	Deletes w immediately (i.e. frees all resources allocated to this object).
	This function should be carefully used.
	WARNING: Do not use this function with BCListViewItem. Use BCListViewItemDestroy instead.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to be destroyed.

	Returns
	-------
	None

	See Also
	--------
	BCDestroyLater

	"""

def BCDestroyLater(w: object) -> None:

	"""

	Deletes w (i.e. frees all resources allocated to this object).
	Is more safe than deleting immediately because frees w resources on the next event delivery.
	WARNING: Do not use this function with BCListViewItem or BCPlotCurve. Use BCListViewItemDestroy or BCPlotCurveDestroy instead.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to be destroyed.

	Returns
	-------
	None

	See Also
	--------
	BCDestroy

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonComboBox LineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(bLayout, "Button")
		    btnCmb = guitk.BCButtonComboBoxCreate(bLayout, ["Option 1", "Option 2", "Option 3"])
		    btnAdd = guitk.BCToolButtonCreate(
		        btnCmb, "add_small.svg", "", btnAddClickedFunction, btnCmb
		    )
		    guitk.BCButtonComboBoxAddLeftButton(btnCmb, btnAdd)
		    guitk.BCShow(window)
		
		
		def btnAddClickedFunction(toolBtn, btnCmb):
		    cmbLineEdit = guitk.BCButtonComboBoxGetButtonLineEditWidget(btnCmb)
		    guitk.BCButtonLineEditSetText(cmbLineEdit, "Added a ToolButton to the left")
		    btnRemoveMe = guitk.BCToolButtonCreate(
		        btnCmb, "cancel_small.svg", "", removeMe, btnCmb
		    )
		    guitk.BCButtonComboBoxAddLeftButton(btnCmb, btnRemoveMe)
		    return 0
		
		
		def removeMe(toolBtn, btnCmb):
		    guitk.BCButtonComboBoxRemoveButton(btnCmb, toolBtn)
		    cmbLineEdit = guitk.BCButtonComboBoxGetButtonLineEditWidget(btnCmb)
		    guitk.BCButtonLineEditSetText(cmbLineEdit, "Removed clicked ToolButton")
		    guitk.BCDestroyLater(toolBtn)
		    return 0
		
		
		def acceptFunction(window, btnCmb):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAddToolTip(w: object, tip: str) -> None:

	"""

	Adds a tooltip (balloon help) to widget w. 
	A tooltip is a piece of text in a small frame that briefly describes the use 
	of the widget. The tooltip is activated when mouse pointer is over widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to which the tooltip will be added by this function.

	tip : str
		the text that the tooltip will contain.

	Returns
	-------
	None

	See Also
	--------
	BCAddToolTipImage

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Common properties example", guitk.constants.BCOnExitDestroy
		    )
		
		    button1 = guitk.BCPushButtonCreate(w, "Disable", disableFunc, None)
		    guitk.BCAddToolTip(button1, "Disable the button widget")
		    button2 = guitk.BCPushButtonCreate(w, "Hide", hideFunc, None)
		    guitk.BCAddToolTip(button2, "Hide the button widget")
		    button3 = guitk.BCPushButtonCreate(w, "Hide later", hideLaterFunc, None)
		    guitk.BCAddToolTip(
		        button3, "Hide the button widget 1 second after the button press"
		    )
		    button4 = guitk.BCPushButtonCreate(w, "Foreground", foregroundFunc, None)
		    guitk.BCAddToolTip(button4, "Change the foreground color of the button widget")
		    button5 = guitk.BCPushButtonCreate(
		        w, "Reset Foreground", resetForegroundFunc, button4
		    )
		    guitk.BCAddToolTip(button5, "Change the foreground color of the button widget")
		    button6 = guitk.BCPushButtonCreate(w, "Background", backgroundFunc, None)
		    guitk.BCAddToolTip(button6, "Change the background color of the button widget")
		
		    guitk.BCShow(w)
		
		
		def disableFunc(b, data):
		    guitk.BCSetEnabled(b, False)
		    return 0
		
		
		def hideFunc(b, data):
		    guitk.BCSetVisible(b, False)
		    return 0
		
		
		def hideLaterFunc(b, data):
		    guitk.BCHideLater(b, 1000)
		    return 0
		
		
		def foregroundFunc(b, data):
		    guitk.BCSetForegroundColor(b, 255, 0, 0)
		    return 0
		
		
		def resetForegroundFunc(b, w):
		    guitk.BCResetForegroundColor(w)
		    return 0
		
		
		def backgroundFunc(b, data):
		    guitk.BCSetBackgroundColor(b, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAddToolTipImage(w: object, fileImage: str) -> None:

	"""

	Adds an image as tooltip (balloon help) to widget w. 
	A tooltip is a piece of text or image in a small frame that briefly describes the use 
	of the widget. The tooltip is activated when mouse pointer is over widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to which the tooltip will be added by this function.

	fileImage : str
		the filename of image that the tooltip will contain.

	Returns
	-------
	None

	See Also
	--------
	BCAddToolTip

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Tooltips example", guitk.constants.BCOnExitDestroy)
		    btn1 = guitk.BCPushButtonCreate(window, "Button without ToolTip", btnClicked, None)
		    btn2 = guitk.BCPushButtonCreate(window, "Button with ToolTip", btnClicked, None)
		    guitk.BCAddToolTip(btn2, "Tooltip Text")
		    btn3 = guitk.BCPushButtonCreate(
		        window, "Button with ToolTipImage", btnClicked, None
		    )
		    iconFileName = "logo_sdm.svg"
		    if guitk.BCIconIsValid(iconFileName):
		        guitk.BCAddToolTipImage(btn3, iconFileName)
		    else:
		        print("Invalid icon FileName")
		    guitk.BCShow(window)
		
		
		def btnClicked(btn, data):
		    print("\\nToolTipText: '" + guitk.BCGetToolTipText(btn) + "'")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGetToolTipText(w: object) -> str:

	"""

	Returns the text that the tooltip (balloon help) of widget w contains.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to which the tooltip is added.

	Returns
	-------
	str
		the text of tooltip.

	See Also
	--------
	BCAddToolTip

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Tooltips example", guitk.constants.BCOnExitDestroy)
		    btn1 = guitk.BCPushButtonCreate(window, "Button without ToolTip", btnClicked, None)
		    btn2 = guitk.BCPushButtonCreate(window, "Button with ToolTip", btnClicked, None)
		    guitk.BCAddToolTip(btn2, "Tooltip Text")
		    btn3 = guitk.BCPushButtonCreate(
		        window, "Button with ToolTipImage", btnClicked, None
		    )
		    iconFileName = "logo_sdm.svg"
		    if guitk.BCIconIsValid(iconFileName):
		        guitk.BCAddToolTipImage(btn3, iconFileName)
		    else:
		        print("Invalid icon FileName")
		    guitk.BCShow(window)
		
		
		def btnClicked(btn, data):
		    print("\\nToolTipText: '" + guitk.BCGetToolTipText(btn) + "'")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLayout(w: object) -> object:

	"""

	Returns the layout engine that manages the geometry of this widget's children. 
	If the widget does not have a layout the BCLayout function returns 0.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		any widget.

	Returns
	-------
	object

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "H/VBoxCreate Example", guitk.constants.BCOnExitDestroy
		    )
		
		    checkBoxReverse = guitk.BCCheckBoxCreate(window, "Reverse Main Layout")
		    guitk.BCCheckBoxSetToggledFunction(checkBoxReverse, reverseToggled, window)
		
		    vBox = guitk.BCVBoxCreate(window)
		    guitk.BCLabelCreate(vBox, "Vertical Label 1")
		    guitk.BCLabelCreate(vBox, "Vertical Label 2")
		    guitk.BCLabelCreate(vBox, "Vertical Label 3")
		
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox, "Horizontal Label 1")
		    guitk.BCLabelCreate(hBox, "Horizontal Label 2")
		
		    vBox2 = guitk.BCVBoxCreate(hBox)
		    guitk.BCLabelCreate(vBox2, "H-V label 1")
		    guitk.BCLabelCreate(vBox2, "H-V label 2")
		    btnFlash = guitk.BCPushButtonCreate(vBox2, "Flash Box", btnFlashClicked, vBox2)
		
		    guitk.BCShow(window)
		
		
		def reverseToggled(checkBOx, state, window):
		    layMain = guitk.BCLayout(window)
		    guitk.BCBoxLayoutSetDirection(
		        layMain,
		        guitk.constants.BCBottomToTop if state else guitk.constants.BCTopToBottom,
		    )
		    return 0
		
		
		def btnFlashClicked(btn, box):
		    guitk.BCFlash(box)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGetUserDataKey(o: object, key: str) -> object:

	"""

	Retrieves user data from widget o using a char key key.
	These data were set by calling BCSetUserData().

	Parameters
	----------
	o : object
		the object (widget or layout) where data were stored.

	key : str
		the key where data was stored.

	Returns
	-------
	object

	See Also
	--------
	BCSetUserDataKey

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("UserDataKey Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button1 = guitk.BCPushButtonCreate(blayout, "Set Caption 1", setCaption, w)
		    button2 = guitk.BCPushButtonCreate(blayout, "Set Caption 2", setCaption, w)
		    button3 = guitk.BCPushButtonCreate(blayout, "Set Caption 3", setCaption, w)
		    guitk.BCSetUserDataKey(button1, "key", "Caption 1")
		    guitk.BCSetUserDataKey(button2, "key", "Caption 2")
		    guitk.BCSetUserDataKey(button3, "key", "Caption 3")
		
		    guitk.BCBoxLayoutInsert(blayout, button1, -1)
		    guitk.BCBoxLayoutInsert(blayout, button2, -1)
		    guitk.BCBoxLayoutInsert(blayout, button3, -1)
		
		    guitk.BCShow(w)
		
		
		def setCaption(b, window):
		    caption = guitk.BCGetUserDataKey(b, "key")
		    guitk.BCSetCaption(window, caption)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetUserDataKey(o: object, key: str, data: Any=None) -> None:

	"""

	Sets user data data for object o using a char key key.
	These data can be retrieved at any time by calling BCGetUserDataKey().
	NOTE: If you want to assign data at ListViewItem use BCListViewItemSetUserData().

	Parameters
	----------
	o : object
		any object (widget or layout).

	key : str
		any key to store data.

	data : Any, optional
		the data to store.

	Returns
	-------
	None

	See Also
	--------
	BCGetUserDataKey

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("UserDataKey Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button1 = guitk.BCPushButtonCreate(blayout, "Set Caption 1", setCaption, w)
		    button2 = guitk.BCPushButtonCreate(blayout, "Set Caption 2", setCaption, w)
		    button3 = guitk.BCPushButtonCreate(blayout, "Set Caption 3", setCaption, w)
		    guitk.BCSetUserDataKey(button1, "key", "Caption 1")
		    guitk.BCSetUserDataKey(button2, "key", "Caption 2")
		    guitk.BCSetUserDataKey(button3, "key", "Caption 3")
		
		    guitk.BCBoxLayoutInsert(blayout, button1, -1)
		    guitk.BCBoxLayoutInsert(blayout, button2, -1)
		    guitk.BCBoxLayoutInsert(blayout, button3, -1)
		
		    guitk.BCShow(w)
		
		
		def setCaption(b, window):
		    caption = guitk.BCGetUserDataKey(b, "key")
		    guitk.BCSetCaption(window, caption)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGetTopWidget(w: object) -> object:

	"""

	Returns the parent widget of w widget provided that the parent is a BCWindow class widget.
	Returns None if parent is not such a type.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		any widget.

	Returns
	-------
	object
		the parent of w provided that parent is a BCWindow.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Accept/Reject Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelCreate(window, "WindowAcceptFunction returns 1 (Closes the window)")
		    guitk.BCLabelCreate(
		        window, "WindowRejectFunction returns 0 (Keeps the window open)"
		    )
		    lineEdit = guitk.BCLineEditCreate(window, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineEdit,
		        "Submitting a lineEdit, i.e. pressing Enter while it has focus, triggers WindowAccept",
		    )
		    btn = guitk.BCPushButtonCreate(window, "OK", okClicked, lineEdit)
		    guitk.BCAddToolTip(
		        btn, "Accepts the window if lineEdit has text; otherwise rejects it"
		    )
		    # Warning: never set both accept and reject function to retun 0
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def okClicked(btn, lineEdit):
		    window = guitk.BCGetTopWidget(btn)
		    if window:
		        guitk.BCWindowAccept(window) if guitk.BCLineEditHasText(
		            lineEdit
		        ) else guitk.BCWindowReject(window)
		    return 0
		
		
		def acceptFunc(window, data):
		    print("Window accepted (Enter). Window will close (return 1).")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Window rejected (Esc). Window will remain open (return 0).")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetTabOrder(firstWidget: object, secondWidget: object) -> None:

	"""

	Modify the order of keyboard focus inside a window.
	Focus changes when the Tab key is pressed. Imagine tab order as a ring. 
	By default keyboard focus order gets the order the widgets are inserted.
	If you decide to change the tab order of a widget, you will have to 
	specify the previous and next focus nodes of the chain.
	This function is not supported under VR mode.

	Parameters
	----------
	firstWidget : object
		any widget.

	secondWidget : object
		any widget.

	Returns
	-------
	None

	See Also
	--------
	BCSetFocusPolicy

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Focus with SaveSettings Example", guitk.constants.BCOnExitDestroy
		    )
		
		    btn1 = guitk.BCPushButtonCreate(window, "Button 1", None, None)
		    btn2 = guitk.BCPushButtonCreate(window, "Button 2", None, None)
		    lineEdit = guitk.BCLineEditCreate(window, "")
		    cmbFocus = guitk.BCComboBoxCreate(
		        window,
		        ["BCNoFocus", "BCTabFocus", "BCClickFocus", "BCStrongFocus", "BCWheelFocus"],
		    )
		
		    chkBoxReverse = guitk.BCCheckBoxCreate(window, "Reverse Buttons' Focus Order")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReverse, cbReverseToggled, [btn1, btn2])
		
		    guitk.BCSetFocusColor(lineEdit, 200, 0, 0)
		
		    widgets = [btn1, btn2, lineEdit, cmbFocus, chkBoxReverse]
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(
		        cmbFocus, cmbFocusCurrentIndexChanged, widgets
		    )
		    guitk.BCComboBoxSetCurrentItem(cmbFocus, 3)
		
		    guitk.BCShow(window)
		
		
		def cbReverseToggled(cb, state, btns):
		    btn1, btn2 = tuple(btns)
		    guitk.BCSetTabOrder(btn2, btn1) if state else guitk.BCSetTabOrder(btn1, btn2)
		    return 0
		
		
		def cmbFocusCurrentIndexChanged(cmb, index, widgets):
		    focusPolicy = eval("guitk.constants." + guitk.BCComboBoxCurrentText(cmb))
		    for widget in widgets:
		        guitk.BCSetFocusPolicy(widget, focusPolicy)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetFocusPolicy(w: object, fpolicy: int) -> None:

	"""

	Sets the focus policy for the widget w to fpolicy.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to affect.

	fpolicy : int
		the focus policy.
		See BCEnumFocusPolicy.
		
		guitk.constants BCEnumFocusPolicy
		This enum defines the various policies a widget can have with respect to acquiring keyboard focus.
		 - guitk.constants.BCNoFocus
		Widget does not accept focus.
		 - guitk.constants.BCTabFocus
		Widget accepts focus by tabbing.
		 - guitk.constants.BCClickFocus
		Widget accepts focus by clicking.
		 - guitk.constants.BCStrongFocus
		Widget accepts focus by both tabbing and clicking.
		 - guitk.constants.BCWheelFocus
		Like BCStrongFocus plus the widget accepts focus by rolling the mouse wheel when widget is under mouse.

	Returns
	-------
	None

	See Also
	--------
	BCSetTabOrder

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Focus with SaveSettings Example", guitk.constants.BCOnExitDestroy
		    )
		
		    btn1 = guitk.BCPushButtonCreate(window, "Button 1", None, None)
		    btn2 = guitk.BCPushButtonCreate(window, "Button 2", None, None)
		    lineEdit = guitk.BCLineEditCreate(window, "")
		    cmbFocus = guitk.BCComboBoxCreate(
		        window,
		        ["BCNoFocus", "BCTabFocus", "BCClickFocus", "BCStrongFocus", "BCWheelFocus"],
		    )
		
		    chkBoxReverse = guitk.BCCheckBoxCreate(window, "Reverse Buttons' Focus Order")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReverse, cbReverseToggled, [btn1, btn2])
		
		    guitk.BCSetFocusColor(lineEdit, 200, 0, 0)
		
		    widgets = [btn1, btn2, lineEdit, cmbFocus, chkBoxReverse]
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(
		        cmbFocus, cmbFocusCurrentIndexChanged, widgets
		    )
		    guitk.BCComboBoxSetCurrentItem(cmbFocus, 3)
		
		    guitk.BCShow(window)
		
		
		def cbReverseToggled(cb, state, btns):
		    btn1, btn2 = tuple(btns)
		    guitk.BCSetTabOrder(btn2, btn1) if state else guitk.BCSetTabOrder(btn1, btn2)
		    return 0
		
		
		def cmbFocusCurrentIndexChanged(cmb, index, widgets):
		    focusPolicy = eval("guitk.constants." + guitk.BCComboBoxCurrentText(cmb))
		    for widget in widgets:
		        guitk.BCSetFocusPolicy(widget, focusPolicy)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetApplicationOverrideCursor(cursor: int) -> None:

	"""

	Overrides the cursors set for all BCWindows/widgets of the current application to the one represented by cursor.
	This function adds a cursor to a stack so that for every call to this function a respective call to BCRestoreApplicationOverrideCursor must be made to restore the application's cursor status.
	This function is not supported under VR mode.

	Parameters
	----------
	cursor : int
		the cursor (see BCEnumCursor). See BCEnumCursor for details.
		
		guitk.constants BCEnumCursor
		The mouse cursor shape.
		 - guitk.constants.BCCursorCross
		Cross pointer used mainly for design areas.
		 - guitk.constants.BCCursorBlank
		A blank cursor has no visualization.
		 - guitk.constants.BCCursorWhatsThis
		A pointer with a questionmark.
		 - guitk.constants.BCCursorWait
		The sandglass pointer used mainly when the application is proccessing.
		 - guitk.constants.BCCursorMouse
		A three button mouse representation in white color.
		 - guitk.constants.BCCursorExclamation
		An exclamation mark in white color.
		 - guitk.constants.BCCursorArrow
		The standard arrow cursor.
		 - guitk.constants.BCCursorSizeVer
		A cursor used for elements that are used to vertically resize top-level windows.
		 - guitk.constants.BCCursorSizeHor
		A cursor used for elements that are used to horizontally resize top-level windows.
		 - guitk.constants.BCCursorSizeBDiag
		A cursor used for elements that are used to diagonally resize top-level windows at their top-right and bottom-left corners.
		 - guitk.constants.BCCursorSizeFDiag
		A cursor used for elements that are used to diagonally resize top-level windows at their top-left and bottom-right corners.
		 - guitk.constants.BCCursorSizeAll
		A cursor used for elements that are used to resize top-level windows in any direction.
		 - guitk.constants.BCCursorSplitV
		A cursor used for vertical splitters, indicating that a handle can be dragged vertically to adjust the use of available space.
		 - guitk.constants.BCCursorSplitH
		A cursor used for horizontal splitters, indicating that a handle can be dragged horizontally to adjust the use of available space.
		 - guitk.constants.BCCursorPointingHand
		A pointing hand cursor that is typically used for clickable elements such as hyperlinks.
		 - guitk.constants.BCCursorForbidden
		A slashed circle cursor, typically used during drag and drop operations to indicate that dragged content cannot be dropped on particular widgets or inside certain regions.
		 - guitk.constants.BCCursorOpenHand
		A cursor representing an open hand, typically used to indicate that the area under the cursor is the visible part of a canvas that the user can click and drag in order to scroll around.
		 - guitk.constants.BCCursorClosedHand
		A cursor representing a closed hand, typically used to indicate that a dragging operation is in progress that involves scrolling.
		 - guitk.constants.BCCursorBusy
		An hourglass or watch cursor, usually shown during operations that allow the user to interact with the application while they are performed in the background.
		 - guitk.constants.BCCursorZoomIn
		A magnifying glass with a plus sign in it.
		 - guitk.constants.BCCursorZoomOut
		A magnifying glass with a minus sign in it.
		 - guitk.constants.BCCursorIBeam
		A caret or ibeam cursor, indicating that a widget can accept and display text input.
		 - guitk.constants.BCCursorUpArrow
		An arrow pointing upwards toward the top of the screen.
		 - guitk.constants.BCCursorRotate
		A cursor indicating that rotation mode is on
		 - guitk.constants.BCCursorZoomRect
		A cursor indicating that zoom reactangle mode is on.
		 - guitk.constants.BCCursorZoom
		A cursor indicating that zoom mode is on.
		 - guitk.constants.BCCursorPanRotateZoom
		A cursor indicating that Pan Rotate Zoom is on.

	Returns
	-------
	None

	See Also
	--------
	BCRestoreApplicationOverrideCursor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Cursor Example", guitk.constants.BCOnExitDestroy)
		
		    guitk.BCSetApplicationOverrideCursor(guitk.constants.BCCursorWait)
		    CalculateHugeData()
		    guitk.BCRestoreApplicationOverrideCursor()
		
		    guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRestoreApplicationOverrideCursor() -> None:

	"""

	Restores the current cursor of the current application set by BCSetApplicationOverrideCursor().
	This function must be called after BCSetApplicationOverrideCursor() was called to remove the current cursor from the stack.
	This function is not supported under VR mode.

	Returns
	-------
	None

	See Also
	--------
	BCSetApplicationOverrideCursor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Cursor Example", guitk.constants.BCOnExitDestroy)
		
		    guitk.BCSetApplicationOverrideCursor(guitk.constants.BCCursorWait)
		    CalculateHugeData()
		    guitk.BCRestoreApplicationOverrideCursor()
		
		    guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetSaveSettings(w: object, name: str) -> None:

	"""

	Set individual widget w to automatically save its settings to xml file on OK (Enter) and discard on Cancel (Esc).
	By default widgets do NOT save their settings. The settings to be saved depends on the nature of w.
	For example checkBox will save on/off status. BCToolBox and BCTabWidget save their settings (current page) on ESC as well.
	Settings are saved using widget name (provide a unique one).
	
	The supported widgets are:
	ButtonGroup (the index of the selected button in an exclusive group and the state of the checkBox in the title, if any)
	CheckBox (checked/unchecked value)
	ComboBox (the index of the current item)
	DoubleSpinBox (the value)
	LineEdit (the text)
	PushButton (the on/off state)
	SpinBox (the value)
	TabWidget (the current tab). Saves on Esc
	TextEdit (the monospace font menu option).
	ToolBox (the current tab). Saves on Esc
	ToolButton (the on/off state)
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to save its settings.

	name : str
		the name of widget.

	Returns
	-------
	None

	See Also
	--------
	BCWindowSaveControlSettings

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Control Settings Example", guitk.constants.BCOnExitDestroy
		    )
		    for i in range(10):
		        toolBtn = guitk.BCToolButtonCreate(
		            window, "logo_sdm.svg", "Button " + str(i), None, None
		        )
		        guitk.BCSetSaveSettings(toolBtn, "ControlSettingsExample_button" + str(i))
		        guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCPushButtonCreate(window, "Adjust Window Size", adjustWindowSize, window)
		    guitk.BCPushButtonCreate(
		        window, "Save Current Settings", saveControlSettings, window
		    )
		    guitk.BCPushButtonCreate(window, "Load Settings", readControlSettings, window)
		    guitk.BCWindowShowTitleBarButtons(
		        window, guitk.constants.BCMaximizeButton | guitk.constants.BCCloseButton
		    )
		    guitk.BCShow(window)
		
		
		def adjustWindowSize(btn, window):
		    guitk.BCWindowAdjustSize(window)
		    return 0
		
		
		def saveControlSettings(btn, window):
		    guitk.BCWindowSaveControlSettings(window)
		    return 0
		
		
		def readControlSettings(btn, window):
		    guitk.BCWindowReadControlSettings(window)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCUpdateGeometry(w: object) -> None:

	"""

	Notifies the layout system that this widget has changed and may need to change geometry.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	None

	"""

def BCSetUpdatesEnabled(w: object, enabled: bool) -> None:

	"""

	Blocks/unblocks widget painting. This is useful for example when making calculations while adding item
	to a listview.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		any widget (e.g. a list view)

	enabled : bool
		set this parameter to True to enable widget updating, or to False to disable it.

	Returns
	-------
	None

	See Also
	--------
	BCIsUpdatesEnabled

	"""

def BCIsUpdatesEnabled(w: object) -> bool:

	"""

	Returns True if updating is enabled for widget w, or False if it is disabled.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	bool

	See Also
	--------
	BCSetUpdatesEnabled

	"""

def BCFontHeight(w: object) -> int:

	"""

	Returns the height of the font for widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	int
		the height of the font.

	See Also
	--------
	BCFontMaxWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFontMaxWidth(w: object) -> int:

	"""

	Returns the width of the widest character in the font for widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	int
		the width of the widest character in the font.

	See Also
	--------
	BCStringWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStringWidth(w: object, str: str, len: int) -> int:

	"""

	Returns the width of the first len characters of string str for widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	str : str
		the string.

	len : int
		the number of characters in str for which length will be returned. Set it to -1
		to return the length of the whole string.

	Returns
	-------
	int

	See Also
	--------
	BCFontMaxWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCIconIsValid(fileName: str) -> bool:

	"""

	This function informs the user whether fileName corresponds to a valid icon, in order to be used in widgets (e.g. BCToolButtons)
	
	A valid icon is either an image file existing on the file system or an application embedded icon.
	The filename fileName can be absolute or relative to application current working directory.
	Application embedded icons can be searched by using Settings &gt; GUI Settings &gt; Buttons Manager.
	Click an icon to open the "Icon Selection" window and press the "Embedded" button.
	This function is not supported under VR mode.

	Parameters
	----------
	fileName : str
		the filename of the icon.

	Returns
	-------
	bool
		True if fileName gives a valid icon or False otherwise.

	See Also
	--------
	BCButtonSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Tooltips example", guitk.constants.BCOnExitDestroy)
		    btn1 = guitk.BCPushButtonCreate(window, "Button without ToolTip", btnClicked, None)
		    btn2 = guitk.BCPushButtonCreate(window, "Button with ToolTip", btnClicked, None)
		    guitk.BCAddToolTip(btn2, "Tooltip Text")
		    btn3 = guitk.BCPushButtonCreate(
		        window, "Button with ToolTipImage", btnClicked, None
		    )
		    iconFileName = "logo_sdm.svg"
		    if guitk.BCIconIsValid(iconFileName):
		        guitk.BCAddToolTipImage(btn3, iconFileName)
		    else:
		        print("Invalid icon FileName")
		    guitk.BCShow(window)
		
		
		def btnClicked(btn, data):
		    print("\\nToolTipText: '" + guitk.BCGetToolTipText(btn) + "'")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGetColor(init_r: int=100, init_g: int=100, init_b: int=100) -> None:

	"""

	Opens a modal color picker window for color selection.
	A color can be preselected if the values init_r, init_g, init_b are defined.
	While the color picker window is open no other widget can receive any input, unless it closes.
	This function is not supported under VR mode.

	Parameters
	----------
	init_r : int, optional
		is the red value of the preselected color.

	init_g : int, optional
		is the green value of the preselected color.

	init_b : int, optional
		is the blue value of the preselected color.

	Returns
	-------
	None
		A tuple with the [int r, int g, int b] values of the selected color. If the selection is canceled a [-1, -1, -1]  tuple is returned.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("GetColor Example", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    toolBtnColor = guitk.BCToolButtonCreate(
		        hBox, "color_palette.svg", "Change Color", getColor, hBox
		    )
		    guitk.BCSetBackgroundColor(hBox, 0, 255, 0)
		    guitk.BCShow(window)
		
		
		def getColor(toolBtn, box):
		    current = guitk.BCGetBackgroundColor(box)
		    color = guitk.BCGetColor(*current)
		    guitk.BCSetBackgroundColor(box, *color)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxCreate(p: object) -> object:

	"""

	Creates a widget that contains a separator, an "OK" and a "Cancel" BCPushButton 
	laid inside a BCGridLayout.
	
	This widget should be the last one added to a BCWindow.
	The OK and Cancel BCPushButtons are automatically connected to the accept
	and reject function of the parent widget if it is a BCWindow (as recommended).
	BCPushButtons can be added or removed by the use of the rest of the BCDialogButtonBox functions.
	A BCDialogButtonBox displays its buttons in a BCGridLayout that can be retrieved by
	calling BCDialogButtonBoxGetGridLayout(). This function can be used to fully customize
	the BCDialogButtonBox widget.

	Parameters
	----------
	p : object
		the parent widget (preferably created by BCWindowCreate()) or layout.

	Returns
	-------
	object
		the created widget.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(l, "New name: ")
		    le = guitk.BCLineEditCreate(l, "")
		
		    dbb = guitk.BCDialogButtonBoxCreate(w)
		    b = guitk.BCPushButtonCreate(w, "Default", setDefaultName, le)
		    guitk.BCDialogButtonBoxAddButton(dbb, b)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(w, rejectFunc, None)
		    guitk.BCShow(w)
		
		
		def acceptFunc(w, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(w, data):
		    print("Reject")
		    return 1
		
		
		def setDefaultName(b, le):
		    guitk.BCLineEditSetText(le, "Default")
		    print("Default")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxGetAcceptButton(dbb: object) -> object:

	"""

	Returns the BCPushButton that is connected to the accept function of the window (i.e. the "OK" button).

	Parameters
	----------
	dbb : object
		the BCDialogButtonBox.

	Returns
	-------
	object
		the "OK" BCPushButton.

	See Also
	--------
	BCDialogButtonBoxGetRejectButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    layout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(window, "Actions taken will be shown here.")
		
		    dialogBtnBox = guitk.BCDialogButtonBoxCreate(window)
		    data = [dialogBtnBox, label]
		    icon_button = guitk.BCPushButtonCreate(window, "Change Me", changeIcon, data)
		    guitk.BCButtonSetIconFileName(icon_button, "apply_white_small.svg")
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, icon_button)
		    btnOk = guitk.BCPushButtonCreate(window, "Get Accept Button", showOk, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnOk)
		    btnCancel = guitk.BCPushButtonCreate(window, "Get Reject Button", showCancel, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnCancel)
		    btnGrid = guitk.BCPushButtonCreate(window, "GridLayout's Info", showGrid, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnGrid)
		    btnSep = guitk.BCPushButtonCreate(
		        window, "Add/Remove Separator", showSeparator, data
		    )
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnSep)
		    btnRemove = guitk.BCPushButtonCreate(window, "Remove Me", autoRemove, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnRemove)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Reject")
		    return 1
		
		
		def changeIcon(btn, data):
		    guitk.BCButtonSetIconFileName(btn, "vr_touch_menu_apply.svg")
		    guitk.BCDialogButtonBoxResetSize(data[0])
		    guitk.BCLabelSetText(
		        data[1], "Button's icon changed and DialogBox's size changed accordingly."
		    )
		    return 0
		
		
		def showOk(btn, data):
		    btnAccept = guitk.BCDialogButtonBoxGetAcceptButton(data[0])
		    text = "Accept Button's text is: " + guitk.BCButtonText(btnAccept)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showCancel(btn, data):
		    btnReject = guitk.BCDialogButtonBoxGetRejectButton(data[0])
		    text = "Reject Button's text is: " + guitk.BCButtonText(btnReject)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def autoRemove(btn, data):
		    guitk.BCDialogButtonBoxRemoveButton(data[0], btn, False)
		    guitk.BCLabelSetText(data[1], "Selected Button removed.")
		    return 0
		
		
		def showGrid(btn, data):
		    grid = guitk.BCDialogButtonBoxGetGridLayout(data[0])
		    text = (
		        "Total number of columns: "
		        + str(guitk.BCGridLayoutCols(grid))
		        + " and rows: "
		        + str(guitk.BCGridLayoutRows(grid))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showSeparator(btn, data):
		    sep = guitk.BCDialogButtonBoxGetSeparator(data[0])
		    if guitk.BCIsShown(sep):
		        guitk.BCHide(sep)
		        guitk.BCLabelSetText(data[1], "Separator Removed.")
		    else:
		        guitk.BCShow(sep)
		        guitk.BCLabelSetText(data[1], "Separator Added.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxGetRejectButton(dbb: object) -> object:

	"""

	Returns the BCPushButton that is connected to the reject function of the window (i.e. the "Cancel" button).

	Parameters
	----------
	dbb : object
		the BCDialogButtonBox.

	Returns
	-------
	object
		the "Cancel" BCPushButton.

	See Also
	--------
	BCDialogButtonBoxGetAcceptButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    layout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(window, "Actions taken will be shown here.")
		
		    dialogBtnBox = guitk.BCDialogButtonBoxCreate(window)
		    data = [dialogBtnBox, label]
		    icon_button = guitk.BCPushButtonCreate(window, "Change Me", changeIcon, data)
		    guitk.BCButtonSetIconFileName(icon_button, "apply_white_small.svg")
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, icon_button)
		    btnOk = guitk.BCPushButtonCreate(window, "Get Accept Button", showOk, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnOk)
		    btnCancel = guitk.BCPushButtonCreate(window, "Get Reject Button", showCancel, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnCancel)
		    btnGrid = guitk.BCPushButtonCreate(window, "GridLayout's Info", showGrid, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnGrid)
		    btnSep = guitk.BCPushButtonCreate(
		        window, "Add/Remove Separator", showSeparator, data
		    )
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnSep)
		    btnRemove = guitk.BCPushButtonCreate(window, "Remove Me", autoRemove, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnRemove)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Reject")
		    return 1
		
		
		def changeIcon(btn, data):
		    guitk.BCButtonSetIconFileName(btn, "vr_touch_menu_apply.svg")
		    guitk.BCDialogButtonBoxResetSize(data[0])
		    guitk.BCLabelSetText(
		        data[1], "Button's icon changed and DialogBox's size changed accordingly."
		    )
		    return 0
		
		
		def showOk(btn, data):
		    btnAccept = guitk.BCDialogButtonBoxGetAcceptButton(data[0])
		    text = "Accept Button's text is: " + guitk.BCButtonText(btnAccept)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showCancel(btn, data):
		    btnReject = guitk.BCDialogButtonBoxGetRejectButton(data[0])
		    text = "Reject Button's text is: " + guitk.BCButtonText(btnReject)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def autoRemove(btn, data):
		    guitk.BCDialogButtonBoxRemoveButton(data[0], btn, False)
		    guitk.BCLabelSetText(data[1], "Selected Button removed.")
		    return 0
		
		
		def showGrid(btn, data):
		    grid = guitk.BCDialogButtonBoxGetGridLayout(data[0])
		    text = (
		        "Total number of columns: "
		        + str(guitk.BCGridLayoutCols(grid))
		        + " and rows: "
		        + str(guitk.BCGridLayoutRows(grid))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showSeparator(btn, data):
		    sep = guitk.BCDialogButtonBoxGetSeparator(data[0])
		    if guitk.BCIsShown(sep):
		        guitk.BCHide(sep)
		        guitk.BCLabelSetText(data[1], "Separator Removed.")
		    else:
		        guitk.BCShow(sep)
		        guitk.BCLabelSetText(data[1], "Separator Added.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxAddButton(dbb: object, b: object) -> None:

	"""

	Adds a BCPushButton b to a BCDialogButtonBox dbb.

	Parameters
	----------
	dbb : object
		the BCDialogButtonBox.

	b : object
		the BCPushButton that will be added.

	Returns
	-------
	None

	See Also
	--------
	BCDialogButtonBoxRemoveButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(l, "New name: ")
		    le = guitk.BCLineEditCreate(l, "")
		
		    dbb = guitk.BCDialogButtonBoxCreate(w)
		    b = guitk.BCPushButtonCreate(w, "Default", setDefaultName, le)
		    guitk.BCDialogButtonBoxAddButton(dbb, b)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(w, rejectFunc, None)
		    guitk.BCShow(w)
		
		
		def acceptFunc(w, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(w, data):
		    print("Reject")
		    return 1
		
		
		def setDefaultName(b, le):
		    guitk.BCLineEditSetText(le, "Default")
		    print("Default")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxRemoveButton(dbb: object, b: object, also_delete: bool) -> None:

	"""

	Removes a BCPushButton b from a BCDialogButtonBox dbb.

	Parameters
	----------
	dbb : object
		the BCDialogButtonBox to be affected.

	b : object
		the BCPushButton that will be removed from dbb.

	also_delete : bool
		set this parameter to True for the BCPushButton b not only to be removed (hidden), but also deleted (i.e free resources).

	Returns
	-------
	None

	See Also
	--------
	BCDialogButtonBoxAddButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    layout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(window, "Actions taken will be shown here.")
		
		    dialogBtnBox = guitk.BCDialogButtonBoxCreate(window)
		    data = [dialogBtnBox, label]
		    icon_button = guitk.BCPushButtonCreate(window, "Change Me", changeIcon, data)
		    guitk.BCButtonSetIconFileName(icon_button, "apply_white_small.svg")
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, icon_button)
		    btnOk = guitk.BCPushButtonCreate(window, "Get Accept Button", showOk, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnOk)
		    btnCancel = guitk.BCPushButtonCreate(window, "Get Reject Button", showCancel, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnCancel)
		    btnGrid = guitk.BCPushButtonCreate(window, "GridLayout's Info", showGrid, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnGrid)
		    btnSep = guitk.BCPushButtonCreate(
		        window, "Add/Remove Separator", showSeparator, data
		    )
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnSep)
		    btnRemove = guitk.BCPushButtonCreate(window, "Remove Me", autoRemove, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnRemove)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Reject")
		    return 1
		
		
		def changeIcon(btn, data):
		    guitk.BCButtonSetIconFileName(btn, "vr_touch_menu_apply.svg")
		    guitk.BCDialogButtonBoxResetSize(data[0])
		    guitk.BCLabelSetText(
		        data[1], "Button's icon changed and DialogBox's size changed accordingly."
		    )
		    return 0
		
		
		def showOk(btn, data):
		    btnAccept = guitk.BCDialogButtonBoxGetAcceptButton(data[0])
		    text = "Accept Button's text is: " + guitk.BCButtonText(btnAccept)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showCancel(btn, data):
		    btnReject = guitk.BCDialogButtonBoxGetRejectButton(data[0])
		    text = "Reject Button's text is: " + guitk.BCButtonText(btnReject)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def autoRemove(btn, data):
		    guitk.BCDialogButtonBoxRemoveButton(data[0], btn, False)
		    guitk.BCLabelSetText(data[1], "Selected Button removed.")
		    return 0
		
		
		def showGrid(btn, data):
		    grid = guitk.BCDialogButtonBoxGetGridLayout(data[0])
		    text = (
		        "Total number of columns: "
		        + str(guitk.BCGridLayoutCols(grid))
		        + " and rows: "
		        + str(guitk.BCGridLayoutRows(grid))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showSeparator(btn, data):
		    sep = guitk.BCDialogButtonBoxGetSeparator(data[0])
		    if guitk.BCIsShown(sep):
		        guitk.BCHide(sep)
		        guitk.BCLabelSetText(data[1], "Separator Removed.")
		    else:
		        guitk.BCShow(sep)
		        guitk.BCLabelSetText(data[1], "Separator Added.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxGetGridLayout(dbb: object) -> object:

	"""

	Returns the BCGridLayout of a BCDialogButtonBox dbb.
	A BCDialogButtonBox accommodates its children widgets inside a BCGridLayout.
	This layout is returned by this function in order to make any desirable customization to the BCDialogButtonBox.

	Parameters
	----------
	dbb : object
		the BCDialogButtonBox.

	Returns
	-------
	object
		the default BCGridLayout child of the BCDialogButtonBox.

	See Also
	--------
	BCGridLayoutSetMargin

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    layout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(window, "Actions taken will be shown here.")
		
		    dialogBtnBox = guitk.BCDialogButtonBoxCreate(window)
		    data = [dialogBtnBox, label]
		    icon_button = guitk.BCPushButtonCreate(window, "Change Me", changeIcon, data)
		    guitk.BCButtonSetIconFileName(icon_button, "apply_white_small.svg")
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, icon_button)
		    btnOk = guitk.BCPushButtonCreate(window, "Get Accept Button", showOk, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnOk)
		    btnCancel = guitk.BCPushButtonCreate(window, "Get Reject Button", showCancel, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnCancel)
		    btnGrid = guitk.BCPushButtonCreate(window, "GridLayout's Info", showGrid, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnGrid)
		    btnSep = guitk.BCPushButtonCreate(
		        window, "Add/Remove Separator", showSeparator, data
		    )
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnSep)
		    btnRemove = guitk.BCPushButtonCreate(window, "Remove Me", autoRemove, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnRemove)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Reject")
		    return 1
		
		
		def changeIcon(btn, data):
		    guitk.BCButtonSetIconFileName(btn, "vr_touch_menu_apply.svg")
		    guitk.BCDialogButtonBoxResetSize(data[0])
		    guitk.BCLabelSetText(
		        data[1], "Button's icon changed and DialogBox's size changed accordingly."
		    )
		    return 0
		
		
		def showOk(btn, data):
		    btnAccept = guitk.BCDialogButtonBoxGetAcceptButton(data[0])
		    text = "Accept Button's text is: " + guitk.BCButtonText(btnAccept)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showCancel(btn, data):
		    btnReject = guitk.BCDialogButtonBoxGetRejectButton(data[0])
		    text = "Reject Button's text is: " + guitk.BCButtonText(btnReject)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def autoRemove(btn, data):
		    guitk.BCDialogButtonBoxRemoveButton(data[0], btn, False)
		    guitk.BCLabelSetText(data[1], "Selected Button removed.")
		    return 0
		
		
		def showGrid(btn, data):
		    grid = guitk.BCDialogButtonBoxGetGridLayout(data[0])
		    text = (
		        "Total number of columns: "
		        + str(guitk.BCGridLayoutCols(grid))
		        + " and rows: "
		        + str(guitk.BCGridLayoutRows(grid))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showSeparator(btn, data):
		    sep = guitk.BCDialogButtonBoxGetSeparator(data[0])
		    if guitk.BCIsShown(sep):
		        guitk.BCHide(sep)
		        guitk.BCLabelSetText(data[1], "Separator Removed.")
		    else:
		        guitk.BCShow(sep)
		        guitk.BCLabelSetText(data[1], "Separator Added.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxGetSeparator(dbb: object) -> object:

	"""

	Returns the line separator (BCFrame type) that is displayed by default above the dialog button box BCPushButtons.
	This is useful if you wish to hide the separator with BCHide().

	Parameters
	----------
	dbb : object
		the BCDialogButtonBox.

	Returns
	-------
	object
		the default separator of dbb.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    layout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(window, "Actions taken will be shown here.")
		
		    dialogBtnBox = guitk.BCDialogButtonBoxCreate(window)
		    data = [dialogBtnBox, label]
		    icon_button = guitk.BCPushButtonCreate(window, "Change Me", changeIcon, data)
		    guitk.BCButtonSetIconFileName(icon_button, "apply_white_small.svg")
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, icon_button)
		    btnOk = guitk.BCPushButtonCreate(window, "Get Accept Button", showOk, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnOk)
		    btnCancel = guitk.BCPushButtonCreate(window, "Get Reject Button", showCancel, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnCancel)
		    btnGrid = guitk.BCPushButtonCreate(window, "GridLayout's Info", showGrid, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnGrid)
		    btnSep = guitk.BCPushButtonCreate(
		        window, "Add/Remove Separator", showSeparator, data
		    )
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnSep)
		    btnRemove = guitk.BCPushButtonCreate(window, "Remove Me", autoRemove, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnRemove)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Reject")
		    return 1
		
		
		def changeIcon(btn, data):
		    guitk.BCButtonSetIconFileName(btn, "vr_touch_menu_apply.svg")
		    guitk.BCDialogButtonBoxResetSize(data[0])
		    guitk.BCLabelSetText(
		        data[1], "Button's icon changed and DialogBox's size changed accordingly."
		    )
		    return 0
		
		
		def showOk(btn, data):
		    btnAccept = guitk.BCDialogButtonBoxGetAcceptButton(data[0])
		    text = "Accept Button's text is: " + guitk.BCButtonText(btnAccept)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showCancel(btn, data):
		    btnReject = guitk.BCDialogButtonBoxGetRejectButton(data[0])
		    text = "Reject Button's text is: " + guitk.BCButtonText(btnReject)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def autoRemove(btn, data):
		    guitk.BCDialogButtonBoxRemoveButton(data[0], btn, False)
		    guitk.BCLabelSetText(data[1], "Selected Button removed.")
		    return 0
		
		
		def showGrid(btn, data):
		    grid = guitk.BCDialogButtonBoxGetGridLayout(data[0])
		    text = (
		        "Total number of columns: "
		        + str(guitk.BCGridLayoutCols(grid))
		        + " and rows: "
		        + str(guitk.BCGridLayoutRows(grid))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showSeparator(btn, data):
		    sep = guitk.BCDialogButtonBoxGetSeparator(data[0])
		    if guitk.BCIsShown(sep):
		        guitk.BCHide(sep)
		        guitk.BCLabelSetText(data[1], "Separator Removed.")
		    else:
		        guitk.BCShow(sep)
		        guitk.BCLabelSetText(data[1], "Separator Added.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDialogButtonBoxResetSize(dbb: object) -> None:

	"""

	Resets the size of the BCDialogButtonBox to fit its contents. 
	Use this function after you have altered the contents of dbb (for example if you set an icon on a button that requires more height).

	Parameters
	----------
	dbb : object
		the BCDialogButtonBox.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCDialogButtonBox example", guitk.constants.BCOnExitDestroy
		    )
		    layout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(window, "Actions taken will be shown here.")
		
		    dialogBtnBox = guitk.BCDialogButtonBoxCreate(window)
		    data = [dialogBtnBox, label]
		    icon_button = guitk.BCPushButtonCreate(window, "Change Me", changeIcon, data)
		    guitk.BCButtonSetIconFileName(icon_button, "apply_white_small.svg")
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, icon_button)
		    btnOk = guitk.BCPushButtonCreate(window, "Get Accept Button", showOk, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnOk)
		    btnCancel = guitk.BCPushButtonCreate(window, "Get Reject Button", showCancel, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnCancel)
		    btnGrid = guitk.BCPushButtonCreate(window, "GridLayout's Info", showGrid, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnGrid)
		    btnSep = guitk.BCPushButtonCreate(
		        window, "Add/Remove Separator", showSeparator, data
		    )
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnSep)
		    btnRemove = guitk.BCPushButtonCreate(window, "Remove Me", autoRemove, data)
		    guitk.BCDialogButtonBoxAddButton(dialogBtnBox, btnRemove)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Accept")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Reject")
		    return 1
		
		
		def changeIcon(btn, data):
		    guitk.BCButtonSetIconFileName(btn, "vr_touch_menu_apply.svg")
		    guitk.BCDialogButtonBoxResetSize(data[0])
		    guitk.BCLabelSetText(
		        data[1], "Button's icon changed and DialogBox's size changed accordingly."
		    )
		    return 0
		
		
		def showOk(btn, data):
		    btnAccept = guitk.BCDialogButtonBoxGetAcceptButton(data[0])
		    text = "Accept Button's text is: " + guitk.BCButtonText(btnAccept)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showCancel(btn, data):
		    btnReject = guitk.BCDialogButtonBoxGetRejectButton(data[0])
		    text = "Reject Button's text is: " + guitk.BCButtonText(btnReject)
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def autoRemove(btn, data):
		    guitk.BCDialogButtonBoxRemoveButton(data[0], btn, False)
		    guitk.BCLabelSetText(data[1], "Selected Button removed.")
		    return 0
		
		
		def showGrid(btn, data):
		    grid = guitk.BCDialogButtonBoxGetGridLayout(data[0])
		    text = (
		        "Total number of columns: "
		        + str(guitk.BCGridLayoutCols(grid))
		        + " and rows: "
		        + str(guitk.BCGridLayoutRows(grid))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		def showSeparator(btn, data):
		    sep = guitk.BCDialogButtonBoxGetSeparator(data[0])
		    if guitk.BCIsShown(sep):
		        guitk.BCHide(sep)
		        guitk.BCLabelSetText(data[1], "Separator Removed.")
		    else:
		        guitk.BCShow(sep)
		        guitk.BCLabelSetText(data[1], "Separator Added.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDrawerGridCreate(p: object) -> object:

	"""

	Creates a DrawerGrid inside parent p.
	DrawerGrid is a container widget, able to accommodate widgets and manage their visibility. 
	Create manager widgets with parent DrawerGrid and then set/insert. 
	NOTE: DrawerGrid stores widgets visibility state to xml file.
	of managed widgets in xml.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created drawer grid.

	See Also
	--------
	BCDrawerGridSetStableWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Drawer Grid Example", guitk.constants.BCOnExitDestroy
		    )
		    drawerGrid = guitk.BCDrawerGridCreate(window)
		    textEdit = guitk.BCTextEditCreate(drawerGrid, "")
		    hBoxTop = guitk.BCHBoxCreate(drawerGrid)
		    for i in range(4):
		        chkBox = guitk.BCCheckBoxCreate(hBoxTop, "CheckBox {}".format(i))
		        guitk.BCCheckBoxSetToggledFunction(chkBox, chkBoxToggled, None)
		    hBoxFoot = guitk.BCHBoxCreate(drawerGrid)
		    for i in range(3):
		        btn = guitk.BCPushButtonCreate(
		            hBoxFoot, "Button {}".format(i), btnClicked, None
		        )
		    # The order in which we insert widgets in the DrawerGrid handles their position.
		    # Current limits: max 1 non-stable widget per side (top-bottom)
		    btnShowFormat = guitk.BCDrawerGridInsertWidget(
		        drawerGrid, hBoxTop, False, "CheckBoxes"
		    )
		    guitk.BCDrawerGridSetStableWidget(drawerGrid, textEdit)
		    btnShowInfo = guitk.BCDrawerGridInsertWidget(drawerGrid, hBoxFoot, False, "Buttons")
		    guitk.BCShow(window)
		
		
		def chkBoxToggled(chkBox, state, data):
		    print(guitk.BCCheckBoxText(chkBox) + " toggled to state: " + str(state))
		    return 0
		
		
		def btnClicked(btn, data):
		    print(guitk.BCButtonText(btn) + " clicked.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDrawerGridInsertWidget(drawer: object, w: object, visible: bool, toolTip: str) -> object:

	"""

	Inserts the widget w inside DrawerGrid drawer with a managing button on the left.
	Standard DrawerGrid stores widgets visibility state to xml.
	A push button is provided at the left side of the widget, able to show/hide it. 
	This button will be returned by the function. 
	The widget can be initialized to be hidden or not, depending on visible parameter. 
	A tooltip toolTip can be applied at the button as well.
	WARNING: If you try to manage (show/hide) the widget manually, the behavior is undefined.
	This function is not supported under VR mode.

	Parameters
	----------
	drawer : object
		the DrawerGrid.

	w : object
		the widget to be inserted.

	visible : bool
		this indicates how the widget initializes. Set False for your widget 
		to appear hidden when the form created.

	toolTip : str
		the text to be displayed as balloon help for the button.

	Returns
	-------
	object
		the push button that show/hide the widget.

	See Also
	--------
	BCDrawerGridSetStableWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Drawer Grid Example", guitk.constants.BCOnExitDestroy
		    )
		    drawerGrid = guitk.BCDrawerGridCreate(window)
		    textEdit = guitk.BCTextEditCreate(drawerGrid, "")
		    hBoxTop = guitk.BCHBoxCreate(drawerGrid)
		    for i in range(4):
		        chkBox = guitk.BCCheckBoxCreate(hBoxTop, "CheckBox {}".format(i))
		        guitk.BCCheckBoxSetToggledFunction(chkBox, chkBoxToggled, None)
		    hBoxFoot = guitk.BCHBoxCreate(drawerGrid)
		    for i in range(3):
		        btn = guitk.BCPushButtonCreate(
		            hBoxFoot, "Button {}".format(i), btnClicked, None
		        )
		    # The order in which we insert widgets in the DrawerGrid handles their position.
		    # Current limits: max 1 non-stable widget per side (top-bottom)
		    btnShowFormat = guitk.BCDrawerGridInsertWidget(
		        drawerGrid, hBoxTop, False, "CheckBoxes"
		    )
		    guitk.BCDrawerGridSetStableWidget(drawerGrid, textEdit)
		    btnShowInfo = guitk.BCDrawerGridInsertWidget(drawerGrid, hBoxFoot, False, "Buttons")
		    guitk.BCShow(window)
		
		
		def chkBoxToggled(chkBox, state, data):
		    print(guitk.BCCheckBoxText(chkBox) + " toggled to state: " + str(state))
		    return 0
		
		
		def btnClicked(btn, data):
		    print(guitk.BCButtonText(btn) + " clicked.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFlowLayoutCreate(p: object) -> object:

	"""

	Creates a BCFlowLayout.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created BCFlowLayout.

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCFlowLayout Example", guitk.constants.BCOnExitDestroy)
		
		    flayout = guitk.BCFlowLayoutCreate(w)
		    button = guitk.BCPushButtonCreate(flayout, "Button 1", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 2", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 3", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 4", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 5", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, flayout)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, flayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, flayout):
		    guitk.BCFlowLayoutSetMargin(flayout, value)
		    return 0
		
		
		def setSpacing(spin, value, flayout):
		    guitk.BCFlowLayoutSetSpacing(flayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFlowLayoutSetMargin(l: object, margin: int) -> None:

	"""

	Sets the margin of BCFlowLayout l to margin.
	This function is not supported under VR mode.

	Parameters
	----------
	l : object
		the BCFlowLayout that will be affected by this function.

	margin : int
		the new value for margin.

	Returns
	-------
	None

	See Also
	--------
	BCFlowLayoutSetSpacing

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCFlowLayout Example", guitk.constants.BCOnExitDestroy)
		
		    flayout = guitk.BCFlowLayoutCreate(w)
		    button = guitk.BCPushButtonCreate(flayout, "Button 1", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 2", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 3", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 4", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 5", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, flayout)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, flayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, flayout):
		    guitk.BCFlowLayoutSetMargin(flayout, value)
		    return 0
		
		
		def setSpacing(spin, value, flayout):
		    guitk.BCFlowLayoutSetSpacing(flayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFlowLayoutSetSpacing(l: object, spacing: int) -> None:

	"""

	Sets the spacing of BCFlowLayout l to spacing.
	This function is not supported under VR mode.

	Parameters
	----------
	l : object
		the BCFlowLayout that will be affected by this function.

	spacing : int
		the new value for spacing.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCFlowLayout Example", guitk.constants.BCOnExitDestroy)
		
		    flayout = guitk.BCFlowLayoutCreate(w)
		    button = guitk.BCPushButtonCreate(flayout, "Button 1", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 2", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 3", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 4", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 5", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, flayout)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, flayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, flayout):
		    guitk.BCFlowLayoutSetMargin(flayout, value)
		    return 0
		
		
		def setSpacing(spin, value, flayout):
		    guitk.BCFlowLayoutSetSpacing(flayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFlowLayoutInsert(l: object, item: object) -> None:

	"""

	Inserts item into this flow layout. The item is added at the end.
	This function is not supported under VR mode.

	Parameters
	----------
	l : object
		the layout.

	item : object
		the widget that will be inserted to l.

	Returns
	-------
	None

	See Also
	--------
	BCFlowLayoutRemove

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCFlowLayout Example", guitk.constants.BCOnExitDestroy)
		
		    flayout = guitk.BCFlowLayoutCreate(w)
		    button = guitk.BCPushButtonCreate(flayout, "Button 1", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 2", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 3", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 4", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		    button = guitk.BCPushButtonCreate(flayout, "Button 5", None, None)
		    guitk.BCFlowLayoutInsert(flayout, button)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, flayout)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, flayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, flayout):
		    guitk.BCFlowLayoutSetMargin(flayout, value)
		    return 0
		
		
		def setSpacing(spin, value, flayout):
		    guitk.BCFlowLayoutSetSpacing(flayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFlowLayoutRemove(l: object, item: object) -> None:

	"""

	Remove item item from flow layout l.
	                      
	WARNING: After this call, it is the caller's responsibility to give the item a reasonable geometry or to put the item back into a layout.
	This function is not supported under VR mode.

	Parameters
	----------
	l : object
		the layout.

	item : object
		can be a widget (BCButton, BCLabel, BCLineEdit ...).

	Returns
	-------
	None

	See Also
	--------
	BCFlowLayoutInsert

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "FlowLayout Remove Example", guitk.constants.BCOnExitDestroy
		    )
		    fLayout = guitk.BCFlowLayoutCreate(window)
		    btn1 = guitk.BCPushButtonCreate(fLayout, "Button 1", None, None)
		    btnTemp = guitk.BCPushButtonCreate(fLayout, "Temporary Button", None, None)
		    btn2 = guitk.BCPushButtonCreate(fLayout, "Button 2", None, None)
		    guitk.BCFlowLayoutInsert(fLayout, btn1)
		    guitk.BCFlowLayoutInsert(fLayout, btnTemp)
		    guitk.BCFlowLayoutInsert(fLayout, btn2)
		    btnRemove = guitk.BCPushButtonCreate(
		        window, "Remove Temporary", removeTemp, (fLayout, btnTemp)
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def removeTemp(btn, data):
		    fLayout, btnToRemove = data
		    guitk.BCFlowLayoutRemove(fLayout, btnToRemove)
		    guitk.BCDestroyLater(btnToRemove)
		    guitk.BCSetEnabled(btn, False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFrameCreate(p: object) -> object:

	"""

	Creates a placeholder box with parent p without any contents or layout.
	NOTE: You will need a layout that specifies how child widgets line up inside.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created BCFrame.

	See Also
	--------
	BCBoxLayoutCreate

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Frame", guitk.constants.BCOnExitDestroy)
		    hbox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    vbox = guitk.BCBoxLayoutCreate(hbox, guitk.constants.BCVertical)
		
		    bgShape = guitk.BCButtonGroupCreate(vbox, "Shape", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bgShape, "NoFrame", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "Box", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "Panel", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "StyledPanel", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "HLine", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "VLine", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "WinPanel", None, None)
		
		    frame = guitk.BCFrameCreate(hbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(frame, "Frame")
		    guitk.BCLabelSetAlignment(label, guitk.constants.BCAlignCenter)
		
		    bgShadow = guitk.BCButtonGroupCreate(vbox, "Shadow", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bgShadow, "Plain", None, None)
		    guitk.BCRadioButtonCreate(bgShadow, "Raised", None, None)
		    guitk.BCRadioButtonCreate(bgShadow, "Sunken", None, None)
		
		    guitk.BCButtonGroupSetButton(bgShape, 0)
		    guitk.BCButtonGroupSetButton(bgShadow, 0)
		
		    guitk.BCButtonGroupSetPressedFunction(bgShape, changeFrameShape, frame)
		    guitk.BCButtonGroupSetPressedFunction(bgShadow, changeFrameShadow, frame)
		
		    guitk.BCShow(window)
		
		
		def changeFrameShape(radio, index, frame):
		    # Call the right option from a dictionary
		    options = {
		        0: guitk.constants.BCNoFrame,
		        1: guitk.constants.BCBox,
		        2: guitk.constants.BCPanel,
		        3: guitk.constants.BCStyledPanel,
		        4: guitk.constants.BCHLine,
		        5: guitk.constants.BCVLine,
		        6: guitk.constants.BCWinPanel,
		    }
		    guitk.BCFrameSetShape(frame, options[index])
		    return 0
		
		
		def changeFrameShadow(radio, index, frame):
		    # Call the right option from a dictionary
		    options = {
		        0: guitk.constants.BCPlain,
		        1: guitk.constants.BCRaised,
		        2: guitk.constants.BCSunken,
		    }
		    guitk.BCFrameSetShadow(frame, options[index])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFrameSetShadow(f: object, shadow: int) -> None:

	"""

	Sets the shadow of the BCFrame f to shadow. It is meant to be used with BCFrameSetShape().
	The affect of this function depends on the applications style.

	Parameters
	----------
	f : object
		the BCFrame to be affected by this function.

	shadow : int
		the new shadow style of the BCFrame f. See BCEnumShadow property
		for details.
		
		guitk.constants BCEnumShadow
		This enum type defines the 3D effect used for BCFrame's frame. Shadow is used with BCFrameSetShadow for example.
		 - guitk.constants.BCPlain
		the frame and contents appear level with the surroundings; draws using the palette foreground
		color (without any 3D effect).
		 - guitk.constants.BCSunken
		the frame and contents appear sunken; draws a 3D sunken line using the light and dark colors
		of the current color group.
		 - guitk.constants.BCRaised
		the frame and contents appear raised; draws a 3D raised line using the light and dark colors
		of the current color group.

	Returns
	-------
	None

	See Also
	--------
	BCFrameSetShape

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Frame", guitk.constants.BCOnExitDestroy)
		    hbox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    vbox = guitk.BCBoxLayoutCreate(hbox, guitk.constants.BCVertical)
		
		    bgShape = guitk.BCButtonGroupCreate(vbox, "Shape", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bgShape, "NoFrame", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "Box", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "Panel", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "StyledPanel", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "HLine", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "VLine", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "WinPanel", None, None)
		
		    frame = guitk.BCFrameCreate(hbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(frame, "Frame")
		    guitk.BCLabelSetAlignment(label, guitk.constants.BCAlignCenter)
		
		    bgShadow = guitk.BCButtonGroupCreate(vbox, "Shadow", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bgShadow, "Plain", None, None)
		    guitk.BCRadioButtonCreate(bgShadow, "Raised", None, None)
		    guitk.BCRadioButtonCreate(bgShadow, "Sunken", None, None)
		
		    guitk.BCButtonGroupSetButton(bgShape, 0)
		    guitk.BCButtonGroupSetButton(bgShadow, 0)
		
		    guitk.BCButtonGroupSetPressedFunction(bgShape, changeFrameShape, frame)
		    guitk.BCButtonGroupSetPressedFunction(bgShadow, changeFrameShadow, frame)
		
		    guitk.BCShow(window)
		
		
		def changeFrameShape(radio, index, frame):
		    # Call the right option from a dictionary
		    options = {
		        0: guitk.constants.BCNoFrame,
		        1: guitk.constants.BCBox,
		        2: guitk.constants.BCPanel,
		        3: guitk.constants.BCStyledPanel,
		        4: guitk.constants.BCHLine,
		        5: guitk.constants.BCVLine,
		        6: guitk.constants.BCWinPanel,
		    }
		    guitk.BCFrameSetShape(frame, options[index])
		    return 0
		
		
		def changeFrameShadow(radio, index, frame):
		    # Call the right option from a dictionary
		    options = {
		        0: guitk.constants.BCPlain,
		        1: guitk.constants.BCRaised,
		        2: guitk.constants.BCSunken,
		    }
		    guitk.BCFrameSetShadow(frame, options[index])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFrameSetShape(f: object, shape: int) -> None:

	"""

	Sets the frame shape of BCFrame f to shape.
	The affect of this function depends on the applications style.

	Parameters
	----------
	f : object
		the BCFrame to be affected by this function.

	shape : int
		the new shape style of BCFrame f. See BCEnumShape property for details.
		
		guitk.constants BCEnumShape
		This enum type defines the shapes of a BCFrame.
		 - guitk.constants.BCNoFrame
		BCFrame draws nothing.
		 - guitk.constants.BCBox
		BCFrame draws a box around its contents.
		 - guitk.constants.BCPanel
		BCFrame draws a panel to make the contents appear raised or sunken.
		 - guitk.constants.BCStyledPanel
		Draws a rectangular panel with a look that depends on the current GUI style. It can be
		raised or sunken.
		 - guitk.constants.BCHLine
		BCFrame draws a horizontal line that frames nothing (useful as separator).
		 - guitk.constants.BCVLine
		BCFrame draws a vertical line that frames nothing (useful as separator).
		 - guitk.constants.BCGroupBoxPanel
		Draws a rectangular panel.
		 - guitk.constants.BCWinPanel
		Draws a rectangular panel that can be raised or sunken like those in Windows 95. Specifying
		this shape sets the line width to 2 pixels. BCWinPanel is provided for compatibility. For
		GUI style independence it is recommended to use BCStyledPanel instead.
		 - guitk.constants.BCLineEditPanel
		It is used to draw a frame suitable for line edits. The look depends upon the current GUI style.
		 - guitk.constants.BCTabWidgetPanel
		It is used to draw a frame suitable for tab widgets. The look depends upon the current GUI style.

	Returns
	-------
	None

	See Also
	--------
	BCFrameSetShadow

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Frame", guitk.constants.BCOnExitDestroy)
		    hbox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    vbox = guitk.BCBoxLayoutCreate(hbox, guitk.constants.BCVertical)
		
		    bgShape = guitk.BCButtonGroupCreate(vbox, "Shape", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bgShape, "NoFrame", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "Box", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "Panel", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "StyledPanel", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "HLine", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "VLine", None, None)
		    guitk.BCRadioButtonCreate(bgShape, "WinPanel", None, None)
		
		    frame = guitk.BCFrameCreate(hbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(frame, "Frame")
		    guitk.BCLabelSetAlignment(label, guitk.constants.BCAlignCenter)
		
		    bgShadow = guitk.BCButtonGroupCreate(vbox, "Shadow", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bgShadow, "Plain", None, None)
		    guitk.BCRadioButtonCreate(bgShadow, "Raised", None, None)
		    guitk.BCRadioButtonCreate(bgShadow, "Sunken", None, None)
		
		    guitk.BCButtonGroupSetButton(bgShape, 0)
		    guitk.BCButtonGroupSetButton(bgShadow, 0)
		
		    guitk.BCButtonGroupSetPressedFunction(bgShape, changeFrameShape, frame)
		    guitk.BCButtonGroupSetPressedFunction(bgShadow, changeFrameShadow, frame)
		
		    guitk.BCShow(window)
		
		
		def changeFrameShape(radio, index, frame):
		    # Call the right option from a dictionary
		    options = {
		        0: guitk.constants.BCNoFrame,
		        1: guitk.constants.BCBox,
		        2: guitk.constants.BCPanel,
		        3: guitk.constants.BCStyledPanel,
		        4: guitk.constants.BCHLine,
		        5: guitk.constants.BCVLine,
		        6: guitk.constants.BCWinPanel,
		    }
		    guitk.BCFrameSetShape(frame, options[index])
		    return 0
		
		
		def changeFrameShadow(radio, index, frame):
		    # Call the right option from a dictionary
		    options = {
		        0: guitk.constants.BCPlain,
		        1: guitk.constants.BCRaised,
		        2: guitk.constants.BCSunken,
		    }
		    guitk.BCFrameSetShadow(frame, options[index])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutCreate(p: object, numRows: int=1, numCols: int=1) -> object:

	"""

	Creates a BCGridLayout.

	Parameters
	----------
	p : object
		the parent widget or layout.

	numRows : int, optional
		this argument is obsolete. It is kept for compatibility reasons.

	numCols : int, optional
		this argument is obsolete. It is kept for compatibility reasons.

	Returns
	-------
	object
		the created layout.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCGridLayout Example", guitk.constants.BCOnExitDestroy)
		
		    glayout = guitk.BCGridLayoutCreate(w)
		
		    label1 = guitk.BCLabelCreate(glayout, "Row 1")
		    label2 = guitk.BCLabelCreate(glayout, "Row 2")
		    label3 = guitk.BCLabelCreate(glayout, "Row 3")
		
		    ledit1 = guitk.BCLineEditCreate(glayout, "")
		    ledit2 = guitk.BCLineEditCreate(glayout, "")
		    ledit3 = guitk.BCLineEditCreate(glayout, "")
		
		    button1 = guitk.BCPushButtonCreate(glayout, "Button 1", None, None)
		    button2 = guitk.BCPushButtonCreate(glayout, "Button 2", None, None)
		    button3 = guitk.BCPushButtonCreate(glayout, "Button 3", None, None)
		    button4 = guitk.BCPushButtonCreate(glayout, "Button 4", None, None)
		
		    guitk.BCGridLayoutAddWidget(glayout, label1, 0, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label2, 1, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label3, 2, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, ledit1, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit2, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit3, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, button1, 0, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button2, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button3, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        glayout, button4, 3, 4, 0, 2, guitk.constants.BCAlignAuto
		    )
		
		    guitk.BCSpacerCreate(w)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin :   ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)  # default margin
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, glayout)
		    guitk.BCSpacerCreate(l)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)  # default spacing
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, glayout)
		    guitk.BCSpacerCreate(l)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, glayout):
		    guitk.BCGridLayoutSetMargin(glayout, value)
		    return 0
		
		
		def setSpacing(spin, value, glayout):
		    guitk.BCGridLayoutSetSpacing(glayout, value)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutAddWidget(grid: object, w: object, row: int, col: int, alignment: int) -> None:

	"""

	Adds a widget (button, checkbox, etc) to a BCGridLayout.

	Parameters
	----------
	grid : object
		the gridlayout that will be affected by this function.

	w : object
		the widget that will be added to the grid.

	row : int
		the row of the gridlayout at which the widget will be added.

	col : int
		the column of the gridlayout at which the widget will be added.

	alignment : int
		the alignment of the widget in the grid cell. See BCEnumAlignment for details.
		NOTE: if you want the child widget to take all vertical space you must set "BCAlignVJustify" alignment.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCGridLayout Example", guitk.constants.BCOnExitDestroy)
		
		    glayout = guitk.BCGridLayoutCreate(w)
		
		    label1 = guitk.BCLabelCreate(glayout, "Row 1")
		    label2 = guitk.BCLabelCreate(glayout, "Row 2")
		    label3 = guitk.BCLabelCreate(glayout, "Row 3")
		
		    ledit1 = guitk.BCLineEditCreate(glayout, "")
		    ledit2 = guitk.BCLineEditCreate(glayout, "")
		    ledit3 = guitk.BCLineEditCreate(glayout, "")
		
		    button1 = guitk.BCPushButtonCreate(glayout, "Button 1", None, None)
		    button2 = guitk.BCPushButtonCreate(glayout, "Button 2", None, None)
		    button3 = guitk.BCPushButtonCreate(glayout, "Button 3", None, None)
		    button4 = guitk.BCPushButtonCreate(glayout, "Button 4", None, None)
		
		    guitk.BCGridLayoutAddWidget(glayout, label1, 0, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label2, 1, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label3, 2, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, ledit1, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit2, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit3, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, button1, 0, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button2, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button3, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        glayout, button4, 3, 4, 0, 2, guitk.constants.BCAlignAuto
		    )
		
		    guitk.BCSpacerCreate(w)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin :   ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)  # default margin
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, glayout)
		    guitk.BCSpacerCreate(l)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)  # default spacing
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, glayout)
		    guitk.BCSpacerCreate(l)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, glayout):
		    guitk.BCGridLayoutSetMargin(glayout, value)
		    return 0
		
		
		def setSpacing(spin, value, glayout):
		    guitk.BCGridLayoutSetSpacing(glayout, value)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutSetMargin(grid: object, margin: int) -> None:

	"""

	Sets the margin of the BCGridLayout.

	Parameters
	----------
	grid : object
		the BCGridLayout that will be affected.

	margin : int
		the size of margin in pixels.

	Returns
	-------
	None

	See Also
	--------
	BCGridLayoutSetSpacing

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCGridLayout Example", guitk.constants.BCOnExitDestroy)
		
		    glayout = guitk.BCGridLayoutCreate(w)
		
		    label1 = guitk.BCLabelCreate(glayout, "Row 1")
		    label2 = guitk.BCLabelCreate(glayout, "Row 2")
		    label3 = guitk.BCLabelCreate(glayout, "Row 3")
		
		    ledit1 = guitk.BCLineEditCreate(glayout, "")
		    ledit2 = guitk.BCLineEditCreate(glayout, "")
		    ledit3 = guitk.BCLineEditCreate(glayout, "")
		
		    button1 = guitk.BCPushButtonCreate(glayout, "Button 1", None, None)
		    button2 = guitk.BCPushButtonCreate(glayout, "Button 2", None, None)
		    button3 = guitk.BCPushButtonCreate(glayout, "Button 3", None, None)
		    button4 = guitk.BCPushButtonCreate(glayout, "Button 4", None, None)
		
		    guitk.BCGridLayoutAddWidget(glayout, label1, 0, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label2, 1, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label3, 2, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, ledit1, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit2, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit3, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, button1, 0, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button2, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button3, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        glayout, button4, 3, 4, 0, 2, guitk.constants.BCAlignAuto
		    )
		
		    guitk.BCSpacerCreate(w)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin :   ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)  # default margin
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, glayout)
		    guitk.BCSpacerCreate(l)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)  # default spacing
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, glayout)
		    guitk.BCSpacerCreate(l)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, glayout):
		    guitk.BCGridLayoutSetMargin(glayout, value)
		    return 0
		
		
		def setSpacing(spin, value, glayout):
		    guitk.BCGridLayoutSetSpacing(glayout, value)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutSetSpacing(grid: object, spacing: int) -> None:

	"""

	Sets the spacing of the BCGridLayout.

	Parameters
	----------
	grid : object
		the BCGridLayout that will be affected.

	spacing : int
		the size of spacing in pixels.
		BCGridLayoutSetMargin()

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCGridLayout Example", guitk.constants.BCOnExitDestroy)
		
		    glayout = guitk.BCGridLayoutCreate(w)
		
		    label1 = guitk.BCLabelCreate(glayout, "Row 1")
		    label2 = guitk.BCLabelCreate(glayout, "Row 2")
		    label3 = guitk.BCLabelCreate(glayout, "Row 3")
		
		    ledit1 = guitk.BCLineEditCreate(glayout, "")
		    ledit2 = guitk.BCLineEditCreate(glayout, "")
		    ledit3 = guitk.BCLineEditCreate(glayout, "")
		
		    button1 = guitk.BCPushButtonCreate(glayout, "Button 1", None, None)
		    button2 = guitk.BCPushButtonCreate(glayout, "Button 2", None, None)
		    button3 = guitk.BCPushButtonCreate(glayout, "Button 3", None, None)
		    button4 = guitk.BCPushButtonCreate(glayout, "Button 4", None, None)
		
		    guitk.BCGridLayoutAddWidget(glayout, label1, 0, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label2, 1, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label3, 2, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, ledit1, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit2, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit3, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, button1, 0, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button2, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button3, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        glayout, button4, 3, 4, 0, 2, guitk.constants.BCAlignAuto
		    )
		
		    guitk.BCSpacerCreate(w)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin :   ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)  # default margin
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, glayout)
		    guitk.BCSpacerCreate(l)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)  # default spacing
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, glayout)
		    guitk.BCSpacerCreate(l)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, glayout):
		    guitk.BCGridLayoutSetMargin(glayout, value)
		    return 0
		
		
		def setSpacing(spin, value, glayout):
		    guitk.BCGridLayoutSetSpacing(glayout, value)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutRows(grid: object) -> int:

	"""

	returns the total number of rows of the BCGridLayout.

	Parameters
	----------
	grid : object
		the BCGridLayout whose number of rows we want to get.

	Returns
	-------
	int
		the total number of rows of the BCGridLayout.

	See Also
	--------
	BCGridLayoutCols

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCGridLayout Example", guitk.constants.BCOnExitDestroy
		    )
		    gLayout = guitk.BCGridLayoutCreate(window)
		    label1 = guitk.BCLabelCreate(gLayout, "Row 1")
		    guitk.BCSetBackgroundColor(label1, 255, 0, 0)
		    label2 = guitk.BCLabelCreate(gLayout, "Row 2")
		    guitk.BCSetBackgroundColor(label2, 0, 255, 0)
		    labelInfo = guitk.BCLabelCreate(
		        gLayout, "Info about the GridLayout will be shown here."
		    )
		    data = [gLayout, labelInfo]
		    btnInfo = guitk.BCPushButtonCreate(
		        gLayout, "GridLayout's Info", gridInfoFunct, data
		    )
		
		    guitk.BCGridLayoutAddWidget(gLayout, label1, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, label2, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, labelInfo, 1, 4, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, btnInfo, 5, 6, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutSetColStretch(gLayout, 0, 2)
		    guitk.BCGridLayoutSetRowStretch(gLayout, 1, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    return 0
		
		
		def gridInfoFunct(btn, data):
		    text = (
		        "Grid's total rows: "
		        + str(guitk.BCGridLayoutRows(data[0]))
		        + "\\nGrid's total columns: "
		        + str(guitk.BCGridLayoutCols(data[0]))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutCols(grid: object) -> int:

	"""

	returns the total number of columns of the BCGridLayout.

	Parameters
	----------
	grid : object
		the BCGridLayout whose number of columns we want to get.

	Returns
	-------
	int
		the total number of columns of the BCGridLayout.

	See Also
	--------
	BCGridLayoutRows

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCGridLayout Example", guitk.constants.BCOnExitDestroy
		    )
		    gLayout = guitk.BCGridLayoutCreate(window)
		    label1 = guitk.BCLabelCreate(gLayout, "Row 1")
		    guitk.BCSetBackgroundColor(label1, 255, 0, 0)
		    label2 = guitk.BCLabelCreate(gLayout, "Row 2")
		    guitk.BCSetBackgroundColor(label2, 0, 255, 0)
		    labelInfo = guitk.BCLabelCreate(
		        gLayout, "Info about the GridLayout will be shown here."
		    )
		    data = [gLayout, labelInfo]
		    btnInfo = guitk.BCPushButtonCreate(
		        gLayout, "GridLayout's Info", gridInfoFunct, data
		    )
		
		    guitk.BCGridLayoutAddWidget(gLayout, label1, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, label2, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, labelInfo, 1, 4, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, btnInfo, 5, 6, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutSetColStretch(gLayout, 0, 2)
		    guitk.BCGridLayoutSetRowStretch(gLayout, 1, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    return 0
		
		
		def gridInfoFunct(btn, data):
		    text = (
		        "Grid's total rows: "
		        + str(guitk.BCGridLayoutRows(data[0]))
		        + "\\nGrid's total columns: "
		        + str(guitk.BCGridLayoutCols(data[0]))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutRemove(grid: object, w: object) -> None:

	"""

	Removes widget w from BCGridLayout grid.

	Parameters
	----------
	grid : object
		the BCGridLayout.

	w : object
		the widget that will be removed.

	Returns
	-------
	None

	See Also
	--------
	BCGridLayoutAddWidget

	Examples
	--------
	::

		import random
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "GridLayout Example: Find the Hidden Button inside the GridLayout.",
		        guitk.constants.BCOnExitDestroy,
		    )
		    gLayout = guitk.BCGridLayoutCreate(window)
		    btnFindMe = guitk.BCPushButtonCreate(gLayout, " ", None, None)
		    guitk.BCHide(btnFindMe)
		    btnStart = guitk.BCPushButtonCreate(
		        window, "Start Searching for button", None, None
		    )
		    guitk.BCButtonSetToggleButton(btnStart, True)
		    guitk.BCButtonSetToggledFunction(btnStart, startGameFunct, [gLayout, btnFindMe])
		    guitk.BCShow(window)
		
		
		def insertButtonInLayout(gLayout, b):
		    row = random.randint(0, 3)
		    col = random.randint(0, 5)
		    multi = random.choice([True, False])
		    toRow = 0
		    toCol = 0
		    if multi:
		        toRow = random.randint(row, 3)
		        toCol = random.randint(col, 5)
		        guitk.BCGridLayoutAddMultiCellWidget(
		            gLayout, b, row, toRow, col, toCol, guitk.constants.BCAlignAuto
		        )
		    else:
		        guitk.BCGridLayoutAddWidget(gLayout, b, row, col, guitk.constants.BCAlignAuto)
		    gridData = [multi, row, col, toRow, toCol]
		    fillWithLabels(gLayout, gridData)
		
		
		def fillWithLabels(gLayout, data):
		    counter = 0
		    for n in range(4):
		        for m in range(6):
		            tempName = "label_" + str(counter)
		            globals()[tempName] = guitk.BCLabelCreate(gLayout, " ")
		            label = eval("label_" + str(counter))
		            counter += 1
		            if data[0]:
		                if n >= data[1] and n <= data[3] and m >= data[2] and m <= data[4]:
		                    guitk.BCHide(label)
		            else:
		                if n == data[1] and m == data[2]:
		                    guitk.BCHide(label)
		            guitk.BCGridLayoutAddWidget(
		                gLayout, label, n, m, guitk.constants.BCAlignVJustify
		            )
		
		
		def removeItemsFromGrid(gLayout, btn):
		    btnFound = guitk.BCGridLayoutFindWidget(gLayout, btn)
		    if btnFound:
		        guitk.BCGridLayoutRemove(gLayout, btn)
		        guitk.BCHide(b)
		    counter = 0
		    for n in range(4):
		        for m in range(6):
		            label = eval("label_" + str(counter))
		            labelFound = guitk.BCGridLayoutFindWidget(gLayout, label)
		            if labelFound[0]:
		                guitk.BCGridLayoutRemove(gLayout, label)
		                guitk.BCDestroyLater(label)
		            counter += 1
		
		
		def startGameFunct(btn, state, data):
		    if state:
		        guitk.BCButtonSetText(btn, "Stop Searching for button")
		        guitk.BCShow(data[1])
		        guitk.BCButtonSetText(data[1], " ")
		        guitk.BCPushButtonSetFlat(data[1], True)
		        guitk.BCButtonSetClickedFunction(data[1], foundMeFunct, data[0])
		        insertButtonInLayout(data[0], data[1])
		    else:
		        guitk.BCButtonSetText(btn, "Start Searching for button")
		        removeItemsFromGrid(data[0], data[1])
		    return 0
		
		
		def foundMeFunct(btn, gLayout):
		    guitk.BCButtonSetText(btn, "Found Me!")
		    for i in range(24):
		        label = eval("label_" + str(i))
		        labelFound = guitk.BCGridLayoutFindWidget(gLayout, label)
		        if labelFound[0]:
		            guitk.BCSetBackgroundColor(label, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutSetRowStretch(grid: object, row: int, val: int) -> None:

	"""

	Sets the stretch factor of row row to val for the BCGridLayout grid.
	The default stretch factor is 0. Stretch factor is relative with other rows in the grid.
	Rows with high stretch factor take more of the available space.
	Stretch factors are used to change how much space widgets are given in proportion to one another.

	Parameters
	----------
	grid : object
		the BCGridLayout.

	row : int
		the row that will be affected. Recall that the first row has index 0.

	val : int
		the stretch factor.

	Returns
	-------
	None

	See Also
	--------
	BCGridLayoutSetColStretch

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCGridLayout Example", guitk.constants.BCOnExitDestroy
		    )
		    gLayout = guitk.BCGridLayoutCreate(window)
		    label1 = guitk.BCLabelCreate(gLayout, "Row 1")
		    guitk.BCSetBackgroundColor(label1, 255, 0, 0)
		    label2 = guitk.BCLabelCreate(gLayout, "Row 2")
		    guitk.BCSetBackgroundColor(label2, 0, 255, 0)
		    labelInfo = guitk.BCLabelCreate(
		        gLayout, "Info about the GridLayout will be shown here."
		    )
		    data = [gLayout, labelInfo]
		    btnInfo = guitk.BCPushButtonCreate(
		        gLayout, "GridLayout's Info", gridInfoFunct, data
		    )
		
		    guitk.BCGridLayoutAddWidget(gLayout, label1, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, label2, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, labelInfo, 1, 4, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, btnInfo, 5, 6, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutSetColStretch(gLayout, 0, 2)
		    guitk.BCGridLayoutSetRowStretch(gLayout, 1, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    return 0
		
		
		def gridInfoFunct(btn, data):
		    text = (
		        "Grid's total rows: "
		        + str(guitk.BCGridLayoutRows(data[0]))
		        + "\\nGrid's total columns: "
		        + str(guitk.BCGridLayoutCols(data[0]))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutSetColStretch(grid: object, col: int, val: int) -> None:

	"""

	Sets the stretch factor of column col to val for the BCGridLayout grid.
	The default stretch factor is 0. Stretch factor is relative with other columns in the grid.
	Columns with high stretch factor take more of the available space.
	Stretch factors are used to change how much space widgets are given in proportion to one another.

	Parameters
	----------
	grid : object
		the BCGridLayout.

	col : int
		the col that will be affected. Recall that the first column has index 0.

	val : int
		the stretch factor.

	Returns
	-------
	None

	See Also
	--------
	BCGridLayoutSetRowStretch

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCGridLayout Example", guitk.constants.BCOnExitDestroy
		    )
		    gLayout = guitk.BCGridLayoutCreate(window)
		    label1 = guitk.BCLabelCreate(gLayout, "Row 1")
		    guitk.BCSetBackgroundColor(label1, 255, 0, 0)
		    label2 = guitk.BCLabelCreate(gLayout, "Row 2")
		    guitk.BCSetBackgroundColor(label2, 0, 255, 0)
		    labelInfo = guitk.BCLabelCreate(
		        gLayout, "Info about the GridLayout will be shown here."
		    )
		    data = [gLayout, labelInfo]
		    btnInfo = guitk.BCPushButtonCreate(
		        gLayout, "GridLayout's Info", gridInfoFunct, data
		    )
		
		    guitk.BCGridLayoutAddWidget(gLayout, label1, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, label2, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, labelInfo, 1, 4, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddMultiCellWidget(
		        gLayout, btnInfo, 5, 6, 0, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutSetColStretch(gLayout, 0, 2)
		    guitk.BCGridLayoutSetRowStretch(gLayout, 1, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    return 0
		
		
		def gridInfoFunct(btn, data):
		    text = (
		        "Grid's total rows: "
		        + str(guitk.BCGridLayoutRows(data[0]))
		        + "\\nGrid's total columns: "
		        + str(guitk.BCGridLayoutCols(data[0]))
		    )
		    guitk.BCLabelSetText(data[1], text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutFindWidget(grid: object, w: object) -> bool:

	"""

	Searches for widget w in this layout (not including child layouts).

	Parameters
	----------
	grid : object
		the BCGridLayout.

	w : object
		the widget that will be searched.

	Returns
	-------
	bool
		A tuple with 3 items: 
		First item is value True if w is found, otherwise False.
		Second value is the row of the BCGridLayout at which w is found.
		Third values is the column of the BCGridLayout at which w is found.
		If the widget w was not found, the row and column values are -1.

	Examples
	--------
	::

		import random
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "GridLayout Example: Find the Hidden Button inside the GridLayout.",
		        guitk.constants.BCOnExitDestroy,
		    )
		    gLayout = guitk.BCGridLayoutCreate(window)
		    btnFindMe = guitk.BCPushButtonCreate(gLayout, " ", None, None)
		    guitk.BCHide(btnFindMe)
		    btnStart = guitk.BCPushButtonCreate(
		        window, "Start Searching for button", None, None
		    )
		    guitk.BCButtonSetToggleButton(btnStart, True)
		    guitk.BCButtonSetToggledFunction(btnStart, startGameFunct, [gLayout, btnFindMe])
		    guitk.BCShow(window)
		
		
		def insertButtonInLayout(gLayout, b):
		    row = random.randint(0, 3)
		    col = random.randint(0, 5)
		    multi = random.choice([True, False])
		    toRow = 0
		    toCol = 0
		    if multi:
		        toRow = random.randint(row, 3)
		        toCol = random.randint(col, 5)
		        guitk.BCGridLayoutAddMultiCellWidget(
		            gLayout, b, row, toRow, col, toCol, guitk.constants.BCAlignAuto
		        )
		    else:
		        guitk.BCGridLayoutAddWidget(gLayout, b, row, col, guitk.constants.BCAlignAuto)
		    gridData = [multi, row, col, toRow, toCol]
		    fillWithLabels(gLayout, gridData)
		
		
		def fillWithLabels(gLayout, data):
		    counter = 0
		    for n in range(4):
		        for m in range(6):
		            tempName = "label_" + str(counter)
		            globals()[tempName] = guitk.BCLabelCreate(gLayout, " ")
		            label = eval("label_" + str(counter))
		            counter += 1
		            if data[0]:
		                if n >= data[1] and n <= data[3] and m >= data[2] and m <= data[4]:
		                    guitk.BCHide(label)
		            else:
		                if n == data[1] and m == data[2]:
		                    guitk.BCHide(label)
		            guitk.BCGridLayoutAddWidget(
		                gLayout, label, n, m, guitk.constants.BCAlignVJustify
		            )
		
		
		def removeItemsFromGrid(gLayout, btn):
		    btnFound = guitk.BCGridLayoutFindWidget(gLayout, btn)
		    if btnFound:
		        guitk.BCGridLayoutRemove(gLayout, btn)
		        guitk.BCHide(b)
		    counter = 0
		    for n in range(4):
		        for m in range(6):
		            label = eval("label_" + str(counter))
		            labelFound = guitk.BCGridLayoutFindWidget(gLayout, label)
		            if labelFound[0]:
		                guitk.BCGridLayoutRemove(gLayout, label)
		                guitk.BCDestroyLater(label)
		            counter += 1
		
		
		def startGameFunct(btn, state, data):
		    if state:
		        guitk.BCButtonSetText(btn, "Stop Searching for button")
		        guitk.BCShow(data[1])
		        guitk.BCButtonSetText(data[1], " ")
		        guitk.BCPushButtonSetFlat(data[1], True)
		        guitk.BCButtonSetClickedFunction(data[1], foundMeFunct, data[0])
		        insertButtonInLayout(data[0], data[1])
		    else:
		        guitk.BCButtonSetText(btn, "Start Searching for button")
		        removeItemsFromGrid(data[0], data[1])
		    return 0
		
		
		def foundMeFunct(btn, gLayout):
		    guitk.BCButtonSetText(btn, "Found Me!")
		    for i in range(24):
		        label = eval("label_" + str(i))
		        labelFound = guitk.BCGridLayoutFindWidget(gLayout, label)
		        if labelFound[0]:
		            guitk.BCSetBackgroundColor(label, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelCreate(p: object, text: str) -> object:

	"""

	Creates a BCLabel with text text.

	Parameters
	----------
	p : object
		the parent widget or layout.

	text : str
		the text that the BCLabel will display.

	Returns
	-------
	object
		The created BCLabel.

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Example Label", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, 5, 2)
		
		    tmp = guitk.BCLabelCreate(grid, "Regular")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 0, 0, guitk.constants.BCAlignAuto)
		    regular = guitk.BCLabelCreate(grid, "Distance from geometry")
		    guitk.BCGridLayoutAddWidget(grid, regular, 0, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Ticker")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 1, 0, guitk.constants.BCAlignAuto)
		    ticker = guitk.BCLabelTickerCreate(
		        w,
		        "The reported <b>deviation</b> is calculated as the ratio of the smallest value over the largest",
		    )
		    guitk.BCGridLayoutAddWidget(grid, ticker, 1, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Pixmap")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 2, 0, guitk.constants.BCAlignAuto)
		    pix = guitk.BCLabelCreate(w, "")
		    guitk.BCLabelSetIconFileName(pix, "logo_sdm.svg")
		    guitk.BCGridLayoutAddWidget(grid, pix, 2, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Style Pixmap")
		    guitk.BCLabelSetStylePixmap(tmp, guitk.constants.BCMessageBoxInformation)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 3, 0, guitk.constants.BCAlignAuto)
		    stylePixmap = guitk.BCLabelCreate(w, "Use this example to give info with Labels")
		    guitk.BCGridLayoutAddWidget(grid, stylePixmap, 3, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="Print Message">Print Message</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 0, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="OpenAWindow">Open Window</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCShow(w)
		
		
		def openLinkFun(lb, link, data):
		    if link == "Print Message":
		        print("Message was printed!")
		    elif link == "OpenAWindow":
		        w = guitk.BCWindowCreate("Comments", guitk.constants.BCOnExitDestroy)
		        guitk.BCLabelCreate(w, "Opened from simple link")
		        guitk.BCDialogButtonBoxCreate(w)
		        guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelTickerCreate(p: object, text: str) -> object:

	"""

	Creates a BCTicker which is an auto-scrolling label with text text.
	BCTicker has the ability to scroll from left to right if the text can not fit in the widget's width.
	User can also scroll left or right by pressing (and keep pressed) the left mouse button and moving the cursor right or left.
	WARNING: the functions of bc_label BCLabelSelectedText BCLabelSetAlignment , BCLabelSetStylePixmap, 
	BCLabelSetIconFileName , BCLabelSetPixmap are not compatible with BCTicker.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	text : str
		the text that the BCTicker will display.

	Returns
	-------
	object
		The created BCTicker.

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Example Label", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, 5, 2)
		
		    tmp = guitk.BCLabelCreate(grid, "Regular")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 0, 0, guitk.constants.BCAlignAuto)
		    regular = guitk.BCLabelCreate(grid, "Distance from geometry")
		    guitk.BCGridLayoutAddWidget(grid, regular, 0, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Ticker")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 1, 0, guitk.constants.BCAlignAuto)
		    ticker = guitk.BCLabelTickerCreate(
		        w,
		        "The reported <b>deviation</b> is calculated as the ratio of the smallest value over the largest",
		    )
		    guitk.BCGridLayoutAddWidget(grid, ticker, 1, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Pixmap")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 2, 0, guitk.constants.BCAlignAuto)
		    pix = guitk.BCLabelCreate(w, "")
		    guitk.BCLabelSetIconFileName(pix, "logo_sdm.svg")
		    guitk.BCGridLayoutAddWidget(grid, pix, 2, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Style Pixmap")
		    guitk.BCLabelSetStylePixmap(tmp, guitk.constants.BCMessageBoxInformation)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 3, 0, guitk.constants.BCAlignAuto)
		    stylePixmap = guitk.BCLabelCreate(w, "Use this example to give info with Labels")
		    guitk.BCGridLayoutAddWidget(grid, stylePixmap, 3, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="Print Message">Print Message</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 0, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="OpenAWindow">Open Window</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCShow(w)
		
		
		def openLinkFun(lb, link, data):
		    if link == "Print Message":
		        print("Message was printed!")
		    elif link == "OpenAWindow":
		        w = guitk.BCWindowCreate("Comments", guitk.constants.BCOnExitDestroy)
		        guitk.BCLabelCreate(w, "Opened from simple link")
		        guitk.BCDialogButtonBoxCreate(w)
		        guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelText(lab: object) -> str:

	"""

	Returns the text of BCLabel lab.

	Parameters
	----------
	lab : object
		the BCLabel.

	Returns
	-------
	str
		the text of the BCLabel.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Dimensions", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    btnDimensions = guitk.BCPushButtonCreate(hBox, "Calculate Dimensions", None, None)
		    label = guitk.BCLabelCreate(hBox, "Button Dimensions\t\t\\nWindow Dimensions\t\t")
		    guitk.BCButtonSetClickedFunction(
		        btnDimensions, lambda btn, data: showDimensions(btn, *data), [window, label]
		    )
		    guitk.BCTimerSingleShot(
		        0, lambda data: showDimensions(btnDimensions, *data), [window, label]
		    )
		    guitk.BCShow(window)
		
		
		def showDimensions(btn, window, label):
		    print("Old dimensions:\\n" + guitk.BCLabelText(label) + "\\n")
		    newDimensionsText = (
		        "Button Dimensions = "
		        + str(guitk.BCWidth(btn))
		        + "x"
		        + str(guitk.BCHeight(btn))
		    )
		    newDimensionsText += (
		        "\\nWindow Dimensions = "
		        + str(guitk.BCWidth(window))
		        + "x"
		        + str(guitk.BCHeight(window))
		    )
		    guitk.BCLabelSetText(label, newDimensionsText)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelSelectedText(lab: object) -> str:

	"""

	Returns the selected text of BCLabel lab.
	This function is not supported under VR mode.

	Parameters
	----------
	lab : object
		the BCLabel.

	Returns
	-------
	str
		the selected text of the BCLabel.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Label Selected Text Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    label = guitk.BCLabelCreate(
		        hBox, "This label's selected text will appear on the line edit to the bottom."
		    )
		    lineEdit = guitk.BCLineEditCreate(window, "")
		    guitk.BCLineEditSetReadOnly(lineEdit, True)
		    # A timer to update text in line edit
		    timer = guitk.BCTimerCreate(window)
		    guitk.BCTimerStart(timer, 100, False)  # 10 Hz
		    guitk.BCTimerSetTimeoutFunction(timer, timerTimedOut, (label, lineEdit))
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Label's Selected Text")
		    guitk.BCShow(window)
		
		
		def timerTimedOut(timer, data):
		    label, lineEdit = data
		    guitk.BCLineEditSetText(lineEdit, guitk.BCLabelSelectedText(label))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelSetText(lab: object, text: str) -> None:

	"""

	Sets the text that will be displayed by BCLabel lab.

	Parameters
	----------
	lab : object
		the BCLabel.

	text : str
		the text that BCLabel lab will display.

	Returns
	-------
	None

	See Also
	--------
	BCLabelText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Dimensions", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    btnDimensions = guitk.BCPushButtonCreate(hBox, "Calculate Dimensions", None, None)
		    label = guitk.BCLabelCreate(hBox, "Button Dimensions\t\t\\nWindow Dimensions\t\t")
		    guitk.BCButtonSetClickedFunction(
		        btnDimensions, lambda btn, data: showDimensions(btn, *data), [window, label]
		    )
		    guitk.BCTimerSingleShot(
		        0, lambda data: showDimensions(btnDimensions, *data), [window, label]
		    )
		    guitk.BCShow(window)
		
		
		def showDimensions(btn, window, label):
		    print("Old dimensions:\\n" + guitk.BCLabelText(label) + "\\n")
		    newDimensionsText = (
		        "Button Dimensions = "
		        + str(guitk.BCWidth(btn))
		        + "x"
		        + str(guitk.BCHeight(btn))
		    )
		    newDimensionsText += (
		        "\\nWindow Dimensions = "
		        + str(guitk.BCWidth(window))
		        + "x"
		        + str(guitk.BCHeight(window))
		    )
		    guitk.BCLabelSetText(label, newDimensionsText)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelSetAlignment(lab: object, alignment: int) -> None:

	"""

	Sets the alignment of the label.
	This function is not supported under VR mode.

	Parameters
	----------
	lab : object
		the BCLabel.

	alignment : int
		specifies the required alignment.
		See BCEnumAlignment for details.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Align Label Example", guitk.constants.BCOnExitDestroy
		    )
		    label = guitk.BCLabelCreate(
		        window, "This label will align according to ButtonGroups on the bottom."
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    btnGroupHorizontal = alignButtonGroupCreate(
		        hBox,
		        "Horizontal Alignment",
		        ["BCAlignLeft", "BCAlignHCenter", "BCAlignRight"],
		        0,
		    )
		    btnGroupVertical = alignButtonGroupCreate(
		        hBox, "Vertical Alignment", ["BCAlignTop", "BCAlignVCenter", "BCAlignBottom"], 1
		    )
		
		    data = (btnGroupHorizontal, btnGroupVertical, label)
		    guitk.BCButtonGroupSetPressedFunction(btnGroupHorizontal, changeAlignment, data)
		    guitk.BCButtonGroupSetPressedFunction(btnGroupVertical, changeAlignment, data)
		    guitk.BCShow(window)
		
		
		def alignButtonGroupCreate(parent, title, options, checked):
		    btnGroup = guitk.BCButtonGroupCreate(parent, title, guitk.constants.BCVertical)
		    radioBtns = [None] * len(options)
		    for i in range(len(options)):
		        radioBtns[i] = guitk.BCRadioButtonCreate(btnGroup, options[i], None, None)
		    guitk.BCRadioButtonSetChecked(radioBtns[checked], True)
		    return btnGroup
		
		
		def changeAlignment(btnGroup, id, data):
		    btnGroupHorizontal, btnGroupVertical, label = data
		    horizontalText = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupSelected(btnGroupHorizontal)
		    )
		    verticalText = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupSelected(btnGroupVertical)
		    )
		    guitk.BCLabelSetAlignment(
		        label,
		        eval("guitk.constants." + horizontalText)
		        | eval("guitk.constants." + verticalText),
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelSetStylePixmap(lab: object, style: int) -> None:

	"""

	Sets the specified pixmap of type style to be displayed on the BCLabel according to the desired kind of message.
	This function is not supported under VR mode.

	Parameters
	----------
	lab : object
		the BCLabel.

	style : int
		the required pixmap. See BCEnumStylePixmap for details.
		
		guitk.constants BCEnumStylePixmap
		This enum represents a StylePixmap. A StylePixmap is a pixmap that can follow some
		existing GUI style or guideline. StylePixmap is used with BCLabelSetStylePixmap for example.
		 - guitk.constants.BCMessageBoxWarning
		the 'warning' icon.
		 - guitk.constants.BCMessageBoxCritical
		the 'critical' icon.
		 - guitk.constants.BCMessageBoxInformation
		the 'information' icon.
		 - guitk.constants.BCMessageBoxQuestion
		the 'question' icon.

	Returns
	-------
	None

	See Also
	--------
	BCLabelSetIconFileName

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Example Label", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, 5, 2)
		
		    tmp = guitk.BCLabelCreate(grid, "Regular")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 0, 0, guitk.constants.BCAlignAuto)
		    regular = guitk.BCLabelCreate(grid, "Distance from geometry")
		    guitk.BCGridLayoutAddWidget(grid, regular, 0, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Ticker")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 1, 0, guitk.constants.BCAlignAuto)
		    ticker = guitk.BCLabelTickerCreate(
		        w,
		        "The reported <b>deviation</b> is calculated as the ratio of the smallest value over the largest",
		    )
		    guitk.BCGridLayoutAddWidget(grid, ticker, 1, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Pixmap")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 2, 0, guitk.constants.BCAlignAuto)
		    pix = guitk.BCLabelCreate(w, "")
		    guitk.BCLabelSetIconFileName(pix, "logo_sdm.svg")
		    guitk.BCGridLayoutAddWidget(grid, pix, 2, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Style Pixmap")
		    guitk.BCLabelSetStylePixmap(tmp, guitk.constants.BCMessageBoxInformation)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 3, 0, guitk.constants.BCAlignAuto)
		    stylePixmap = guitk.BCLabelCreate(w, "Use this example to give info with Labels")
		    guitk.BCGridLayoutAddWidget(grid, stylePixmap, 3, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="Print Message">Print Message</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 0, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="OpenAWindow">Open Window</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCShow(w)
		
		
		def openLinkFun(lb, link, data):
		    if link == "Print Message":
		        print("Message was printed!")
		    elif link == "OpenAWindow":
		        w = guitk.BCWindowCreate("Comments", guitk.constants.BCOnExitDestroy)
		        guitk.BCLabelCreate(w, "Opened from simple link")
		        guitk.BCDialogButtonBoxCreate(w)
		        guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelSetIconFileName(lab: object, fileName: str) -> None:

	"""

	Sets the specified iconname pixmap file to be displayed on the BCLabel lab.
	NOTE: If you set a pixmap file to a label, its text will be replaced and vice versa.
	This function is not supported under VR mode.

	Parameters
	----------
	lab : object
		the BCLabel.

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCLabelSetStylePixmap

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Example Label", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, 5, 2)
		
		    tmp = guitk.BCLabelCreate(grid, "Regular")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 0, 0, guitk.constants.BCAlignAuto)
		    regular = guitk.BCLabelCreate(grid, "Distance from geometry")
		    guitk.BCGridLayoutAddWidget(grid, regular, 0, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Ticker")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 1, 0, guitk.constants.BCAlignAuto)
		    ticker = guitk.BCLabelTickerCreate(
		        w,
		        "The reported <b>deviation</b> is calculated as the ratio of the smallest value over the largest",
		    )
		    guitk.BCGridLayoutAddWidget(grid, ticker, 1, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Pixmap")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 2, 0, guitk.constants.BCAlignAuto)
		    pix = guitk.BCLabelCreate(w, "")
		    guitk.BCLabelSetIconFileName(pix, "logo_sdm.svg")
		    guitk.BCGridLayoutAddWidget(grid, pix, 2, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Style Pixmap")
		    guitk.BCLabelSetStylePixmap(tmp, guitk.constants.BCMessageBoxInformation)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 3, 0, guitk.constants.BCAlignAuto)
		    stylePixmap = guitk.BCLabelCreate(w, "Use this example to give info with Labels")
		    guitk.BCGridLayoutAddWidget(grid, stylePixmap, 3, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="Print Message">Print Message</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 0, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="OpenAWindow">Open Window</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCShow(w)
		
		
		def openLinkFun(lb, link, data):
		    if link == "Print Message":
		        print("Message was printed!")
		    elif link == "OpenAWindow":
		        w = guitk.BCWindowCreate("Comments", guitk.constants.BCOnExitDestroy)
		        guitk.BCLabelCreate(w, "Opened from simple link")
		        guitk.BCDialogButtonBoxCreate(w)
		        guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutCreate(p: object, o: int) -> object:

	"""

	Creates a BCBoxLayout with horizontal or vertical orientation depending on o.

	Parameters
	----------
	p : object
		the parent widget or layout.

	o : int
		the orientation. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	Returns
	-------
	object
		the created BCBoxLayout.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCBoxLayout Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button = guitk.BCPushButtonCreate(blayout, "Button 1", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 2", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 3", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 4", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 5", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(hl, "Layout Direction", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "Left to right", None, None)
		    guitk.BCRadioButtonCreate(bg, "Right to left", None, None)
		    guitk.BCRadioButtonCreate(bg, "Top to bottom", None, None)
		    guitk.BCRadioButtonCreate(bg, "Bottom to top", None, None)
		    guitk.BCButtonGroupSetButton(bg, 0)
		    guitk.BCButtonGroupSetClickedFunction(bg, setLayoutDirection, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, blayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setLayoutDirection(bg, buttonIndex, blayout):
		    if buttonIndex == 0:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCLeftToRight)
		    elif buttonIndex == 1:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCRightToLeft)
		    elif buttonIndex == 2:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCTopToBottom)
		    elif buttonIndex == 3:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCBottomToTop)
		    return 0
		
		
		def setMargin(spin, value, blayout):
		    guitk.BCBoxLayoutSetMargin(blayout, value)
		    return 0
		
		
		def setSpacing(spin, value, blayout):
		    guitk.BCBoxLayoutSetSpacing(blayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutSetMargin(l: object, margin: int) -> None:

	"""

	Sets the margin of BCBoxLayout l to margin.

	Parameters
	----------
	l : object
		the BCBoxLayout that will be affected by this function.

	margin : int
		the new value for margin.

	Returns
	-------
	None

	See Also
	--------
	BCBoxLayoutSetSpacing

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCBoxLayout Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button = guitk.BCPushButtonCreate(blayout, "Button 1", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 2", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 3", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 4", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 5", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(hl, "Layout Direction", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "Left to right", None, None)
		    guitk.BCRadioButtonCreate(bg, "Right to left", None, None)
		    guitk.BCRadioButtonCreate(bg, "Top to bottom", None, None)
		    guitk.BCRadioButtonCreate(bg, "Bottom to top", None, None)
		    guitk.BCButtonGroupSetButton(bg, 0)
		    guitk.BCButtonGroupSetClickedFunction(bg, setLayoutDirection, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, blayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setLayoutDirection(bg, buttonIndex, blayout):
		    if buttonIndex == 0:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCLeftToRight)
		    elif buttonIndex == 1:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCRightToLeft)
		    elif buttonIndex == 2:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCTopToBottom)
		    elif buttonIndex == 3:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCBottomToTop)
		    return 0
		
		
		def setMargin(spin, value, blayout):
		    guitk.BCBoxLayoutSetMargin(blayout, value)
		    return 0
		
		
		def setSpacing(spin, value, blayout):
		    guitk.BCBoxLayoutSetSpacing(blayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutSetSpacing(l: object, spacing: int) -> None:

	"""

	Sets the spacing of BCBoxLayout l to spacing.

	Parameters
	----------
	l : object
		the layout that will be affected by this function.

	spacing : int
		the new value for spacing.

	Returns
	-------
	None

	See Also
	--------
	BCBoxLayoutSetMargin

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCBoxLayout Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button = guitk.BCPushButtonCreate(blayout, "Button 1", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 2", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 3", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 4", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 5", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(hl, "Layout Direction", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "Left to right", None, None)
		    guitk.BCRadioButtonCreate(bg, "Right to left", None, None)
		    guitk.BCRadioButtonCreate(bg, "Top to bottom", None, None)
		    guitk.BCRadioButtonCreate(bg, "Bottom to top", None, None)
		    guitk.BCButtonGroupSetButton(bg, 0)
		    guitk.BCButtonGroupSetClickedFunction(bg, setLayoutDirection, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, blayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setLayoutDirection(bg, buttonIndex, blayout):
		    if buttonIndex == 0:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCLeftToRight)
		    elif buttonIndex == 1:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCRightToLeft)
		    elif buttonIndex == 2:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCTopToBottom)
		    elif buttonIndex == 3:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCBottomToTop)
		    return 0
		
		
		def setMargin(spin, value, blayout):
		    guitk.BCBoxLayoutSetMargin(blayout, value)
		    return 0
		
		
		def setSpacing(spin, value, blayout):
		    guitk.BCBoxLayoutSetSpacing(blayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutSetStretchFactor(l: object, item: object, stretch: int) -> int:

	"""

	Sets the stretch factor for item to stretch and returns 1 if item is found in this layout (not including child layouts), otherwise returns 0.

	Parameters
	----------
	l : object
		the layout (either horizontal or vertical).

	item : object
		the item for which the stretch factor will be set. Either a widget or a layout.

	stretch : int
		the new stretch factor for item.

	Returns
	-------
	int
		1 if item is found in layout l, 0 otherwise.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCBoxLayout Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayoutHor = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    createButtons(boxLayoutHor)
		    button = guitk.BCPushButtonCreate(boxLayoutHor, "Stretched Button", None, None)
		    guitk.BCBoxLayoutInsert(boxLayoutHor, button, -1)
		    guitk.BCWindowAddSeparator(window)
		    boxLayoutVer = guitk.BCBoxLayoutCreate(window, guitk.constants.BCVertical)
		    btnChange = guitk.BCPushButtonCreate(
		        boxLayoutVer, "Change Direction", changeDirectionFunction, boxLayoutHor
		    )
		    btnRemove = guitk.BCPushButtonCreate(boxLayoutVer, "Remove Button", None, None)
		    guitk.BCButtonSetToggleButton(btnRemove, True)
		    guitk.BCButtonSetToggledFunction(btnRemove, removeFunction, [boxLayoutHor, button])
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCShow(window)
		
		
		def createButtons(boxLayoutHor):
		    for i in range(4):
		        button = guitk.BCPushButtonCreate(
		            boxLayoutHor, "Button " + str(i + 1), None, None
		        )
		        guitk.BCBoxLayoutInsert(boxLayoutHor, button, -1)
		
		
		def changeDirectionFunction(btn, boxLayoutHor):
		    direction = guitk.BCBoxLayoutDirection(boxLayoutHor)
		    if direction == guitk.constants.BCLeftToRight:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCRightToLeft)
		    elif direction == guitk.constants.BCRightToLeft:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCTopToBottom)
		    elif direction == guitk.constants.BCTopToBottom:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCBottomToTop)
		    elif direction == guitk.constants.BCBottomToTop:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCLeftToRight)
		    return 0
		
		
		def removeFunction(btn, state, data):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetText(btn, "Reset Button")
		        guitk.BCBoxLayoutRemove(data[0], data[1])
		    else:
		        guitk.BCButtonSetText(btn, "Remove Button")
		        guitk.BCBoxLayoutInsert(data[0], data[1], -1)
		    foundButton(data[0], data[1])
		    return 0
		
		
		def foundButton(boxLayoutHor, button):
		    isPressent = guitk.BCBoxLayoutSetStretchFactor(boxLayoutHor, button, 2)
		    if isPressent:
		        print("Button added to layout and stretched.")
		    else:
		        print("Button removed from layout.")
		
		
		def acceptFunc(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutSetDirection(l: object, d: int) -> None:

	"""

	Sets the direction of layout l to d.

	Parameters
	----------
	l : object
		the layout (either horizontal or vertical).

	d : int
		the new direction of l. See BCEnumDirection.
		
		guitk.constants BCEnumDirection
		This enum type defines the direction of box layouts. It can be used with BCBoxLayoutSetDirection for example.
		 - guitk.constants.BCLeftToRight
		The new widgets are inserted on the right of previously inserted widgets.
		 - guitk.constants.BCRightToLeft
		The new widgets are inserted on the left of previously inserted widgets.
		 - guitk.constants.BCTopToBottom
		The new widgets are inserted down under the previously inserted widgets.
		 - guitk.constants.BCBottomToTop
		The new widgets are inserted up above the previously inserted widgets.
		 - guitk.constants.BCDown
		same as BCTopToBottom.
		 - guitk.constants.BCUp
		same as BCBottomToTop.

	Returns
	-------
	None

	See Also
	--------
	BCBoxLayoutDirection

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCBoxLayout Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button = guitk.BCPushButtonCreate(blayout, "Button 1", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 2", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 3", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 4", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 5", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(hl, "Layout Direction", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "Left to right", None, None)
		    guitk.BCRadioButtonCreate(bg, "Right to left", None, None)
		    guitk.BCRadioButtonCreate(bg, "Top to bottom", None, None)
		    guitk.BCRadioButtonCreate(bg, "Bottom to top", None, None)
		    guitk.BCButtonGroupSetButton(bg, 0)
		    guitk.BCButtonGroupSetClickedFunction(bg, setLayoutDirection, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, blayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setLayoutDirection(bg, buttonIndex, blayout):
		    if buttonIndex == 0:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCLeftToRight)
		    elif buttonIndex == 1:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCRightToLeft)
		    elif buttonIndex == 2:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCTopToBottom)
		    elif buttonIndex == 3:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCBottomToTop)
		    return 0
		
		
		def setMargin(spin, value, blayout):
		    guitk.BCBoxLayoutSetMargin(blayout, value)
		    return 0
		
		
		def setSpacing(spin, value, blayout):
		    guitk.BCBoxLayoutSetSpacing(blayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutDirection(l: object) -> int:

	"""

	Returns the direction of layout l.

	Parameters
	----------
	l : object
		the layout.

	Returns
	-------
	int
		the direction of layout (see BCEnumDirection).
		BCEnumDirection: This enum type defines the direction of box layouts. It can be used with BCBoxLayoutSetDirection for example.
		guitk.constants.BCLeftToRight: The new widgets are inserted on the right of previously inserted widgets.
		guitk.constants.BCRightToLeft: The new widgets are inserted on the left of previously inserted widgets.
		guitk.constants.BCTopToBottom: The new widgets are inserted down under the previously inserted widgets.
		guitk.constants.BCBottomToTop: The new widgets are inserted up above the previously inserted widgets.
		guitk.constants.BCDown: same as BCTopToBottom.
		guitk.constants.BCUp: same as BCBottomToTop.

	See Also
	--------
	BCBoxLayoutSetDirection

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCBoxLayout Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayoutHor = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    createButtons(boxLayoutHor)
		    button = guitk.BCPushButtonCreate(boxLayoutHor, "Stretched Button", None, None)
		    guitk.BCBoxLayoutInsert(boxLayoutHor, button, -1)
		    guitk.BCWindowAddSeparator(window)
		    boxLayoutVer = guitk.BCBoxLayoutCreate(window, guitk.constants.BCVertical)
		    btnChange = guitk.BCPushButtonCreate(
		        boxLayoutVer, "Change Direction", changeDirectionFunction, boxLayoutHor
		    )
		    btnRemove = guitk.BCPushButtonCreate(boxLayoutVer, "Remove Button", None, None)
		    guitk.BCButtonSetToggleButton(btnRemove, True)
		    guitk.BCButtonSetToggledFunction(btnRemove, removeFunction, [boxLayoutHor, button])
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCShow(window)
		
		
		def createButtons(boxLayoutHor):
		    for i in range(4):
		        button = guitk.BCPushButtonCreate(
		            boxLayoutHor, "Button " + str(i + 1), None, None
		        )
		        guitk.BCBoxLayoutInsert(boxLayoutHor, button, -1)
		
		
		def changeDirectionFunction(btn, boxLayoutHor):
		    direction = guitk.BCBoxLayoutDirection(boxLayoutHor)
		    if direction == guitk.constants.BCLeftToRight:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCRightToLeft)
		    elif direction == guitk.constants.BCRightToLeft:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCTopToBottom)
		    elif direction == guitk.constants.BCTopToBottom:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCBottomToTop)
		    elif direction == guitk.constants.BCBottomToTop:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCLeftToRight)
		    return 0
		
		
		def removeFunction(btn, state, data):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetText(btn, "Reset Button")
		        guitk.BCBoxLayoutRemove(data[0], data[1])
		    else:
		        guitk.BCButtonSetText(btn, "Remove Button")
		        guitk.BCBoxLayoutInsert(data[0], data[1], -1)
		    foundButton(data[0], data[1])
		    return 0
		
		
		def foundButton(boxLayoutHor, button):
		    isPressent = guitk.BCBoxLayoutSetStretchFactor(boxLayoutHor, button, 2)
		    if isPressent:
		        print("Button added to layout and stretched.")
		    else:
		        print("Button removed from layout.")
		
		
		def acceptFunc(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutInsert(l: object, item: object, index: int) -> None:

	"""

	Inserts item into this box layout at position index. If index is negative, the item is added at the end.

	Parameters
	----------
	l : object
		the layout (either horizontal or vertical).

	item : object
		the widget or layout that will be inserted to l.

	index : int
		the index where item will be inserted. If index == -1 item is added at the end of l.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCBoxLayout Example", guitk.constants.BCOnExitDestroy)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button = guitk.BCPushButtonCreate(blayout, "Button 1", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 2", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 3", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 4", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		    button = guitk.BCPushButtonCreate(blayout, "Button 5", None, None)
		    guitk.BCBoxLayoutInsert(blayout, button, -1)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(hl, "Layout Direction", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "Left to right", None, None)
		    guitk.BCRadioButtonCreate(bg, "Right to left", None, None)
		    guitk.BCRadioButtonCreate(bg, "Top to bottom", None, None)
		    guitk.BCRadioButtonCreate(bg, "Bottom to top", None, None)
		    guitk.BCButtonGroupSetButton(bg, 0)
		    guitk.BCButtonGroupSetClickedFunction(bg, setLayoutDirection, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin : ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, blayout)
		
		    l = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, blayout)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setLayoutDirection(bg, buttonIndex, blayout):
		    if buttonIndex == 0:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCLeftToRight)
		    elif buttonIndex == 1:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCRightToLeft)
		    elif buttonIndex == 2:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCTopToBottom)
		    elif buttonIndex == 3:
		        guitk.BCBoxLayoutSetDirection(blayout, guitk.constants.BCBottomToTop)
		    return 0
		
		
		def setMargin(spin, value, blayout):
		    guitk.BCBoxLayoutSetMargin(blayout, value)
		    return 0
		
		
		def setSpacing(spin, value, blayout):
		    guitk.BCBoxLayoutSetSpacing(blayout, value)
		    return 0
		
		
		def acceptFunc(win, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBoxLayoutRemove(l: object, item: object) -> None:

	"""

	Remove item item from box layout l.
	WARNING: After this call, it is the caller's responsibility to give the item a reasonable geometry or to put the item back into a layout.

	Parameters
	----------
	l : object
		the layout (either horizontal or vertical).

	item : object
		can be either widget (BCButton, BCLabel, BCLineEdit ...) or layout (either horizontal or vertical).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCBoxLayout Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayoutHor = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    createButtons(boxLayoutHor)
		    button = guitk.BCPushButtonCreate(boxLayoutHor, "Stretched Button", None, None)
		    guitk.BCBoxLayoutInsert(boxLayoutHor, button, -1)
		    guitk.BCWindowAddSeparator(window)
		    boxLayoutVer = guitk.BCBoxLayoutCreate(window, guitk.constants.BCVertical)
		    btnChange = guitk.BCPushButtonCreate(
		        boxLayoutVer, "Change Direction", changeDirectionFunction, boxLayoutHor
		    )
		    btnRemove = guitk.BCPushButtonCreate(boxLayoutVer, "Remove Button", None, None)
		    guitk.BCButtonSetToggleButton(btnRemove, True)
		    guitk.BCButtonSetToggledFunction(btnRemove, removeFunction, [boxLayoutHor, button])
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCShow(window)
		
		
		def createButtons(boxLayoutHor):
		    for i in range(4):
		        button = guitk.BCPushButtonCreate(
		            boxLayoutHor, "Button " + str(i + 1), None, None
		        )
		        guitk.BCBoxLayoutInsert(boxLayoutHor, button, -1)
		
		
		def changeDirectionFunction(btn, boxLayoutHor):
		    direction = guitk.BCBoxLayoutDirection(boxLayoutHor)
		    if direction == guitk.constants.BCLeftToRight:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCRightToLeft)
		    elif direction == guitk.constants.BCRightToLeft:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCTopToBottom)
		    elif direction == guitk.constants.BCTopToBottom:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCBottomToTop)
		    elif direction == guitk.constants.BCBottomToTop:
		        guitk.BCBoxLayoutSetDirection(boxLayoutHor, guitk.constants.BCLeftToRight)
		    return 0
		
		
		def removeFunction(btn, state, data):
		    if guitk.BCButtonIsOn(btn):
		        guitk.BCButtonSetText(btn, "Reset Button")
		        guitk.BCBoxLayoutRemove(data[0], data[1])
		    else:
		        guitk.BCButtonSetText(btn, "Remove Button")
		        guitk.BCBoxLayoutInsert(data[0], data[1], -1)
		    foundButton(data[0], data[1])
		    return 0
		
		
		def foundButton(boxLayoutHor, button):
		    isPressent = guitk.BCBoxLayoutSetStretchFactor(boxLayoutHor, button, 2)
		    if isPressent:
		        print("Button added to layout and stretched.")
		    else:
		        print("Button removed from layout.")
		
		
		def acceptFunc(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditCreateDouble(p: object, val: float=guitk.constants.blank) -> object:

	"""

	Creates a BCLineEdit that only accepts doubles.
	NOTE: Initializing with val value guitk.constants.blank will create an empty-valid double LineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget.

	val : float, optional
		the value with which the text of the BCLineEdit will be set (in double format).

	Returns
	-------
	object
		the created BCLineEdit.

	See Also
	--------
	BCLineEditCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Double LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateDouble if user wants to have an empty-valid initial double LineEdit
		    doubleLineEdit = guitk.BCLineEditCreateDouble(hl, guitk.constants.blank)
		    guitk.BCLineEditSetDecimals(doubleLineEdit, 2)
		
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, doubleenterpressedFunction, None
		    )
		    doublelineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        doublelineeditHL, "", "Validate", validateFunction, doubleLineEdit
		    )
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(doublelineeditHL, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleLineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 92.1
		    else:
		        maxvalue = 1000000.0
		    guitk.BCLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def doubleenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditCreateInt(p: object, val: int=guitk.constants.blank) -> object:

	"""

	Creates a BCLineEdit that only accepts integers.
	NOTE: Initializing with val value guitk.constants.blank will create an empty-valid int LineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget.

	val : int, optional
		the value with which the text of the BCLineEdit will be set (in int format).

	Returns
	-------
	object
		the created BCLineEdit.

	See Also
	--------
	BCLineEditCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Integer LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateInt if user wants to have an empty-valid initial int LineEdit
		    intLineEdit = guitk.BCLineEditCreateInt(hl, guitk.constants.blank)
		
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, intenterpressedFunction, None)
		    intlineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        intlineeditHL, "", "Validate", validateFunction, intLineEdit
		    )
		
		    maximumintCB = guitk.BCCheckBoxCreate(intlineeditHL, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(maximumintCB, maximumintFunction, intLineEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def intenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditCreate(p: object, val: str) -> object:

	"""

	Creates a BCLineEdit that accepts any text.

	Parameters
	----------
	p : object
		the parent widget or layout.

	val : str
		the value with which the text of the LineEdit will be set

	Returns
	-------
	object
		the created BCLineEdit.

	See Also
	--------
	BCLineEditCreateInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditGetText(le: object) -> str:

	"""

	Returns the text of BCLineEdit le.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	str
		the text of the BCLineEdit.

	See Also
	--------
	BCLineEditGetInt, BCLineEditGetSelectedText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditHasText(le: object) -> int:

	"""

	Checks whether BCLineEdit le has text or not.
	NOTE: Spaces and tabs are also meant as text, so in such cases this function will return 1.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	int
		0 in case le is empty; 1 otherwise.

	See Also
	--------
	BCLineEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the current text of LineEdit."
		    )
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Write something here.")
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_left_16.png",
		        "Move Cursor Left",
		        moveCursorLeftFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_right_16.png",
		        "Move Cursor Right",
		        moveCursorRightFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "info_small.svg",
		        "Get info(Holder) as text",
		        getInfoFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns, "clean_small.svg", "Clean LineEdit", clearFunction, lineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, lineEdit):
		    if guitk.BCLineEditHasText(lineEdit):
		        print("Has text and will be cleared.")
		        guitk.BCLineEditClear(lineEdit)
		    return 0
		
		
		def getInfoFunction(toolBtn, lineEdit):
		    # Must set placeholder text first. Using guitk.BCLineEditSetPlaceholderText()
		    infoTxt = guitk.BCLineEditGetPlaceholderText(lineEdit)
		    if not infoTxt == None:
		        guitk.BCLineEditSetText(lineEdit, infoTxt)
		    else:
		        guitk.BCLineEditSetText(lineEdit, "No info set.")
		    return 0
		
		
		def moveCursorRightFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) + 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) - 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditGetSelectedText(le: object) -> str:

	"""

	Returns the selected text of BCLineEdit le if any, otherwise returns None.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	str
		the selected text of the BCLineEdit or None if nothing is selected.

	See Also
	--------
	BCLineEditGetText, BCLineEditSelectAll

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the text of line edit. This is the selected text."
		    )
		    checkBox = guitk.BCCheckBoxCreate(boxLayout, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, selectAllFunct, lineEdit)
		    guitk.BCToolButtonCreate(
		        window, "", "Insert Auto-Text", confirmNewTextFunct, lineEdit
		    )
		    guitk.BCLineEditSetTextChangeFunction(
		        lineEdit, textChangedFunct, guitk.BCLineEditGetText(lineEdit)
		    )
		    guitk.BCLineEditSetSelectionChangedFunction(lineEdit, selectionChangedFunct, None)
		    guitk.BCLineEditSetSelection(lineEdit, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def confirmNewTextFunct(tb, lineEdit):
		    new_text = "This is the new text! "
		    guitk.BCLineEditInsertText(lineEdit, new_text)
		    return 0
		
		
		def selectAllFunct(checkBox, state, lineEdit):
		    if state:
		        print("Select all activated.")
		        guitk.BCLineEditSelectAll(lineEdit)
		    else:
		        print("Select all deactivated.")
		        guitk.BCLineEditSetSelection(lineEdit, 0, 0)
		    return 0
		
		
		def textChangedFunct(lineEdit, text, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Previous text: " + data)
		    print("Text changed to: " + text)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(lineEdit, data):
		    print("Currently selected text: " + guitk.BCLineEditGetSelectedText(lineEdit))
		    print("Whole text: " + guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditGetInt(le: object) -> int:

	"""

	Returns the content of BCLineEdit le in int format.
	NOTE: le should be checked if is empty (i.e. it has no text) with function BCLineEditHasText().
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	int
		the content of the BCLineEdit in int format. If the content is not a valid integer or le is empty, guitk.constants.blank will be returned, indicating that the integer is invalid.

	See Also
	--------
	BCLineEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Integer LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateInt if user wants to have an empty-valid initial int LineEdit
		    intLineEdit = guitk.BCLineEditCreateInt(hl, guitk.constants.blank)
		
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, intenterpressedFunction, None)
		    intlineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        intlineeditHL, "", "Validate", validateFunction, intLineEdit
		    )
		
		    maximumintCB = guitk.BCCheckBoxCreate(intlineeditHL, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(maximumintCB, maximumintFunction, intLineEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def intenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditGetDouble(le: object) -> float:

	"""

	Returns the content of BCLineEdit le in double format.
	NOTE: le should be checked if is empty (i.e. it has no text) with function BCLineEditHasText().
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	float
		the content of the BCLineEdit in double format. If the content is not a valid double or le is empty, guitk.constants.blank will be returned, indicating that the double is invalid.

	See Also
	--------
	BCLineEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Double LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateDouble if user wants to have an empty-valid initial double LineEdit
		    doubleLineEdit = guitk.BCLineEditCreateDouble(hl, guitk.constants.blank)
		    guitk.BCLineEditSetDecimals(doubleLineEdit, 2)
		
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, doubleenterpressedFunction, None
		    )
		    doublelineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        doublelineeditHL, "", "Validate", validateFunction, doubleLineEdit
		    )
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(doublelineeditHL, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleLineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 92.1
		    else:
		        maxvalue = 1000000.0
		    guitk.BCLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def doubleenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetText(le: object, text: str) -> None:

	"""

	Sets the text of BCLineEdit le to be the text in text.

	Parameters
	----------
	le : object
		the BCLineEdit.

	text : str
		the new text that will be displayed in BCLineEdit le.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetInt(le: object, val: int) -> None:

	"""

	Sets the integer val to be the content of BCLineEdit le.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	val : int
		the integer value that will be displayed in BCLineEdit le.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Int Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Int LineEdit")
		    lineEdit = guitk.BCLineEditCreateInt(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorInt)
		    guitk.BCLineEditSetInt(lineEdit, 123)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1005)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1, 4999)", None, None)
		    cbNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorInt:
		        print("Wrong type of validator.")
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6)":
		            guitk.BCLineEditSetMinLimitInt(lineEdit, 6)
		        elif buttonText == "Max (1005)":
		            guitk.BCLineEditSetMaxLimitInt(lineEdit, 1005)
		        elif buttonText == "Both (1, 4999)":
		            guitk.BCLineEditSetMinMaxLimitInt(lineEdit, 1, 4999)
		        else:
		            guitk.BCLineEditSetMinMaxLimitInt(lineEdit, -2147483648, 2147483647)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetDouble(le: object, val: float) -> None:

	"""

	Sets the text of BCLineEdit le to be a text representation of val.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	val : float
		the double value that will be displayed in BCLineEdit le.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetQuestionMarkFunction(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when a question mark (?) is entered in the BCLineEdit.
	NOTE: If BCLineEditSetF1Function() is not set, when pressing F1 the function funct will be called.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_QUESTIONMARK_FUNCTION for details.
		integer BC_LINEEDIT_QUESTIONMARK_FUNCTION(le, data)
		The function to be called when a questionmark (?) is entered in a BCLineEdit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetF1Function

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "Press Enter Key, Question Mark (?) Key or F1 key"
		    )
		    guitk.BCLineEditSetQuestionMarkFunction(lineEdit, questionMarkEntered, None)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, enterPressed, None)
		    guitk.BCLineEditSetF1Function(lineEdit, f1pressedFunct, None)
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, editingFinishedFunction, None)
		    guitk.BCLineEditSetFixedNumCharWidth(lineEdit, 50)
		    guitk.BCLineEditSetMinimumWidth(lineEdit, guitk.constants.BCSizeSmall)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def editingFinishedFunction(lineEdit, data):
		    print("Enter pressed. editingFinishedFunction() called after.")
		    guitk.BCLineEditSetText(lineEdit, "Editing Finished.")
		    return 0
		
		
		def enterPressed(lineEdit, data):
		    print("Enter pressed. enterPressed() called first.")
		    guitk.BCLineEditSetText(lineEdit, "Enter Pressed.")
		    return 0
		
		
		def questionMarkEntered(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "Question Mark Entered.")
		    return 0
		
		
		def f1pressedFunct(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "F1 pressed.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetF1Function(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when F1 key is pressed in the BCLineEdit.
	NOTE: If BCLineEditSetQuestionMarkFunction() is not set, when pressing question mark (?) the function funct will be called.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_F1_FUNCTION for details.
		integer BC_LINEEDIT_F1_FUNCTION(le, data)
		The function to be called when F1 key is pressed in BCLineEdit le.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetQuestionMarkFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetF3Function(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when F3 key is pressed in the BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_F3_FUNCTION for details.
		integer BC_LINEEDIT_F3_FUNCTION(le, data)
		The function to be called when F3 key is pressed in BCLineEdit le.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly
		but with the use of a timer (BCTimerSingleShot). If you are not sure how to do it, please contact GUI Dept for more details.
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetQuestionMarkFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetTextChangeFunction(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the text changes in the BCLineEdit.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_TEXT_CHANGED_FUNCTION for details.
		integer BC_LINEEDIT_TEXT_CHANGED_FUNCTION(le, text, data)
		The function to be called when the text changes in the BCLineEdit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * text : str
		                    the current text in the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		a pointer to any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the text of line edit. This is the selected text."
		    )
		    checkBox = guitk.BCCheckBoxCreate(boxLayout, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, selectAllFunct, lineEdit)
		    guitk.BCToolButtonCreate(
		        window, "", "Insert Auto-Text", confirmNewTextFunct, lineEdit
		    )
		    guitk.BCLineEditSetTextChangeFunction(
		        lineEdit, textChangedFunct, guitk.BCLineEditGetText(lineEdit)
		    )
		    guitk.BCLineEditSetSelectionChangedFunction(lineEdit, selectionChangedFunct, None)
		    guitk.BCLineEditSetSelection(lineEdit, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def confirmNewTextFunct(tb, lineEdit):
		    new_text = "This is the new text! "
		    guitk.BCLineEditInsertText(lineEdit, new_text)
		    return 0
		
		
		def selectAllFunct(checkBox, state, lineEdit):
		    if state:
		        print("Select all activated.")
		        guitk.BCLineEditSelectAll(lineEdit)
		    else:
		        print("Select all deactivated.")
		        guitk.BCLineEditSetSelection(lineEdit, 0, 0)
		    return 0
		
		
		def textChangedFunct(lineEdit, text, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Previous text: " + data)
		    print("Text changed to: " + text)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(lineEdit, data):
		    print("Currently selected text: " + guitk.BCLineEditGetSelectedText(lineEdit))
		    print("Whole text: " + guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetSelectionChangedFunction(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the selection changes in the BCLineEdit.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_SELECTION_CHANGED_FUNCTION for details.
		integer BC_LINEEDIT_SELECTION_CHANGED_FUNCTION(le, data)
		The function to be called when selected text inside a BCLineEdit changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetSelection

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the text of line edit. This is the selected text."
		    )
		    checkBox = guitk.BCCheckBoxCreate(boxLayout, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, selectAllFunct, lineEdit)
		    guitk.BCToolButtonCreate(
		        window, "", "Insert Auto-Text", confirmNewTextFunct, lineEdit
		    )
		    guitk.BCLineEditSetTextChangeFunction(
		        lineEdit, textChangedFunct, guitk.BCLineEditGetText(lineEdit)
		    )
		    guitk.BCLineEditSetSelectionChangedFunction(lineEdit, selectionChangedFunct, None)
		    guitk.BCLineEditSetSelection(lineEdit, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def confirmNewTextFunct(tb, lineEdit):
		    new_text = "This is the new text! "
		    guitk.BCLineEditInsertText(lineEdit, new_text)
		    return 0
		
		
		def selectAllFunct(checkBox, state, lineEdit):
		    if state:
		        print("Select all activated.")
		        guitk.BCLineEditSelectAll(lineEdit)
		    else:
		        print("Select all deactivated.")
		        guitk.BCLineEditSetSelection(lineEdit, 0, 0)
		    return 0
		
		
		def textChangedFunct(lineEdit, text, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Previous text: " + data)
		    print("Text changed to: " + text)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(lineEdit, data):
		    print("Currently selected text: " + guitk.BCLineEditGetSelectedText(lineEdit))
		    print("Whole text: " + guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetEnterPressedFunction(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when enter is pressed inside le.
	If this function returns 1, the default behaviour is completely overridden.
	This means that if you return 0, the accept function of the window that le belongs, will operate (window may close). If you return 1, the accept will NOT operate and it seems like you pressed a regular key inside line edit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function that will be called when enter is pressed. See BC_LINEEDIT_ENTER_PRESSED_FUNCTION for details.
		integer BC_LINEEDIT_ENTER_PRESSED_FUNCTION(le, data)
		The function to be called when enter/return key is pressed inside BCLineEdit le.
		If you return 0, the accept function of the window that le belongs, will
		operate (window may close). If you return 1, the accept will NOT operate and
		it seems like you pressed any regular key inside line edit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 0 if you want accept function of window to operate, otherwise return 1.

	data : Any, optional
		any user data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetMinMaxLimitInt(le: object, minVal: int, maxVal: int) -> None:

	"""

	Sets the minimum and maximum integer values allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	minVal : int
		the minimum value.

	maxVal : int
		the maximum value.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Int Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Int LineEdit")
		    lineEdit = guitk.BCLineEditCreateInt(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorInt)
		    guitk.BCLineEditSetInt(lineEdit, 123)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1005)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1, 4999)", None, None)
		    cbNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorInt:
		        print("Wrong type of validator.")
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6)":
		            guitk.BCLineEditSetMinLimitInt(lineEdit, 6)
		        elif buttonText == "Max (1005)":
		            guitk.BCLineEditSetMaxLimitInt(lineEdit, 1005)
		        elif buttonText == "Both (1, 4999)":
		            guitk.BCLineEditSetMinMaxLimitInt(lineEdit, 1, 4999)
		        else:
		            guitk.BCLineEditSetMinMaxLimitInt(lineEdit, -2147483648, 2147483647)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetMinMaxLimitDouble(le: object, minVal: float, maxVal: float) -> None:

	"""

	Sets the minimum and maximum double values allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	minVal : float
		the minimum value.

	maxVal : float
		the maximum value.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetMinMaxLimitInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSelectAll(le: object) -> None:

	"""

	Select all content of BCLineEdit widget.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the text of line edit. This is the selected text."
		    )
		    checkBox = guitk.BCCheckBoxCreate(boxLayout, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, selectAllFunct, lineEdit)
		    guitk.BCToolButtonCreate(
		        window, "", "Insert Auto-Text", confirmNewTextFunct, lineEdit
		    )
		    guitk.BCLineEditSetTextChangeFunction(
		        lineEdit, textChangedFunct, guitk.BCLineEditGetText(lineEdit)
		    )
		    guitk.BCLineEditSetSelectionChangedFunction(lineEdit, selectionChangedFunct, None)
		    guitk.BCLineEditSetSelection(lineEdit, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def confirmNewTextFunct(tb, lineEdit):
		    new_text = "This is the new text! "
		    guitk.BCLineEditInsertText(lineEdit, new_text)
		    return 0
		
		
		def selectAllFunct(checkBox, state, lineEdit):
		    if state:
		        print("Select all activated.")
		        guitk.BCLineEditSelectAll(lineEdit)
		    else:
		        print("Select all deactivated.")
		        guitk.BCLineEditSetSelection(lineEdit, 0, 0)
		    return 0
		
		
		def textChangedFunct(lineEdit, text, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Previous text: " + data)
		    print("Text changed to: " + text)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(lineEdit, data):
		    print("Currently selected text: " + guitk.BCLineEditGetSelectedText(lineEdit))
		    print("Whole text: " + guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditTakeKeyboard(le: object) -> None:

	"""

	Take all the keyboard events from the drawing area and send them to BCLineEdit le.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	None

	"""

def BCLineEditSetFixedWidth(le: object, numChars: int) -> None:

	"""

	Function is obsolete. Use BCLineEditSetFixedNumCharWidth() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	numChars : int
		the number of characters.

	Returns
	-------
	None

	"""

def BCLineEditSetMinimumWidth(le: object, s: int) -> None:

	"""

	Sets the minimum width of BCLineEdit le according to s.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	s : int
		the minimum width for le. See BCEnumSize for details.
		
		guitk.constants BCEnumSize
		This enum type is used to define the size (minimum/fixed/maximum) of a widget, depending on the function, measured in number of characters.
		 - guitk.constants.BCSizeAuto
		the widget's size depends on its contents.
		 - guitk.constants.BCSizeSmall
		sets the widget's size to small.
		 - guitk.constants.BCSizeMedium
		sets the widget's size to medium.
		 - guitk.constants.BCSizeLarge
		sets the widget's size to large.
		 - guitk.constants.BCSizeExtraLarge
		sets the widget's size to extra large.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetFixedNumCharWidth

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "Press Enter Key, Question Mark (?) Key or F1 key"
		    )
		    guitk.BCLineEditSetQuestionMarkFunction(lineEdit, questionMarkEntered, None)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, enterPressed, None)
		    guitk.BCLineEditSetF1Function(lineEdit, f1pressedFunct, None)
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, editingFinishedFunction, None)
		    guitk.BCLineEditSetFixedNumCharWidth(lineEdit, 50)
		    guitk.BCLineEditSetMinimumWidth(lineEdit, guitk.constants.BCSizeSmall)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def editingFinishedFunction(lineEdit, data):
		    print("Enter pressed. editingFinishedFunction() called after.")
		    guitk.BCLineEditSetText(lineEdit, "Editing Finished.")
		    return 0
		
		
		def enterPressed(lineEdit, data):
		    print("Enter pressed. enterPressed() called first.")
		    guitk.BCLineEditSetText(lineEdit, "Enter Pressed.")
		    return 0
		
		
		def questionMarkEntered(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "Question Mark Entered.")
		    return 0
		
		
		def f1pressedFunct(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "F1 pressed.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetReadOnly(le: object, readOnly: bool) -> None:

	"""

	Makes BCLineEdit le readonly (i.e. if input by the user is allowed).

	Parameters
	----------
	le : object
		the BCLineEdit that will be affected.

	readOnly : bool
		set this parameter to True to make le readonly.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetValidator(le: object, v: int) -> None:

	"""

	Set the validator for BCLineEdit le to v.
	Validators are used in order to check if the input text is valid according to them.
	
	 There are two kinds of validators: BCValidatorInt for integer values and BCValidatorDouble for double values. Even if a validator
	is set, you can write anything you want in the BCLineEdit as if there was no validator at all! You can check whether or not
	the input text is valid by calling BCLineEditValidate() or BCLineEditApplyValidator().
	WARNING: This function also clears the text of le!
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	v : int
		the validator type. See BCEnumValidatorType for details.
		
		guitk.constants BCEnumValidatorType
		This enum type defines the types of valid input. It can be used with BCLineEditSetValidator for example.
		 - guitk.constants.BCValidatorNone
		free text input.
		 - guitk.constants.BCValidatorInt
		only integer values are permitted.
		 - guitk.constants.BCValidatorDouble
		double/float values are permitted.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditGetValidator

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditGetValidator(le: object) -> int:

	"""

	Returns the validator type of BCLineEdit le.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	int
		the validator type of the BCLineEdit. See BCEnumValidatorType for details.
		BCEnumValidatorType: This enum type defines the types of valid input. It can be used with BCLineEditSetValidator for example.
		guitk.constants.BCValidatorNone: free text input.
		guitk.constants.BCValidatorInt: only integer values are permitted.
		guitk.constants.BCValidatorDouble: double/float values are permitted.

	See Also
	--------
	BCLineEditSetValidator

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetMinLimitInt(le: object, minVal: int) -> None:

	"""

	Sets the minimum integer value allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	minVal : int
		the minimum value.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Int Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Int LineEdit")
		    lineEdit = guitk.BCLineEditCreateInt(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorInt)
		    guitk.BCLineEditSetInt(lineEdit, 123)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1005)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6)", None, None)
		    cBoxMinmax = guitk.BCRadioButtonCreate(btnGroup, "Both (1, 4999)", None, None)
		    cbNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorInt:
		        print("Wrong type of validator.")
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6)":
		            guitk.BCLineEditSetMinLimitInt(lineEdit, 6)
		        elif buttonText == "Max (1005)":
		            guitk.BCLineEditSetMaxLimitInt(lineEdit, 1005)
		        elif buttonText == "Both (1, 4999)":
		            guitk.BCLineEditSetMinMaxLimitInt(lineEdit, 1, 4999)
		        else:
		            guitk.BCLineEditSetMinMaxLimitInt(lineEdit, -2147483648, 2147483647)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetMaxLimitInt(le: object, maxVal: int) -> None:

	"""

	Sets the maximum integer value allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	maxVal : int
		the maximum value.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Integer LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateInt if user wants to have an empty-valid initial int LineEdit
		    intLineEdit = guitk.BCLineEditCreateInt(hl, guitk.constants.blank)
		
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, intenterpressedFunction, None)
		    intlineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        intlineeditHL, "", "Validate", validateFunction, intLineEdit
		    )
		
		    maximumintCB = guitk.BCCheckBoxCreate(intlineeditHL, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(maximumintCB, maximumintFunction, intLineEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def intenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetMinLimitDouble(le: object, minVal: float) -> None:

	"""

	Sets the minimum double value allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	minVal : float
		the minimum value.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetMaxLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetMaxLimitDouble(le: object, maxVal: float) -> None:

	"""

	Sets the maximum double value allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	maxVal : float
		the maximum value.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetMinLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Double LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateDouble if user wants to have an empty-valid initial double LineEdit
		    doubleLineEdit = guitk.BCLineEditCreateDouble(hl, guitk.constants.blank)
		    guitk.BCLineEditSetDecimals(doubleLineEdit, 2)
		
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, doubleenterpressedFunction, None
		    )
		    doublelineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        doublelineeditHL, "", "Validate", validateFunction, doubleLineEdit
		    )
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(doublelineeditHL, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleLineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 92.1
		    else:
		        maxvalue = 1000000.0
		    guitk.BCLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def doubleenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetExtentionsFilter(le: object, extensions: object) -> None:

	"""

	Sets what file types to be shown when tab is pressed (i.e. auto completion) into BCLineEdit le.
	If you need to clear the filter, just recall this function passing extensions with None.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	extensions : object
		a list of strings with which auto completion will be filtered.

	Returns
	-------
	None

	"""

def BCLineEditSetCursorPosition(le: object, pos: int) -> None:

	"""

	Sets the current cursor position for BCLineEdit le.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	pos : int
		the position in the BCLineEdit to set the cursor.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditGetCursorPosition

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the current text of LineEdit."
		    )
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Write something here.")
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_left_16.png",
		        "Move Cursor Left",
		        moveCursorLeftFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_right_16.png",
		        "Move Cursor Right",
		        moveCursorRightFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "info_small.svg",
		        "Get info(Holder) as text",
		        getInfoFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns, "clean_small.svg", "Clean LineEdit", clearFunction, lineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, lineEdit):
		    if guitk.BCLineEditHasText(lineEdit):
		        print("Has text and will be cleared.")
		        guitk.BCLineEditClear(lineEdit)
		    return 0
		
		
		def getInfoFunction(toolBtn, lineEdit):
		    # Must set placeholder text first. Using guitk.BCLineEditSetPlaceholderText()
		    infoTxt = guitk.BCLineEditGetPlaceholderText(lineEdit)
		    if not infoTxt == None:
		        guitk.BCLineEditSetText(lineEdit, infoTxt)
		    else:
		        guitk.BCLineEditSetText(lineEdit, "No info set.")
		    return 0
		
		
		def moveCursorRightFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) + 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) - 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditGetCursorPosition(le: object) -> int:

	"""

	Returns the current cursor position in BCLineEdit le.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	int
		the current cursor position.

	See Also
	--------
	BCLineEditSetCursorPosition

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the current text of LineEdit."
		    )
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Write something here.")
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_left_16.png",
		        "Move Cursor Left",
		        moveCursorLeftFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_right_16.png",
		        "Move Cursor Right",
		        moveCursorRightFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "info_small.svg",
		        "Get info(Holder) as text",
		        getInfoFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns, "clean_small.svg", "Clean LineEdit", clearFunction, lineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, lineEdit):
		    if guitk.BCLineEditHasText(lineEdit):
		        print("Has text and will be cleared.")
		        guitk.BCLineEditClear(lineEdit)
		    return 0
		
		
		def getInfoFunction(toolBtn, lineEdit):
		    # Must set placeholder text first. Using guitk.BCLineEditSetPlaceholderText()
		    infoTxt = guitk.BCLineEditGetPlaceholderText(lineEdit)
		    if not infoTxt == None:
		        guitk.BCLineEditSetText(lineEdit, infoTxt)
		    else:
		        guitk.BCLineEditSetText(lineEdit, "No info set.")
		    return 0
		
		
		def moveCursorRightFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) + 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) - 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetSelection(le: object, start: int, length: int) -> None:

	"""

	Selects text from position start and for length characters.

	Parameters
	----------
	le : object
		the BCLineEdit.

	start : int
		the starting position.

	length : int
		the length of the text to be selected.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetSelectionChangedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the text of line edit. This is the selected text."
		    )
		    checkBox = guitk.BCCheckBoxCreate(boxLayout, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, selectAllFunct, lineEdit)
		    guitk.BCToolButtonCreate(
		        window, "", "Insert Auto-Text", confirmNewTextFunct, lineEdit
		    )
		    guitk.BCLineEditSetTextChangeFunction(
		        lineEdit, textChangedFunct, guitk.BCLineEditGetText(lineEdit)
		    )
		    guitk.BCLineEditSetSelectionChangedFunction(lineEdit, selectionChangedFunct, None)
		    guitk.BCLineEditSetSelection(lineEdit, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def confirmNewTextFunct(tb, lineEdit):
		    new_text = "This is the new text! "
		    guitk.BCLineEditInsertText(lineEdit, new_text)
		    return 0
		
		
		def selectAllFunct(checkBox, state, lineEdit):
		    if state:
		        print("Select all activated.")
		        guitk.BCLineEditSelectAll(lineEdit)
		    else:
		        print("Select all deactivated.")
		        guitk.BCLineEditSetSelection(lineEdit, 0, 0)
		    return 0
		
		
		def textChangedFunct(lineEdit, text, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Previous text: " + data)
		    print("Text changed to: " + text)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(lineEdit, data):
		    print("Currently selected text: " + guitk.BCLineEditGetSelectedText(lineEdit))
		    print("Whole text: " + guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetMaxLength(le: object, length: int) -> None:

	"""

	Sets the maximum permitted length of the text.
	If the text is too long, it is truncated to the limit. If truncation occurs any selected text will be
	unselected, the cursor position is set to 0 and the first part of the string is shown.
	NOTE: The length set by length it is meant the number of any character. So, in case your line edit
	is of type float/double, keep in mind that every character is counted, this is the dot, the 'E' character
	etc, and not only the number of digits or decimals. If the number you want to set has number of
	characters greater than length, then your number will be truncated. In case of float/double line edit
	the characters to be removed will be the decimals. In any other case the result will be text having removed
	the last characters just to fit length.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	length : int
		the maximum permitted length of the text.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditMaxLength

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(boxLayout, "This is an example for LineEdit.")
		    cBoxMax = guitk.BCCheckBoxCreate(boxLayout, "Set Max Length to 20 characters")
		    guitk.BCCheckBoxSetToggledFunction(cBoxMax, setMaxFunct, lineEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def setMaxFunct(checkBox, state, lineEdit):
		    if state:
		        guitk.BCLineEditSetMaxLength(lineEdit, 20)
		    else:
		        guitk.BCLineEditSetMaxLength(lineEdit, 32767)
		    print(
		        "Maximum permitted content's length: "
		        + str(guitk.BCLineEditMaxLength(lineEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditMaxLength(le: object) -> int:

	"""

	Returns the maximum permitted length of the text.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	int
		the maximum permitted length of the text.

	See Also
	--------
	BCLineEditSetMaxLength

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(boxLayout, "This is an example for LineEdit.")
		    cBoxMax = guitk.BCCheckBoxCreate(boxLayout, "Set Max Length to 20 characters")
		    guitk.BCCheckBoxSetToggledFunction(cBoxMax, setMaxFunct, lineEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def setMaxFunct(checkBox, state, lineEdit):
		    if state:
		        guitk.BCLineEditSetMaxLength(lineEdit, 20)
		    else:
		        guitk.BCLineEditSetMaxLength(lineEdit, 32767)
		    print(
		        "Maximum permitted content's length: "
		        + str(guitk.BCLineEditMaxLength(lineEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditClear(le: object) -> None:

	"""

	Clears the contents of the BCLineEdit.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the current text of LineEdit."
		    )
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Write something here.")
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_left_16.png",
		        "Move Cursor Left",
		        moveCursorLeftFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_right_16.png",
		        "Move Cursor Right",
		        moveCursorRightFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "info_small.svg",
		        "Get info(Holder) as text",
		        getInfoFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns, "clean_small.svg", "Clean LineEdit", clearFunction, lineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, lineEdit):
		    if guitk.BCLineEditHasText(lineEdit):
		        print("Has text and will be cleared.")
		        guitk.BCLineEditClear(lineEdit)
		    return 0
		
		
		def getInfoFunction(toolBtn, lineEdit):
		    # Must set placeholder text first. Using guitk.BCLineEditSetPlaceholderText()
		    infoTxt = guitk.BCLineEditGetPlaceholderText(lineEdit)
		    if not infoTxt == None:
		        guitk.BCLineEditSetText(lineEdit, infoTxt)
		    else:
		        guitk.BCLineEditSetText(lineEdit, "No info set.")
		    return 0
		
		
		def moveCursorRightFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) + 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) - 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetAlignment(le: object, alignment: int) -> None:

	"""

	Sets the alignment of the text inside BCLineEdit.
	By definition, numbers are aligned right while texts are aligned left. Use this function if you want for example to design a BCLineEdit that accepts %, or characters for calculations and you want to align the text right to show that this is number.

	Parameters
	----------
	le : object
		the BCLineEdit.

	alignment : int
		specifies the required alignment. See BCEnumAlignment for details.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditValidate(le: object) -> bool:

	"""

	Validates the input of BCLineEdit le about minimum and maximum value.
	le is validated if it is created with BCLineEditCreateInt()  or BCLineEditCreateDouble(); otherwise returns False.
	NOTE: This function does not alter any text. It only does a check against le's validator.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	bool
		True if the value entered is a valid value, i.e., between minimum and maximum values (if any). In case a value is not valid or le accepts any text, this function returns False.

	See Also
	--------
	BCLineEditApplyValidator

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Integer LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Integer LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateInt if user wants to have an empty-valid initial int LineEdit
		    intLineEdit = guitk.BCLineEditCreateInt(hl, guitk.constants.blank)
		
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, intenterpressedFunction, None)
		    intlineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        intlineeditHL, "", "Validate", validateFunction, intLineEdit
		    )
		
		    maximumintCB = guitk.BCCheckBoxCreate(intlineeditHL, "Max Int")
		    guitk.BCCheckBoxSetToggledFunction(maximumintCB, maximumintFunction, intLineEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumintFunction(cb, state, data):
		    if state:
		        maxvalue = 100
		    else:
		        maxvalue = 1000000
		    guitk.BCLineEditSetMaxLimitInt(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def intenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetInt(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditMaxLimitDouble(le: object) -> float:

	"""

	Returns the maximum double value allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	float
		the maximum double value allowed in a BCLineEdit.

	See Also
	--------
	BCLineEditMinLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditMinLimitDouble(le: object) -> float:

	"""

	Returns the minimum double value allowed in a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	float
		the minimum double value allowed in a BCLineEdit.

	See Also
	--------
	BCLineEditMaxLimitDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetDecimals(le: object, numDecimals: int) -> None:

	"""

	Sets the number of decimal digits to validate in a BCLineEdit which accepts only floats or doubles.
	NOTE: The user must call BCLineEditApplyValidator() in order to apply the validator and effectively see
	the number of decimals set by this function.
	WARNING: The value set by this function will affect the number of digits that can be shown into a BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	numDecimals : int
		the number of decimal digits to validate.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditDecimals

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Double LineEdit", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Double LineEdit")
		
		    # "guitk.constants.blank" initialize value is used in LineEditCreateDouble if user wants to have an empty-valid initial double LineEdit
		    doubleLineEdit = guitk.BCLineEditCreateDouble(hl, guitk.constants.blank)
		    guitk.BCLineEditSetDecimals(doubleLineEdit, 2)
		
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, doubleenterpressedFunction, None
		    )
		    doublelineeditHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    validateTB = guitk.BCToolButtonCreate(
		        doublelineeditHL, "", "Validate", validateFunction, doubleLineEdit
		    )
		
		    maximumdoubleCB = guitk.BCCheckBoxCreate(doublelineeditHL, "Max Double")
		    guitk.BCCheckBoxSetToggledFunction(
		        maximumdoubleCB, maximumdoubleFunction, doubleLineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def maximumdoubleFunction(cb, state, data):
		    if state:
		        maxvalue = 92.1
		    else:
		        maxvalue = 1000000.0
		    guitk.BCLineEditSetMaxLimitDouble(data, maxvalue)
		    print("Maximum Value is: " + str(maxvalue))
		    return 0
		
		
		def doubleenterpressedFunction(le, data):
		    if guitk.BCLineEditValidate(le):
		        print("Current value is: " + str(guitk.BCLineEditGetDouble(le)))
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def validateFunction(tb, data):
		    if guitk.BCLineEditValidate(data):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditDecimals(le: object) -> int:

	"""

	Returns the number of decimal digits to validate in a BCLineEdit which accepts only floats or doubles.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	int
		the number of decimal digits to validate if BCLineEdit accepts doubles or floats; -1 in case BCLineEdit accepts any text or integers.

	See Also
	--------
	BCLineEditSetDecimals

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditApplyValidator(le: object) -> None:

	"""

	Applies the validator (if any) of BCLineEdit le.
	This function validates the text of le and, if necessary, alters it according to the validator previously set.
	If no validator has been set to le (i.e. le has been created with function BCLineEditCreate and
	BCLineEditSetValidator has not been called for le ), this function has no effect.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetDecimals

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Double Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "Double LineEdit")
		    lineEdit = guitk.BCLineEditCreateDouble(boxLayout, 0)
		    guitk.BCLineEditSetValidator(lineEdit, guitk.constants.BCValidatorDouble)
		    guitk.BCLineEditSetDouble(lineEdit, 32.24)
		    guitk.BCLineEditSetDecimals(lineEdit, 2)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, validateFunction, None)
		
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Select Limit(s)", guitk.constants.BCVertical
		    )
		    cBoxMax = guitk.BCRadioButtonCreate(btnGroup, "Max (1004.73)", None, None)
		    cBoxMin = guitk.BCRadioButtonCreate(btnGroup, "Min (6.5)", None, None)
		    cBoxMinMax = guitk.BCRadioButtonCreate(btnGroup, "Both (1.23, 456.7)", None, None)
		    cBoxNone = guitk.BCRadioButtonCreate(btnGroup, "None", None, None)
		    guitk.BCButtonGroupSetClickedFunction(btnGroup, limitsFunction, lineEdit)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def validateFunction(lineEdit, data):
		    if not guitk.BCLineEditGetValidator(lineEdit) == guitk.constants.BCValidatorDouble:
		        print("Wrong type of validator.")
		    dec = guitk.BCLineEditDecimals(lineEdit)
		    print("The number of decimal digits to validate is: " + str(dec))
		    if guitk.BCLineEditValidate(lineEdit):
		        print("Value is valid!")
		    else:
		        print("Value is invalid!")
		    guitk.BCLineEditApplyValidator(lineEdit)
		    return 0
		
		
		def limitsFunction(btnGroup, index, lineEdit):
		    button = guitk.BCButtonGroupFind(btnGroup, index)
		    buttonText = guitk.BCRadioButtonText(button)
		    if guitk.BCButtonGroupGetSelectedId(btnGroup) == index:
		        if buttonText == "Min (6.5)":
		            guitk.BCLineEditSetMinLimitDouble(lineEdit, 6.5)
		        elif buttonText == "Max (1004.73)":
		            guitk.BCLineEditSetMaxLimitDouble(lineEdit, 1004.73)
		        elif buttonText == "Both (1.23, 456.7)":
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, 1.23, 456.7)
		        else:
		            guitk.BCLineEditSetMinMaxLimitDouble(lineEdit, float("-inf"), float("inf"))
		    currentMax = guitk.BCLineEditMaxLimitDouble(lineEdit)
		    currentMin = guitk.BCLineEditMinLimitDouble(lineEdit)
		    print("New limits, min: " + str(currentMin) + " Current max: " + str(currentMax))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditInsertText(le: object, text: str) -> None:

	"""

	Deletes any selected text, inserts text in cursor's point.
	
	It also validates the result. If it is valid, it sets it as the new content of the BCLineEdit.

	Parameters
	----------
	le : object
		the BCLineEdit.

	text : str
		the inserted text.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the text of line edit. This is the selected text."
		    )
		    checkBox = guitk.BCCheckBoxCreate(boxLayout, "Select All")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, selectAllFunct, lineEdit)
		    guitk.BCToolButtonCreate(
		        window, "", "Insert Auto-Text", confirmNewTextFunct, lineEdit
		    )
		    guitk.BCLineEditSetTextChangeFunction(
		        lineEdit, textChangedFunct, guitk.BCLineEditGetText(lineEdit)
		    )
		    guitk.BCLineEditSetSelectionChangedFunction(lineEdit, selectionChangedFunct, None)
		    guitk.BCLineEditSetSelection(lineEdit, 31, 26)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def confirmNewTextFunct(tb, lineEdit):
		    new_text = "This is the new text! "
		    guitk.BCLineEditInsertText(lineEdit, new_text)
		    return 0
		
		
		def selectAllFunct(checkBox, state, lineEdit):
		    if state:
		        print("Select all activated.")
		        guitk.BCLineEditSelectAll(lineEdit)
		    else:
		        print("Select all deactivated.")
		        guitk.BCLineEditSetSelection(lineEdit, 0, 0)
		    return 0
		
		
		def textChangedFunct(lineEdit, text, data):
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    print("Previous text: " + data)
		    print("Text changed to: " + text)
		    print(
		        "--------------------------------------------------------------------------------------------------"
		    )
		    return 0
		
		
		def selectionChangedFunct(lineEdit, data):
		    print("Currently selected text: " + guitk.BCLineEditGetSelectedText(lineEdit))
		    print("Whole text: " + guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetAddItemsToPopupMenu(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Adds custom menu items or sub-popups above the default menu items of BCLineEdit's right-mouse-click popup.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the callback function which must be called to create the custom menu.
		See BC_LINEEDIT_ADD_ITEMS_TO_POPUPMENU_FUNCTION for details.
		integer BC_LINEEDIT_ADD_ITEMS_TO_POPUPMENU_FUNCTION(le, popup, data)
		The function to add items to the popup on a right mouse click over the le BCLineEdit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * popup : object
		                    the BCLineEdit's BCMenu with the default menu items to which you want to add extra items.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Mode/State Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "Right-click inside LineEdit to change Mode or State."
		    )
		    popup = guitk.BCPopupMenuCreate(window)
		    guitk.BCLineEditSetAddItemsToPopupMenu(lineEdit, createPopup, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def echoModeFunction(popupMenu, id, lineEdit):
		    if id == 0:
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCNormalEchoMode)
		    elif id == 1:
		        # The text is still there, cursor moved at lineEditft. Moving back to normal mode will make it appear again.
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCNoEchoMode)
		    elif id == 2:
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCPasswordMode)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		def echoStateFunction(popupMenu, id, lineEdit):
		    guitk.BCLineEditSetReadOnly(lineEdit, False)
		    # All states forced to change colors
		    if id == 0:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateNone, 1)
		    elif id == 1:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateInformation, 1)
		    elif id == 2:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateWarning, 1)
		    elif id == 3:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateError, 1)
		    elif id == 4:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateReadOnly, 1)
		        # Set BCLineEdit to read-only mode, too.
		        guitk.BCLineEditSetReadOnly(lineEdit, True)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		def createPopup(lineEdit, popup, data):
		    guitk.BCPopupMenuInsertSeparator(popup)
		    submenuMode = guitk.BCPopupMenuCreate(popup)
		    popupItemNormal = guitk.BCPopupMenuInsertItem(
		        submenuMode, "Normal Mode", echoModeFunction, lineEdit
		    )
		    popupItemNoEcho = guitk.BCPopupMenuInsertItem(
		        submenuMode, "No Echo Mode", echoModeFunction, lineEdit
		    )
		    popupItemPass = guitk.BCPopupMenuInsertItem(
		        submenuMode, "Password Mode", echoModeFunction, lineEdit
		    )
		    submenuState = guitk.BCPopupMenuCreate(popup)
		    popupItemNone = guitk.BCPopupMenuInsertItem(
		        submenuState, "None", echoStateFunction, lineEdit
		    )
		    popupItemInformation = guitk.BCPopupMenuInsertItem(
		        submenuState, "Information", echoStateFunction, lineEdit
		    )
		    popupItemWarning = guitk.BCPopupMenuInsertItem(
		        submenuState, "Warning", echoStateFunction, lineEdit
		    )
		    popupItemError = guitk.BCPopupMenuInsertItem(
		        submenuState, "Error", echoStateFunction, lineEdit
		    )
		    popupItemReadOnly = guitk.BCPopupMenuInsertItem(
		        submenuState, "Read Only", echoStateFunction, lineEdit
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Mode", submenuMode)
		    guitk.BCPopupMenuInsertPopupMenu(popup, "State", submenuState)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetInfo(le: object, info: str) -> None:

	"""

	Function is obsolete. Use BCLineEditSetPlaceholderText() instead.

	Parameters
	----------
	le : object
		the BCLineEdit.

	info : str
		the message.

	Returns
	-------
	None

	"""

def BCLineEditGetInfo(le: object) -> str:

	"""

	Function is obsolete. Use BCLineEditGetPlaceholderText() instead.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	str
		the text displayed as info.

	"""

def BCLineEditSetEchoMode(le: object, mode: int) -> None:

	"""

	Sets the line edit's echo mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	mode : int
		the echo mode for le. See BCEnumEchoMode for details.
		
		guitk.constants BCEnumEchoMode
		This enum type is used to indicate how the echo on lineedit will appear.
		 - guitk.constants.BCNormalEchoMode
		Display characters as they are entered.
		 - guitk.constants.BCNoEchoMode
		Do not display anything.
		 - guitk.constants.BCPasswordMode
		Display asterisks instead of the characters actually entered.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Mode/State Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "Right-click inside LineEdit to change Mode or State."
		    )
		    popup = guitk.BCPopupMenuCreate(window)
		    guitk.BCLineEditSetAddItemsToPopupMenu(lineEdit, createPopup, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def echoModeFunction(popupMenu, id, lineEdit):
		    if id == 0:
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCNormalEchoMode)
		    elif id == 1:
		        # The text is still there, cursor moved at lineEditft. Moving back to normal mode will make it appear again.
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCNoEchoMode)
		    elif id == 2:
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCPasswordMode)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		def echoStateFunction(popupMenu, id, lineEdit):
		    guitk.BCLineEditSetReadOnly(lineEdit, False)
		    # All states forced to change colors
		    if id == 0:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateNone, 1)
		    elif id == 1:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateInformation, 1)
		    elif id == 2:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateWarning, 1)
		    elif id == 3:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateError, 1)
		    elif id == 4:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateReadOnly, 1)
		        # Set BCLineEdit to read-only mode, too.
		        guitk.BCLineEditSetReadOnly(lineEdit, True)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		def createPopup(lineEdit, popup, data):
		    guitk.BCPopupMenuInsertSeparator(popup)
		    submenuMode = guitk.BCPopupMenuCreate(popup)
		    popupItemNormal = guitk.BCPopupMenuInsertItem(
		        submenuMode, "Normal Mode", echoModeFunction, lineEdit
		    )
		    popupItemNoEcho = guitk.BCPopupMenuInsertItem(
		        submenuMode, "No Echo Mode", echoModeFunction, lineEdit
		    )
		    popupItemPass = guitk.BCPopupMenuInsertItem(
		        submenuMode, "Password Mode", echoModeFunction, lineEdit
		    )
		    submenuState = guitk.BCPopupMenuCreate(popup)
		    popupItemNone = guitk.BCPopupMenuInsertItem(
		        submenuState, "None", echoStateFunction, lineEdit
		    )
		    popupItemInformation = guitk.BCPopupMenuInsertItem(
		        submenuState, "Information", echoStateFunction, lineEdit
		    )
		    popupItemWarning = guitk.BCPopupMenuInsertItem(
		        submenuState, "Warning", echoStateFunction, lineEdit
		    )
		    popupItemError = guitk.BCPopupMenuInsertItem(
		        submenuState, "Error", echoStateFunction, lineEdit
		    )
		    popupItemReadOnly = guitk.BCPopupMenuInsertItem(
		        submenuState, "Read Only", echoStateFunction, lineEdit
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Mode", submenuMode)
		    guitk.BCPopupMenuInsertPopupMenu(popup, "State", submenuState)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathCreate(p: object, type: int, initial: str, mode: int, name: str) -> object:

	"""

	Creates a BCLineEditPath, which is a BCFrame that contains an editable history BCComboBox, a "Browse" BCToolButton and a "Clear history" BCToolButton.
	The BCComboBox of the BCLineEditPath maximum number of recent paths is controlled by the "Maximum file paths" option in the options window. These paths will be available any time ANSA is used. The BCLineEditPath can be a "files", "folders" or "everything" type and it can be used with "open" or "save as" mode.
	The type and mode set for the created BCLineEditPath is used by the filemanager that will be called. This means that the filemanager may be of type "file/folder selection" and "Open/Save as".
	If you want to further customize a BCLineEditPath, you can get  all widgets (BCComboBox, file-dialog and clear-history BCToolButtons) and apply the desired BC function. For example if you want to hide the file-dialog button, use BCLineEditPathGetDialogButton() and apply BCHide() to the returned value.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	type : int
		the type of BCLineEditPath. See BCEnumLineEditPathType for details.
		
		guitk.constants BCEnumLineEditPathType
		This enumeration describes the type of BCLineEditPath.
		 - guitk.constants.BCHistoryFolders
		The BCLineEditPath will store folder names (full path)
		 - guitk.constants.BCHistoryFiles
		The BCLineEditPath will store file names (full path)
		 - guitk.constants.BCHistoryAnything
		The BCLineEditPath will store anything that has been typed after enter is pressed.

	initial : str
		an inital path. NOTE : It is not necessairy to pass an initial path. If an empty string is passed, then the current working directory is used. Also, note that if initial is set, this overrides any previous history paths. This means, everytime the window is shown, it will first show initial as path.

	mode : int
		the mode of BCLineEditPath. See BCEnumLineEditPathMode for details.
		
		guitk.constants BCEnumLineEditPathMode
		This enumeration describes the mode of the filemanager which will be called from a BCLineEditPath.
		 - guitk.constants.BCHistoryOpen
		The filemanager will open for reading a file or folder (depending on BCEnumLineEditPathType)
		 - guitk.constants.BCHistorySaveAs
		The filemanager will open for saving a file or folder (depending on BCEnumLineEditPathType)
		 - guitk.constants.BCHistorySelect
		The filemanager will open for selecting a file or folder (depending on BCEnumLineEditPathType)

	name : str
		the name of the BCLineEditPath which will be used as node into the xml.
		WARNING: Special care must be taken with name. If there's another BCLineEditPath with the same name, they will share the same paths!

	Returns
	-------
	object
		the newly created BCLineEditPath.

	See Also
	--------
	BCLineEditPathGetDialogButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit Path")
		    lep = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lep, guitk.constants.BCMulti)
		
		    guitk.BCLineEditPathSetDialogEnterEnabled(lep, True)
		    guitk.BCLineEditPathAddFilter(lep, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetEnterPressedFunction(lep, enterpressFunction, None)
		    guitk.BCLineEditPathSetFileDialogTitle(lep, "Select File Example")
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enterpressFunction(le, data):
		    print("Enter Pressed.")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathClearHistory(lip: object) -> None:

	"""

	Clears the history of BCLineEditPath lip.
	NOTE: History can also be cleared by getting the BCComboBox from lip and call
	BCComboBoxClear, but using this method does not assure you clear also the XML!
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathGetCombo

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    btnClearHistory = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Clear History", clearHistoryFunction, lineEditPath
		    )
		    btnRemoveOld = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Remove Oldest Entry", removeOEntryFunction, lineEditPath
		    )
		    btnRemoveNew = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Remove Newest Entry", removeNEntryFunction, lineEditPath
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearHistoryFunction(btn, lineEditPath):
		    guitk.BCLineEditPathClearHistory(lineEditPath)
		    print(
		        "Current text got from LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def removeOEntryFunction(btn, lineEditPath):
		    # Negative value to remove the oldest entry
		    isRemoved = guitk.BCLineEditPathRemoveEntry(lineEditPath, -1)
		    if isRemoved:
		        print("Removal succeded.")
		    else:
		        print("Removal failed.")
		    print(
		        "Current text shown in LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def removeNEntryFunction(btn, lineEditPath):
		    # Newest entry, index = 0
		    isRemoved = guitk.BCLineEditPathRemoveEntry(lineEditPath, 0)
		    if isRemoved:
		        print("Removal succeded.")
		    else:
		        print("Removal failed.")
		    print(
		        "Current text got from LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathGetCombo(lip: object) -> object:

	"""

	Returns the BCComboBox of BCLineEditPath lip.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	Returns
	-------
	object
		the combobox of the BCLineEditPath.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathAddFilter(lineEditPath, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    guitk.BCLineEditPathSetFileDialogModal(lineEditPath, False)
		    boxLayoutCheckBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    checkBox = guitk.BCCheckBoxCreate(boxLayoutCheckBox, "Disable BCLineEditPath")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, enableFunction, lineEditPath)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enableFunction(checkBox, state, lineEditPath):
		    combo = guitk.BCLineEditPathGetCombo(lineEditPath)
		    lineEdit = guitk.BCComboBoxGetLineEdit(combo)
		    path = guitk.BCLineEditPathGetLineEditPathFromLineEdit(lineEdit)
		    btnClear = guitk.BCLineEditPathGetClearButton(lineEditPath)
		    btnDialog = guitk.BCLineEditPathGetDialogButton(lineEditPath)
		    guitk.BCSetEnabled(path, not state)
		    guitk.BCSetEnabled(btnClear, not state)
		    guitk.BCSetEnabled(btnDialog, not state)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathGetDialogButton(lip: object) -> object:

	"""

	Returns the dialog button (i.e. the BCToolButton that opens the file-dialog window) of history-path BCFrame lip.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	Returns
	-------
	object
		the dialog button of the history-path BCFrame.

	See Also
	--------
	BCLineEditPathGetClearButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathAddFilter(lineEditPath, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    guitk.BCLineEditPathSetFileDialogModal(lineEditPath, False)
		    boxLayoutCheckBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    checkBox = guitk.BCCheckBoxCreate(boxLayoutCheckBox, "Disable BCLineEditPath")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, enableFunction, lineEditPath)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enableFunction(checkBox, state, lineEditPath):
		    combo = guitk.BCLineEditPathGetCombo(lineEditPath)
		    lineEdit = guitk.BCComboBoxGetLineEdit(combo)
		    path = guitk.BCLineEditPathGetLineEditPathFromLineEdit(lineEdit)
		    btnClear = guitk.BCLineEditPathGetClearButton(lineEditPath)
		    btnDialog = guitk.BCLineEditPathGetDialogButton(lineEditPath)
		    guitk.BCSetEnabled(path, not state)
		    guitk.BCSetEnabled(btnClear, not state)
		    guitk.BCSetEnabled(btnDialog, not state)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathGetClearButton(lip: object) -> object:

	"""

	Returns the clear button (i.e. the BCToolButton that clears the history) of history-box BCFrame lip.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	Returns
	-------
	object
		the clear button of the history-path BCFrame.

	See Also
	--------
	BCLineEditPathGetDialogButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathAddFilter(lineEditPath, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    guitk.BCLineEditPathSetFileDialogModal(lineEditPath, False)
		    boxLayoutCheckBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    checkBox = guitk.BCCheckBoxCreate(boxLayoutCheckBox, "Disable BCLineEditPath")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, enableFunction, lineEditPath)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enableFunction(checkBox, state, lineEditPath):
		    combo = guitk.BCLineEditPathGetCombo(lineEditPath)
		    lineEdit = guitk.BCComboBoxGetLineEdit(combo)
		    path = guitk.BCLineEditPathGetLineEditPathFromLineEdit(lineEdit)
		    btnClear = guitk.BCLineEditPathGetClearButton(lineEditPath)
		    btnDialog = guitk.BCLineEditPathGetDialogButton(lineEditPath)
		    guitk.BCSetEnabled(path, not state)
		    guitk.BCSetEnabled(btnClear, not state)
		    guitk.BCSetEnabled(btnDialog, not state)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathGetLineEditPathFromLineEdit(le: object) -> object:

	"""

	Returns the BCLineEditPath container of BCLineEdit le.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit found in BCLineEditPath.

	Returns
	-------
	object
		the BCLineEditPath container.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathAddFilter(lineEditPath, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    guitk.BCLineEditPathSetFileDialogModal(lineEditPath, False)
		    boxLayoutCheckBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    checkBox = guitk.BCCheckBoxCreate(boxLayoutCheckBox, "Disable BCLineEditPath")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, enableFunction, lineEditPath)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enableFunction(checkBox, state, lineEditPath):
		    combo = guitk.BCLineEditPathGetCombo(lineEditPath)
		    lineEdit = guitk.BCComboBoxGetLineEdit(combo)
		    path = guitk.BCLineEditPathGetLineEditPathFromLineEdit(lineEdit)
		    btnClear = guitk.BCLineEditPathGetClearButton(lineEditPath)
		    btnDialog = guitk.BCLineEditPathGetDialogButton(lineEditPath)
		    guitk.BCSetEnabled(path, not state)
		    guitk.BCSetEnabled(btnClear, not state)
		    guitk.BCSetEnabled(btnDialog, not state)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetDialogEnterEnabled(lip: object, enable: bool) -> None:

	"""

	This function enables/disables the property of calling the EnterPressedFunction. 
	The latter is automatically called right after a selection from the file dialog or from the combobox of history-box frame lip.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	enable : bool
		set this parameter to True to enable this feature; False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathSetEnterPressedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit Path")
		    lep = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lep, guitk.constants.BCMulti)
		
		    guitk.BCLineEditPathSetDialogEnterEnabled(lep, True)
		    guitk.BCLineEditPathAddFilter(lep, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetEnterPressedFunction(lep, enterpressFunction, None)
		    guitk.BCLineEditPathSetFileDialogTitle(lep, "Select File Example")
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enterpressFunction(le, data):
		    print("Enter Pressed.")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetEnterPressedFunction(lip: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when enter/return key is pressed inside the combobox of history-path window lip.
	NOTE: If funct returns 0, then the parent window of history-box BCFrame will be closed. If you don't want this, just return 1.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	funct : Callable
		the function to be called when enter/return key is pressed. See BC_LINEEDIT_ENTER_PRESSED_FUNCTION for details.
		integer BC_LINEEDIT_ENTER_PRESSED_FUNCTION(le, data)
		The function to be called when enter/return key is pressed inside BCLineEdit le.
		If you return 0, the accept function of the window that le belongs, will
		operate (window may close). If you return 1, the accept will NOT operate and
		it seems like you pressed any regular key inside line edit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 0 if you want accept function of window to operate, otherwise return 1.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathSetDialogEnterEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit Path")
		    lep = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lep, guitk.constants.BCMulti)
		
		    guitk.BCLineEditPathSetDialogEnterEnabled(lep, True)
		    guitk.BCLineEditPathAddFilter(lep, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetEnterPressedFunction(lep, enterpressFunction, None)
		    guitk.BCLineEditPathSetFileDialogTitle(lep, "Select File Example")
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enterpressFunction(le, data):
		    print("Enter Pressed.")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathAddFilter(lip: object, groupFilterName: str, extensions: object) -> None:

	"""

	Adds a filter in the file manager that is called after pressing the file manager button.
	In extensions you should pass only the extensions you're interested in without putting the prefix "*.". It'll
	be automatically prepended.
	In case you want to add a filter as is (i.e. without automatically prepend the "*." string), it must begin
	with two asterisks. The filter will result without the first asterisk. For example, if you want to add
	the filter "*", you must pass "**", or if you want to add the filter "*test*", you must pass "**test*". The
	groupFilterName is not affected.
	After inserting a new filter, the default filter "*.*" will be removed. So, in case you still want this filter,
	you should manually add it (pass in extensions the "*" string).
	NOTE: This function has no effect if the created BCLineEditPath is of directory type, either reading or
	writing.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	groupFilterName : str
		the name for the filter group.

	extensions : object
		the extensions to be used for group groupFilterName.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathSetFilter

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit Path")
		    lep = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lep, guitk.constants.BCMulti)
		
		    guitk.BCLineEditPathSetDialogEnterEnabled(lep, True)
		    guitk.BCLineEditPathAddFilter(lep, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetEnterPressedFunction(lep, enterpressFunction, None)
		    guitk.BCLineEditPathSetFileDialogTitle(lep, "Select File Example")
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enterpressFunction(le, data):
		    print("Enter Pressed.")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetFileDialogModal(lip: object, modal: bool) -> None:

	"""

	Sets whether the filemanager that should show from BCLineEditPath lip will be modal or modeless.
	WARNING: If lip's parent BCWindow is modal, then the filemanager will always be launched as modal, overriding this option!
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	modal : bool
		set this to True for a modal filedialog; False otherwise. The default value is True.

	Returns
	-------
	None

	See Also
	--------
	BCWindowSetModal

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathAddFilter(lineEditPath, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    guitk.BCLineEditPathSetFileDialogModal(lineEditPath, False)
		    boxLayoutCheckBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    checkBox = guitk.BCCheckBoxCreate(boxLayoutCheckBox, "Disable BCLineEditPath")
		    guitk.BCCheckBoxSetToggledFunction(checkBox, enableFunction, lineEditPath)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enableFunction(checkBox, state, lineEditPath):
		    combo = guitk.BCLineEditPathGetCombo(lineEditPath)
		    lineEdit = guitk.BCComboBoxGetLineEdit(combo)
		    path = guitk.BCLineEditPathGetLineEditPathFromLineEdit(lineEdit)
		    btnClear = guitk.BCLineEditPathGetClearButton(lineEditPath)
		    btnDialog = guitk.BCLineEditPathGetDialogButton(lineEditPath)
		    guitk.BCSetEnabled(path, not state)
		    guitk.BCSetEnabled(btnClear, not state)
		    guitk.BCSetEnabled(btnDialog, not state)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetFileDialogTitle(lip: object, title: str) -> None:

	"""

	Sets the title of the filemanager window.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	title : str
		The title of the filemanager window.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathSetFileDialogModal

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit Path")
		    lep = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lep, guitk.constants.BCMulti)
		
		    guitk.BCLineEditPathSetDialogEnterEnabled(lep, True)
		    guitk.BCLineEditPathAddFilter(lep, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetEnterPressedFunction(lep, enterpressFunction, None)
		    guitk.BCLineEditPathSetFileDialogTitle(lep, "Select File Example")
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enterpressFunction(le, data):
		    print("Enter Pressed.")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetSelectionMode(lip: object, mode: int) -> None:

	"""

	Sets the selection mode of the file manager which will be launched from lip.
	NOTE: If mode of lip is "save", this function has no effect.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	mode : int
		the selection mode of the file maanger. See BCEnumSelectionMode
		for details.
		
		guitk.constants BCEnumSelectionMode
		This enum type defines the selection mode. Selection is used with BCListViewSetSelectionMode for example.
		 - guitk.constants.BCMulti
		when the user selects an item in the usual way, the previous selection is cleared and the new item is selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. And if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item get selected or unselected, depending on the state of the clicked item. Also, multiple items can be selected by dragging the mouse over them.
		 - guitk.constants.BCSingle
		the user can select only one item. Any already-selected item becomes unselected.
		 - guitk.constants.BCNoSelection
		items cannot be selected.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit Path")
		    lep = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lep, guitk.constants.BCMulti)
		
		    guitk.BCLineEditPathSetDialogEnterEnabled(lep, True)
		    guitk.BCLineEditPathAddFilter(lep, "CPP", "**.cpp")
		    guitk.BCLineEditPathSetEnterPressedFunction(lep, enterpressFunction, None)
		    guitk.BCLineEditPathSetFileDialogTitle(lep, "Select File Example")
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def enterpressFunction(le, data):
		    print("Enter Pressed.")
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSelectedFilePaths(lip: object) -> str:

	"""

	Returns the selected files/paths from filemanager.
	If lip selection mode is set to BCMulti and more than one file/path is selected, the returned string
	is composed of all the selected files/paths, separated by a double-semicolon (";;").
	This function can be used only in the EnterPressedFunction and the DialogEnter must be enabled.
	NOTE: If an invalid file/path is written, after pressing Enter/Return, this function will return None.
	WARNING: The returned pointer is automatically freed by the bcgui mechanism. If you
	wish to keep a copy to the text, use strdup on this pointer.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	Returns
	-------
	str
		the selected files/paths.

	See Also
	--------
	BCLineEditPathSetDialogEnterEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(
		        lineEditPath, enterpressFunction, lineEditPath
		    )
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    # Note the difference in BCLineEditPath's history when using these functions
		    guitk.BCToolButtonCreate(
		        boxLayout, "", "Insert Entry", insertEntryFunction, lineEditPath
		    )
		    guitk.BCToolButtonCreate(
		        boxLayout, "", "Set LineEdit's Text", setTextFunction, lineEditPath
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def insertEntryFunction(btn, lineEditPath):
		    entry = "/testing/path/insertEntryToHistory"
		    isInserted = guitk.BCLineEditPathInsertEntry(lineEditPath, entry)
		    if isInserted:
		        print("Successful insertion.")
		    else:
		        print("Insertion failed.")
		    return 0
		
		
		def setTextFunction(btn, lineEditPath):
		    entry = "/testing/path/setLineEditText/noHistoryInsertion"
		    guitk.BCLineEditPathSetLineEditText(lineEditPath, entry)
		    return 0
		
		
		def enterpressFunction(le, lineEditPath):
		    print("Enter Pressed. ")
		    selected = guitk.BCLineEditPathSelectedFilePaths(lineEditPath)
		    if selected:
		        print("Selected Paths: " + selected)
		    else:
		        # This is true only when writing in LineEditPath manually and the input is empty
		        print("Aborded. Selected Paths: " + str(selected))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathInsertEntry(lip: object, entry: str) -> bool:

	"""

	Inserts entry entry into BCLineEditPath lip.
	The new entry will be successfully inserted only if is valid, i.e. same type/mode. If BCLineEditPathSetDialogEnterEnabled()
	is set to True, then the callback function will also be called after successful insertion.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath.

	entry : str
		the entry to insert.

	Returns
	-------
	bool
		True uppon successful insertion; False otherwise.

	See Also
	--------
	BCLineEditPathSetDialogEnterEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(
		        lineEditPath, enterpressFunction, lineEditPath
		    )
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    # Note the difference in BCLineEditPath's history when using these functions
		    guitk.BCToolButtonCreate(
		        boxLayout, "", "Insert Entry", insertEntryFunction, lineEditPath
		    )
		    guitk.BCToolButtonCreate(
		        boxLayout, "", "Set LineEdit's Text", setTextFunction, lineEditPath
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def insertEntryFunction(btn, lineEditPath):
		    entry = "/testing/path/insertEntryToHistory"
		    isInserted = guitk.BCLineEditPathInsertEntry(lineEditPath, entry)
		    if isInserted:
		        print("Successful insertion.")
		    else:
		        print("Insertion failed.")
		    return 0
		
		
		def setTextFunction(btn, lineEditPath):
		    entry = "/testing/path/setLineEditText/noHistoryInsertion"
		    guitk.BCLineEditPathSetLineEditText(lineEditPath, entry)
		    return 0
		
		
		def enterpressFunction(le, lineEditPath):
		    print("Enter Pressed. ")
		    selected = guitk.BCLineEditPathSelectedFilePaths(lineEditPath)
		    if selected:
		        print("Selected Paths: " + selected)
		    else:
		        # This is true only when writing in LineEditPath manually and the input is empty
		        print("Aborded. Selected Paths: " + str(selected))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathRemoveEntry(lip: object, index: int) -> bool:

	"""

	Removes from BCLineEditPath lip the entry at index index.
	If index is a negative number, the least recent item will be removed. If index is
	greater than lip's items or if lip is empty, this function has no effect and False will be returned.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath

	index : int
		the index of the entry to be removed

	Returns
	-------
	bool
		True uppon successful removal; False otherwise.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    btnClearHistory = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Clear History", clearHistoryFunction, lineEditPath
		    )
		    btnRemoveOld = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Remove Oldest Entry", removeOEntryFunction, lineEditPath
		    )
		    btnRemoveNew = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Remove Newest Entry", removeNEntryFunction, lineEditPath
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearHistoryFunction(btn, lineEditPath):
		    guitk.BCLineEditPathClearHistory(lineEditPath)
		    print(
		        "Current text got from LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def removeOEntryFunction(btn, lineEditPath):
		    # Negative value to remove the oldest entry
		    isRemoved = guitk.BCLineEditPathRemoveEntry(lineEditPath, -1)
		    if isRemoved:
		        print("Removal succeded.")
		    else:
		        print("Removal failed.")
		    print(
		        "Current text shown in LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def removeNEntryFunction(btn, lineEditPath):
		    # Newest entry, index = 0
		    isRemoved = guitk.BCLineEditPathRemoveEntry(lineEditPath, 0)
		    if isRemoved:
		        print("Removal succeded.")
		    else:
		        print("Removal failed.")
		    print(
		        "Current text got from LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetLineEditText(lip: object, txt: str) -> None:

	"""

	Sets the text of BCLineEditPath lip to txt.
	Unlike BCLineEditPathInsertEntry(), this function changes only the text of lip without inserting it into its history. This is
	useful in various cases where you don't want the current history to be set as the text of lip. For example, you may want
	an empty text to be set or even an invalid path/text because this function does not do any check on the validity of txt.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath

	txt : str
		the text to be set. Pass None or an empty text in order to show an empty space.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathInsertEntry

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetDialogEnterEnabled(lineEditPath, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(
		        lineEditPath, enterpressFunction, lineEditPath
		    )
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    # Note the difference in BCLineEditPath's history when using these functions
		    guitk.BCToolButtonCreate(
		        boxLayout, "", "Insert Entry", insertEntryFunction, lineEditPath
		    )
		    guitk.BCToolButtonCreate(
		        boxLayout, "", "Set LineEdit's Text", setTextFunction, lineEditPath
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def insertEntryFunction(btn, lineEditPath):
		    entry = "/testing/path/insertEntryToHistory"
		    isInserted = guitk.BCLineEditPathInsertEntry(lineEditPath, entry)
		    if isInserted:
		        print("Successful insertion.")
		    else:
		        print("Insertion failed.")
		    return 0
		
		
		def setTextFunction(btn, lineEditPath):
		    entry = "/testing/path/setLineEditText/noHistoryInsertion"
		    guitk.BCLineEditPathSetLineEditText(lineEditPath, entry)
		    return 0
		
		
		def enterpressFunction(le, lineEditPath):
		    print("Enter Pressed. ")
		    selected = guitk.BCLineEditPathSelectedFilePaths(lineEditPath)
		    if selected:
		        print("Selected Paths: " + selected)
		    else:
		        # This is true only when writing in LineEditPath manually and the input is empty
		        print("Aborded. Selected Paths: " + str(selected))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewCreate(p: object, numCols: int, colNames: object, sorting: bool) -> object:

	"""

	Creates a ListView inside parent p.
	In order to avoid performance issues, it is recommended that sorting is enabled after adding the items into the list.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	numCols : int
		the number of columns that this ListView is required to have.

	colNames : object
		the column header names.

	sorting : bool
		False to disable or True to enable sorting in first column (index 0).

	Returns
	-------
	object
		the created ListView.

	See Also
	--------
	BCListViewAddTopLevelItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Simple", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    # Start adding parts. Notice that we disable sorting while adding for performance reasons
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemDestroy(item: object) -> None:

	"""

	Completely deletes ListViewItem item.
	After calling this function access to item will cause undefined behaviour.
	NOTE: If item is selected, the selection change call back of list view where item belongs, will run.
	NOTE: When an item deleted, it also deletes its children (if any).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that will be deleted.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectedRemove

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Destroy Selected", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    menu = guitk.BCPopupMenuCreate(listView)
		    guitk.BCPopupMenuInsertItem(menu, "Delete", DeleteSelectedItems, listView)
		    guitk.BCPopupMenuInsertSeparator(menu)
		    guitk.BCPopupMenuInsertItem(menu, "Update", None, None)
		    guitk.BCListViewSetMousePressedFunction(listView, ListViewMousePressed, menu)
		    guitk.BCShow(window)
		
		
		def DeleteSelectedItems(menu, id, listView):
		    # standard deletion with a single function as below
		    # guitk.BCListViewSelectedRemove(listView)
		    # or custom deletion with iteration
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    # silent mode (for example the selection change call back, if any, will not be triggerred)
		    guitk.BCBlockCallBackFunctions(listView, 1)
		    for item in items:
		        guitk.BCListViewItemDestroy(item)
		    guitk.BCBlockCallBackFunctions(listView, 0)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewMousePressed(listView, button, item, col, menu):
		    # do not popup on mouse button left or middle buttons
		    if button is not guitk.constants.BCRightButton:
		        return 0
		    # do not popup when press on empty viewport space
		    if not item:
		        return 0
		    guitk.BCPopupMenuPopup(menu)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewTakeItem(lv_or_item: object, item: object) -> None:

	"""

	Removes ListViewItem item from lv_or_item (ListView or ListViewItem). The item is not deleted.
	Use this function followed by BCListViewInsertItem() to move an item to a new location.
	WARNING: This function does NOT delete the item. Use BCListViewItemDestroy() if you want to delete the item.
	This function is not supported under VR mode.

	Parameters
	----------
	lv_or_item : object
		the ListView or ListViewItem.

	item : object
		the ListViewItem that will be taken (removed).

	Returns
	-------
	None

	See Also
	--------
	BCListViewInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Tree/Flat View Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], 1)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Hexagon", "6")
		    addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    childItems = []
		    childItems.append(addShape(quad, "Cyclic", "4"))
		    childItems.append(addShape(quad, "Parallelogram", "4"))
		    childItems.append(addShape(quad, "Tangential", "4"))
		    childItems.append(addShape(quad, "Trapezoid", "4"))
		    childItems.append(addShape(tria, "Acute", "3"))
		    childItems.append(addShape(tria, "Equilateral", "3"))
		    childItems.append(addShape(tria, "Isosceles", "3"))
		    childItems.append(addShape(tria, "Right", "3"))
		    childItems.append(addShape(tria, "Scalene", "3"))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    btnSwitchView = guitk.BCPushButtonCreate(window, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(btnSwitchView, True)
		    guitk.BCButtonSetToggledFunction(btnSwitchView, switchView, childItems)  # new way
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    guitk.BCListViewItemSetUserData(item, parentItem)
		    return item
		
		
		def switchView(btn, stateFlat, childItems):
		    listView = guitk.BCListViewItemGetListView(childItems[0])
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    for childItem in childItems:
		        parentItem = guitk.BCListViewItemGetUserData(childItem)
		        guitk.BCListViewTakeItem(parentItem if stateFlat else listView, childItem)
		        guitk.BCListViewInsertItem(listView if stateFlat else parentItem, childItem)
		        txtChild = guitk.BCListViewItemGetText(childItem, 0)
		        print(
		            "BCTopLevelItemExists(listView, '{}') = {}".format(
		                txtChild, guitk.BCListViewTopLevelItemExists(listView, 0, txtChild)
		            )
		        )
		    print("New TopLevelCount = {}".format(guitk.BCListViewTopLevelItemCount(listView)))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetRootIsDecorated(listView, not stateFlat)
		    guitk.BCButtonSetText(btn, "Flat View" if stateFlat else "Tree View")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewInsertItem(lv_or_item: object, item: object) -> None:

	"""

	Inserts ListViewItem item into a ListView or a ListViewItem.
	You do not need to call this unless you've called BCListViewTakeItem() and need to reinsert item elsewhere.
	NOTE: The item position after insert is first.
	This function is not supported under VR mode.

	Parameters
	----------
	lv_or_item : object
		the ListView or ListViewItem.

	item : object
		the ListViewItem.

	Returns
	-------
	None

	See Also
	--------
	BCListViewTakeItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Tree/Flat View Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], 1)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Hexagon", "6")
		    addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    childItems = []
		    childItems.append(addShape(quad, "Cyclic", "4"))
		    childItems.append(addShape(quad, "Parallelogram", "4"))
		    childItems.append(addShape(quad, "Tangential", "4"))
		    childItems.append(addShape(quad, "Trapezoid", "4"))
		    childItems.append(addShape(tria, "Acute", "3"))
		    childItems.append(addShape(tria, "Equilateral", "3"))
		    childItems.append(addShape(tria, "Isosceles", "3"))
		    childItems.append(addShape(tria, "Right", "3"))
		    childItems.append(addShape(tria, "Scalene", "3"))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    btnSwitchView = guitk.BCPushButtonCreate(window, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(btnSwitchView, True)
		    guitk.BCButtonSetToggledFunction(btnSwitchView, switchView, childItems)  # new way
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    guitk.BCListViewItemSetUserData(item, parentItem)
		    return item
		
		
		def switchView(btn, stateFlat, childItems):
		    listView = guitk.BCListViewItemGetListView(childItems[0])
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    for childItem in childItems:
		        parentItem = guitk.BCListViewItemGetUserData(childItem)
		        guitk.BCListViewTakeItem(parentItem if stateFlat else listView, childItem)
		        guitk.BCListViewInsertItem(listView if stateFlat else parentItem, childItem)
		        txtChild = guitk.BCListViewItemGetText(childItem, 0)
		        print(
		            "BCTopLevelItemExists(listView, '{}') = {}".format(
		                txtChild, guitk.BCListViewTopLevelItemExists(listView, 0, txtChild)
		            )
		        )
		    print("New TopLevelCount = {}".format(guitk.BCListViewTopLevelItemCount(listView)))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetRootIsDecorated(listView, not stateFlat)
		    guitk.BCButtonSetText(btn, "Flat View" if stateFlat else "Tree View")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetParent(item: object) -> object:

	"""

	Returns the parent ListViewItem of item or None if its parent is the ListView (i.e. if item is a top-level ListViewItem).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem of the ListView whose parent is returned.

	Returns
	-------
	object
		the parent item of ListViewItem item or None if its parent is the ListView.

	See Also
	--------
	BCListViewItemGetFirstChild

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Get Neighbouring Items Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], True)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    # Begin adding items
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Pentagon", "5")
		    quadItem = addShapeGroup(listView, "Quadrilateral", "4")
		    addShape(quadItem, "Parallelogram", "4")
		    addShape(quadItem, "Tangential", "4")
		    triaItem = addShapeGroup(listView, "Triangle", "3")
		    addShape(triaItem, "Acute", "3")
		    addShape(triaItem, "Equilateral", "3")
		    addShape(triaItem, "Isosceles", "3")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    statusLabel = guitk.BCLabelCreate(window, "")
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, statusLabel)
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def itemSelected(listView, item, label):
		    # Note that you can retrieve neighbouring items
		    parent = guitk.BCListViewItemGetParent(item)
		    firstChild = guitk.BCListViewItemGetFirstChild(item)
		    above = guitk.BCListViewItemGetItemAbove(item)
		    below = guitk.BCListViewItemGetItemBelow(item)
		    root = guitk.BCListViewItemRoot(item)
		    text = "SelectedItem: " + guitk.BCListViewItemGetText(item, 0)
		    text += "\\nDepth: " + str(guitk.BCListViewItemDepth(item))
		    text += "\\nChildCount: " + str(guitk.BCListViewItemChildCount(item))
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemRoot(item: object) -> object:

	"""

	Return the root of the ListViewItem item or the item itself if it is already root (i.e. if item is a top level item).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose root is returned.

	Returns
	-------
	object
		the root of the ListViewItem or the item itself if it is already root.

	See Also
	--------
	BCListViewItemGetParent

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Get Neighbouring Items Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], True)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    # Begin adding items
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Pentagon", "5")
		    quadItem = addShapeGroup(listView, "Quadrilateral", "4")
		    addShape(quadItem, "Parallelogram", "4")
		    addShape(quadItem, "Tangential", "4")
		    triaItem = addShapeGroup(listView, "Triangle", "3")
		    addShape(triaItem, "Acute", "3")
		    addShape(triaItem, "Equilateral", "3")
		    addShape(triaItem, "Isosceles", "3")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    statusLabel = guitk.BCLabelCreate(window, "")
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, statusLabel)
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def itemSelected(listView, item, label):
		    # Note that you can retrieve neighbouring items
		    parent = guitk.BCListViewItemGetParent(item)
		    firstChild = guitk.BCListViewItemGetFirstChild(item)
		    above = guitk.BCListViewItemGetItemAbove(item)
		    below = guitk.BCListViewItemGetItemBelow(item)
		    root = guitk.BCListViewItemRoot(item)
		    text = "SelectedItem: " + guitk.BCListViewItemGetText(item, 0)
		    text += "\\nDepth: " + str(guitk.BCListViewItemDepth(item))
		    text += "\\nChildCount: " + str(guitk.BCListViewItemChildCount(item))
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetFirstChild(lv_or_item: object) -> object:

	"""

	Returns the first child of parent lv_or_item.
	This function is not supported under VR mode.

	Parameters
	----------
	lv_or_item : object
		the ListView or ListViewItem.

	Returns
	-------
	object
		the first child item either of a ListView or of a ListViewItem, or None if there is no first item.

	See Also
	--------
	BCListViewItemGetNextSibling

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Get Neighbouring Items Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], True)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    # Begin adding items
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Pentagon", "5")
		    quadItem = addShapeGroup(listView, "Quadrilateral", "4")
		    addShape(quadItem, "Parallelogram", "4")
		    addShape(quadItem, "Tangential", "4")
		    triaItem = addShapeGroup(listView, "Triangle", "3")
		    addShape(triaItem, "Acute", "3")
		    addShape(triaItem, "Equilateral", "3")
		    addShape(triaItem, "Isosceles", "3")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    statusLabel = guitk.BCLabelCreate(window, "")
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, statusLabel)
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def itemSelected(listView, item, label):
		    # Note that you can retrieve neighbouring items
		    parent = guitk.BCListViewItemGetParent(item)
		    firstChild = guitk.BCListViewItemGetFirstChild(item)
		    above = guitk.BCListViewItemGetItemAbove(item)
		    below = guitk.BCListViewItemGetItemBelow(item)
		    root = guitk.BCListViewItemRoot(item)
		    text = "SelectedItem: " + guitk.BCListViewItemGetText(item, 0)
		    text += "\\nDepth: " + str(guitk.BCListViewItemDepth(item))
		    text += "\\nChildCount: " + str(guitk.BCListViewItemChildCount(item))
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetPreviousSibling(item: object) -> object:

	"""

	Returns the previous ListViewItem in the ListView that is of the same level as item.
	If you want to iterate to items use BCListViewForEachItem() since is by far faster.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose sibling is returned.

	Returns
	-------
	object
		item's previous sibling, or None if none exist.

	See Also
	--------
	BCListViewItemGetNextSibling

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetNextSibling(item: object) -> object:

	"""

	Returns the next ListViewItem in the ListView that is of the same level as item.
	If you want to iterate to items use BCListViewForEachItem() since is by far faster.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose sibling is returned.

	Returns
	-------
	object
		item's next sibling, or None if none exist.

	See Also
	--------
	BCListViewItemGetPreviousSibling

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetText(lv: object, row: int, col: int, text: str) -> None:

	"""

	Sets the text at column col of ListViewItem at row row to text.
	WARNING: In order to avoid performance issues, it is recommended that sorting in list is disabled on mass items text change.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	row : int
		the row.

	col : int
		the column.

	text : str
		the new text for column col for the ListViewItem at row row.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetText

	Examples
	--------
	::

		from sdm import guitk
		from random import randint
		import math
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Progress", "Show Percentage"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addAverage(listView)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateVisible, addProgressBar, 3
		    )
		    showAverageFunct(listView)
		
		    guitk.BCShow(window)
		
		
		def addAverage(parent):
		    avg = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetProgressBar(avg, 3)
		    guitk.BCListViewItemSetVisible(avg, False)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addProgressBar(item, col):
		    progress = randint(0, 100)
		    guitk.BCListViewItemSetProgressBar(item, col)
		    guitk.BCListViewItemProgressBarSetProgress(item, col, progress)
		    if progress == 100:
		        guitk.BCListViewItemWidgetDestroy(item, col)
		        guitk.BCListViewItemSetText(item, col, "DONE")
		    else:
		        guitk.BCListViewItemSetCheckBox(item, col + 1, True, showPercentageFunct, None)
		    return 0
		
		
		def showPercentageFunct(item, col, state, data):
		    guitk.BCListViewItemProgressBarSetPercentageVisible(item, col - 1, state)
		    return 0
		
		
		def showAverageFunct(lv):
		    # Counts average row too, subtracting - 1
		    rows = guitk.BCListViewTopLevelItemCount(lv) - 1
		    sum = 0
		    for row in range(rows):
		        item = guitk.BCListViewGetTopLevelItem(lv, row)
		        currentProgress = guitk.BCListViewItemProgressBarProgress(item, 3)
		        # currentProgress equals -1, when there is no progressBar, which means progress is 100%
		        if currentProgress < 0:
		            sum += 100
		        else:
		            sum += currentProgress
		    # Rounding down (only if all items are completed, the whole progress will be 100%)
		    avg = int(math.floor(sum / rows))
		    guitk.BCListViewSetText(lv, rows, 2, "AVERAGE PROGRESS:")
		    item_avg = guitk.BCListViewGetTopLevelItem(lv, rows)
		    guitk.BCListViewItemProgressBarSetProgress(item_avg, 3, avg)
		    guitk.BCListViewItemSetBold(item_avg, True)
		    guitk.BCListViewItemSetVisible(item_avg, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetSortingColumn(lv: object, col: int, ascending: bool) -> None:

	"""

	Sets the column according to which sorting will be performed.
	If sorting column is -1, sorting is disabled and the user cannot sort columns by clicking on the column headers. If column is larger than the number of columns the user must click on a column header to sort the ListView. 
	WARNING: In order to avoid performance issues, it is recommended that sorting is disabled on mass items modifications (items text change, adding items etc).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	ascending : bool
		set to True for ascending or to False for descending sorting.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemsSortedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Tree", guitk.constants.BCOnExitDestroy
		    )
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], False)
		    # create group A
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 1, "Group A31")
		    addPart(groupA, "Bumper", "A31_1001", "8")
		    addPart(groupA, "Decklid", "A31_1002", "12")
		    # create group B
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 1, "Group B12")
		    addPart(groupB, "Roof rack", "B12_1004", "6")
		    addPart(groupB, "Spoiler", "B12_1005", "2")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(treeView, 0, True)
		    # item expand/collapse controllers display only at first column ('Part name' in this case)
		    guitk.BCListViewSetRootIsDecorated(treeView, True)
		    guitk.BCListViewSetItemsExpanded(treeView, True)
		    guitk.BCListViewMoveColumn(treeView, 1, 0)
		    guitk.BCShow(window)
		
		
		def addPart(parentItem, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSortColumn(lv: object) -> int:

	"""

	Returns the column by which the list view is sorted, or -1 if sorting is disabled.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	int
		the index of the sorting column, or -1 if sorting is disabled.

	See Also
	--------
	BCListViewSetSortingColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Sort Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        hBox, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    vBox = guitk.BCVBoxCreate(hBox)
		    btnSort = guitk.BCPushButtonCreate(
		        vBox, "Sort 'Part Name' Ascending", btnSortClicked, listView
		    )
		    statusLabel = guitk.BCLabelCreate(vBox, "")
		    guitk.BCListViewSetItemsSortedFunction(listView, itemsSorted, statusLabel)
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def btnSortClicked(btn, listView):
		    guitk.BCListViewSetSortingColumn(listView, 1, 1)
		    guitk.BCListViewSort(listView)
		    return 0
		
		
		def itemsSorted(listView, col, ascenting, label):
		    guitk.BCLabelSetText(
		        label,
		        "Sorting column: "
		        + str(guitk.BCListViewSortColumn(listView))
		        + "\\nSorting order: "
		        + str(guitk.BCListViewSortOrder(listView)),
		    )
		    return 0
		
		
		def addPart(listView, id, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, id)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSortOrder(lv: object) -> int:

	"""

	Returns the sorting order of the list view items.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	int
		1 if sorting is ascending or 0 if sorting is descending.

	See Also
	--------
	BCListViewSetSortingColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Sort Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        hBox, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    vBox = guitk.BCVBoxCreate(hBox)
		    btnSort = guitk.BCPushButtonCreate(
		        vBox, "Sort 'Part Name' Ascending", btnSortClicked, listView
		    )
		    statusLabel = guitk.BCLabelCreate(vBox, "")
		    guitk.BCListViewSetItemsSortedFunction(listView, itemsSorted, statusLabel)
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def btnSortClicked(btn, listView):
		    guitk.BCListViewSetSortingColumn(listView, 1, 1)
		    guitk.BCListViewSort(listView)
		    return 0
		
		
		def itemsSorted(listView, col, ascenting, label):
		    guitk.BCLabelSetText(
		        label,
		        "Sorting column: "
		        + str(guitk.BCListViewSortColumn(listView))
		        + "\\nSorting order: "
		        + str(guitk.BCListViewSortOrder(listView)),
		    )
		    return 0
		
		
		def addPart(listView, id, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, id)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSort(lv: object) -> None:

	"""

	Sorts the ListView using the last sorting configuration (sort column and ascending/descending).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetSortingColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Sort Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        hBox, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    vBox = guitk.BCVBoxCreate(hBox)
		    btnSort = guitk.BCPushButtonCreate(
		        vBox, "Sort 'Part Name' Ascending", btnSortClicked, listView
		    )
		    statusLabel = guitk.BCLabelCreate(vBox, "")
		    guitk.BCListViewSetItemsSortedFunction(listView, itemsSorted, statusLabel)
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def btnSortClicked(btn, listView):
		    guitk.BCListViewSetSortingColumn(listView, 1, 1)
		    guitk.BCListViewSort(listView)
		    return 0
		
		
		def itemsSorted(listView, col, ascenting, label):
		    guitk.BCLabelSetText(
		        label,
		        "Sorting column: "
		        + str(guitk.BCListViewSortColumn(listView))
		        + "\\nSorting order: "
		        + str(guitk.BCListViewSortOrder(listView)),
		    )
		    return 0
		
		
		def addPart(listView, id, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, id)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetText(item: object, col: int, text: str) -> None:

	"""

	Sets the text at column col for ListViewItem item to be text.
	The standard text is aligned left.
	WARNING: In order to avoid performance issues, it is recommended that sorting in list is disabled on mass items text change.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	text : str
		the new text.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Simple", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    # Start adding parts. Notice that we disable sorting while adding for performance reasons
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetDate(item: object, col: int, y: int, m: int, d: int) -> None:

	"""

	Sets the item item at column col to display date.
	WARNING: Items that provide date (and time) cannot currently be renamed. Item item at column col will be set rename disabled.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	y : int
		the year in range 1752-8000.

	m : int
		the month in range 1-12.

	d : int
		the day in range 1-31.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetDateTime

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "List View Set Date Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", "At Date"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		
		    hBox = guitk.BCHBoxCreate(window)
		    atDateEdit = guitk.BCDateEditCreate(hBox)
		    btnSetDate = guitk.BCPushButtonCreate(
		        hBox, "Set Selected Date", setDate, (listView, atDateEdit)
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setDate(btn, data):
		    listView, dateEdit = data
		    item = guitk.BCListViewGetSelectedItem(listView)
		    if item:
		        guitk.BCListViewItemSetDate(
		            item,
		            4,
		            guitk.BCDateEditGetYear(dateEdit),
		            guitk.BCDateEditGetMonth(dateEdit),
		            guitk.BCDateEditGetDay(dateEdit),
		        )
		        guitk.BCListViewAdjustColumn(listView, 4)
		    else:
		        print("Please select an item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetDateTime(item: object, col: int, y: int, m: int, d: int, h: int, min: int, sec: int) -> None:

	"""

	Sets the item item at column col to provide date and time.
	Time format is HH:MM:SS. See an example, assuming the time is 16:45:08. Time is always placed on the right of date.
	WARNING: Items that provide date (and time) cannot currently be renamed. Item item at column col will be set rename disabled.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	y : int
		the year in range 1752-8000.

	m : int
		the month in range 1-12.

	d : int
		the day in range 1-31.

	h : int
		the hour in range 0-23.

	min : int
		the minute in range 0-59.

	sec : int
		the seconds in range 0-59.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetDate

	Examples
	--------
	::

		from sdm import guitk
		from datetime import datetime
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView DateTime Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", "Last Modified"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetRenameItemFinishedFunction(listView, updateModified, None)
		    guitk.BCShow(window)
		
		
		def updateModified(listView, item, col, dataCommitted, text, data):
		    now = datetime.now()
		    guitk.BCListViewItemSetDateTime(
		        item, 4, now.year, now.month, now.day, now.hour, now.minute, now.second
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    modified = datetime.now()
		    guitk.BCListViewItemSetDateTime(
		        item,
		        4,
		        modified.year,
		        modified.month,
		        modified.day,
		        modified.hour,
		        modified.minute,
		        modified.second,
		    )
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewAddItem(lv: object, numCols: int, text: object, rename: list) -> object:

	"""

	Adds a top level item to ListView lv.
	
	If you want to insert an item without any data at this point use the much faster BCListViewAddTopLevelItem().
	This convenience function will also
	- set the text as text
	- set the rename type as rename
	- apply contents alignment with respect to BCListViewSetColumnAlignment()
	for each item cell.
	WARNING: If no sorting enabled in the list, the item's position (first or last) depends on BCListViewSetAddItemsInReverseOrderEnabled().
	WARNING: In order to avoid performance issues, it is recommended that sorting in list is disabled on mass adding items.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	numCols : int
		the number of columns

	text : object
		an array of strings with the text for each column

	rename : list
		an array of values with the rename type of each cell. See BCEnumRenameType for details.
		
		guitk.constants BCEnumRenameType
		This enum type is used to describe the data type of the editor on ListViewItem rename.
		 - guitk.constants.BCRenameType_None
		The item cannot be renamed by the user.
		 - guitk.constants.BCRenameType_Double
		Rename editor accepts double values.
		 - guitk.constants.BCRenameType_Int
		Rename editor accepts integer values.
		 - guitk.constants.BCRenameType_String
		Rename editor accepts any string value.

	Returns
	-------
	object
		The created ListViewItem

	See Also
	--------
	BCListViewAddTopLevelItem

	"""

def BCListViewItemAddItem(item: object, numCols: int, text: object, rename: list) -> object:

	"""

	Adds an item as a child of item (parent item).
	If you want to insert an item without any data at this point use the much faster BCListViewItemAddChild().
	This convenience function will also
	- set the text as text
	- set the rename type as rename
	- apply contents alignment with respect to BCListViewSetColumnAlignment()
	for each item cell.
	WARNING: If no sorting enabled in the list, the item's position (first or last) depends on BCListViewSetAddItemsInReverseOrderEnabled().
	WARNING: In order to avoid performance issues, it is recommended that sorting in list is disabled on mass adding items.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the parent item

	numCols : int
		the number of columns

	text : object
		an array of strings with the text for each column

	rename : list
		an array of values with the rename type of each cell. See BCEnumRenameType for details.
		
		guitk.constants BCEnumRenameType
		This enum type is used to describe the data type of the editor on ListViewItem rename.
		 - guitk.constants.BCRenameType_None
		The item cannot be renamed by the user.
		 - guitk.constants.BCRenameType_Double
		Rename editor accepts double values.
		 - guitk.constants.BCRenameType_Int
		Rename editor accepts integer values.
		 - guitk.constants.BCRenameType_String
		Rename editor accepts any string value.

	Returns
	-------
	object
		The created ListViewItem.

	See Also
	--------
	BCListViewItemAddChild

	"""

def BCListViewSetIsRootDecorated(lv: object, decorated: bool) -> None:

	"""

	Function is obsolete. Use BCListViewSetRootIsDecorated() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	decorated : bool
		set True to show expand/collapse controls or False otherwise (default).

	Returns
	-------
	None

	"""

def BCListViewGetItem(lv: object, row: int) -> object:

	"""

	Function is obsolete. Use BCListViewGetTopLevelItem() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	row : int
		the row.

	Returns
	-------
	object
		the top level item at the given row.

	"""

def BCListViewItemGetInt(item: object, col: int) -> int:

	"""

	Returns the value of ListViewItem item at column col in int format.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	int
		the text of column col of ListViewItem item in int format.

	See Also
	--------
	BCListViewItemGetText

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, random, randint
		from math import sqrt
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Test Score", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        7,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "N Tests",
		            "Mean test score",
		            "Pass",
		        ],
		        1,
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, calculateRectangleColor, None
		    )
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def calculateRectangleColor(item, data):
		    meanScore = guitk.BCListViewItemGetDouble(item, 5)
		    std = guitk.BCListViewItemGetUserData(item)["TestStd"]
		    nTests = guitk.BCListViewItemGetInt(item, 4)
		    confidence99Lower = meanScore - 2.578 * std / sqrt(nTests)
		    print(
		        "Item ID={}, Name={}: Lower 99% Confidence Bound = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemGetText(item, 1),
		            confidence99Lower,
		        )
		    )
		    guitk.BCListViewItemSetRectangleColor(
		        item, 6, 0, 255, 0
		    ) if confidence99Lower > 7 else guitk.BCListViewItemSetRectangleColor(
		        item, 6, 255, 0, 0
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Assign random nTests and test-score
		    guitk.BCListViewItemSetText(item, 4, str(randint(20, 60)))
		    guitk.BCListViewItemSetText(item, 5, str(6 + 3 * random()))
		    guitk.BCListViewItemSetUserData(item, {"TestStd": 3 * random()})
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetDouble(item: object, col: int) -> float:

	"""

	Returns the value of ListViewItem item at column col in double format.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	float
		the text of column col of ListViewItem item in double format.

	See Also
	--------
	BCListViewItemGetText

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, random, randint
		from math import sqrt
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Test Score", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        7,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "N Tests",
		            "Mean test score",
		            "Pass",
		        ],
		        1,
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, calculateRectangleColor, None
		    )
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def calculateRectangleColor(item, data):
		    meanScore = guitk.BCListViewItemGetDouble(item, 5)
		    std = guitk.BCListViewItemGetUserData(item)["TestStd"]
		    nTests = guitk.BCListViewItemGetInt(item, 4)
		    confidence99Lower = meanScore - 2.578 * std / sqrt(nTests)
		    print(
		        "Item ID={}, Name={}: Lower 99% Confidence Bound = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemGetText(item, 1),
		            confidence99Lower,
		        )
		    )
		    guitk.BCListViewItemSetRectangleColor(
		        item, 6, 0, 255, 0
		    ) if confidence99Lower > 7 else guitk.BCListViewItemSetRectangleColor(
		        item, 6, 255, 0, 0
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Assign random nTests and test-score
		    guitk.BCListViewItemSetText(item, 4, str(randint(20, 60)))
		    guitk.BCListViewItemSetText(item, 5, str(6 + 3 * random()))
		    guitk.BCListViewItemSetUserData(item, {"TestStd": 3 * random()})
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetText(item: object, col: int) -> str:

	"""

	Returns the value of the ListViewItem item at column col, or None if column col does not exist.
	NOTE: If a ComboBox lives in this column this function returns the ComboBox current text (BCListViewItemComboBoxCurrentText).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	str
		the text of column col of ListViewItem item, or None if column col does not exist or has no text.

	See Also
	--------
	BCListViewItemGetInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Print Selection", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetSelectionChangedFunction(
		        listView, ListViewItemSelectionChanged, None
		    )
		    guitk.BCShow(window)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewItemSelectionChanged(listView, data):
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    print("Selected items")
		    for item in items:
		        print("ID = ", guitk.BCListViewItemGetText(item, 0))
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetUserData(item: object, data: Any) -> None:

	"""

	Assigns user data data to ListViewItem item.
	These data can be retrieved anytime using BCListViewItemGetUserData().
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListView item of which the user's data will be set.

	data : Any
		the user's data.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemGetUserData

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, random, randint
		from math import sqrt
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Test Score", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        7,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "N Tests",
		            "Mean test score",
		            "Pass",
		        ],
		        1,
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, calculateRectangleColor, None
		    )
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def calculateRectangleColor(item, data):
		    meanScore = guitk.BCListViewItemGetDouble(item, 5)
		    std = guitk.BCListViewItemGetUserData(item)["TestStd"]
		    nTests = guitk.BCListViewItemGetInt(item, 4)
		    confidence99Lower = meanScore - 2.578 * std / sqrt(nTests)
		    print(
		        "Item ID={}, Name={}: Lower 99% Confidence Bound = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemGetText(item, 1),
		            confidence99Lower,
		        )
		    )
		    guitk.BCListViewItemSetRectangleColor(
		        item, 6, 0, 255, 0
		    ) if confidence99Lower > 7 else guitk.BCListViewItemSetRectangleColor(
		        item, 6, 255, 0, 0
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Assign random nTests and test-score
		    guitk.BCListViewItemSetText(item, 4, str(randint(20, 60)))
		    guitk.BCListViewItemSetText(item, 5, str(6 + 3 * random()))
		    guitk.BCListViewItemSetUserData(item, {"TestStd": 3 * random()})
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetUserData(item: object) -> object:

	"""

	Returns the user's data associated with ListViewItem item.
	These data have been previously assigned using BCListViewItemSetUserData().
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose user's data will be returned.

	Returns
	-------
	object
		the user's data associated with ListViewItem item.

	See Also
	--------
	BCListViewItemSetUserData

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, random, randint
		from math import sqrt
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Test Score", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        7,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "N Tests",
		            "Mean test score",
		            "Pass",
		        ],
		        1,
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, calculateRectangleColor, None
		    )
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def calculateRectangleColor(item, data):
		    meanScore = guitk.BCListViewItemGetDouble(item, 5)
		    std = guitk.BCListViewItemGetUserData(item)["TestStd"]
		    nTests = guitk.BCListViewItemGetInt(item, 4)
		    confidence99Lower = meanScore - 2.578 * std / sqrt(nTests)
		    print(
		        "Item ID={}, Name={}: Lower 99% Confidence Bound = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemGetText(item, 1),
		            confidence99Lower,
		        )
		    )
		    guitk.BCListViewItemSetRectangleColor(
		        item, 6, 0, 255, 0
		    ) if confidence99Lower > 7 else guitk.BCListViewItemSetRectangleColor(
		        item, 6, 255, 0, 0
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Assign random nTests and test-score
		    guitk.BCListViewItemSetText(item, 4, str(randint(20, 60)))
		    guitk.BCListViewItemSetText(item, 5, str(6 + 3 * random()))
		    guitk.BCListViewItemSetUserData(item, {"TestStd": 3 * random()})
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsSelected(item: object) -> bool:

	"""

	Returns True if item is selected, or False otherwise.
	Convenience function for BCListViewIsSelected().
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if item is selected; False otherwise

	See Also
	--------
	BCListViewCountSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    label = guitk.BCLabelCreate(window, "Currently Selected Items: 0")
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, currentChanged, label)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def currentChanged(listView, item, label):
		    print("Current item changed")
		    text = "Current Item: " + guitk.BCListViewItemGetText(item, 1)
		    if guitk.BCListViewItemIsSelected(item):
		        text += " is selected."
		    else:
		        text += " is not selected."
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewTopLevelItemCount(lv: object) -> int:

	"""

	Returns the number of top-level (parentless) items in ListView lv.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	int
		The number of top-level items in ListView lv.

	See Also
	--------
	BCListViewItemChildCount

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Tree/Flat View Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], 1)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Hexagon", "6")
		    addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    childItems = []
		    childItems.append(addShape(quad, "Cyclic", "4"))
		    childItems.append(addShape(quad, "Parallelogram", "4"))
		    childItems.append(addShape(quad, "Tangential", "4"))
		    childItems.append(addShape(quad, "Trapezoid", "4"))
		    childItems.append(addShape(tria, "Acute", "3"))
		    childItems.append(addShape(tria, "Equilateral", "3"))
		    childItems.append(addShape(tria, "Isosceles", "3"))
		    childItems.append(addShape(tria, "Right", "3"))
		    childItems.append(addShape(tria, "Scalene", "3"))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    btnSwitchView = guitk.BCPushButtonCreate(window, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(btnSwitchView, True)
		    guitk.BCButtonSetToggledFunction(btnSwitchView, switchView, childItems)  # new way
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    guitk.BCListViewItemSetUserData(item, parentItem)
		    return item
		
		
		def switchView(btn, stateFlat, childItems):
		    listView = guitk.BCListViewItemGetListView(childItems[0])
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    for childItem in childItems:
		        parentItem = guitk.BCListViewItemGetUserData(childItem)
		        guitk.BCListViewTakeItem(parentItem if stateFlat else listView, childItem)
		        guitk.BCListViewInsertItem(listView if stateFlat else parentItem, childItem)
		        txtChild = guitk.BCListViewItemGetText(childItem, 0)
		        print(
		            "BCTopLevelItemExists(listView, '{}') = {}".format(
		                txtChild, guitk.BCListViewTopLevelItemExists(listView, 0, txtChild)
		            )
		        )
		    print("New TopLevelCount = {}".format(guitk.BCListViewTopLevelItemCount(listView)))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetRootIsDecorated(listView, not stateFlat)
		    guitk.BCButtonSetText(btn, "Flat View" if stateFlat else "Tree View")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewColumns(lv: object) -> int:

	"""

	Returns the number of columns in ListView lv.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	int
		the number of columns in lv.

	See Also
	--------
	BCListViewTopLevelItemCount

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemChildCount(item: object) -> int:

	"""

	Returns the number of immediate children of item.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose number of children will be counted.

	Returns
	-------
	int
		the number of immediate children of item.

	See Also
	--------
	BCListViewTopLevelItemCount

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Get Neighbouring Items Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], True)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    # Begin adding items
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Pentagon", "5")
		    quadItem = addShapeGroup(listView, "Quadrilateral", "4")
		    addShape(quadItem, "Parallelogram", "4")
		    addShape(quadItem, "Tangential", "4")
		    triaItem = addShapeGroup(listView, "Triangle", "3")
		    addShape(triaItem, "Acute", "3")
		    addShape(triaItem, "Equilateral", "3")
		    addShape(triaItem, "Isosceles", "3")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    statusLabel = guitk.BCLabelCreate(window, "")
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, statusLabel)
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def itemSelected(listView, item, label):
		    # Note that you can retrieve neighbouring items
		    parent = guitk.BCListViewItemGetParent(item)
		    firstChild = guitk.BCListViewItemGetFirstChild(item)
		    above = guitk.BCListViewItemGetItemAbove(item)
		    below = guitk.BCListViewItemGetItemBelow(item)
		    root = guitk.BCListViewItemRoot(item)
		    text = "SelectedItem: " + guitk.BCListViewItemGetText(item, 0)
		    text += "\\nDepth: " + str(guitk.BCListViewItemDepth(item))
		    text += "\\nChildCount: " + str(guitk.BCListViewItemChildCount(item))
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetRectangleColor(item: object, col: int, r: int, g: int, b: int) -> None:

	"""

	Displays a colored rectangle at col, specified by RGB (red, green and blue) components.
	The color is specified in RGB format by r g and b. If you use invalid values (out of 0..255 range), the rectangle will be cleared.
	The standard rectangle color box is aligned center.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, random, randint
		from math import sqrt
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Test Score", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        7,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "N Tests",
		            "Mean test score",
		            "Pass",
		        ],
		        1,
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, calculateRectangleColor, None
		    )
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def calculateRectangleColor(item, data):
		    meanScore = guitk.BCListViewItemGetDouble(item, 5)
		    std = guitk.BCListViewItemGetUserData(item)["TestStd"]
		    nTests = guitk.BCListViewItemGetInt(item, 4)
		    confidence99Lower = meanScore - 2.578 * std / sqrt(nTests)
		    print(
		        "Item ID={}, Name={}: Lower 99% Confidence Bound = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemGetText(item, 1),
		            confidence99Lower,
		        )
		    )
		    guitk.BCListViewItemSetRectangleColor(
		        item, 6, 0, 255, 0
		    ) if confidence99Lower > 7 else guitk.BCListViewItemSetRectangleColor(
		        item, 6, 255, 0, 0
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Assign random nTests and test-score
		    guitk.BCListViewItemSetText(item, 4, str(randint(20, 60)))
		    guitk.BCListViewItemSetText(item, 5, str(6 + 3 * random()))
		    guitk.BCListViewItemSetUserData(item, {"TestStd": 3 * random()})
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetSelectable(item: object, selectable: bool) -> None:

	"""

	Sets whether ListViewItem item can be selected or not.
	NOTE: The ListViewItem item can still be selected programatically
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	selectable : bool
		set this parameter to True for item to be selectable; False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsSelectable

	"""

def BCListViewItemIsSelectable(item: object) -> bool:

	"""

	Returns whether ListViewItem item can be selected or not.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if item can be selected; False otherwise.

	See Also
	--------
	BCListViewItemSetSelectable

	"""

def BCListViewItemGetListView(item: object) -> object:

	"""

	Returns the ListView to which ListViewItem item belongs.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	object
		the ListView to which item belongs.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Tree/Flat View Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], 1)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Hexagon", "6")
		    addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    childItems = []
		    childItems.append(addShape(quad, "Cyclic", "4"))
		    childItems.append(addShape(quad, "Parallelogram", "4"))
		    childItems.append(addShape(quad, "Tangential", "4"))
		    childItems.append(addShape(quad, "Trapezoid", "4"))
		    childItems.append(addShape(tria, "Acute", "3"))
		    childItems.append(addShape(tria, "Equilateral", "3"))
		    childItems.append(addShape(tria, "Isosceles", "3"))
		    childItems.append(addShape(tria, "Right", "3"))
		    childItems.append(addShape(tria, "Scalene", "3"))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    btnSwitchView = guitk.BCPushButtonCreate(window, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(btnSwitchView, True)
		    guitk.BCButtonSetToggledFunction(btnSwitchView, switchView, childItems)  # new way
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    guitk.BCListViewItemSetUserData(item, parentItem)
		    return item
		
		
		def switchView(btn, stateFlat, childItems):
		    listView = guitk.BCListViewItemGetListView(childItems[0])
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    for childItem in childItems:
		        parentItem = guitk.BCListViewItemGetUserData(childItem)
		        guitk.BCListViewTakeItem(parentItem if stateFlat else listView, childItem)
		        guitk.BCListViewInsertItem(listView if stateFlat else parentItem, childItem)
		        txtChild = guitk.BCListViewItemGetText(childItem, 0)
		        print(
		            "BCTopLevelItemExists(listView, '{}') = {}".format(
		                txtChild, guitk.BCListViewTopLevelItemExists(listView, 0, txtChild)
		            )
		        )
		    print("New TopLevelCount = {}".format(guitk.BCListViewTopLevelItemCount(listView)))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetRootIsDecorated(listView, not stateFlat)
		    guitk.BCButtonSetText(btn, "Flat View" if stateFlat else "Tree View")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemMoveItem(item: object, afterItem: object) -> None:

	"""

	Move the item to be after item afterItem, anywhere in the hierarchy.
	Both items must belong to the same ListView. If you want to append you item at the end 
	do not move after the last item, but use BCListViewSetAddItemsInReverseOrderEnabled().
	NOTE: this function will have no effect if sorting is enabled at the list.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that will be moved.

	afterItem : object
		the ListViewItem after which item will be placed.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetAddItemsInReverseOrderEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView DoubleClick Move Example", guitk.constants.BCOnExitDestroy
		    )
		    # Notice that we do not use sorting for moving to work
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 0
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    statusBar = guitk.BCStatusBarCreate(window)
		    lastDoubleClicked = [None]
		    guitk.BCListViewSetDoubleClickedFunction(
		        listView, moveAfterDoubleClicked, (lastDoubleClicked, statusBar)
		    )
		    guitk.BCStatusBarMessage(statusBar, "Double click an item to select it for moving")
		    guitk.BCShow(window)
		
		
		def moveAfterDoubleClicked(listView, item, col, data):
		    lastDoubleClicked, statusBar = data
		    if lastDoubleClicked[0]:
		        guitk.BCListViewItemMoveItem(lastDoubleClicked[0], item)
		        lastDoubleClicked[0] = None
		        guitk.BCStatusBarMessage(
		            statusBar, "Double click an item to select it for moving"
		        )
		    else:
		        lastDoubleClicked[0] = item
		        guitk.BCStatusBarMessage(
		            statusBar, "Double click an item to insert the selected after"
		        )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetExpanded(item: object, expand: bool) -> None:

	"""

	Expands or collapses ListViewItem item, depending on the values of expand.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	expand : bool
		set this parameter to True to expand item, or to False to collapse it.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemsExpanded

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListViewItemSetExpanded Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], False)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    hexa = addShapeGroup(listView, "Hexagon", "6")
		    penta = addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    addShape(quad, "Cyclic", "4")
		    addShape(quad, "Parallelogram", "4")
		    addShape(quad, "Tangential", "4")
		    addShape(quad, "Trapezoid", "4")
		    addShape(tria, "Acute", "3")
		    addShape(tria, "Equilateral", "3")
		    addShape(tria, "Isosceles", "3")
		    addShape(tria, "Right", "3")
		    addShape(tria, "Scalene", "3")
		    guitk.BCListViewSetSortingColumn(listView, 1, False)
		    guitk.BCListViewItemSetExpanded(quad, True)
		
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateFirstLevel, printExpandedStatus, None
		    )
		    guitk.BCListViewSetExpandItemsButtonEnabled(listView, True)
		    guitk.BCShow(window)
		
		
		def printExpandedStatus(item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " is Expanded = "
		        + str(guitk.BCListViewItemIsExpanded(item))
		    )
		    return 0
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parent, name, sides):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsExpanded(item: object) -> bool:

	"""

	Returns True if ListViewItem item is expand (expanded), or False if item is closed (collapsed).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that is checked.

	Returns
	-------
	bool
		True or False depending on the state of item.

	See Also
	--------
	BCListViewItemSetExpanded

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListViewItemSetExpanded Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], False)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    hexa = addShapeGroup(listView, "Hexagon", "6")
		    penta = addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    addShape(quad, "Cyclic", "4")
		    addShape(quad, "Parallelogram", "4")
		    addShape(quad, "Tangential", "4")
		    addShape(quad, "Trapezoid", "4")
		    addShape(tria, "Acute", "3")
		    addShape(tria, "Equilateral", "3")
		    addShape(tria, "Isosceles", "3")
		    addShape(tria, "Right", "3")
		    addShape(tria, "Scalene", "3")
		    guitk.BCListViewSetSortingColumn(listView, 1, False)
		    guitk.BCListViewItemSetExpanded(quad, True)
		
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateFirstLevel, printExpandedStatus, None
		    )
		    guitk.BCListViewSetExpandItemsButtonEnabled(listView, True)
		    guitk.BCShow(window)
		
		
		def printExpandedStatus(item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " is Expanded = "
		        + str(guitk.BCListViewItemIsExpanded(item))
		    )
		    return 0
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parent, name, sides):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetSelected(lv: object, item: object, selected: bool) -> None:

	"""

	Sets item to be selected or not in ListView lv depending on the value of selected.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	item : object
		the ListViewItem that will be selected or deselected.

	selected : bool
		set this parameter to False to deselect, or True to select item.

	Returns
	-------
	None

	See Also
	--------
	BCListViewIsSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Iterate", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    # Find the part Pillar 1003 button
		    buttonFrame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(buttonFrame, guitk.constants.BCHorizontal)
		    guitk.BCSpacerCreate(buttonFrame)
		    guitk.BCPushButtonCreate(
		        buttonFrame, "Find the part Pillar 1003", FindPillar1003ButtonClicked, listView
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def CheckForPillar1003(item, part1003List):
		    print("Checking item ", guitk.BCListViewItemGetText(item, 0))
		    if (
		        guitk.BCListViewItemGetText(item, 0) == "1003"
		        and guitk.BCListViewItemGetText(item, 1) == "Pillar"
		    ):
		        part1003List.append(item)
		        return 1  # I know no duplicate items so stop iterating
		    return 0  # keep searching
		
		
		def FindPillar1003ButtonClicked(button, listView):
		    # Using BCListViewFindItem
		    maybePillar = guitk.BCListViewFindItem(
		        listView, "1003", 0, guitk.constants.BCExactMatch
		    )
		    if maybePillar:
		        if guitk.BCListViewItemGetText(maybePillar, 1) == "Pillar":
		            print("Pillar 1003 was found using FindItem")
		
		    # Using iterate we can compare both id and name for each item
		    part1003List = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, CheckForPillar1003, part1003List
		    )
		    if len(part1003List):
		        print("Pillar 1003 was found.")
		        guitk.BCListViewSetSelected(listView, part1003List[0], True)
		    else:
		        print("Pillar 1003 was not found.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewCountSelected(lv: object) -> int:

	"""

	Counts the number of selected items.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	int
		the number of selected items.

	See Also
	--------
	BCListViewSetSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Selected Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    for i in range(1, guitk.BCListViewColumns(listView)):
		        guitk.BCListViewSetSelectableColumn(listView, i, False)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Click item on ID column or press Space to select an item.",
		    )
		    if guitk.BCListViewGetSelectionMode(listView) != guitk.constants.BCMulti:
		        guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, printIsSelected, None)
		    guitk.BCListViewRestoreSortState(listView)
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnReverse = guitk.BCPushButtonCreate(
		        hBox1, "Reverse Selection", reverseSelectionAll, listView
		    )
		    btnAll = guitk.BCPushButtonCreate(
		        hBox1,
		        "Select All",
		        lambda b, listView: guitk.BCListViewSelectAll(listView),
		        listView,
		    )
		    btnClear = guitk.BCPushButtonCreate(
		        hBox1,
		        "Clear Selection",
		        lambda b, listView: guitk.BCListViewClearSelection(listView),
		        listView,
		    )
		    guitk.BCShow(window)
		
		
		def printIsSelected(listView, item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " isSelected = "
		        + str(guitk.BCListViewIsSelected(listView, item))
		    )
		    return 0
		
		
		def reverseSelectionAll(b, listView):
		    guitk.BCListViewInvertSelection(listView)
		    print("New Selected Count = {}".format(guitk.BCListViewCountSelected(listView)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetSelectionMode(lv: object, mode: int) -> None:

	"""

	Sets the selection mode of ListView lv to depend on the value of mode (default BCSingle).
	The options are BCSingle, BCMulti and BCNoSelection.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	mode : int
		the selection mode. See BCEnumSelectionMode for details.
		
		guitk.constants BCEnumSelectionMode
		This enum type defines the selection mode. Selection is used with BCListViewSetSelectionMode for example.
		 - guitk.constants.BCMulti
		when the user selects an item in the usual way, the previous selection is cleared and the new item is selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. And if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item get selected or unselected, depending on the state of the clicked item. Also, multiple items can be selected by dragging the mouse over them.
		 - guitk.constants.BCSingle
		the user can select only one item. Any already-selected item becomes unselected.
		 - guitk.constants.BCNoSelection
		items cannot be selected.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Print Selection", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetSelectionChangedFunction(
		        listView, ListViewItemSelectionChanged, None
		    )
		    guitk.BCShow(window)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewItemSelectionChanged(listView, data):
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    print("Selected items")
		    for item in items:
		        print("ID = ", guitk.BCListViewItemGetText(item, 0))
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewGetSelectionMode(lv: object) -> int:

	"""

	Return the selection mode of ListView lv.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	int
		the selection mode (BCSingle, BCMulti or BCNoSelection).

	See Also
	--------
	BCListViewSetSelectionMode

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Selected Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    for i in range(1, guitk.BCListViewColumns(listView)):
		        guitk.BCListViewSetSelectableColumn(listView, i, False)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Click item on ID column or press Space to select an item.",
		    )
		    if guitk.BCListViewGetSelectionMode(listView) != guitk.constants.BCMulti:
		        guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, printIsSelected, None)
		    guitk.BCListViewRestoreSortState(listView)
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnReverse = guitk.BCPushButtonCreate(
		        hBox1, "Reverse Selection", reverseSelectionAll, listView
		    )
		    btnAll = guitk.BCPushButtonCreate(
		        hBox1,
		        "Select All",
		        lambda b, listView: guitk.BCListViewSelectAll(listView),
		        listView,
		    )
		    btnClear = guitk.BCPushButtonCreate(
		        hBox1,
		        "Clear Selection",
		        lambda b, listView: guitk.BCListViewClearSelection(listView),
		        listView,
		    )
		    guitk.BCShow(window)
		
		
		def printIsSelected(listView, item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " isSelected = "
		        + str(guitk.BCListViewIsSelected(listView, item))
		    )
		    return 0
		
		
		def reverseSelectionAll(b, listView):
		    guitk.BCListViewInvertSelection(listView)
		    print("New Selected Count = {}".format(guitk.BCListViewCountSelected(listView)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewGetInt(lv: object, row: int, col: int) -> int:

	"""

	Returns the value at row row and column col of ListView lv in int format.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	int
		the value at (row, col) of ListView lv.

	See Also
	--------
	BCListViewItemGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Value"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", "2", "91.57")
		    addPart(listView, "1002", "Decklid", "1", "15.12")
		    createHeaderSideButtons(infoBox, listView, 2)
		    addPart(listView, "1003", "Pillar", "3", "62.03")
		    createHeaderSideButtons(infoBox, listView, 3)
		    guitk.BCListViewSetColumnDataType(listView, 2, guitk.constants.BCInt)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCDouble)
		    guitk.BCListViewSetRenameItemPrecision(listView, 3)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, quantity, value):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetText(item, 3, value)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def createHeaderSideButtons(infoBox, listView, col):
		    dict = {"listView": listView, "col": col, "infoBox": infoBox}
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "gear.svg", "", lambda btn, data: calculateFunct(btn, **data), dict
		    )
		    guitk.BCListViewHeaderSetColumnSideButton(listView, col, toolBtn)
		    guitk.BCListViewHeaderSetToolTip(listView, col, "Calculate Sum")
		
		
		def calculateFunct(btn, listView=0, col=0, infoBox=0):
		    isInt = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCInt
		    isDouble = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCDouble
		    rows = guitk.BCListViewTopLevelItemCount(listView)
		    total = 0
		    if isInt:
		        for row in range(rows):
		            total += guitk.BCListViewGetInt(listView, row, col)
		    elif isDouble:
		        for row in range(rows):
		            total += guitk.BCListViewGetDouble(listView, row, col)
		    text = (
		        "Sum of column '"
		        + guitk.BCListViewHeaderGetText(listView, col)
		        + "' is "
		        + str(total)
		    )
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewGetDouble(lv: object, row: int, col: int) -> float:

	"""

	Returns the value at row row and column col of ListView lv in double format.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	float
		the value at (row, col) of ListView lv.

	See Also
	--------
	BCListViewItemGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Value"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", "2", "91.57")
		    addPart(listView, "1002", "Decklid", "1", "15.12")
		    createHeaderSideButtons(infoBox, listView, 2)
		    addPart(listView, "1003", "Pillar", "3", "62.03")
		    createHeaderSideButtons(infoBox, listView, 3)
		    guitk.BCListViewSetColumnDataType(listView, 2, guitk.constants.BCInt)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCDouble)
		    guitk.BCListViewSetRenameItemPrecision(listView, 3)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, quantity, value):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetText(item, 3, value)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def createHeaderSideButtons(infoBox, listView, col):
		    dict = {"listView": listView, "col": col, "infoBox": infoBox}
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "gear.svg", "", lambda btn, data: calculateFunct(btn, **data), dict
		    )
		    guitk.BCListViewHeaderSetColumnSideButton(listView, col, toolBtn)
		    guitk.BCListViewHeaderSetToolTip(listView, col, "Calculate Sum")
		
		
		def calculateFunct(btn, listView=0, col=0, infoBox=0):
		    isInt = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCInt
		    isDouble = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCDouble
		    rows = guitk.BCListViewTopLevelItemCount(listView)
		    total = 0
		    if isInt:
		        for row in range(rows):
		            total += guitk.BCListViewGetInt(listView, row, col)
		    elif isDouble:
		        for row in range(rows):
		            total += guitk.BCListViewGetDouble(listView, row, col)
		    text = (
		        "Sum of column '"
		        + guitk.BCListViewHeaderGetText(listView, col)
		        + "' is "
		        + str(total)
		    )
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewGetText(lv: object, row: int, col: int) -> str:

	"""

	Returns the text at row row and column col of ListView lv.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	str
		the value at (row, col) of ListView lv.

	See Also
	--------
	BCListViewItemGetInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SortedFunction Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetItemsSortedFunction(listView, itemsSorted, None)
		    guitk.BCShow(window)
		
		
		def itemsSorted(listView, col, ascending, data):
		    firstText = guitk.BCListViewGetText(listView, 0, col)
		    lastText = guitk.BCListViewItemGetText(guitk.BCListViewLastItem(listView), col)
		    print(
		        "Items sorted {}ending at column {}.".format(
		            "asc" if ascending else "desc", col
		        )
		    )
		    print(
		        "\\tFirst Sorted Column Value: {}\\n\\tLast Sorted Column Value: {}".format(
		            firstText, lastText
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSelectedRemove(lv: object) -> None:

	"""

	Removes all selected items of ListView lv.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetDeletePressedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Destroy Selected", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    menu = guitk.BCPopupMenuCreate(listView)
		    guitk.BCPopupMenuInsertItem(menu, "Delete", DeleteSelectedItems, listView)
		    guitk.BCPopupMenuInsertSeparator(menu)
		    guitk.BCPopupMenuInsertItem(menu, "Update", None, None)
		    guitk.BCListViewSetMousePressedFunction(listView, ListViewMousePressed, menu)
		    guitk.BCShow(window)
		
		
		def DeleteSelectedItems(menu, id, listView):
		    # standard deletion with a single function as below
		    # guitk.BCListViewSelectedRemove(listView)
		    # or custom deletion with iteration
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    # silent mode (for example the selection change call back, if any, will not be triggerred)
		    guitk.BCBlockCallBackFunctions(listView, 1)
		    for item in items:
		        guitk.BCListViewItemDestroy(item)
		    guitk.BCBlockCallBackFunctions(listView, 0)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewMousePressed(listView, button, item, col, menu):
		    # do not popup on mouse button left or middle buttons
		    if button is not guitk.constants.BCRightButton:
		        return 0
		    # do not popup when press on empty viewport space
		    if not item:
		        return 0
		    guitk.BCPopupMenuPopup(menu)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSelectedMoveUp(lv: object) -> None:

	"""

	Moves the selected items of ListView lv one step up in the same depth.
	NOTE: this function will have no effect if sorting is enabled at the list view. If you try to sort while you move items you may end up in infinite recursion.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectedMoveDown

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SelectedMove Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        hBox, 4, ["ID", "Part name", "Version", "Manufactured"], 0
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    vBox = guitk.BCVBoxCreate(hBox)
		    toolBtnUp = guitk.BCToolButtonCreate(vBox, "arrow_up.svg", "", moveUp, listView)
		    toolBtnDown = guitk.BCToolButtonCreate(
		        vBox, "arrow_down.svg", "", moveDown, listView
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(
		        listView
		    )  # Cannot move and sort at the same time.
		    guitk.BCShow(window)
		
		
		def moveUp(btn, listView):
		    guitk.BCListViewSelectedMoveUp(listView)
		    return 0
		
		
		def moveDown(btn, listView):
		    guitk.BCListViewSelectedMoveDown(listView)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSelectedMoveDown(lv: object) -> None:

	"""

	Moves the selected items of ListView lv one step down in the same depth.
	NOTE: this function will have no effect if sorting is enabled at the list view. If you try to sort while you move items you may end up in infinite recursion.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectedMoveUp

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SelectedMove Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        hBox, 4, ["ID", "Part name", "Version", "Manufactured"], 0
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    vBox = guitk.BCVBoxCreate(hBox)
		    toolBtnUp = guitk.BCToolButtonCreate(vBox, "arrow_up.svg", "", moveUp, listView)
		    toolBtnDown = guitk.BCToolButtonCreate(
		        vBox, "arrow_down.svg", "", moveDown, listView
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(
		        listView
		    )  # Cannot move and sort at the same time.
		    guitk.BCShow(window)
		
		
		def moveUp(btn, listView):
		    guitk.BCListViewSelectedMoveUp(listView)
		    return 0
		
		
		def moveDown(btn, listView):
		    guitk.BCListViewSelectedMoveDown(listView)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetSelectedMoveMode(lv: object, mode: int) -> None:

	"""

	Sets the moving mode of list view for its items (default BCMoveModeSameDepth).
	If you set BCMoveModeNoRestriction mode then you can select different depth items and move them simultaneously.
	NOTE: The selected items will not change their position in the tree hierarchy regardless the moving mode.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	mode : int
		the restrictions to be set for moving the items. Default value is BCMoveModeSameDepth.
		See BCEnumSelectedMoveMode for details.
		
		guitk.constants BCEnumSelectedMoveMode
		This enum type describes how the selected items of a Listview will be moved when the appropriate function is called. Items always move in the same depth.
		you can select different depth items and move them simultaneously. Note that the items always move in the same depth.
		 - guitk.constants.BCMoveModeNoRestriction
		Selected items from different depths can move simultaneously (in the same depth).
		 - guitk.constants.BCMoveModeSameDepth
		The selected items with same depth can move (in the same depth).

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectedMoveUp

	"""

def BCListViewSelectedSetColumnDouble(lv: object, col: int, val: float) -> None:

	"""

	Sets the text at column col to val for all selected items of ListView lv.
	Optimizes performance compared to set double value item by item.
	Default precision for conversion is 6 digits. You can set with BCListViewSetRenameItemPrecision().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	val : float
		the double value to which the column text will be set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectedSetColumnText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SetColumn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Name", "Quantity", "Price"], False
		    )
		    guitk.BCSetUserDataKey(listView, "lastID", 0)
		    for i in range(20):
		        addEmptyItem(listView)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    hBox = guitk.BCHBoxCreate(window)
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "New selected item's text.")
		    btn = guitk.BCPushButtonCreate(hBox, "Set Column", None, None)
		    menu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCPopupMenuInsertItem(menu, "Name", None, None)  # id 0 -> col 1
		    guitk.BCPopupMenuInsertItem(menu, "Quantity", None, None)  # id 1 -> col 2
		    guitk.BCPopupMenuInsertItem(menu, "Price", None, None)  # id 2 -> col 3
		    guitk.BCButtonSetPopup(btn, menu)
		    multipleChkBox = guitk.BCCheckBoxCreate(
		        window, "ListView Multiple Rename For column 'Name'"
		    )
		    guitk.BCCheckBoxSetChecked(
		        multipleChkBox, guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		    )
		    guitk.BCCheckBoxSetToggledFunction(multipleChkBox, toggleMulRename, listView)
		    guitk.BCPopupMenuSetActivatedFunction(menu, pmActivated, (lineEdit, listView))
		    guitk.BCShow(window)
		
		
		def addEmptyItem(listView):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    itemId = guitk.BCGetUserDataKey(listView, "lastID") + 1
		    guitk.BCSetUserDataKey(listView, "lastID", itemId)
		    guitk.BCListViewItemSetText(item, 0, str(itemId))
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def pmActivated(menu, id, data):
		    lineEdit, listView = data
		    if guitk.BCListViewHasSelected(listView) and guitk.BCLineEditHasText(lineEdit):
		        col = id + 1
		        if col == 1:
		            name = guitk.BCLineEditGetText(lineEdit)
		            guitk.BCListViewSelectedSetColumnText(listView, col, name)
		        elif col == 2:
		            quantity = guitk.BCLineEditGetInt(lineEdit)
		            if quantity == guitk.constants.blank:
		                quantity = 0
		            guitk.BCListViewSelectedSetColumnInt(listView, col, quantity)
		        elif col == 3:
		            price = guitk.BCLineEditGetDouble(lineEdit)
		            if price == guitk.constants.blank:
		                price = 0
		            guitk.BCListViewSelectedSetColumnDouble(listView, col, price)
		        guitk.BCListViewAdjustColumn(listView, col)
		    else:
		        print("Select item/s and insert value to the LineEdit first")
		    return 0
		
		
		def toggleMulRename(chkBox, state, listView):
		    guitk.BCListViewSetMultipleItemsRenameEnabled(listView, 1, state)
		    print(
		        "MultipleItemsRename for column=1 set to {}".format(
		            guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSelectedSetColumnInt(lv: object, col: int, val: int) -> None:

	"""

	Sets the text at column col to val for all selected items of ListView lv.
	Optimizes performance compared to set integer value item by item.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	val : int
		the integer value to which the column text will be set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectedSetColumnText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SetColumn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Name", "Quantity", "Price"], False
		    )
		    guitk.BCSetUserDataKey(listView, "lastID", 0)
		    for i in range(20):
		        addEmptyItem(listView)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    hBox = guitk.BCHBoxCreate(window)
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "New selected item's text.")
		    btn = guitk.BCPushButtonCreate(hBox, "Set Column", None, None)
		    menu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCPopupMenuInsertItem(menu, "Name", None, None)  # id 0 -> col 1
		    guitk.BCPopupMenuInsertItem(menu, "Quantity", None, None)  # id 1 -> col 2
		    guitk.BCPopupMenuInsertItem(menu, "Price", None, None)  # id 2 -> col 3
		    guitk.BCButtonSetPopup(btn, menu)
		    multipleChkBox = guitk.BCCheckBoxCreate(
		        window, "ListView Multiple Rename For column 'Name'"
		    )
		    guitk.BCCheckBoxSetChecked(
		        multipleChkBox, guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		    )
		    guitk.BCCheckBoxSetToggledFunction(multipleChkBox, toggleMulRename, listView)
		    guitk.BCPopupMenuSetActivatedFunction(menu, pmActivated, (lineEdit, listView))
		    guitk.BCShow(window)
		
		
		def addEmptyItem(listView):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    itemId = guitk.BCGetUserDataKey(listView, "lastID") + 1
		    guitk.BCSetUserDataKey(listView, "lastID", itemId)
		    guitk.BCListViewItemSetText(item, 0, str(itemId))
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def pmActivated(menu, id, data):
		    lineEdit, listView = data
		    if guitk.BCListViewHasSelected(listView) and guitk.BCLineEditHasText(lineEdit):
		        col = id + 1
		        if col == 1:
		            name = guitk.BCLineEditGetText(lineEdit)
		            guitk.BCListViewSelectedSetColumnText(listView, col, name)
		        elif col == 2:
		            quantity = guitk.BCLineEditGetInt(lineEdit)
		            if quantity == guitk.constants.blank:
		                quantity = 0
		            guitk.BCListViewSelectedSetColumnInt(listView, col, quantity)
		        elif col == 3:
		            price = guitk.BCLineEditGetDouble(lineEdit)
		            if price == guitk.constants.blank:
		                price = 0
		            guitk.BCListViewSelectedSetColumnDouble(listView, col, price)
		        guitk.BCListViewAdjustColumn(listView, col)
		    else:
		        print("Select item/s and insert value to the LineEdit first")
		    return 0
		
		
		def toggleMulRename(chkBox, state, listView):
		    guitk.BCListViewSetMultipleItemsRenameEnabled(listView, 1, state)
		    print(
		        "MultipleItemsRename for column=1 set to {}".format(
		            guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSelectedSetColumnText(lv: object, col: int, text: str) -> None:

	"""

	Sets the text at column col to text for all selected items of ListView lv.
	Optimizes performance compared to set text value item by item.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	text : str
		the string to which the column text will be set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectedSetColumnInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SetColumn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Name", "Quantity", "Price"], False
		    )
		    guitk.BCSetUserDataKey(listView, "lastID", 0)
		    for i in range(20):
		        addEmptyItem(listView)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    hBox = guitk.BCHBoxCreate(window)
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "New selected item's text.")
		    btn = guitk.BCPushButtonCreate(hBox, "Set Column", None, None)
		    menu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCPopupMenuInsertItem(menu, "Name", None, None)  # id 0 -> col 1
		    guitk.BCPopupMenuInsertItem(menu, "Quantity", None, None)  # id 1 -> col 2
		    guitk.BCPopupMenuInsertItem(menu, "Price", None, None)  # id 2 -> col 3
		    guitk.BCButtonSetPopup(btn, menu)
		    multipleChkBox = guitk.BCCheckBoxCreate(
		        window, "ListView Multiple Rename For column 'Name'"
		    )
		    guitk.BCCheckBoxSetChecked(
		        multipleChkBox, guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		    )
		    guitk.BCCheckBoxSetToggledFunction(multipleChkBox, toggleMulRename, listView)
		    guitk.BCPopupMenuSetActivatedFunction(menu, pmActivated, (lineEdit, listView))
		    guitk.BCShow(window)
		
		
		def addEmptyItem(listView):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    itemId = guitk.BCGetUserDataKey(listView, "lastID") + 1
		    guitk.BCSetUserDataKey(listView, "lastID", itemId)
		    guitk.BCListViewItemSetText(item, 0, str(itemId))
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def pmActivated(menu, id, data):
		    lineEdit, listView = data
		    if guitk.BCListViewHasSelected(listView) and guitk.BCLineEditHasText(lineEdit):
		        col = id + 1
		        if col == 1:
		            name = guitk.BCLineEditGetText(lineEdit)
		            guitk.BCListViewSelectedSetColumnText(listView, col, name)
		        elif col == 2:
		            quantity = guitk.BCLineEditGetInt(lineEdit)
		            if quantity == guitk.constants.blank:
		                quantity = 0
		            guitk.BCListViewSelectedSetColumnInt(listView, col, quantity)
		        elif col == 3:
		            price = guitk.BCLineEditGetDouble(lineEdit)
		            if price == guitk.constants.blank:
		                price = 0
		            guitk.BCListViewSelectedSetColumnDouble(listView, col, price)
		        guitk.BCListViewAdjustColumn(listView, col)
		    else:
		        print("Select item/s and insert value to the LineEdit first")
		    return 0
		
		
		def toggleMulRename(chkBox, state, listView):
		    guitk.BCListViewSetMultipleItemsRenameEnabled(listView, 1, state)
		    print(
		        "MultipleItemsRename for column=1 set to {}".format(
		            guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetMousePressedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when a mouse button is pressed on a ListView.
	WARNING: If you wish to delete a ListViewItem in funct, do so by using a Timer. If you don't use a Timer the result will be undefined.
	Mouse press and click events may change the selected item(s), a user activity discoverable using BCListViewSetSelectionChangedFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView whose mouse pressed function will be set.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_MOUSE_PRESSED_FUNCTION for details.
		integer BC_LISTVIEW_MOUSE_PRESSED_FUNCTION(lv, mb, item, col, data)
		The function to be called when a mouse button is pressed on a ListView.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		NOTE: Consider to check item existence since will be empty when mouse pressed on empty viewport area.
		
		Arguments
		          * lv : object
		                    the ListView.
		          * mb : int
		                    the mouse button pressed. See BCEnumButtonState for details.
		          * item : object
		                    the ListViewItem that is selected.
		          * col : int
		                    the ListViewItem column where button was pressed.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetMouseClickedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Destroy Selected", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    menu = guitk.BCPopupMenuCreate(listView)
		    guitk.BCPopupMenuInsertItem(menu, "Delete", DeleteSelectedItems, listView)
		    guitk.BCPopupMenuInsertSeparator(menu)
		    guitk.BCPopupMenuInsertItem(menu, "Update", None, None)
		    guitk.BCListViewSetMousePressedFunction(listView, ListViewMousePressed, menu)
		    guitk.BCShow(window)
		
		
		def DeleteSelectedItems(menu, id, listView):
		    # standard deletion with a single function as below
		    # guitk.BCListViewSelectedRemove(listView)
		    # or custom deletion with iteration
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    # silent mode (for example the selection change call back, if any, will not be triggerred)
		    guitk.BCBlockCallBackFunctions(listView, 1)
		    for item in items:
		        guitk.BCListViewItemDestroy(item)
		    guitk.BCBlockCallBackFunctions(listView, 0)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewMousePressed(listView, button, item, col, menu):
		    # do not popup on mouse button left or middle buttons
		    if button is not guitk.constants.BCRightButton:
		        return 0
		    # do not popup when press on empty viewport space
		    if not item:
		        return 0
		    guitk.BCPopupMenuPopup(menu)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetDoubleClickedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the user double clicks on the ListView.
	
	WARNING: If you wish to delete a ListViewItem in funct, do so by using a Timer. If you don't use a Timer the result will be undefined.
	In funct return 1 if you want to prevent item from expanding (expand) its children if any, otherwise return 0.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_DOUBLE_CLICK_FUNCTION for details.
		integer BC_LISTVIEW_DOUBLE_CLICK_FUNCTION(lv, item, col, data)
		The function to be called when the user double clicks on the list.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		NOTE: Consider to check item existence since will be empty when double clicking on empty viewport area.
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem under the mouse.
		          * col : int
		                    the ListView column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Return 1 if you want to prevent item from expanding its children (if any) otherwise return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetMousePressedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView DoubleClick Move Example", guitk.constants.BCOnExitDestroy
		    )
		    # Notice that we do not use sorting for moving to work
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 0
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    statusBar = guitk.BCStatusBarCreate(window)
		    lastDoubleClicked = [None]
		    guitk.BCListViewSetDoubleClickedFunction(
		        listView, moveAfterDoubleClicked, (lastDoubleClicked, statusBar)
		    )
		    guitk.BCStatusBarMessage(statusBar, "Double click an item to select it for moving")
		    guitk.BCShow(window)
		
		
		def moveAfterDoubleClicked(listView, item, col, data):
		    lastDoubleClicked, statusBar = data
		    if lastDoubleClicked[0]:
		        guitk.BCListViewItemMoveItem(lastDoubleClicked[0], item)
		        lastDoubleClicked[0] = None
		        guitk.BCStatusBarMessage(
		            statusBar, "Double click an item to select it for moving"
		        )
		    else:
		        lastDoubleClicked[0] = item
		        guitk.BCStatusBarMessage(
		            statusBar, "Double click an item to insert the selected after"
		        )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetDeletePressedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the 'Delete' key is pressed inside ListView.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_DELETE_PRESSED_FUNCTION for details.
		integer BC_LISTVIEW_DELETE_PRESSED_FUNCTION(lv, data)
		The function to be called whenever the user presses the DEL key in the list view.
		Delete key may change the selection at multi selection list view (when multiple items selected and Delete key pressed).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 to block the event otherwise return 0 (selection may change).

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Delete Pressed Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 0
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetDeletePressedFunction(listView, deleteSelected, None)
		    guitk.BCLabelCreate(window, "Pressing Delete Key will delete the selected item")
		    guitk.BCPushButtonCreate(window, "Clear List", clearList, listView)
		    guitk.BCShow(window)
		
		
		def clearList(b, listView):
		    guitk.BCListViewClear(listView)
		    return 0
		
		
		def deleteSelected(listView, data):
		    itemSelected = guitk.BCListViewGetSelectedItem(listView)
		    guitk.BCListViewSelectedRemove(listView)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewClear(lv: object) -> None:

	"""

	Removes and deletes all the items from the list view.
	NOTE: If at least one item is selected, the selection change call back will run.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Delete Pressed Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 0
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetDeletePressedFunction(listView, deleteSelected, None)
		    guitk.BCLabelCreate(window, "Pressing Delete Key will delete the selected item")
		    guitk.BCPushButtonCreate(window, "Clear List", clearList, listView)
		    guitk.BCShow(window)
		
		
		def clearList(b, listView):
		    guitk.BCListViewClear(listView)
		    return 0
		
		
		def deleteSelected(listView, data):
		    itemSelected = guitk.BCListViewGetSelectedItem(listView)
		    guitk.BCListViewSelectedRemove(listView)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetSelectionChangedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets a function that will be called when the selection in ListView lv changes.
	That is when items are selected/deselected. Selection may change on a user mouse button click, keyboard press or programmatically.
	WARNING: If you wish to delete a ListViewItem in funct, do so by using a Timer. If you don't use a Timer the result will be undefined.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called when selection changes. See BC_LISTVIEW_SELECTION_CHANGED_FUNCTION for details.
		integer BC_LISTVIEW_SELECTION_CHANGED_FUNCTION(lv, data)
		The function to be called when the selection in ListView lv changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemSelectedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Print Selection", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetSelectionChangedFunction(
		        listView, ListViewItemSelectionChanged, None
		    )
		    guitk.BCShow(window)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewItemSelectionChanged(listView, data):
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    print("Selected items")
		    for item in items:
		        print("ID = ", guitk.BCListViewItemGetText(item, 0))
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewAddColumn(lv: object, text: str, width: int) -> int:

	"""

	Adds a column with header text.
	If you set width -1, the column will be automatically adjusted on ListView show and on items insertion (BCMaximumMode).
	It is not a good practice to set a fixed column width (BCManualMode), since font size and header margins are style dependent.
	All columns (apart from the first one) are inserted at the right of the existing ones.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	text : str
		the text that will be displayed on the header.

	width : int
		the width in pixels. If you use -1 the width is set automatically.

	Returns
	-------
	int
		the index of the new column.

	See Also
	--------
	BCListViewRemoveColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Simple Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - Auto Width", -1)
		    guitk.BCListViewAddColumn(listView, "Part name - Fixed Width", 400)
		    guitk.BCListViewAddColumn(listView, "Version - Resize Disabled", -1)
		    guitk.BCListViewSetColumnResizeEnabled(listView, 2, False)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Resized", 50)
		    guitk.BCListViewSetColumnWidth(listView, 3, 500)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    btnPrintStats = guitk.BCPushButtonCreate(
		        window, "Print Column Stats", printStats, listView
		    )
		    guitk.BCListViewSetColumnMovedFunction(listView, columnMoved, None)
		    guitk.BCListViewSetColumnResizedFunction(listView, columnResized, None)
		    guitk.BCWindowSetAcceptFunction(window, printStats, listView)
		    guitk.BCShow(window)
		
		
		def printStats(_, listView):
		    for col in range(guitk.BCListViewColumns(listView)):
		        print(
		            "Column {}: width={}, position={}".format(
		                col,
		                guitk.BCListViewColumnWidth(listView, col),
		                guitk.BCListViewColumnPosition(listView, col),
		            )
		        )
		    return 0
		
		
		def columnMoved(listView, col, fromPos, toPos, data):
		    print("Column {} moved position from: {} to: {}".format(col, fromPos, toPos))
		    return 0
		
		
		def columnResized(listView, col, oldSize, newSize, data):
		    print("Column {} resized from: {} to: {}".format(col, oldSize, newSize))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnWidth(lv: object, col: int, width: int) -> None:

	"""

	Sets the width of column col to be width pixels.
	It is not a good practice to set a fixed column width (BCManualMode), since font size and header margins are style dependent.
	You can set mode (BCListViewSetColumnWidthMode) to BCMaximumMode for automatically adjust.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	width : int
		the new width of col.

	Returns
	-------
	None

	See Also
	--------
	BCListViewColumnWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Simple Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - Auto Width", -1)
		    guitk.BCListViewAddColumn(listView, "Part name - Fixed Width", 400)
		    guitk.BCListViewAddColumn(listView, "Version - Resize Disabled", -1)
		    guitk.BCListViewSetColumnResizeEnabled(listView, 2, False)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Resized", 50)
		    guitk.BCListViewSetColumnWidth(listView, 3, 500)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    btnPrintStats = guitk.BCPushButtonCreate(
		        window, "Print Column Stats", printStats, listView
		    )
		    guitk.BCListViewSetColumnMovedFunction(listView, columnMoved, None)
		    guitk.BCListViewSetColumnResizedFunction(listView, columnResized, None)
		    guitk.BCWindowSetAcceptFunction(window, printStats, listView)
		    guitk.BCShow(window)
		
		
		def printStats(_, listView):
		    for col in range(guitk.BCListViewColumns(listView)):
		        print(
		            "Column {}: width={}, position={}".format(
		                col,
		                guitk.BCListViewColumnWidth(listView, col),
		                guitk.BCListViewColumnPosition(listView, col),
		            )
		        )
		    return 0
		
		
		def columnMoved(listView, col, fromPos, toPos, data):
		    print("Column {} moved position from: {} to: {}".format(col, fromPos, toPos))
		    return 0
		
		
		def columnResized(listView, col, oldSize, newSize, data):
		    print("Column {} resized from: {} to: {}".format(col, oldSize, newSize))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewColumnWidth(lv: object, col: int) -> int:

	"""

	Returns the width of column col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	int
		the width of col.

	See Also
	--------
	BCListViewSetColumnWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Simple Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - Auto Width", -1)
		    guitk.BCListViewAddColumn(listView, "Part name - Fixed Width", 400)
		    guitk.BCListViewAddColumn(listView, "Version - Resize Disabled", -1)
		    guitk.BCListViewSetColumnResizeEnabled(listView, 2, False)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Resized", 50)
		    guitk.BCListViewSetColumnWidth(listView, 3, 500)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    btnPrintStats = guitk.BCPushButtonCreate(
		        window, "Print Column Stats", printStats, listView
		    )
		    guitk.BCListViewSetColumnMovedFunction(listView, columnMoved, None)
		    guitk.BCListViewSetColumnResizedFunction(listView, columnResized, None)
		    guitk.BCWindowSetAcceptFunction(window, printStats, listView)
		    guitk.BCShow(window)
		
		
		def printStats(_, listView):
		    for col in range(guitk.BCListViewColumns(listView)):
		        print(
		            "Column {}: width={}, position={}".format(
		                col,
		                guitk.BCListViewColumnWidth(listView, col),
		                guitk.BCListViewColumnPosition(listView, col),
		            )
		        )
		    return 0
		
		
		def columnMoved(listView, col, fromPos, toPos, data):
		    print("Column {} moved position from: {} to: {}".format(col, fromPos, toPos))
		    return 0
		
		
		def columnResized(listView, col, oldSize, newSize, data):
		    print("Column {} resized from: {} to: {}".format(col, oldSize, newSize))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHideColumn(lv: object, col: int) -> None:

	"""

	Hides the column specified by col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewShowColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Hide Column", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    # hide column on first show
		    guitk.BCListViewHideColumn(listView, 3)
		    # the user is able to modify columns visibility from a header button menu
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    # the user cannot hide from menu the column ID
		    guitk.BCListViewHeaderMenuBlockColumnVisibilityChange(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(
		        item, 0, guitk.constants.BCRenameType_None
		    )  # default
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewShowColumn(lv: object, col: int) -> None:

	"""

	Shows the column specified by col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewHideColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Hide/Remove Column Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    chkBoxHide2 = guitk.BCCheckBoxCreate(window, "Hide Column 2")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxHide2, hideColumn2, listView)
		
		    btnRemove3 = guitk.BCPushButtonCreate(
		        window, "Remove Column 3", removeColumn3, listView
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def hideColumn2(cb, state, listView):
		    guitk.BCListViewHideColumn(listView, 2) if state else guitk.BCListViewShowColumn(
		        listView, 2
		    )
		    return 0
		
		
		def removeColumn3(b, listView):
		    guitk.BCListViewRemoveColumn(listView, 3)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewRemoveColumn(lv: object, col: int) -> None:

	"""

	Removes the column specified by col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewAddColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Hide/Remove Column Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    chkBoxHide2 = guitk.BCCheckBoxCreate(window, "Hide Column 2")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxHide2, hideColumn2, listView)
		
		    btnRemove3 = guitk.BCPushButtonCreate(
		        window, "Remove Column 3", removeColumn3, listView
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def hideColumn2(cb, state, listView):
		    guitk.BCListViewHideColumn(listView, 2) if state else guitk.BCListViewShowColumn(
		        listView, 2
		    )
		    return 0
		
		
		def removeColumn3(b, listView):
		    guitk.BCListViewRemoveColumn(listView, 3)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnAlignment(lv: object, col: int, alignment: int) -> None:

	"""

	Sets the alignment of ListViewItems for column col to alignment.
	The standard item aligns text/icon left while widgets (check box, radio button and rect color) aligns at center.
	The function will iterate to all items applying the alignment (BCListViewItemSetContentsAlignment).
	Alignment applied to content type
	- text
	- icon only
	- check box
	- radio button
	- rectangle color
	- sibling colors
	NOTE: Alignment consist of horizontal and vertical components. If you only use the horizontal component (BCAlignLeft-BCAlignHCenter-BCAlignRight), 
	the BCAlignVCenter will be attached to ensure uniform behavior. 
	For example, if you apply BCAlignRight the applied value is actually the combination of BCAlignRight | BCAlignVCenter.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	alignment : int
		the alignment for the column col. It is an integer value that is composed of BCEnumAlignment OR'ed (i.e. added) together. 
		See BCEnumAlignment for details.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	"""

def BCListViewSetColumnWidthMode(lv: object, col: int, mode: int) -> None:

	"""

	Sets col column's width mode (how column width responds to contents change) to mode.
	BCManualMode does not automatically change column width. On BCMaximumMode mode the column adjust (on ListView show and on item insertion) to fit the largest item text.
	If column with index 0 has BCMaximumMode and you expand an item, it will adjust its width. Width mode is initialised when adding columns (BCListViewAddColumn()).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	mode : int
		the width mode. See BCEnumWidthMode for details.
		
		guitk.constants BCEnumWidthMode
		This enum describes how the width of a column in a ListView changes.
		 - guitk.constants.BCManualMode
		The column width does not change automatically.
		 - guitk.constants.BCMaximumMode
		The column is always resized to the width of the item with the largest width in the column.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetColumnAlignment

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView ColumnWidthMode Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - ManualMode", 400)
		    # Using width -1 sets the column to Width Mode = Auto
		    guitk.BCListViewAddColumn(listView, "Part name - MaximumMode", -1)
		    guitk.BCListViewAddColumn(listView, "Version - Maximum to Manual", -1)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Adjusted", 10)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetColumnWidth(listView, 0, 100)
		    # The line below doesn't work because ColumnWidthMode is set to Auto on ListViewAddColumn
		    guitk.BCListViewSetColumnWidth(listView, 1, 100)
		    # Width Mode has to be changed to manual to set a custom width
		    guitk.BCListViewSetColumnWidthMode(listView, 2, guitk.constants.BCManualMode)
		    guitk.BCListViewSetColumnWidth(listView, 2, 40)
		    guitk.BCListViewAdjustColumn(listView, 3)  # Manual can also be adjusted
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetMultipleItemsRenameEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Set whether ListView lv enables multiple items renaming for column col.
	If this property is enabled, then the user can select multiple items and if succesfully rename one
	of them, then all renamable non disabled selected items in same column, will get the same text value.
	The default listview column has this property false.
	This property only has a meaning for multi selection lists.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	enable : bool
		set 1 to enable or 0 to disable multiple items rename property.

	Returns
	-------
	None

	See Also
	--------
	BCListViewIsMultipleItemsRenameEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SetColumn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Name", "Quantity", "Price"], False
		    )
		    guitk.BCSetUserDataKey(listView, "lastID", 0)
		    for i in range(20):
		        addEmptyItem(listView)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    hBox = guitk.BCHBoxCreate(window)
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "New selected item's text.")
		    btn = guitk.BCPushButtonCreate(hBox, "Set Column", None, None)
		    menu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCPopupMenuInsertItem(menu, "Name", None, None)  # id 0 -> col 1
		    guitk.BCPopupMenuInsertItem(menu, "Quantity", None, None)  # id 1 -> col 2
		    guitk.BCPopupMenuInsertItem(menu, "Price", None, None)  # id 2 -> col 3
		    guitk.BCButtonSetPopup(btn, menu)
		    multipleChkBox = guitk.BCCheckBoxCreate(
		        window, "ListView Multiple Rename For column 'Name'"
		    )
		    guitk.BCCheckBoxSetChecked(
		        multipleChkBox, guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		    )
		    guitk.BCCheckBoxSetToggledFunction(multipleChkBox, toggleMulRename, listView)
		    guitk.BCPopupMenuSetActivatedFunction(menu, pmActivated, (lineEdit, listView))
		    guitk.BCShow(window)
		
		
		def addEmptyItem(listView):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    itemId = guitk.BCGetUserDataKey(listView, "lastID") + 1
		    guitk.BCSetUserDataKey(listView, "lastID", itemId)
		    guitk.BCListViewItemSetText(item, 0, str(itemId))
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def pmActivated(menu, id, data):
		    lineEdit, listView = data
		    if guitk.BCListViewHasSelected(listView) and guitk.BCLineEditHasText(lineEdit):
		        col = id + 1
		        if col == 1:
		            name = guitk.BCLineEditGetText(lineEdit)
		            guitk.BCListViewSelectedSetColumnText(listView, col, name)
		        elif col == 2:
		            quantity = guitk.BCLineEditGetInt(lineEdit)
		            if quantity == guitk.constants.blank:
		                quantity = 0
		            guitk.BCListViewSelectedSetColumnInt(listView, col, quantity)
		        elif col == 3:
		            price = guitk.BCLineEditGetDouble(lineEdit)
		            if price == guitk.constants.blank:
		                price = 0
		            guitk.BCListViewSelectedSetColumnDouble(listView, col, price)
		        guitk.BCListViewAdjustColumn(listView, col)
		    else:
		        print("Select item/s and insert value to the LineEdit first")
		    return 0
		
		
		def toggleMulRename(chkBox, state, listView):
		    guitk.BCListViewSetMultipleItemsRenameEnabled(listView, 1, state)
		    print(
		        "MultipleItemsRename for column=1 set to {}".format(
		            guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewInvertSelection(lv: object) -> None:

	"""

	Inverts the current item selection on ListView. Turns selected items to unselected and vice versa.
	If ListView is single selection nothing happen.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Selected Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    for i in range(1, guitk.BCListViewColumns(listView)):
		        guitk.BCListViewSetSelectableColumn(listView, i, False)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Click item on ID column or press Space to select an item.",
		    )
		    if guitk.BCListViewGetSelectionMode(listView) != guitk.constants.BCMulti:
		        guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, printIsSelected, None)
		    guitk.BCListViewRestoreSortState(listView)
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnReverse = guitk.BCPushButtonCreate(
		        hBox1, "Reverse Selection", reverseSelectionAll, listView
		    )
		    btnAll = guitk.BCPushButtonCreate(
		        hBox1,
		        "Select All",
		        lambda b, listView: guitk.BCListViewSelectAll(listView),
		        listView,
		    )
		    btnClear = guitk.BCPushButtonCreate(
		        hBox1,
		        "Clear Selection",
		        lambda b, listView: guitk.BCListViewClearSelection(listView),
		        listView,
		    )
		    guitk.BCShow(window)
		
		
		def printIsSelected(listView, item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " isSelected = "
		        + str(guitk.BCListViewIsSelected(listView, item))
		    )
		    return 0
		
		
		def reverseSelectionAll(b, listView):
		    guitk.BCListViewInvertSelection(listView)
		    print("New Selected Count = {}".format(guitk.BCListViewCountSelected(listView)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetBold(item: object, enable: bool) -> None:

	"""

	Sets the font of ListViewItem item to bold if enable is 1 or to normal if enable is 0.
	This function affects all columns of item. By default a ListViewItem is painted non-bold.
	WARNING: There are some fonts that do not support bold style at all. In these case nothing will happen.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	enable : bool
		use True to set current font to bold and False to unset.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemBold

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part Name", "Bold", 'Bold ("Part Name" only)', "Italic", "Strike Out"],
		        0,
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createCheckBox, None
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createCheckBox(item, data):
		    guitk.BCListViewItemSetCheckBox(item, 2, True, setBoldFunct, None)
		    guitk.BCListViewItemSetBold(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 3, True, setColumnBoldFunct, None)
		    guitk.BCListViewItemColumnSetBold(item, 0, True)
		    guitk.BCListViewItemSetCheckBox(item, 4, True, setItalicFunct, None)
		    guitk.BCListViewItemSetItalic(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 5, True, strikeOutFunct, None)
		    guitk.BCListViewItemSetStrikeOut(item, True)
		    return 0
		
		
		def setBoldFunct(item, col, state, data):
		    guitk.BCListViewItemSetBold(item, state)
		    print("Is Item bold? " + str(guitk.BCListViewItemBold(item)))
		    return 0
		
		
		def setItalicFunct(item, col, state, data):
		    guitk.BCListViewItemSetItalic(item, state)
		    print("Is Item italic? " + str(guitk.BCListViewItemItalic(item)))
		    return 0
		
		
		def strikeOutFunct(item, col, state, data):
		    guitk.BCListViewItemSetStrikeOut(item, state)
		    print("Is Item strike out? " + str(guitk.BCListViewItemStrikeOut(item)))
		    return 0
		
		
		def setColumnBoldFunct(item, col, state, data):
		    guitk.BCListViewItemColumnSetBold(item, 1, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemBold(item: object) -> bool:

	"""

	Returns True if item item is painted in bold font or False otherwise.
	WARNING: There are some fonts that do not support bold fonts at all. In these cases you will not get what you see.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if item is painted in bold font, False otherwise.

	See Also
	--------
	BCListViewItemSetBold

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part Name", "Bold", 'Bold ("Part Name" only)', "Italic", "Strike Out"],
		        0,
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createCheckBox, None
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createCheckBox(item, data):
		    guitk.BCListViewItemSetCheckBox(item, 2, True, setBoldFunct, None)
		    guitk.BCListViewItemSetBold(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 3, True, setColumnBoldFunct, None)
		    guitk.BCListViewItemColumnSetBold(item, 0, True)
		    guitk.BCListViewItemSetCheckBox(item, 4, True, setItalicFunct, None)
		    guitk.BCListViewItemSetItalic(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 5, True, strikeOutFunct, None)
		    guitk.BCListViewItemSetStrikeOut(item, True)
		    return 0
		
		
		def setBoldFunct(item, col, state, data):
		    guitk.BCListViewItemSetBold(item, state)
		    print("Is Item bold? " + str(guitk.BCListViewItemBold(item)))
		    return 0
		
		
		def setItalicFunct(item, col, state, data):
		    guitk.BCListViewItemSetItalic(item, state)
		    print("Is Item italic? " + str(guitk.BCListViewItemItalic(item)))
		    return 0
		
		
		def strikeOutFunct(item, col, state, data):
		    guitk.BCListViewItemSetStrikeOut(item, state)
		    print("Is Item strike out? " + str(guitk.BCListViewItemStrikeOut(item)))
		    return 0
		
		
		def setColumnBoldFunct(item, col, state, data):
		    guitk.BCListViewItemColumnSetBold(item, 1, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemColumnSetBold(item: object, col: int, enable: bool) -> None:

	"""

	Sets the font of ListViewItem item column col to bold if enable is 1 or to normal if enable is 0 (default).
	WARNING: There are some fonts that do not support bold style at all. In these case nothing will happen.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	enable : bool
		use True to set current font to bold and False to unset.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetBold

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part Name", "Bold", 'Bold ("Part Name" only)', "Italic", "Strike Out"],
		        0,
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createCheckBox, None
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createCheckBox(item, data):
		    guitk.BCListViewItemSetCheckBox(item, 2, True, setBoldFunct, None)
		    guitk.BCListViewItemSetBold(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 3, True, setColumnBoldFunct, None)
		    guitk.BCListViewItemColumnSetBold(item, 0, True)
		    guitk.BCListViewItemSetCheckBox(item, 4, True, setItalicFunct, None)
		    guitk.BCListViewItemSetItalic(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 5, True, strikeOutFunct, None)
		    guitk.BCListViewItemSetStrikeOut(item, True)
		    return 0
		
		
		def setBoldFunct(item, col, state, data):
		    guitk.BCListViewItemSetBold(item, state)
		    print("Is Item bold? " + str(guitk.BCListViewItemBold(item)))
		    return 0
		
		
		def setItalicFunct(item, col, state, data):
		    guitk.BCListViewItemSetItalic(item, state)
		    print("Is Item italic? " + str(guitk.BCListViewItemItalic(item)))
		    return 0
		
		
		def strikeOutFunct(item, col, state, data):
		    guitk.BCListViewItemSetStrikeOut(item, state)
		    print("Is Item strike out? " + str(guitk.BCListViewItemStrikeOut(item)))
		    return 0
		
		
		def setColumnBoldFunct(item, col, state, data):
		    guitk.BCListViewItemColumnSetBold(item, 1, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetItalic(item: object, enable: bool) -> None:

	"""

	Sets the font of ListViewItem item to italic if enable is 1 or to normal if enable is 0 (default).
	This function affects item in all columns. 
	WARNING: There are some fonts that do not support italic style at all. In these case nothing will happen.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	enable : bool
		use True to set current font to italic and False to unset.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemItalic

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part Name", "Bold", 'Bold ("Part Name" only)', "Italic", "Strike Out"],
		        0,
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createCheckBox, None
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createCheckBox(item, data):
		    guitk.BCListViewItemSetCheckBox(item, 2, True, setBoldFunct, None)
		    guitk.BCListViewItemSetBold(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 3, True, setColumnBoldFunct, None)
		    guitk.BCListViewItemColumnSetBold(item, 0, True)
		    guitk.BCListViewItemSetCheckBox(item, 4, True, setItalicFunct, None)
		    guitk.BCListViewItemSetItalic(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 5, True, strikeOutFunct, None)
		    guitk.BCListViewItemSetStrikeOut(item, True)
		    return 0
		
		
		def setBoldFunct(item, col, state, data):
		    guitk.BCListViewItemSetBold(item, state)
		    print("Is Item bold? " + str(guitk.BCListViewItemBold(item)))
		    return 0
		
		
		def setItalicFunct(item, col, state, data):
		    guitk.BCListViewItemSetItalic(item, state)
		    print("Is Item italic? " + str(guitk.BCListViewItemItalic(item)))
		    return 0
		
		
		def strikeOutFunct(item, col, state, data):
		    guitk.BCListViewItemSetStrikeOut(item, state)
		    print("Is Item strike out? " + str(guitk.BCListViewItemStrikeOut(item)))
		    return 0
		
		
		def setColumnBoldFunct(item, col, state, data):
		    guitk.BCListViewItemColumnSetBold(item, 1, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemItalic(item: object) -> bool:

	"""

	Returns True if ListViewItem item is painted in italic font or False otherwise.
	WARNING: There are some fonts that do not support italic fonts at all. In these cases you will not get what you see.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if item is painted in italic font, False otherwise.

	See Also
	--------
	BCListViewItemSetItalic

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part Name", "Bold", 'Bold ("Part Name" only)', "Italic", "Strike Out"],
		        0,
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createCheckBox, None
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createCheckBox(item, data):
		    guitk.BCListViewItemSetCheckBox(item, 2, True, setBoldFunct, None)
		    guitk.BCListViewItemSetBold(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 3, True, setColumnBoldFunct, None)
		    guitk.BCListViewItemColumnSetBold(item, 0, True)
		    guitk.BCListViewItemSetCheckBox(item, 4, True, setItalicFunct, None)
		    guitk.BCListViewItemSetItalic(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 5, True, strikeOutFunct, None)
		    guitk.BCListViewItemSetStrikeOut(item, True)
		    return 0
		
		
		def setBoldFunct(item, col, state, data):
		    guitk.BCListViewItemSetBold(item, state)
		    print("Is Item bold? " + str(guitk.BCListViewItemBold(item)))
		    return 0
		
		
		def setItalicFunct(item, col, state, data):
		    guitk.BCListViewItemSetItalic(item, state)
		    print("Is Item italic? " + str(guitk.BCListViewItemItalic(item)))
		    return 0
		
		
		def strikeOutFunct(item, col, state, data):
		    guitk.BCListViewItemSetStrikeOut(item, state)
		    print("Is Item strike out? " + str(guitk.BCListViewItemStrikeOut(item)))
		    return 0
		
		
		def setColumnBoldFunct(item, col, state, data):
		    guitk.BCListViewItemColumnSetBold(item, 1, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetStrikeOut(item: object, enable: bool) -> None:

	"""

	Sets/unsets the text to drawn with a horizontal line through the center of it.
	This function affects item in all columns. A ListViewItem is painted by default with non-strike out font.
	WARNING: There are some fonts that do not support strike out style at all. In these case nothing will happen.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	enable : bool
		True to strike out text and False to unset.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemStrikeOut

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part Name", "Bold", 'Bold ("Part Name" only)', "Italic", "Strike Out"],
		        0,
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createCheckBox, None
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createCheckBox(item, data):
		    guitk.BCListViewItemSetCheckBox(item, 2, True, setBoldFunct, None)
		    guitk.BCListViewItemSetBold(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 3, True, setColumnBoldFunct, None)
		    guitk.BCListViewItemColumnSetBold(item, 0, True)
		    guitk.BCListViewItemSetCheckBox(item, 4, True, setItalicFunct, None)
		    guitk.BCListViewItemSetItalic(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 5, True, strikeOutFunct, None)
		    guitk.BCListViewItemSetStrikeOut(item, True)
		    return 0
		
		
		def setBoldFunct(item, col, state, data):
		    guitk.BCListViewItemSetBold(item, state)
		    print("Is Item bold? " + str(guitk.BCListViewItemBold(item)))
		    return 0
		
		
		def setItalicFunct(item, col, state, data):
		    guitk.BCListViewItemSetItalic(item, state)
		    print("Is Item italic? " + str(guitk.BCListViewItemItalic(item)))
		    return 0
		
		
		def strikeOutFunct(item, col, state, data):
		    guitk.BCListViewItemSetStrikeOut(item, state)
		    print("Is Item strike out? " + str(guitk.BCListViewItemStrikeOut(item)))
		    return 0
		
		
		def setColumnBoldFunct(item, col, state, data):
		    guitk.BCListViewItemColumnSetBold(item, 1, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemStrikeOut(item: object) -> bool:

	"""

	Returns True if ListViewItem item is strike out (horizontal line through the center of it) or False otherwise (default).
	WARNING: There are some fonts that do not support strike out at all. In these cases you will not get what you see.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if item text is strike out, False otherwise.

	See Also
	--------
	BCListViewItemSetStrikeOut

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part Name", "Bold", 'Bold ("Part Name" only)', "Italic", "Strike Out"],
		        0,
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createCheckBox, None
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createCheckBox(item, data):
		    guitk.BCListViewItemSetCheckBox(item, 2, True, setBoldFunct, None)
		    guitk.BCListViewItemSetBold(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 3, True, setColumnBoldFunct, None)
		    guitk.BCListViewItemColumnSetBold(item, 0, True)
		    guitk.BCListViewItemSetCheckBox(item, 4, True, setItalicFunct, None)
		    guitk.BCListViewItemSetItalic(item, True)
		    guitk.BCListViewItemSetCheckBox(item, 5, True, strikeOutFunct, None)
		    guitk.BCListViewItemSetStrikeOut(item, True)
		    return 0
		
		
		def setBoldFunct(item, col, state, data):
		    guitk.BCListViewItemSetBold(item, state)
		    print("Is Item bold? " + str(guitk.BCListViewItemBold(item)))
		    return 0
		
		
		def setItalicFunct(item, col, state, data):
		    guitk.BCListViewItemSetItalic(item, state)
		    print("Is Item italic? " + str(guitk.BCListViewItemItalic(item)))
		    return 0
		
		
		def strikeOutFunct(item, col, state, data):
		    guitk.BCListViewItemSetStrikeOut(item, state)
		    print("Is Item strike out? " + str(guitk.BCListViewItemStrikeOut(item)))
		    return 0
		
		
		def setColumnBoldFunct(item, col, state, data):
		    guitk.BCListViewItemColumnSetBold(item, 1, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetForegroundColor(item: object, mode: int, r: int, g: int, b: int) -> None:

	"""

	Sets a foreground (text) color to a ListViewItem.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose foreground color will be changed.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	r : int
		the value of RED of the RGB foreground color.

	g : int
		the value of GREEN of the RGB foreground color.

	b : int
		the value of BLUE of the RGB foreground color.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetBackgroundColor(item: object, mode: int, r: int, g: int, b: int) -> None:

	"""

	Sets a custom background color to a ListViewItem.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose background color will be changed.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	r : int
		the value of RED of the RGB background color.

	g : int
		the value of GREEN of the RGB background color.

	b : int
		the value of BLUE of the RGB background color.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetForegroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemResetForegroundColor(item: object, mode: int) -> None:

	"""

	Resets the foreground color of a ListViewItem to the default one.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose foreground color will be reset. The new color will be in accordance with the colors of the parent ListView.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemResetBackgroundColor(item: object, mode: int) -> None:

	"""

	Resets the background color of a ListViewItem to the default one.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose background color will be reset. The new color will be in accordance with the colors of the parent ListView.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetEnabled(item: object, enabled: bool) -> None:

	"""

	Enables or disables the ListViewItem item.
	The default ListViewItem is enabled.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	enabled : bool
		set to False if you want to disable the item, otherwise True.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Inactive and Disabled Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Item Description"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    itemInactive = addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewItemSetInactive(itemInactive, True)
		    guitk.BCListViewItemSetText(itemInactive, 4, "Inactive item")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    itemDisabled = addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewItemSetEnabled(itemDisabled, False)
		    guitk.BCListViewItemSetText(itemDisabled, 4, "Disabled item")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, None)
		    guitk.BCListViewSetItemDeselectedFunction(listView, itemDeselected, None)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, printInactiveEnabled, None
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printInactiveEnabled(item, data):
		    print(
		        "Item ID={}: isInactive = {}, isEnabled = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemInactive(item),
		            guitk.BCListViewItemIsEnabled(item),
		        )
		    )
		    return 0
		
		
		def itemSelected(listView, item, data):
		    print(
		        "--------------\\nItem ID={} Selected!".format(
		            guitk.BCListViewItemGetText(item, 0)
		        )
		    )
		    return 0
		
		
		def itemDeselected(listView, item, data):
		    print("Item ID={} Deselected!".format(guitk.BCListViewItemGetText(item, 0)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetText(item, 4, "Regular Item")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsEnabled(item: object) -> bool:

	"""

	Informs the user whether the ListViewItem item is enabled or not.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if the item is enabled or False if it is disabled.

	See Also
	--------
	BCListViewItemSetEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Inactive and Disabled Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Item Description"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    itemInactive = addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewItemSetInactive(itemInactive, True)
		    guitk.BCListViewItemSetText(itemInactive, 4, "Inactive item")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    itemDisabled = addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewItemSetEnabled(itemDisabled, False)
		    guitk.BCListViewItemSetText(itemDisabled, 4, "Disabled item")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, None)
		    guitk.BCListViewSetItemDeselectedFunction(listView, itemDeselected, None)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, printInactiveEnabled, None
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printInactiveEnabled(item, data):
		    print(
		        "Item ID={}: isInactive = {}, isEnabled = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemInactive(item),
		            guitk.BCListViewItemIsEnabled(item),
		        )
		    )
		    return 0
		
		
		def itemSelected(listView, item, data):
		    print(
		        "--------------\\nItem ID={} Selected!".format(
		            guitk.BCListViewItemGetText(item, 0)
		        )
		    )
		    return 0
		
		
		def itemDeselected(listView, item, data):
		    print("Item ID={} Deselected!".format(guitk.BCListViewItemGetText(item, 0)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetText(item, 4, "Regular Item")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetRenamedFunction(item: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when renaming of a column of ListViewItem item is completed (data have been committed).
	Use view oriented BCListViewSetRenameItemFinishedFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	funct : Callable
		the function that will be called. See BC_LISTVIEWITEM_RENAMED_FUNCTION for details.
		integer BC_LISTVIEWITEM_RENAMED_FUNCTION(item, col, data)
		The function to be called when renaming of a column of item is completed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetRenameItemFinishedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Rename Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    chkBox = guitk.BCCheckBoxCreate(window, "Set DirectOnClicked Rename")
		    guitk.BCCheckBoxSetToggledFunction(chkBox, setDirectRename, listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetButton(item, 2, startRenameName, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 2, "edit_small.svg")
		    guitk.BCListViewItemSetText(item, 3, version)
		    guitk.BCListViewItemSetText(item, 4, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 4, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetAboutToRenameFunction(item, itemAboutToRename, None)
		    guitk.BCListViewItemSetRenameCanceledFunction(item, itemRenameCanceled, None)
		    guitk.BCListViewItemSetRenamedFunction(item, itemRenamed, None)
		    return item
		
		
		def startRenameName(item, col, data):
		    guitk.BCListViewStartRename(guitk.BCListViewItemGetListView(item), item, 1)
		    return 0
		
		
		def itemAboutToRename(item, col, data):
		    print(
		        "Item ID={}, column={} about to be renamed.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenameCanceled(item, col, data):
		    print(
		        "Item ID={}, column={} rename canceled.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenamed(item, col, data):
		    print(
		        "Item ID={}, column={} renamed. New Name: '{}'".format(
		            guitk.BCListViewItemGetText(item, 0),
		            col,
		            guitk.BCListViewItemGetText(item, col),
		        )
		    )
		    guitk.BCListViewItemSetUserData(item, col)
		    return 0
		
		
		def setDirectRename(chkBox, state, listView):
		    guitk.BCListViewSetRenameItemMode(
		        listView,
		        guitk.constants.BCDirectOnClicked
		        if state
		        else guitk.constants.BCDelayedOnSelectedClicked,
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetRenameCanceledFunction(item: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when renaming of a column of ListViewItem item has been canceled.
	Use view oriented BCListViewSetRenameItemFinishedFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	funct : Callable
		the function that will be called. See BC_LISTVIEWITEM_RENAME_CANCELED_FUNCTION for details.
		integer BC_LISTVIEWITEM_RENAME_CANCELED_FUNCTION(item, col, data)
		The function to be called when renaming of a column of item is canceled.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetRenameItemFinishedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Rename Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    chkBox = guitk.BCCheckBoxCreate(window, "Set DirectOnClicked Rename")
		    guitk.BCCheckBoxSetToggledFunction(chkBox, setDirectRename, listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetButton(item, 2, startRenameName, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 2, "edit_small.svg")
		    guitk.BCListViewItemSetText(item, 3, version)
		    guitk.BCListViewItemSetText(item, 4, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 4, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetAboutToRenameFunction(item, itemAboutToRename, None)
		    guitk.BCListViewItemSetRenameCanceledFunction(item, itemRenameCanceled, None)
		    guitk.BCListViewItemSetRenamedFunction(item, itemRenamed, None)
		    return item
		
		
		def startRenameName(item, col, data):
		    guitk.BCListViewStartRename(guitk.BCListViewItemGetListView(item), item, 1)
		    return 0
		
		
		def itemAboutToRename(item, col, data):
		    print(
		        "Item ID={}, column={} about to be renamed.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenameCanceled(item, col, data):
		    print(
		        "Item ID={}, column={} rename canceled.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenamed(item, col, data):
		    print(
		        "Item ID={}, column={} renamed. New Name: '{}'".format(
		            guitk.BCListViewItemGetText(item, 0),
		            col,
		            guitk.BCListViewItemGetText(item, col),
		        )
		    )
		    guitk.BCListViewItemSetUserData(item, col)
		    return 0
		
		
		def setDirectRename(chkBox, state, listView):
		    guitk.BCListViewSetRenameItemMode(
		        listView,
		        guitk.constants.BCDirectOnClicked
		        if state
		        else guitk.constants.BCDelayedOnSelectedClicked,
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetIconFileName(item: object, col: int, fileName: str) -> None:

	"""

	Sets the icon that is displayed on column col of item to be the one specified by fileName.
	Icons are always displayed on the left of text.
	If an empty string is passed into this function, the icon is cleared.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemHasIcon

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Icon And ToolTip", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    item = addPart(listView, "1001", "Bumper", "67", "23.5")
		    item = addPart(listView, "1002", "Decklid", "4", "0.9")
		    guitk.BCListViewItemSetIconFileName(item, 2, "warning_small.svg")
		    guitk.BCListViewItemSetToolTip(item, 2, "Quantity is very low")
		    item = addPart(listView, "1003", "Pillar", "254", "12.2")
		    item = addPart(listView, "1004", "Roof rack", "14", "6.75")
		    guitk.BCListViewItemSetIconFileName(item, 2, "warning_small.svg")
		    guitk.BCListViewItemSetToolTip(item, 2, "Quantity is very low")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    # whitespace (empty_small.svg) used for correct alignment of icons
		    guitk.BCListViewItemSetIconFileName(item, 2, "empty_small.svg")
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemHasIcon(item: object, col: int) -> bool:

	"""

	Returns True if item has icon at column col, False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		False if there is no icon (default) at column col, True otherwise.

	See Also
	--------
	BCListViewItemSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item Has Icon Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    item = addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewItemSetIconFileName(item, 1, "logo_sdm.svg")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    item = addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewItemSetIconFileName(item, 1, "logo_sdm.svg")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, printItemHasIcon, None
		    )
		    guitk.BCShow(window)
		
		
		def printItemHasIcon(item, data):
		    itemId = guitk.BCListViewItemGetText(item, 0)
		    print(
		        "Item ID={}, column=1, has icon = {}".format(
		            itemId, guitk.BCListViewItemHasIcon(item, 1)
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetCheckable(item: object, checkable: bool) -> None:

	"""

	Sets whether the ListViewItem is user checkable, i.e provides a check box next to the item's text for column index 0.
	The standard item is not checkable.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	checkable : bool
		True sets item to be checkable, False sets it to be non checkable.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Checkable", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetEnterPressedFunction(listView, enterPressed, None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def enterPressed(listView, item, data):
		    if guitk.BCListViewItemIsCheckable(item):
		        isOn = guitk.BCListViewItemCheckableIsOn(item)
		        guitk.BCListViewItemCheckableSetOn(item, not isOn)
		    return 0
		
		
		def itemToggled(item, state, data):
		    strState = "off to on" if state else "on to off"
		    print(
		        "Checkable Item with ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + " toggled from "
		        + strState
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Set item Checkable
		    guitk.BCListViewItemSetCheckable(item, True)
		    guitk.BCListViewItemCheckableSetToggledFunction(item, itemToggled, None)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsCheckable(item: object) -> bool:

	"""

	Returns True if item is checkable, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True or False depending on the checkable state of item.

	See Also
	--------
	BCListViewItemSetCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Checkable", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetEnterPressedFunction(listView, enterPressed, None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def enterPressed(listView, item, data):
		    if guitk.BCListViewItemIsCheckable(item):
		        isOn = guitk.BCListViewItemCheckableIsOn(item)
		        guitk.BCListViewItemCheckableSetOn(item, not isOn)
		    return 0
		
		
		def itemToggled(item, state, data):
		    strState = "off to on" if state else "on to off"
		    print(
		        "Checkable Item with ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + " toggled from "
		        + strState
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Set item Checkable
		    guitk.BCListViewItemSetCheckable(item, True)
		    guitk.BCListViewItemCheckableSetToggledFunction(item, itemToggled, None)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckableSetOn(item: object, on: bool) -> None:

	"""

	Sets the ListViewItem checkable to be checked or unchecked, depending on the value of on.
	If item is not checkable nothing happens.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	on : bool
		True sets item to checked, False sets it to unchecked.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Checkable", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetEnterPressedFunction(listView, enterPressed, None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def enterPressed(listView, item, data):
		    if guitk.BCListViewItemIsCheckable(item):
		        isOn = guitk.BCListViewItemCheckableIsOn(item)
		        guitk.BCListViewItemCheckableSetOn(item, not isOn)
		    return 0
		
		
		def itemToggled(item, state, data):
		    strState = "off to on" if state else "on to off"
		    print(
		        "Checkable Item with ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + " toggled from "
		        + strState
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Set item Checkable
		    guitk.BCListViewItemSetCheckable(item, True)
		    guitk.BCListViewItemCheckableSetToggledFunction(item, itemToggled, None)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckableIsOn(item: object) -> bool:

	"""

	Returns True if item is checked, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True or False depending on the state of item.

	See Also
	--------
	BCListViewItemCheckableSetOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Checkable", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetEnterPressedFunction(listView, enterPressed, None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def enterPressed(listView, item, data):
		    if guitk.BCListViewItemIsCheckable(item):
		        isOn = guitk.BCListViewItemCheckableIsOn(item)
		        guitk.BCListViewItemCheckableSetOn(item, not isOn)
		    return 0
		
		
		def itemToggled(item, state, data):
		    strState = "off to on" if state else "on to off"
		    print(
		        "Checkable Item with ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + " toggled from "
		        + strState
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Set item Checkable
		    guitk.BCListViewItemSetCheckable(item, True)
		    guitk.BCListViewItemCheckableSetToggledFunction(item, itemToggled, None)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckableSetToggledFunction(item: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when checkable ListViewItem item check state change.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the checkable ListViewItem.

	funct : Callable
		the function that is called. See BC_LISTVIEWITEM_CHECKABLE_TOGGLED_FUNCTION for details.
		integer BC_LISTVIEWITEM_CHECKABLE_TOGGLED_FUNCTION(item, state, data)
		The function to be called when checkable ListViewItem item is checked or unchecked.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the checkable ListViewItem.
		          * state : int
		                    the toggle state information: 1 when the BCPushButton is on (i.e. toggled); 0 otherwise.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Checkable", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetEnterPressedFunction(listView, enterPressed, None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def enterPressed(listView, item, data):
		    if guitk.BCListViewItemIsCheckable(item):
		        isOn = guitk.BCListViewItemCheckableIsOn(item)
		        guitk.BCListViewItemCheckableSetOn(item, not isOn)
		    return 0
		
		
		def itemToggled(item, state, data):
		    strState = "off to on" if state else "on to off"
		    print(
		        "Checkable Item with ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + " toggled from "
		        + strState
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Set item Checkable
		    guitk.BCListViewItemSetCheckable(item, True)
		    guitk.BCListViewItemCheckableSetToggledFunction(item, itemToggled, None)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetItemAbove(item: object) -> object:

	"""

	Returns the ListViewItem above item or None if there is no ListViewItem above.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	object
		The ListViewItem above item.

	See Also
	--------
	BCListViewItemGetItemBelow

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Get Neighbouring Items Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], True)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    # Begin adding items
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Pentagon", "5")
		    quadItem = addShapeGroup(listView, "Quadrilateral", "4")
		    addShape(quadItem, "Parallelogram", "4")
		    addShape(quadItem, "Tangential", "4")
		    triaItem = addShapeGroup(listView, "Triangle", "3")
		    addShape(triaItem, "Acute", "3")
		    addShape(triaItem, "Equilateral", "3")
		    addShape(triaItem, "Isosceles", "3")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    statusLabel = guitk.BCLabelCreate(window, "")
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, statusLabel)
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def itemSelected(listView, item, label):
		    # Note that you can retrieve neighbouring items
		    parent = guitk.BCListViewItemGetParent(item)
		    firstChild = guitk.BCListViewItemGetFirstChild(item)
		    above = guitk.BCListViewItemGetItemAbove(item)
		    below = guitk.BCListViewItemGetItemBelow(item)
		    root = guitk.BCListViewItemRoot(item)
		    text = "SelectedItem: " + guitk.BCListViewItemGetText(item, 0)
		    text += "\\nDepth: " + str(guitk.BCListViewItemDepth(item))
		    text += "\\nChildCount: " + str(guitk.BCListViewItemChildCount(item))
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemGetItemBelow(item: object) -> object:

	"""

	Returns the ListViewItem below item or None if there is no ListViewItem below.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	object
		The ListViewItem below item.

	See Also
	--------
	BCListViewItemGetItemAbove

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Get Neighbouring Items Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], True)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    # Begin adding items
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Pentagon", "5")
		    quadItem = addShapeGroup(listView, "Quadrilateral", "4")
		    addShape(quadItem, "Parallelogram", "4")
		    addShape(quadItem, "Tangential", "4")
		    triaItem = addShapeGroup(listView, "Triangle", "3")
		    addShape(triaItem, "Acute", "3")
		    addShape(triaItem, "Equilateral", "3")
		    addShape(triaItem, "Isosceles", "3")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    statusLabel = guitk.BCLabelCreate(window, "")
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, statusLabel)
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def itemSelected(listView, item, label):
		    # Note that you can retrieve neighbouring items
		    parent = guitk.BCListViewItemGetParent(item)
		    firstChild = guitk.BCListViewItemGetFirstChild(item)
		    above = guitk.BCListViewItemGetItemAbove(item)
		    below = guitk.BCListViewItemGetItemBelow(item)
		    root = guitk.BCListViewItemRoot(item)
		    text = "SelectedItem: " + guitk.BCListViewItemGetText(item, 0)
		    text += "\\nDepth: " + str(guitk.BCListViewItemDepth(item))
		    text += "\\nChildCount: " + str(guitk.BCListViewItemChildCount(item))
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemEnsureVisible(item: object) -> None:

	"""

	Ensures that item item is visible.
	This means scrolling the ListView vertically if necessary and opening (expanding) any parent items if this is required to show the item.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the item.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Ensure Visible Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], False)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    addShapeGroup(listView, "Hexagon", "6")
		    addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    addShape(quad, "Cyclic", "4")
		    addShape(quad, "Parallelogram", "4")
		    addShape(quad, "Tangential", "4")
		    trapezoid = addShape(quad, "Trapezoid", "4")
		    addShape(tria, "Acute", "3")
		    addShape(tria, "Equilateral", "3")
		    addShape(tria, "Isosceles", "3")
		    addShape(tria, "Right", "3")
		    addShape(tria, "Scalene", "3")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCWindowSetInitSize(window, 300, 180)
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter, "Trapezoid Visible", setTrapezoidVisible, trapezoid
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter, "Trapezoid Visible Top", setTrapezoidVisibleTop, trapezoid
		    )
		    guitk.BCShow(window)
		
		
		def setTrapezoidVisible(btn, trapezoid):
		    guitk.BCListViewItemEnsureVisible(trapezoid)
		    return 0
		
		
		def setTrapezoidVisibleTop(btn, trapezoid):
		    guitk.BCListViewItemEnsureVisibleTop(trapezoid)
		    return 0
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parent, name, sides):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemEnsureVisibleTop(item: object) -> None:

	"""

	Ensures that item item is visible and scrolls the vertical bar (if available), such as item is the top visible item.
	This also means opening (expanding) any parent items if this is required to show the item. 
	NOTE: Top suffix refers to the position in the ListView's viewport, not the level of the item.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the item that will be visible.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemEnsureVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Ensure Visible Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], False)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    addShapeGroup(listView, "Hexagon", "6")
		    addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    addShape(quad, "Cyclic", "4")
		    addShape(quad, "Parallelogram", "4")
		    addShape(quad, "Tangential", "4")
		    trapezoid = addShape(quad, "Trapezoid", "4")
		    addShape(tria, "Acute", "3")
		    addShape(tria, "Equilateral", "3")
		    addShape(tria, "Isosceles", "3")
		    addShape(tria, "Right", "3")
		    addShape(tria, "Scalene", "3")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCWindowSetInitSize(window, 300, 180)
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter, "Trapezoid Visible", setTrapezoidVisible, trapezoid
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter, "Trapezoid Visible Top", setTrapezoidVisibleTop, trapezoid
		    )
		    guitk.BCShow(window)
		
		
		def setTrapezoidVisible(btn, trapezoid):
		    guitk.BCListViewItemEnsureVisible(trapezoid)
		    return 0
		
		
		def setTrapezoidVisibleTop(btn, trapezoid):
		    guitk.BCListViewItemEnsureVisibleTop(trapezoid)
		    return 0
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parent, name, sides):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsVisible(item: object) -> bool:

	"""

	Returns True if ListViewItem item is visible, False otherwise.
	The return value depends on the attribute that explicitly was set with BCListViewItemSetVisible().
	NOTE: The return value does not depend whether item is physically visible, i.e.
	- an item that currently not drawn at the viewport (you have to scroll down to find it) can be visible.
	- a child item that is collapsed to its parent can be visible.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if item is visible, False otherwise.

	See Also
	--------
	BCListViewItemEnsureVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Odds Invisible Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    cbEvenInvisible = guitk.BCCheckBoxCreate(window, "Set even IDs Invisible")
		    guitk.BCCheckBoxSetToggledFunction(cbEvenInvisible, setEvenInvisible, listView)
		    guitk.BCShow(window)
		
		
		def setEvenInvisible(cb, state, listView):
		    visible = not state
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, setEvenItemVisible, visible
		    )
		    return 0
		
		
		def setEvenItemVisible(item, visible):
		    itemId = guitk.BCListViewItemGetInt(item, 0)
		    if itemId % 2 == 0:
		        guitk.BCListViewItemSetVisible(item, visible)
		    print(
		        "Item ID={} is Visible = {}".format(itemId, guitk.BCListViewItemIsVisible(item))
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetVisible(item: object, visible: bool) -> None:

	"""

	Sets whether ListViewItem item will be visible (default) or not.
	If you want to modify item's selectability, use BCListViewItemSetSelectable().
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	visible : bool
		set True to show or False to hide the item.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemEnsureVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Odds Invisible Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    cbEvenInvisible = guitk.BCCheckBoxCreate(window, "Set even IDs Invisible")
		    guitk.BCCheckBoxSetToggledFunction(cbEvenInvisible, setEvenInvisible, listView)
		    guitk.BCShow(window)
		
		
		def setEvenInvisible(cb, state, listView):
		    visible = not state
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, setEvenItemVisible, visible
		    )
		    return 0
		
		
		def setEvenItemVisible(item, visible):
		    itemId = guitk.BCListViewItemGetInt(item, 0)
		    if itemId % 2 == 0:
		        guitk.BCListViewItemSetVisible(item, visible)
		    print(
		        "Item ID={} is Visible = {}".format(itemId, guitk.BCListViewItemIsVisible(item))
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetCheckBox(item: object, col: int, checked: bool, funct: Callable, data: Any=None) -> None:

	"""

	Sets a checkbox to be displayed in the ListViewItem item cell specified by the given column col.
	If you want to set a check box together with text use BCListViewItemSetCheckable().
	You can also use generic item widget functions BCListViewItemWidgetSetVisible(), BCListViewItemWidgetSetEnabled() and BCListViewItemWidgetDestroy().
	The standard check box is aligned center.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	checked : bool
		whether the checkBox will be initially set to checked or not ( True for checked, False otherwise ).

	funct : Callable
		a callback function that will be called every time the checkBox will be checked or unchecked. 
		See BC_LISTVIEWITEM_CHECKBOX_TOGGLED_FUNCTION for details.
		integer BC_LISTVIEWITEM_CHECKBOX_TOGGLED_FUNCTION(item, col, state, data)
		The function to be called everytime the checkBox will be checked or unchecked.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column in which the checkBox is found.
		          * state : int
		                    the new value of the checkBox: 1 if checked; 0 otherwise.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsCheckBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Item Widgets", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Completed"], 0
		    )
		    item1 = addPart(listView, "1001", "Bumper")
		    guitk.BCListViewItemCheckBoxSetChecked(item1, 3, True)
		    item2 = addPart(listView, "1002", "Decklid")
		    # This will not trigger the ComboBox callback
		    guitk.BCListViewItemComboBoxSetCurrentItem(item2, 2, 1)
		    item3 = addPart(listView, "1003", "Pillar")
		    item4 = addPart(listView, "1004", "Roof rack")
		    guitk.BCListViewItemCheckBoxSetChecked(item4, 3, True)
		    # This will trigger the ComboBox callback:
		    guitk.BCListViewItemComboBoxSetCurrentItemExecuteActivatedCallBack(item4, 2, 2)
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name):
		    users = ["Alexander", "David", "George", "Sarah"]
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(item, 2, users, AssigneeChanged, None)
		    guitk.BCListViewItemSetCheckBox(item, 3, False, CompletedChanged, None)
		    return item
		
		
		def AssigneeChanged(item, col, index, data):
		    print("Assignee Changed!")
		    # UpdateDataOnAssigneeChanged()
		    return 0
		
		
		def CompletedChanged(item, col, state, data):
		    print("Completed Changed!")
		    # UpdateDataOnCompletedChanged()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckBoxSetChecked(item: object, col: int, check: bool) -> None:

	"""

	Sets the value of the checkBox at item item.
	If you want to change the value without the call back to run, use BCBlockCallBackFunctions() (remember to unblock).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	check : bool
		the value to be set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetCheckBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Item Widgets", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Completed"], 0
		    )
		    item1 = addPart(listView, "1001", "Bumper")
		    guitk.BCListViewItemCheckBoxSetChecked(item1, 3, True)
		    item2 = addPart(listView, "1002", "Decklid")
		    # This will not trigger the ComboBox callback
		    guitk.BCListViewItemComboBoxSetCurrentItem(item2, 2, 1)
		    item3 = addPart(listView, "1003", "Pillar")
		    item4 = addPart(listView, "1004", "Roof rack")
		    guitk.BCListViewItemCheckBoxSetChecked(item4, 3, True)
		    # This will trigger the ComboBox callback:
		    guitk.BCListViewItemComboBoxSetCurrentItemExecuteActivatedCallBack(item4, 2, 2)
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name):
		    users = ["Alexander", "David", "George", "Sarah"]
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(item, 2, users, AssigneeChanged, None)
		    guitk.BCListViewItemSetCheckBox(item, 3, False, CompletedChanged, None)
		    return item
		
		
		def AssigneeChanged(item, col, index, data):
		    print("Assignee Changed!")
		    # UpdateDataOnAssigneeChanged()
		    return 0
		
		
		def CompletedChanged(item, col, state, data):
		    print("Completed Changed!")
		    # UpdateDataOnCompletedChanged()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckBoxIsChecked(item: object, col: int) -> bool:

	"""

	Returns 1 if the checkBox at column col of ListViewItem item is checked, or 0 otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		1 if the checkBox at column col of ListViewItem item is checked, or 0 otherwise.

	See Also
	--------
	BCListViewItemSetCheckBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView CheckBox Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Quality Assured"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", False)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", True)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", False)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", True)
		
		    guitk.BCListViewSetCtrlXFunction(listView, toggleItemChkBoxes, None)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Pressing Ctrl+X will toggle all CheckBoxes on the selected item.",
		    )
		    guitk.BCShow(window)
		
		
		def toggleItemChkBoxes(listView, data):
		    item = guitk.BCListViewGetSelectedItem(listView)
		    if item != None:
		        for col in range(guitk.BCListViewColumns(listView)):
		            if guitk.BCListViewItemIsCheckBox(item, col):
		                guitk.BCListViewItemCheckBoxSetChecked(
		                    item, col, not guitk.BCListViewItemCheckBoxIsChecked(item, col)
		                )
		    return 0
		
		
		def QAToggled(item, col, state, data):
		    print(
		        "Item ID={}, Column={} CheckBox state set to {}".format(
		            guitk.BCListViewItemGetText(item, 0), col, state
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured, qualityAssured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetCheckBox(item, 4, qualityAssured, QAToggled, None)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckBoxSetDim(item: object, col: int, dim: bool) -> None:

	"""

	Sets the dim state (partially checked) of the checkBox at item item (default false).
	Check box can be drawn dimmed only when it is checked.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	dim : bool
		set 1 to turn it dimmed (partially checked), otherwise 0.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetCheckBox

	"""

def BCListViewItemIsCheckBox(item: object, col: int) -> bool:

	"""

	Returns True if the ListViewItem item cell displays a check box at given column col, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	col : int
		the column index.

	Returns
	-------
	bool
		True if the ListViewItem item at column col is a checkBox, or False otherwise.

	See Also
	--------
	BCListViewItemSetCheckBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView CheckBox Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Quality Assured"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", False)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", True)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", False)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", True)
		
		    guitk.BCListViewSetCtrlXFunction(listView, toggleItemChkBoxes, None)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Pressing Ctrl+X will toggle all CheckBoxes on the selected item.",
		    )
		    guitk.BCShow(window)
		
		
		def toggleItemChkBoxes(listView, data):
		    item = guitk.BCListViewGetSelectedItem(listView)
		    if item != None:
		        for col in range(guitk.BCListViewColumns(listView)):
		            if guitk.BCListViewItemIsCheckBox(item, col):
		                guitk.BCListViewItemCheckBoxSetChecked(
		                    item, col, not guitk.BCListViewItemCheckBoxIsChecked(item, col)
		                )
		    return 0
		
		
		def QAToggled(item, col, state, data):
		    print(
		        "Item ID={}, Column={} CheckBox state set to {}".format(
		            guitk.BCListViewItemGetText(item, 0), col, state
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured, qualityAssured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetCheckBox(item, 4, qualityAssured, QAToggled, None)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewButtonGroupCreate(lv: object, col: int) -> object:

	"""

	Creates an non visible object that treats a group of radio button items exclusively.
	Once you create the group insert items in it and they will operate exclusively. Exclusive property means that to untoggle a radio button you must mouse press on another radio button in the group.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	object
		the created BCListViewButtonGroup.

	See Also
	--------
	BCListViewButtonGroupInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCSingle)
		    guitk.BCListViewSetSelectionChangedFunction(listView, selectionChangedFuntct, None)
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    item = addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    guitk.BCListViewItemRadioButtonSetChecked(item, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def selectionChangedFuntct(listView, data):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        print("Selected item is: " + guitk.BCListViewItemGetText(selectedItem, 1))
		        isItemChecked(selectedItem)
		    return 0
		
		
		def isItemChecked(selectedItem):
		    text = guitk.BCListViewItemGetText(selectedItem, 1)
		    if guitk.BCListViewItemRadioButtonIsChecked(selectedItem, 2):
		        text += " is Checked."
		    else:
		        text += " is not Checked."
		    print(text)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewButtonGroupSetMousePressedFunction(lvbg: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function to be called when a radio button in the group is pressed.
	This function is not supported under VR mode.

	Parameters
	----------
	lvbg : object
		the ListViewButtonGroup.

	funct : Callable
		a callback function that will be called every time the radio button inside group lvbg will be toggled. 
		See BC_LISTVIEW_BUTTONGROUP_MOUSE_PRESSED_FUNCTION for details.
		integer BC_LISTVIEW_BUTTONGROUP_MOUSE_PRESSED_FUNCTION(lvbg, item, col, data)
		The function to be called everytime a radio button in the group is pressed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lvbg : object
		                    the ListViewButtonGroup.
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewButtonGroupSetChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewButtonGroupSetChecked(lvbg: object, item: object) -> None:

	"""

	Set the selected radio button of button group lvbg to the radio at item.
	This function is not supported under VR mode.

	Parameters
	----------
	lvbg : object
		the ListViewButtonGroup.

	item : object
		the ListViewItem.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewButtonGroupInsertItem(lvbg: object, item: object) -> None:

	"""

	Insert item item to be managed exclusively by button group lvbg.
	This function is not supported under VR mode.

	Parameters
	----------
	lvbg : object
		the ListViewButtonGroup.

	item : object
		the ListViewItem.

	Returns
	-------
	None

	See Also
	--------
	BCListViewButtonGroupRemoveItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCSingle)
		    guitk.BCListViewSetSelectionChangedFunction(listView, selectionChangedFuntct, None)
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    item = addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    guitk.BCListViewItemRadioButtonSetChecked(item, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def selectionChangedFuntct(listView, data):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        print("Selected item is: " + guitk.BCListViewItemGetText(selectedItem, 1))
		        isItemChecked(selectedItem)
		    return 0
		
		
		def isItemChecked(selectedItem):
		    text = guitk.BCListViewItemGetText(selectedItem, 1)
		    if guitk.BCListViewItemRadioButtonIsChecked(selectedItem, 2):
		        text += " is Checked."
		    else:
		        text += " is not Checked."
		    print(text)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewButtonGroupRemoveItem(lvbg: object, item: object) -> None:

	"""

	Removes item item from button group lvbg. Does not delete item item.
	This function is not supported under VR mode.

	Parameters
	----------
	lvbg : object
		the ListViewButtonGroup.

	item : object
		the ListViewItem.

	Returns
	-------
	None

	See Also
	--------
	BCListViewButtonGroupInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetRadioButton(item: object, col: int, checked: bool, funct: Callable, data: Any=None) -> None:

	"""

	Sets a radio button to be displayed in the ListViewItem item cell specified by the given column col.
	Radio buttons inside items do not operate exclusively by default. Use ListViewButtonGroup to treat them exclusively.
	You can also use generic item widget functions BCListViewItemWidgetSetVisible(), BCListViewItemWidgetSetEnabled() and BCListViewItemWidgetDestroy().
	The standard radio button aligned center.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	checked : bool
		whether the radio button will be initially set to checked or not ( True for on, False otherwise ).

	funct : Callable
		a callback function that will be called every time the radio button will be toggled. 
		See BC_LISTVIEWITEM_RADIOBUTTON_TOGGLED_FUNCTION for details.
		integer BC_LISTVIEWITEM_RADIOBUTTON_TOGGLED_FUNCTION(item, col, state, data)
		The function to be called everytime the radio button will change status (on/off).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * state : int
		                    the new value of the radio button: 1 if turned on; 0 otherwise.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsRadioButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCSingle)
		    guitk.BCListViewSetSelectionChangedFunction(listView, selectionChangedFuntct, None)
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    item = addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    guitk.BCListViewItemRadioButtonSetChecked(item, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def selectionChangedFuntct(listView, data):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        print("Selected item is: " + guitk.BCListViewItemGetText(selectedItem, 1))
		        isItemChecked(selectedItem)
		    return 0
		
		
		def isItemChecked(selectedItem):
		    text = guitk.BCListViewItemGetText(selectedItem, 1)
		    if guitk.BCListViewItemRadioButtonIsChecked(selectedItem, 2):
		        text += " is Checked."
		    else:
		        text += " is not Checked."
		    print(text)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemRadioButtonSetChecked(item: object, col: int, check: bool) -> None:

	"""

	Sets the value (on/off) of the radio button at item item.
	If you want to change the value without the call back to run, use BCBlockCallBackFunctions() (remember to unblock).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	check : bool
		1 to turn it on or 0 to turn it off.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemRadioButtonIsChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCSingle)
		    guitk.BCListViewSetSelectionChangedFunction(listView, selectionChangedFuntct, None)
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    item = addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    guitk.BCListViewItemRadioButtonSetChecked(item, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def selectionChangedFuntct(listView, data):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        print("Selected item is: " + guitk.BCListViewItemGetText(selectedItem, 1))
		        isItemChecked(selectedItem)
		    return 0
		
		
		def isItemChecked(selectedItem):
		    text = guitk.BCListViewItemGetText(selectedItem, 1)
		    if guitk.BCListViewItemRadioButtonIsChecked(selectedItem, 2):
		        text += " is Checked."
		    else:
		        text += " is not Checked."
		    print(text)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemRadioButtonIsChecked(item: object, col: int) -> bool:

	"""

	Returns 1 if the radio button at column col of ListViewItem item is on, or 0 otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		1 if the radio button at column col of ListViewItem item is on, or 0 otherwise.

	See Also
	--------
	BCListViewItemRadioButtonSetChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCSingle)
		    guitk.BCListViewSetSelectionChangedFunction(listView, selectionChangedFuntct, None)
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    item = addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    guitk.BCListViewItemRadioButtonSetChecked(item, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def selectionChangedFuntct(listView, data):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        print("Selected item is: " + guitk.BCListViewItemGetText(selectedItem, 1))
		        isItemChecked(selectedItem)
		    return 0
		
		
		def isItemChecked(selectedItem):
		    text = guitk.BCListViewItemGetText(selectedItem, 1)
		    if guitk.BCListViewItemRadioButtonIsChecked(selectedItem, 2):
		        text += " is Checked."
		    else:
		        text += " is not Checked."
		    print(text)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsRadioButton(item: object, col: int) -> bool:

	"""

	Returns True if the ListViewItem item cell displays a radio button at given column col, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		True if the ListViewItem item at column col is a radio button, or False otherwise.

	See Also
	--------
	BCListViewItemSetRadioButton

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, randint
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Is Some Widget Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        8,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "Radio",
		            "ComboBox",
		            "Progress",
		            "Button",
		        ],
		        False,
		    )
		    btnGroup = guitk.BCListViewButtonGroupCreate(listView, 4)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", btnGroup)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", btnGroup)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", btnGroup)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", btnGroup)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, printIsers, None)
		    guitk.BCShow(window)
		
		
		def printIsers(listView, item, data):
		    itemId = guitk.BCListViewItemGetText(item, 0)
		    for col in range(4, 8):
		        print(
		            "\\nItem ID={}, Column {} IsRadioButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsRadioButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsComboBox = {}".format(
		                itemId, col, guitk.BCListViewItemIsComboBox(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsProgressBar = {}".format(
		                itemId, col, guitk.BCListViewItemIsProgressBar(item, col)
		            )
		        )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured, btnGroup):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add widgets
		    guitk.BCListViewItemSetRadioButton(item, 4, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(btnGroup, item)
		    guitk.BCListViewItemSetComboBox(
		        item, 5, ["Triangles", "Ortho-Triangles", "Rectangles"], None, None
		    )
		    guitk.BCListViewItemSetProgressBar(item, 6)
		    guitk.BCListViewItemProgressBarSetProgress(item, 6, randint(0, 100))
		    guitk.BCListViewItemSetButton(item, 7, None, None)
		    guitk.BCListViewItemButtonSetText(item, 7, "Button")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetButton(item: object, col: int, funct: Callable, data: Any=None) -> None:

	"""

	Sets a push button to be displayed in the ListViewItem item cell specified by the given column col.
	You can also use generic item widget functions BCListViewItemWidgetSetVisible(), BCListViewItemWidgetSetEnabled() and BCListViewItemWidgetDestroy().
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	funct : Callable
		a callback function that will be called every time the button will be clicked.
		See BC_LISTVIEWITEM_BUTTON_CLICKED_FUNCTION for details.
		integer BC_LISTVIEWITEM_BUTTON_CLICKED_FUNCTION(item, col, data)
		The function to be called everytime the button will be clicked.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column at which the button is found.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Button PrintMe Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part name", "Version", "Manufactured", "Button", "IconButton"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCShow(window)
		
		
		def printMe(item, col, data):
		    btnText = guitk.BCListViewItemButtonText(item, col)
		    btnIconName = guitk.BCListViewItemButtonIconFileName(item, col)
		    print("ButtonText = '{}', ButtonIconFileName = '{}'".format(btnText, btnIconName))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add buttons
		    guitk.BCListViewItemSetButton(item, 4, printMe, None)
		    guitk.BCListViewItemButtonSetText(item, 4, "Simple Button")
		    guitk.BCListViewItemSetButton(item, 5, printMe, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 5, "info_small.svg")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemButtonSetText(item: object, col: int, text: str) -> None:

	"""

	Sets text as label of the button of item at col.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the button.

	col : int
		the column index.

	text : str
		the label of the button.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemButtonText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Button PrintMe Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part name", "Version", "Manufactured", "Button", "IconButton"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCShow(window)
		
		
		def printMe(item, col, data):
		    btnText = guitk.BCListViewItemButtonText(item, col)
		    btnIconName = guitk.BCListViewItemButtonIconFileName(item, col)
		    print("ButtonText = '{}', ButtonIconFileName = '{}'".format(btnText, btnIconName))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add buttons
		    guitk.BCListViewItemSetButton(item, 4, printMe, None)
		    guitk.BCListViewItemButtonSetText(item, 4, "Simple Button")
		    guitk.BCListViewItemSetButton(item, 5, printMe, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 5, "info_small.svg")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemButtonText(item: object, col: int) -> str:

	"""

	Returns the button's label of item at col.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the button.

	col : int
		the column index.

	Returns
	-------
	str
		the label of the button.

	See Also
	--------
	BCListViewItemButtonSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Button PrintMe Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part name", "Version", "Manufactured", "Button", "IconButton"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCShow(window)
		
		
		def printMe(item, col, data):
		    btnText = guitk.BCListViewItemButtonText(item, col)
		    btnIconName = guitk.BCListViewItemButtonIconFileName(item, col)
		    print("ButtonText = '{}', ButtonIconFileName = '{}'".format(btnText, btnIconName))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add buttons
		    guitk.BCListViewItemSetButton(item, 4, printMe, None)
		    guitk.BCListViewItemButtonSetText(item, 4, "Simple Button")
		    guitk.BCListViewItemSetButton(item, 5, printMe, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 5, "info_small.svg")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemButtonSetIconFileName(item: object, col: int, fileName: str) -> None:

	"""

	Sets an icon with file name fileName to the button of item at col.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the button.

	col : int
		the column index.

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemButtonIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Button PrintMe Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part name", "Version", "Manufactured", "Button", "IconButton"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCShow(window)
		
		
		def printMe(item, col, data):
		    btnText = guitk.BCListViewItemButtonText(item, col)
		    btnIconName = guitk.BCListViewItemButtonIconFileName(item, col)
		    print("ButtonText = '{}', ButtonIconFileName = '{}'".format(btnText, btnIconName))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add buttons
		    guitk.BCListViewItemSetButton(item, 4, printMe, None)
		    guitk.BCListViewItemButtonSetText(item, 4, "Simple Button")
		    guitk.BCListViewItemSetButton(item, 5, printMe, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 5, "info_small.svg")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemButtonIconFileName(item: object, col: int) -> str:

	"""

	Returns the file name of the icon that has been set to the button of item at col.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the button.

	col : int
		the column index.

	Returns
	-------
	str
		the filename of the icon.

	See Also
	--------
	BCListViewItemButtonSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Button PrintMe Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        6,
		        ["ID", "Part name", "Version", "Manufactured", "Button", "IconButton"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCShow(window)
		
		
		def printMe(item, col, data):
		    btnText = guitk.BCListViewItemButtonText(item, col)
		    btnIconName = guitk.BCListViewItemButtonIconFileName(item, col)
		    print("ButtonText = '{}', ButtonIconFileName = '{}'".format(btnText, btnIconName))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add buttons
		    guitk.BCListViewItemSetButton(item, 4, printMe, None)
		    guitk.BCListViewItemButtonSetText(item, 4, "Simple Button")
		    guitk.BCListViewItemSetButton(item, 5, printMe, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 5, "info_small.svg")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsButton(item: object, col: int) -> bool:

	"""

	Returns True if the ListViewItem item cell displays a push button at given column col, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	col : int
		the column index.

	Returns
	-------
	bool
		True if the ListViewItem item at column col has button, or False otherwise.

	See Also
	--------
	BCListViewItemSetButton

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, randint
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Is Some Widget Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        8,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "Radio",
		            "ComboBox",
		            "Progress",
		            "Button",
		        ],
		        False,
		    )
		    btnGroup = guitk.BCListViewButtonGroupCreate(listView, 4)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", btnGroup)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", btnGroup)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", btnGroup)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", btnGroup)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, printIsers, None)
		    guitk.BCShow(window)
		
		
		def printIsers(listView, item, data):
		    itemId = guitk.BCListViewItemGetText(item, 0)
		    for col in range(4, 8):
		        print(
		            "\\nItem ID={}, Column {} IsRadioButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsRadioButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsComboBox = {}".format(
		                itemId, col, guitk.BCListViewItemIsComboBox(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsProgressBar = {}".format(
		                itemId, col, guitk.BCListViewItemIsProgressBar(item, col)
		            )
		        )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured, btnGroup):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add widgets
		    guitk.BCListViewItemSetRadioButton(item, 4, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(btnGroup, item)
		    guitk.BCListViewItemSetComboBox(
		        item, 5, ["Triangles", "Ortho-Triangles", "Rectangles"], None, None
		    )
		    guitk.BCListViewItemSetProgressBar(item, 6)
		    guitk.BCListViewItemProgressBarSetProgress(item, 6, randint(0, 100))
		    guitk.BCListViewItemSetButton(item, 7, None, None)
		    guitk.BCListViewItemButtonSetText(item, 7, "Button")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemDepth(item: object) -> int:

	"""

	Returns the depth of item item.
	Top level items have depth 0.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem to be tested.

	Returns
	-------
	int
		the depth of an item.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Get Neighbouring Items Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], True)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    # Begin adding items
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Pentagon", "5")
		    quadItem = addShapeGroup(listView, "Quadrilateral", "4")
		    addShape(quadItem, "Parallelogram", "4")
		    addShape(quadItem, "Tangential", "4")
		    triaItem = addShapeGroup(listView, "Triangle", "3")
		    addShape(triaItem, "Acute", "3")
		    addShape(triaItem, "Equilateral", "3")
		    addShape(triaItem, "Isosceles", "3")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    statusLabel = guitk.BCLabelCreate(window, "")
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, statusLabel)
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def itemSelected(listView, item, label):
		    # Note that you can retrieve neighbouring items
		    parent = guitk.BCListViewItemGetParent(item)
		    firstChild = guitk.BCListViewItemGetFirstChild(item)
		    above = guitk.BCListViewItemGetItemAbove(item)
		    below = guitk.BCListViewItemGetItemBelow(item)
		    root = guitk.BCListViewItemRoot(item)
		    text = "SelectedItem: " + guitk.BCListViewItemGetText(item, 0)
		    text += "\\nDepth: " + str(guitk.BCListViewItemDepth(item))
		    text += "\\nChildCount: " + str(guitk.BCListViewItemChildCount(item))
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetToolTip(item: object, col: int, tip: str) -> None:

	"""

	Sets the tooltip (balloon help) for list view item item at column col to the text specified by tip.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	tip : str
		the text to be displayed at balloon help.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Icon And ToolTip", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    item = addPart(listView, "1001", "Bumper", "67", "23.5")
		    item = addPart(listView, "1002", "Decklid", "4", "0.9")
		    guitk.BCListViewItemSetIconFileName(item, 2, "warning_small.svg")
		    guitk.BCListViewItemSetToolTip(item, 2, "Quantity is very low")
		    item = addPart(listView, "1003", "Pillar", "254", "12.2")
		    item = addPart(listView, "1004", "Roof rack", "14", "6.75")
		    guitk.BCListViewItemSetIconFileName(item, 2, "warning_small.svg")
		    guitk.BCListViewItemSetToolTip(item, 2, "Quantity is very low")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    # whitespace (empty_small.svg) used for correct alignment of icons
		    guitk.BCListViewItemSetIconFileName(item, 2, "empty_small.svg")
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetRenameType(item: object, col: int, type: int) -> None:

	"""

	Defines what data type (integer, string) item accepts for column col when renamed.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	type : int
		See BCEnumRenameType for more details.
		
		guitk.constants BCEnumRenameType
		This enum type is used to describe the data type of the editor on ListViewItem rename.
		 - guitk.constants.BCRenameType_None
		The item cannot be renamed by the user.
		 - guitk.constants.BCRenameType_Double
		Rename editor accepts double values.
		 - guitk.constants.BCRenameType_Int
		Rename editor accepts integer values.
		 - guitk.constants.BCRenameType_String
		Rename editor accepts any string value.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemRenameType

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Hide Column", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    # hide column on first show
		    guitk.BCListViewHideColumn(listView, 3)
		    # the user is able to modify columns visibility from a header button menu
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    # the user cannot hide from menu the column ID
		    guitk.BCListViewHeaderMenuBlockColumnVisibilityChange(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(
		        item, 0, guitk.constants.BCRenameType_None
		    )  # default
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemRenameType(item: object, col: int) -> int:

	"""

	Returns what data type (integer, string) item accepts for column col when renamed.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	int
		The rename data type. See BCEnumRenameType for more details.
		BCEnumRenameType: This enum type is used to describe the data type of the editor on ListViewItem rename.
		guitk.constants.BCRenameType_None: The item cannot be renamed by the user.
		guitk.constants.BCRenameType_Double: Rename editor accepts double values.
		guitk.constants.BCRenameType_Int: Rename editor accepts integer values.
		guitk.constants.BCRenameType_String: Rename editor accepts any string value.

	See Also
	--------
	

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Rename Item", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    messenger = guitk.BCAnimationMessageCreate(listView, guitk.constants.BCOnExitHide)
		    guitk.BCListViewSetAboutToRenameItemFunction(
		        listView, DynamicDiscardRenameItem, messenger
		    )
		    guitk.BCListViewSetAboutToCommitRenameEditorDataFunction(
		        listView, DiscardNegativeNumbers, messenger
		    )
		    guitk.BCListViewSetRenameItemFinishedFunction(
		        listView, ShowMessageOnQuantityUpdated, messenger
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def DynamicDiscardRenameItem(listView, item, col, editor, messenger):
		    if (
		        guitk.BCListViewItemGetText(item, 0) == "1003"
		    ):  # scenario: check you data whether item is locked
		        guitk.BCAnimationMessageShowTextTimeout(
		            messenger, "Pillar is locked from another user.", 3000
		        )
		        return 1
		    return 0
		
		
		def DiscardNegativeNumbers(listView, item, col, editor, reason, messenger):
		    # discard empty or negative for numeric columns
		    renameType = guitk.BCListViewItemRenameType(item, col)
		    if renameType in (
		        guitk.constants.BCRenameType_Int,
		        guitk.constants.BCRenameType_Double,
		    ):
		        if not len(guitk.BCLineEditGetText(editor)):
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Empty value discarded.", 3000
		            )
		            return 1  # discard empty
		        value = -1
		        value = (
		            guitk.BCLineEditGetInt(editor)
		            if renameType == guitk.constants.BCRenameType_Int
		            else guitk.BCLineEditGetDouble(editor)
		        )
		        if value < 0:
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Negative value discarded.", 3000
		            )
		            return 1  # discard
		    return 0  # accept
		
		
		def ShowMessageOnQuantityUpdated(listView, item, col, dataCommitted, text, messenger):
		    if col == 2 and dataCommitted:
		        guitk.BCAnimationMessageShowTextTimeout(messenger, "Quantity updated.", 3000)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemRenameEnabled(item: object, col: int) -> bool:

	"""

	Returns True if rename is enabled (rename type different from BCRenameType_None) for column col of ListViewItem item, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		True if rename is enabled for column (rename type different from BCRenameType_None) col of item; False otherwise.

	See Also
	--------
	BCListViewItemSetRenameType

	"""

def BCListViewSetFilterEnabled(lv: object, enable: bool) -> None:

	"""

	Sets whether the ListView lv provides a filter button on the right of the header or not.
	If you enable this property a (toggle) button at the right of header will be shown.
	This button shows/hides a line below header accommodating widgets able to filter the ListView per column. 
	The default filter provides line edits. If you have column with checkBoxes you will filter with a tristate checkBox. If you have a small finite number of item names you are able to use a comboBox as well.
	While you filter you can see the full query at the bottom of the ListView, comprised by multiple ANDed conditions. Filter operates as you type, but it is recommended to disable this property for ListViews with large number of items, and filter when Enter pressed. You can also set the filter to be case sensitive or not.
	WARNING: If you have columns with numbers or checkBoxes, you have to set the data types for the columns such as the filter to be able to operate correct. See BCListViewSetColumnDataType().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	enable : bool
		set this parameter to True to enable the filter, or to False to disable it.

	Returns
	-------
	None

	See Also
	--------
	BCListViewIsFilterEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    guitk.BCSetUserDataKey(window, "listView", listView)
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    # filter options
		    enableFilterCheckBox = guitk.BCCheckBoxCreate(window, "Enable filtering")
		    autoShowCheckBox = guitk.BCCheckBoxCreate(window, "Auto show query bar")
		    guitk.BCSetUserDataKey(window, "autoShowCheckBox", autoShowCheckBox)
		    guitk.BCCheckBoxSetChecked(autoShowCheckBox, True)
		    guitk.BCCheckBoxSetToggledFunction(
		        enableFilterCheckBox, enableFilteringFunct, window
		    )
		    guitk.BCCheckBoxSetToggledFunction(autoShowCheckBox, autoShowQueryBarFunct, window)
		    guitk.BCCheckBoxAddManagedWidget(
		        enableFilterCheckBox,
		        autoShowCheckBox,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def enableFilteringFunct(checkBox, state, window):
		    listView = guitk.BCGetUserDataKey(window, "listView")
		    guitk.BCListViewSetFilterEnabled(listView, state)
		    autoShowCheckBox = guitk.BCGetUserDataKey(window, "autoShowCheckBox")
		    guitk.BCListViewFilterSetAutoShowQueryBar(
		        listView, guitk.BCCheckBoxIsChecked(autoShowCheckBox)
		    )
		    return 0
		
		
		def autoShowQueryBarFunct(checkBox, state, window):
		    listView = guitk.BCGetUserDataKey(window, "listView")
		    if guitk.BCListViewIsFilterEnabled(listView):
		        guitk.BCListViewFilterSetAutoShowQueryBar(listView, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewIsFilterEnabled(lv: object) -> bool:

	"""

	Check if filter is enabled for ListView lv.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to check.

	Returns
	-------
	bool
		True if the filter is enabled or False otherwise.

	See Also
	--------
	BCListViewSetFilterEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    guitk.BCSetUserDataKey(window, "listView", listView)
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    # filter options
		    enableFilterCheckBox = guitk.BCCheckBoxCreate(window, "Enable filtering")
		    autoShowCheckBox = guitk.BCCheckBoxCreate(window, "Auto show query bar")
		    guitk.BCSetUserDataKey(window, "autoShowCheckBox", autoShowCheckBox)
		    guitk.BCCheckBoxSetChecked(autoShowCheckBox, True)
		    guitk.BCCheckBoxSetToggledFunction(
		        enableFilterCheckBox, enableFilteringFunct, window
		    )
		    guitk.BCCheckBoxSetToggledFunction(autoShowCheckBox, autoShowQueryBarFunct, window)
		    guitk.BCCheckBoxAddManagedWidget(
		        enableFilterCheckBox,
		        autoShowCheckBox,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def enableFilteringFunct(checkBox, state, window):
		    listView = guitk.BCGetUserDataKey(window, "listView")
		    guitk.BCListViewSetFilterEnabled(listView, state)
		    autoShowCheckBox = guitk.BCGetUserDataKey(window, "autoShowCheckBox")
		    guitk.BCListViewFilterSetAutoShowQueryBar(
		        listView, guitk.BCCheckBoxIsChecked(autoShowCheckBox)
		    )
		    return 0
		
		
		def autoShowQueryBarFunct(checkBox, state, window):
		    listView = guitk.BCGetUserDataKey(window, "listView")
		    if guitk.BCListViewIsFilterEnabled(listView):
		        guitk.BCListViewFilterSetAutoShowQueryBar(listView, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetLineEdit(lv: object, col: int) -> None:

	"""

	Sets the filter at column col to provide line edit (default).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterSetComboBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Quantity", "Complete"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, addCheckBoxColFunct, 4
		    )
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewFilterSetColumnEnabled(listView, 2, False)
		    guitk.BCListViewFilterSetFilterAsYouTypeEnabled(listView, False)
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Change filter type to ComboBox at column 'Size'"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, changeFilterTypeFunct, listView)
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addCheckBoxColFunct(item, col):
		    guitk.BCListViewItemSetCheckBox(item, col, True, None, None)
		    return 0
		
		
		def changeFilterTypeFunct(checkBox, state, listView):
		    if state:
		        guitk.BCListViewFilterSetComboBox(listView, 2)
		    else:
		        guitk.BCListViewFilterSetLineEdit(listView, 2)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetComboBox(lv: object, col: int) -> None:

	"""

	Sets the filter at column col to provide comboBox.
	This is useful if you have small finite number of item names, for example all your items may have values 'small', 'medium' and 'large'. The default filter provides line edits.
	WARNING: You are responsible to update the comboBox items (use BCListViewFilterUpdateComboBox()).
	Update it when you finish adding/removing items. An automatic update in a ListView with large number of items would cause really slow behavior.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterUpdateComboBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Size"], 0)
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetComboBox(listView, 2)
		    toolBtn = guitk.BCToolButtonCreate(
		        window, "add_16.png", "Add New items", addNewItemsFunct, listView
		    )
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addNewParts(listView):
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addPart(listView, "1005", "Spoiler", "Large")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		
		
		def addNewItemsFunct(btn, listView):
		    addNewParts(listView)
		    guitk.BCListViewFilterUpdateComboBox(listView, 2)
		    guitk.BCListViewFilterApply(listView)
		    guitk.BCHide(btn)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetCheckableMenu(lv: object, col: int) -> None:

	"""

	Sets whether or not the filter at column col will provide a button with a checkable popup menu.
	It works like the combo box, provided the ability to apply many filter conditions in the same column. First insert your items and then apply the checkable menu because this function will also update the checkable menu.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterSetComboBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetCheckableMenu(listView, 2)
		    guitk.BCToolButtonCreate(
		        window, "add_16.png", "Add New items", addNewItemsFunct, listView
		    )
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addNewParts(listView):
		    addPart(listView, "1004", "Welded Assembly", "Small", "5")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		
		
		def addNewItemsFunct(btn, listView):
		    addNewParts(listView)
		    guitk.BCListViewFilterUpdateCheckableMenus(listView)
		    guitk.BCListViewFilterApply(listView)
		    guitk.BCHide(btn)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterUpdateCheckableMenus(lv: object) -> None:

	"""

	Updates all checkable menus (if any) inside filter.
	You will need this function if items inside list view removed dynamically. This function runs a loop to all items, so in lists with large number of items be careful where to use it.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterSetCheckableMenu

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetCheckableMenu(listView, 2)
		    guitk.BCToolButtonCreate(
		        window, "add_16.png", "Add New items", addNewItemsFunct, listView
		    )
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addNewParts(listView):
		    addPart(listView, "1004", "Welded Assembly", "Small", "5")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		
		
		def addNewItemsFunct(btn, listView):
		    addNewParts(listView)
		    guitk.BCListViewFilterUpdateCheckableMenus(listView)
		    guitk.BCListViewFilterApply(listView)
		    guitk.BCHide(btn)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnDataType(lv: object, col: int, dataType: int) -> None:

	"""

	Define the data type for column col of your ListView (default BCString).
	This type is used by filter to specify the search method. It is also related with the widget type that will be used inside the filter bar.
	Valid types are
	- BCInt will use a BCLineEditCreateInt() for filtering column col,
	- BCDouble will use a BCLineEditCreateDouble() for filtering column col,
	- BCBool will use a tristate BCCheckBoxCreate() for filtering column col,
	- BCString will use a BCLineEditCreate() for filtering column col,
	- BCDate will use a complex date editor widget for filtering column col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	col : int
		the column index.

	dataType : int
		See BCEnumDataType for more details.
		
		guitk.constants BCEnumDataType
		This enum type is used to describe the data type or the widget type of a ListViewItem
		 - guitk.constants.BCInt
		Defines the variant-column as integer.
		 - guitk.constants.BCFloat
		Defines the variant-column as float.
		 - guitk.constants.BCDouble
		Defines the variant-column as double.
		 - guitk.constants.BCString
		Defines the variant-column as string.
		 - guitk.constants.BCStringList
		Defines the variant-column as a list of strings (e.g. possible values of a variant red/green/blue).
		 - guitk.constants.BCBool
		Defines the variant-column as a boolen (e.g. for BCCheckBoxes that only take values 0 or 1).
		 - guitk.constants.BCInvalid
		Defines the variant with an invalid type.
		 - guitk.constants.BCDate
		Defines that the variant-column displays date.

	Returns
	-------
	None

	See Also
	--------
	BCListViewColumnDataType

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    if not guitk.BCListViewColumnDataType(listView, 3) == guitk.constants.BCInt:
		        guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    guitk.BCListViewFilterSetFilterAsYouTypeEnabled(listView, False)
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Apply filter to  'Group B' [Default = 'Group A']"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, setGroupToApplyFilterFunct, listView)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, checkBox
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setGroupToApplyFilterFunct(checkBox, state, listView):
		    guitk.BCListViewFilterApply(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, checkBox):
		    state = guitk.BCCheckBoxIsChecked(checkBox)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, iterateGroupFunct, [state, listView]
		    )
		    return 1
		
		
		def iterateGroupFunct(item, data):
		    parent = guitk.BCListViewItemGetParent(item)
		    if parent:
		        if (
		            not data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group A"
		            or data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group B"
		        ):
		            passes_filter = guitk.BCListViewAboutToFilterItem(data[1], item)
		            if passes_filter:
		                guitk.BCListViewSetSelected(data[1], item, True)
		        guitk.BCListViewSetItemsExpanded(data[1], True)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewColumnDataType(lv: object, col: int) -> int:

	"""

	Returns the data type for column col of ListView lv (default BCString).
	Possible types are
	- BCInt,
	- BCDouble,
	- BCBool,
	- BCString,
	- BCDate.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to check.

	col : int
		the column index.

	Returns
	-------
	int
		the data type of column. See BCEnumDataType.
		BCEnumDataType: This enum type is used to describe the data type or the widget type of a ListViewItem
		guitk.constants.BCInt: Defines the variant-column as integer.
		guitk.constants.BCFloat: Defines the variant-column as float.
		guitk.constants.BCDouble: Defines the variant-column as double.
		guitk.constants.BCString: Defines the variant-column as string.
		guitk.constants.BCStringList: Defines the variant-column as a list of strings (e.g. possible values of a variant red/green/blue).
		guitk.constants.BCBool: Defines the variant-column as a boolen (e.g. for BCCheckBoxes that only take values 0 or 1).
		guitk.constants.BCInvalid: Defines the variant with an invalid type.
		guitk.constants.BCDate: Defines that the variant-column displays date.

	See Also
	--------
	BCListViewSetColumnDataType

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    if not guitk.BCListViewColumnDataType(listView, 3) == guitk.constants.BCInt:
		        guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    guitk.BCListViewFilterSetFilterAsYouTypeEnabled(listView, False)
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Apply filter to  'Group B' [Default = 'Group A']"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, setGroupToApplyFilterFunct, listView)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, checkBox
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setGroupToApplyFilterFunct(checkBox, state, listView):
		    guitk.BCListViewFilterApply(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, checkBox):
		    state = guitk.BCCheckBoxIsChecked(checkBox)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, iterateGroupFunct, [state, listView]
		    )
		    return 1
		
		
		def iterateGroupFunct(item, data):
		    parent = guitk.BCListViewItemGetParent(item)
		    if parent:
		        if (
		            not data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group A"
		            or data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group B"
		        ):
		            passes_filter = guitk.BCListViewAboutToFilterItem(data[1], item)
		            if passes_filter:
		                guitk.BCListViewSetSelected(data[1], item, True)
		        guitk.BCListViewSetItemsExpanded(data[1], True)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewCopyItemsToClipboard(lv: object, selectedOnly: int) -> None:

	"""

	Copies to application global clipboard the ListViewItems contents of ListView lv.
	Used for copy and paste text data between applications.
	If an item cell contains both text and icon, it will only copy the text.
	If an item cell contains a widget
	- check box and radio button will copy 1 or 0 ragarding its state,
	- button will copy its text (not icon),
	- combo box will copy the text of current item.
	NOTE: If no items are available to for copying, the clipboard remains as is.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView whose items will be copied.

	selectedOnly : int
		if set to 0, all items will be copied. Only the selected ones, otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewCopyColumnToClipboard

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Copy Example", guitk.constants.BCOnExitDestroy
		    )
		    headerTitles = ["ID", "Part name", "Version", "Manufactured", "Valid", "Calculate"]
		    listView = guitk.BCListViewCreate(window, 6, headerTitles, False)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", True)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", False)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", True)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", False)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		
		    hBox = guitk.BCHBoxCreate(window)
		    chkBox = guitk.BCCheckBoxCreate(hBox, "Only Selected Items")
		    guitk.BCLabelCreate(hBox, "Column:")
		    cmb = guitk.BCComboBoxCreate(hBox, ["All"] + headerTitles)
		    guitk.BCPushButtonCreate(
		        hBox, "Copy And Print", copyAndPrint, (listView, cmb, chkBox)
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured, valid):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(
		        item, 2, ["3A", "4A", "4A", "3A", "3D", "3D"], None, None
		    )
		    guitk.BCListViewItemComboBoxSetCurrentText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetCheckBox(item, 4, valid, None, None)
		    guitk.BCListViewItemSetButton(item, 5, None, None)
		    guitk.BCListViewItemButtonSetText(item, 5, "Calculate")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def copyAndPrint(_, data):
		    listView, cmb, chkBox = data
		    col = guitk.BCComboBoxCurrentItem(cmb) - 1
		    onlySelected = guitk.BCCheckBoxIsChecked(chkBox)
		    if col == -1:
		        guitk.BCListViewCopyItemsToClipboard(listView, onlySelected)
		    else:
		        guitk.BCListViewCopyColumnToClipboard(listView, col, onlySelected)
		    print("\\n" + guitk.BCApplicationClipboardGetText())
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewCopyColumnToClipboard(lv: object, col: int, selectedOnly: int) -> None:

	"""

	Copies to application global clipboard the ListViewItem fields of column col, of ListView lv.
	Used for copy and paste text data between applications.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	selectedOnly : int
		if set to 0, all item fields will be copied. Only the column fields of the selected items, otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewCopyItemsToClipboard

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Copy Example", guitk.constants.BCOnExitDestroy
		    )
		    headerTitles = ["ID", "Part name", "Version", "Manufactured", "Valid", "Calculate"]
		    listView = guitk.BCListViewCreate(window, 6, headerTitles, False)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", True)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", False)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", True)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", False)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		
		    hBox = guitk.BCHBoxCreate(window)
		    chkBox = guitk.BCCheckBoxCreate(hBox, "Only Selected Items")
		    guitk.BCLabelCreate(hBox, "Column:")
		    cmb = guitk.BCComboBoxCreate(hBox, ["All"] + headerTitles)
		    guitk.BCPushButtonCreate(
		        hBox, "Copy And Print", copyAndPrint, (listView, cmb, chkBox)
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured, valid):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(
		        item, 2, ["3A", "4A", "4A", "3A", "3D", "3D"], None, None
		    )
		    guitk.BCListViewItemComboBoxSetCurrentText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetCheckBox(item, 4, valid, None, None)
		    guitk.BCListViewItemSetButton(item, 5, None, None)
		    guitk.BCListViewItemButtonSetText(item, 5, "Calculate")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def copyAndPrint(_, data):
		    listView, cmb, chkBox = data
		    col = guitk.BCComboBoxCurrentItem(cmb) - 1
		    onlySelected = guitk.BCCheckBoxIsChecked(chkBox)
		    if col == -1:
		        guitk.BCListViewCopyItemsToClipboard(listView, onlySelected)
		    else:
		        guitk.BCListViewCopyColumnToClipboard(listView, col, onlySelected)
		    print("\\n" + guitk.BCApplicationClipboardGetText())
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterButton(lv: object) -> object:

	"""

	Returns the button at the right on the header's ListView that is used to show/hide the filter.
	If filter is not enabled you will get None. 
	WARNING: Do not manage this button (toggle/hide), it operates automatically.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to check.

	Returns
	-------
	object
		The button for show/hide the filter or None otherwise.

	See Also
	--------
	BCListViewSetFilterEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    addNewPopupItem(listView)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addNewPopupItem(listView):
		    btn = guitk.BCListViewFilterButton(listView)
		    if not btn == None:
		        popup = guitk.BCButtonPopup(btn)
		        guitk.BCPopupMenuInsertItem(popup, "Load ListView", loadFilterFunct, listView)
		
		
		def loadFilterFunct(popupMenu, id, listView):
		    print("Load ListView")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterClear(lv: object) -> None:

	"""

	Clears the filter from any condition.
	The widgets of filter are set to their default value (line edits set empty text, checkBoxes to mid state and comboBoxes to 'All'). All ListViewItems will be visible. The cleared function (if any) will operate.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetFilterEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded Assembly", "Small", "5")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    toolBtnClean = guitk.BCToolButtonCreate(
		        window, "clean_small.svg", "Clear applied filters", clearFiltersFunct, listView
		    )
		    guitk.BCSetEnabled(toolBtnClean, False)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, toolBtnClean
		    )
		    guitk.BCListViewSetFilterClearedFunction(listView, filterClearedFunct, toolBtnClean)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def clearFiltersFunct(btn, listView):
		    if not guitk.BCListViewFilterCleared(listView):
		        guitk.BCListViewFilterClear(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, btn):
		    guitk.BCSetEnabled(btn, True)
		    return 0
		
		
		def filterClearedFunct(listView, btn):
		    print("Cleared all active filters.")
		    guitk.BCSetEnabled(btn, False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterCleared(lv: object) -> bool:

	"""

	Check if filter of ListView lv is clear (no condition is currently applied).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	bool
		True if filter is clear or  False if at least one condition is currently applied.

	See Also
	--------
	BCListViewFilterClear

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded Assembly", "Small", "5")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    toolBtnClean = guitk.BCToolButtonCreate(
		        window, "clean_small.svg", "Clear applied filters", clearFiltersFunct, listView
		    )
		    guitk.BCSetEnabled(toolBtnClean, False)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, toolBtnClean
		    )
		    guitk.BCListViewSetFilterClearedFunction(listView, filterClearedFunct, toolBtnClean)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def clearFiltersFunct(btn, listView):
		    if not guitk.BCListViewFilterCleared(listView):
		        guitk.BCListViewFilterClear(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, btn):
		    guitk.BCSetEnabled(btn, True)
		    return 0
		
		
		def filterClearedFunct(listView, btn):
		    print("Cleared all active filters.")
		    guitk.BCSetEnabled(btn, False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetFilterAsYouTypeOn(lv: object, on: bool) -> None:

	"""

	Set whether filter is applied while text changes inside line edits (as you type).
	This property can be modified by the menu that popups on the button. In ListViews with large number of items you may need to set off and disable this property (cannot be modified by the user).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	on : bool
		set True to enable filtering while text changes inside line edits or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterIsFilterAsYouTypeOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterIsFilterAsYouTypeOn(lv: object) -> bool:

	"""

	Returns True if the property of applying filter as text changes inside line edits is on or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to check.

	Returns
	-------
	bool
		True if filter as you type is on, otherwise returns False.

	See Also
	--------
	BCListViewFilterSetFilterAsYouTypeOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetSelectFilteredOn(lv: object, on: bool) -> None:

	"""

	Sets whether filtered ListViewItems will also be selected.
	This property can be modified by the menu that popups on the button. This is useful if you want to apply a function to the selected items after they have been filtered. Recall that in hierarchical ListViews although an item may be filtered and its parent not, both items will be visible. The default filter has this property on.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	on : bool
		set True to select the filtered items or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterIsSelectFilteredOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterIsSelectFilteredOn(lv: object) -> bool:

	"""

	Returns True if the property of selecting the filtered items is on or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to check.

	Returns
	-------
	bool
		True if selecting filtered items is on, otherwise returns False.

	See Also
	--------
	BCListViewFilterSetSelectFilteredOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetCaseSensitiveOn(lv: object, on: bool) -> None:

	"""

	Sets whether filter is case sensitive.
	If case sensitive is on, 'value' matches 'value' but not 'VALUE'. The default filter has this property off. This property can be modified by the menu that popups on the button.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	on : bool
		set True for case sensitive or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterIsCaseSensitiveOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterIsCaseSensitiveOn(lv: object) -> bool:

	"""

	Returns True if filter is case sensitive or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to check.

	Returns
	-------
	bool
		True if filter is case sensitive, otherwise returns False.

	See Also
	--------
	BCListViewFilterSetCaseSensitiveOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetShowChildrenOn(lv: object, on: bool) -> None:

	"""

	Sets whether filter will enforce a filtered item to show and expand its children.
	The children items to be shown is not necessary to agree with filter. The default filter has this property off. This property can be modified by the menu that popups on the button.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	on : bool
		set True to enforce an item to show its children otherwise set False.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterIsShowChildrenOn(lv: object) -> bool:

	"""

	Returns whether filter enforces a filtered item to show and expand its children.
	The default filter has this property off.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to check.

	Returns
	-------
	bool
		True if filter enforces filtered items to show and expand their children.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetFilterAsYouTypeEnabled(lv: object, enable: bool) -> None:

	"""

	Sets whether the user can modify the filtering when text changes property.
	The default filter has this property on. If you turn off this property, the 'Filter As You Type' option will be disabled in the menu.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	enable : bool
		set True for enabling the user to have filter as you type property or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterSetFilterAsYouTypeOn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    if not guitk.BCListViewColumnDataType(listView, 3) == guitk.constants.BCInt:
		        guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    guitk.BCListViewFilterSetFilterAsYouTypeEnabled(listView, False)
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Apply filter to  'Group B' [Default = 'Group A']"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, setGroupToApplyFilterFunct, listView)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, checkBox
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setGroupToApplyFilterFunct(checkBox, state, listView):
		    guitk.BCListViewFilterApply(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, checkBox):
		    state = guitk.BCCheckBoxIsChecked(checkBox)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, iterateGroupFunct, [state, listView]
		    )
		    return 1
		
		
		def iterateGroupFunct(item, data):
		    parent = guitk.BCListViewItemGetParent(item)
		    if parent:
		        if (
		            not data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group A"
		            or data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group B"
		        ):
		            passes_filter = guitk.BCListViewAboutToFilterItem(data[1], item)
		            if passes_filter:
		                guitk.BCListViewSetSelected(data[1], item, True)
		        guitk.BCListViewSetItemsExpanded(data[1], True)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetSaveListEnabled(lv: object, enable: bool) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	enable : bool
		set True for enabling the user to save the ListViews in txt format or False otherwise.

	Returns
	-------
	None

	"""

def BCListViewFilterSetColumnEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Sets whether filtering at column col is enabled by the user.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	col : int
		the column index.

	enable : bool
		set True for enable user input or False otherwise.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Quantity", "Complete"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, addCheckBoxColFunct, 4
		    )
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewFilterSetColumnEnabled(listView, 2, False)
		    guitk.BCListViewFilterSetFilterAsYouTypeEnabled(listView, False)
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Change filter type to ComboBox at column 'Size'"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, changeFilterTypeFunct, listView)
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addCheckBoxColFunct(item, col):
		    guitk.BCListViewItemSetCheckBox(item, col, True, None, None)
		    return 0
		
		
		def changeFilterTypeFunct(checkBox, state, listView):
		    if state:
		        guitk.BCListViewFilterSetComboBox(listView, 2)
		    else:
		        guitk.BCListViewFilterSetLineEdit(listView, 2)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterApplyCondition(lv: object, col: int, text: str) -> None:

	"""

	Apply a custom condition at a column col.
	The default filter column has a line edit. You can use operators, as well, if you have int or float numbers (for example use '&gt;3'). If filter at column col has a comboBox, the comboBox item with text text will be set as current item and filter will run. If comboBox has not an item with text, nothing happens. If you have checkBox at column col, use '1' or 'true' for checked and '0' or 'false' for unchecked.
	WARNING: Condition cannot be applied in column with checkable menu.
	At the end the function will call filter Applied function.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	col : int
		the column index.

	text : str
		value to filter.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetFilterAboutToApplyFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCToolButtonCreate(
		        window,
		        "filter_small.svg",
		        "Apply Custom Filter: 'Quantity' < 3",
		        applyCustomFilterFunct,
		        listView,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def applyCustomFilterFunct(btn, listView):
		    if guitk.BCListViewFilterIsFilterAsYouTypeOn(listView):
		        guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    if not guitk.BCListViewFilterIsCaseSensitiveOn(listView):
		        guitk.BCListViewFilterSetCaseSensitiveOn(listView, True)
		    if guitk.BCListViewGetSelectionMode(listView) == 0:
		        if not guitk.BCListViewFilterIsSelectFilteredOn(listView):
		            guitk.BCListViewFilterSetSelectFilteredOn(listView, True)
		        if not guitk.BCListViewFilterIsShowChildrenOn(listView):
		            # Note that 'Group B' passes the filter.
		            # Due to the following setting, all its children will be shown, even if they don't pass the filter.
		            guitk.BCListViewFilterSetShowChildrenOn(listView, True)
		    guitk.BCListViewFilterApplyCondition(listView, 3, "<3")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterApply(lv: object) -> None:

	"""

	Apply the current filter.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetFilterAboutToApplyFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Size"], 0)
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetComboBox(listView, 2)
		    toolBtn = guitk.BCToolButtonCreate(
		        window, "add_16.png", "Add New items", addNewItemsFunct, listView
		    )
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addNewParts(listView):
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addPart(listView, "1005", "Spoiler", "Large")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		
		
		def addNewItemsFunct(btn, listView):
		    addNewParts(listView)
		    guitk.BCListViewFilterUpdateComboBox(listView, 2)
		    guitk.BCListViewFilterApply(listView)
		    guitk.BCHide(btn)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterUpdateComboBox(lv: object, col: int) -> None:

	"""

	Updates the comboBox of filter at column col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterSetComboBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Size"], 0)
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetComboBox(listView, 2)
		    toolBtn = guitk.BCToolButtonCreate(
		        window, "add_16.png", "Add New items", addNewItemsFunct, listView
		    )
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addNewParts(listView):
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addPart(listView, "1005", "Spoiler", "Large")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		
		
		def addNewItemsFunct(btn, listView):
		    addNewParts(listView)
		    guitk.BCListViewFilterUpdateComboBox(listView, 2)
		    guitk.BCListViewFilterApply(listView)
		    guitk.BCHide(btn)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetOutputAlwaysHidden(lv: object, alwaysHidden: bool) -> None:

	"""

	Function is obsolete. Use BCListViewFilterSetAutoShowQueryBar() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	alwaysHidden : bool
		set True to permanent hide the output or False to automatically shown the output if needed.

	Returns
	-------
	None

	"""

def BCListViewSetColumnVisibilityChangedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called on column show/hide.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		is a function that will be called when columns are shown or hidden.
		See BC_LISTVIEW_COLUMN_VISIBILITY_CHANGED_FUNCTION for details.
		integer BC_LISTVIEW_COLUMN_VISIBILITY_CHANGED_FUNCTION(lv, col, visible, data)
		The function to be called when a column was shown/hidden.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * col : int
		                    the ListView column.
		          * visible : int
		                    1 when column is shown and 0 if was hidden.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Visibility Changed Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, True)
		    guitk.BCListViewSetColumnVisibilityChangedFunction(
		        listView, lvColumnVisibilityChanged, None
		    )
		    guitk.BCShow(window)
		
		
		def lvColumnVisibilityChanged(listView, col, visible, data):
		    headerText = guitk.BCListViewHeaderGetText(listView, col)
		    isHidden = guitk.BCListViewIsColumnHidden(listView, col)
		    print(
		        "ListView Column '{}', (id {}) IsHidden = {}".format(headerText, col, isHidden)
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnMovedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when the user moves column from one position to another.
	When columns are inserted, they obtain a unique unsigned integer identifier. The columns have also a current position in the ListView. Although the columns can move to a different position, column index remains unchanged.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function to be called when the user moves column. See BC_LISTVIEW_COLUMN_MOVED_FUNCTION for details.
		integer BC_LISTVIEW_COLUMN_MOVED_FUNCTION(lv, col, fromPos, toPos, data)
		The function to be called when the user moves column col from position fromPos to position toPos.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * col : int
		                    the ListView column to be moved.
		          * fromPos : int
		                    the old position of column col.
		          * toPos : int
		                    the new position of column col.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewMoveColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Simple Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - Auto Width", -1)
		    guitk.BCListViewAddColumn(listView, "Part name - Fixed Width", 400)
		    guitk.BCListViewAddColumn(listView, "Version - Resize Disabled", -1)
		    guitk.BCListViewSetColumnResizeEnabled(listView, 2, False)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Resized", 50)
		    guitk.BCListViewSetColumnWidth(listView, 3, 500)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    btnPrintStats = guitk.BCPushButtonCreate(
		        window, "Print Column Stats", printStats, listView
		    )
		    guitk.BCListViewSetColumnMovedFunction(listView, columnMoved, None)
		    guitk.BCListViewSetColumnResizedFunction(listView, columnResized, None)
		    guitk.BCWindowSetAcceptFunction(window, printStats, listView)
		    guitk.BCShow(window)
		
		
		def printStats(_, listView):
		    for col in range(guitk.BCListViewColumns(listView)):
		        print(
		            "Column {}: width={}, position={}".format(
		                col,
		                guitk.BCListViewColumnWidth(listView, col),
		                guitk.BCListViewColumnPosition(listView, col),
		            )
		        )
		    return 0
		
		
		def columnMoved(listView, col, fromPos, toPos, data):
		    print("Column {} moved position from: {} to: {}".format(col, fromPos, toPos))
		    return 0
		
		
		def columnResized(listView, col, oldSize, newSize, data):
		    print("Column {} resized from: {} to: {}".format(col, oldSize, newSize))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnResizedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when the user resizes column.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function to be called when the user resizes columns. See BC_LISTVIEW_COLUMN_RESIZED_FUNCTION for details.
		integer BC_LISTVIEW_COLUMN_RESIZED_FUNCTION(lv, col, oldSize, newSize, data)
		The function to be called when the user resizes column col.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * col : int
		                    the ListView column that resized.
		          * oldSize : int
		                    the old size of resized column col.
		          * newSize : int
		                    the new size of resized column col.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetColumnResizeMode

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Simple Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - Auto Width", -1)
		    guitk.BCListViewAddColumn(listView, "Part name - Fixed Width", 400)
		    guitk.BCListViewAddColumn(listView, "Version - Resize Disabled", -1)
		    guitk.BCListViewSetColumnResizeEnabled(listView, 2, False)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Resized", 50)
		    guitk.BCListViewSetColumnWidth(listView, 3, 500)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    btnPrintStats = guitk.BCPushButtonCreate(
		        window, "Print Column Stats", printStats, listView
		    )
		    guitk.BCListViewSetColumnMovedFunction(listView, columnMoved, None)
		    guitk.BCListViewSetColumnResizedFunction(listView, columnResized, None)
		    guitk.BCWindowSetAcceptFunction(window, printStats, listView)
		    guitk.BCShow(window)
		
		
		def printStats(_, listView):
		    for col in range(guitk.BCListViewColumns(listView)):
		        print(
		            "Column {}: width={}, position={}".format(
		                col,
		                guitk.BCListViewColumnWidth(listView, col),
		                guitk.BCListViewColumnPosition(listView, col),
		            )
		        )
		    return 0
		
		
		def columnMoved(listView, col, fromPos, toPos, data):
		    print("Column {} moved position from: {} to: {}".format(col, fromPos, toPos))
		    return 0
		
		
		def columnResized(listView, col, oldSize, newSize, data):
		    print("Column {} resized from: {} to: {}".format(col, oldSize, newSize))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetFilterClearedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function to be called when the filter is cleared.
	Filter cleared when no condition left or when clicked the 'Reset' button on the left of the output or untoggle the button that shows/hides filter (on the right of ListView header). 
	NOTE: selected ListViewItems that do not match turn deselected.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function to be called when filter is cleared. See BC_LISTVIEW_FILTER_CLEARED_FUNCTION for details.
		integer BC_LISTVIEW_FILTER_CLEARED_FUNCTION(lv, data)
		The function to be called when filter is cleared.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterClear

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded Assembly", "Small", "5")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    toolBtnClean = guitk.BCToolButtonCreate(
		        window, "clean_small.svg", "Clear applied filters", clearFiltersFunct, listView
		    )
		    guitk.BCSetEnabled(toolBtnClean, False)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, toolBtnClean
		    )
		    guitk.BCListViewSetFilterClearedFunction(listView, filterClearedFunct, toolBtnClean)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def clearFiltersFunct(btn, listView):
		    if not guitk.BCListViewFilterCleared(listView):
		        guitk.BCListViewFilterClear(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, btn):
		    guitk.BCSetEnabled(btn, True)
		    return 0
		
		
		def filterClearedFunct(listView, btn):
		    print("Cleared all active filters.")
		    guitk.BCSetEnabled(btn, False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewAboutToFilterItem(lv: object, item: object) -> bool:

	"""

	Check if item item agrees with the current filter condition of ListView lv.
	Returns True if the item item passes the filter otherwise returns False. This function does not change the visibility of an item, but only indicates if the item will be filtered or not in the default procedure.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True if the item agrees with current filter or False otherwise.

	See Also
	--------
	BCListViewSetFilterAboutToApplyFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    if not guitk.BCListViewColumnDataType(listView, 3) == guitk.constants.BCInt:
		        guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    guitk.BCListViewFilterSetFilterAsYouTypeEnabled(listView, False)
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Apply filter to  'Group B' [Default = 'Group A']"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, setGroupToApplyFilterFunct, listView)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, checkBox
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setGroupToApplyFilterFunct(checkBox, state, listView):
		    guitk.BCListViewFilterApply(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, checkBox):
		    state = guitk.BCCheckBoxIsChecked(checkBox)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, iterateGroupFunct, [state, listView]
		    )
		    return 1
		
		
		def iterateGroupFunct(item, data):
		    parent = guitk.BCListViewItemGetParent(item)
		    if parent:
		        if (
		            not data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group A"
		            or data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group B"
		        ):
		            passes_filter = guitk.BCListViewAboutToFilterItem(data[1], item)
		            if passes_filter:
		                guitk.BCListViewSetSelected(data[1], item, True)
		        guitk.BCListViewSetItemsExpanded(data[1], True)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetCtrlXFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when shortcut Ctrl+X key is pressed in the ListView.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_CTRL_X_FUNCTION for details.
		integer BC_LISTVIEW_CTRL_X_FUNCTION(lv, data)
		The function to be called when Ctrl+X key is pressed in ListView lv.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetCtrlCFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView CheckBox Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Quality Assured"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", False)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", True)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", False)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", True)
		
		    guitk.BCListViewSetCtrlXFunction(listView, toggleItemChkBoxes, None)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Pressing Ctrl+X will toggle all CheckBoxes on the selected item.",
		    )
		    guitk.BCShow(window)
		
		
		def toggleItemChkBoxes(listView, data):
		    item = guitk.BCListViewGetSelectedItem(listView)
		    if item != None:
		        for col in range(guitk.BCListViewColumns(listView)):
		            if guitk.BCListViewItemIsCheckBox(item, col):
		                guitk.BCListViewItemCheckBoxSetChecked(
		                    item, col, not guitk.BCListViewItemCheckBoxIsChecked(item, col)
		                )
		    return 0
		
		
		def QAToggled(item, col, state, data):
		    print(
		        "Item ID={}, Column={} CheckBox state set to {}".format(
		            guitk.BCListViewItemGetText(item, 0), col, state
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured, qualityAssured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetCheckBox(item, 4, qualityAssured, QAToggled, None)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetCtrlCFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when shortcut Ctrl+C key is pressed in the ListView.
	
	The standard list view on Ctrl+C copies the contents (text) of selected items for all columns to application global clipboard.
	NOTE: If you set your custom function, the default copy to clipboard of selected items' contents (text) will not run. You can manually call BCListViewCopyItemsToClipboard(list, 1) inside your call back to restore the default copy selected items text to clipboard.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_CTRL_C_FUNCTION for details.
		integer BC_LISTVIEW_CTRL_C_FUNCTION(lv, data)
		The function to be called when Ctrl+C key is pressed in ListView lv.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewCopyItemsToClipboard

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Ctrl+C/V Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(
		            window,
		            "Pressing Ctrl+C copies data from selected items,\\nwhile Ctrl+V prints it",
		        ),
		        guitk.constants.BCAlignHCenter,
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCtrlVFunction(listView, printClipboard, None)
		    chkBox = guitk.BCCheckBoxCreate(window, "Only copy id, name")
		    guitk.BCAddToolTip(
		        chkBox,
		        "By default, Ctrl+C copies all the columns of the selected to the clipboard.",
		    )
		    guitk.BCCheckBoxSetToggledFunction(chkBox, toggleCtrlC, listView)
		    guitk.BCShow(window)
		
		
		def printClipboard(listView, data):
		    print(guitk.BCApplicationClipboardGetText())
		    return 0
		
		
		def toggleCtrlC(chkBox, state, listView):
		    guitk.BCListViewSetCtrlCFunction(
		        listView, copyNamesToClipboard if state else None, None
		    )
		    return 0
		
		
		def copyNamesToClipboard(listView, data):
		    idAndNames = []
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, appendName, idAndNames
		    )
		    guitk.BCApplicationClipboardSetText(str(idAndNames))
		    return 0
		
		
		def appendName(item, idAndNames):
		    idAndNames.append(
		        "{}: {}".format(
		            guitk.BCListViewItemGetInt(item, 0), guitk.BCListViewItemGetText(item, 1)
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetCtrlVFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when shortcut Ctrl+V key is pressed in the ListView.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_CTRL_V_FUNCTION for details.
		integer BC_LISTVIEW_CTRL_V_FUNCTION(lv, data)
		The function to be called when Ctrl+V key is pressed in ListView lv.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetCtrlXFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Ctrl+C/V Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(
		            window,
		            "Pressing Ctrl+C copies data from selected items,\\nwhile Ctrl+V prints it",
		        ),
		        guitk.constants.BCAlignHCenter,
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCtrlVFunction(listView, printClipboard, None)
		    chkBox = guitk.BCCheckBoxCreate(window, "Only copy id, name")
		    guitk.BCAddToolTip(
		        chkBox,
		        "By default, Ctrl+C copies all the columns of the selected to the clipboard.",
		    )
		    guitk.BCCheckBoxSetToggledFunction(chkBox, toggleCtrlC, listView)
		    guitk.BCShow(window)
		
		
		def printClipboard(listView, data):
		    print(guitk.BCApplicationClipboardGetText())
		    return 0
		
		
		def toggleCtrlC(chkBox, state, listView):
		    guitk.BCListViewSetCtrlCFunction(
		        listView, copyNamesToClipboard if state else None, None
		    )
		    return 0
		
		
		def copyNamesToClipboard(listView, data):
		    idAndNames = []
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, appendName, idAndNames
		    )
		    guitk.BCApplicationClipboardSetText(str(idAndNames))
		    return 0
		
		
		def appendName(item, idAndNames):
		    idAndNames.append(
		        "{}: {}".format(
		            guitk.BCListViewItemGetInt(item, 0), guitk.BCListViewItemGetText(item, 1)
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewLastItem(lv: object) -> object:

	"""

	Returns the last item of ListView lv.
	
	If you want to append you item at the end do not move after the last item,
	but consider using BCListViewSetAddItemsInReverseOrderEnabled().
	WARNING: this function traverses the whole ListView and thus is slow on long ListViews.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView of which the last item is returned.

	Returns
	-------
	object
		the last item of ListView or None if no item exists.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SortedFunction Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetItemsSortedFunction(listView, itemsSorted, None)
		    guitk.BCShow(window)
		
		
		def itemsSorted(listView, col, ascending, data):
		    firstText = guitk.BCListViewGetText(listView, 0, col)
		    lastText = guitk.BCListViewItemGetText(guitk.BCListViewLastItem(listView), col)
		    print(
		        "Items sorted {}ending at column {}.".format(
		            "asc" if ascending else "desc", col
		        )
		    )
		    print(
		        "\\tFirst Sorted Column Value: {}\\n\\tLast Sorted Column Value: {}".format(
		            firstText, lastText
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewClearSelection(lv: object) -> None:

	"""

	Deselects all the items in the ListView.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	Returns
	-------
	None

	See Also
	--------
	BCListViewSelectAll

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Selected Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    for i in range(1, guitk.BCListViewColumns(listView)):
		        guitk.BCListViewSetSelectableColumn(listView, i, False)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Click item on ID column or press Space to select an item.",
		    )
		    if guitk.BCListViewGetSelectionMode(listView) != guitk.constants.BCMulti:
		        guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, printIsSelected, None)
		    guitk.BCListViewRestoreSortState(listView)
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnReverse = guitk.BCPushButtonCreate(
		        hBox1, "Reverse Selection", reverseSelectionAll, listView
		    )
		    btnAll = guitk.BCPushButtonCreate(
		        hBox1,
		        "Select All",
		        lambda b, listView: guitk.BCListViewSelectAll(listView),
		        listView,
		    )
		    btnClear = guitk.BCPushButtonCreate(
		        hBox1,
		        "Clear Selection",
		        lambda b, listView: guitk.BCListViewClearSelection(listView),
		        listView,
		    )
		    guitk.BCShow(window)
		
		
		def printIsSelected(listView, item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " isSelected = "
		        + str(guitk.BCListViewIsSelected(listView, item))
		    )
		    return 0
		
		
		def reverseSelectionAll(b, listView):
		    guitk.BCListViewInvertSelection(listView)
		    print("New Selected Count = {}".format(guitk.BCListViewCountSelected(listView)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewAdjustColumn(lv: object, col: int) -> None:

	"""

	Adjusts the column col to its preferred width.
	If you adjust a hidden column it will be first show and then adjust.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView ColumnWidthMode Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - ManualMode", 400)
		    # Using width -1 sets the column to Width Mode = Auto
		    guitk.BCListViewAddColumn(listView, "Part name - MaximumMode", -1)
		    guitk.BCListViewAddColumn(listView, "Version - Maximum to Manual", -1)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Adjusted", 10)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetColumnWidth(listView, 0, 100)
		    # The line below doesn't work because ColumnWidthMode is set to Auto on ListViewAddColumn
		    guitk.BCListViewSetColumnWidth(listView, 1, 100)
		    # Width Mode has to be changed to manual to set a custom width
		    guitk.BCListViewSetColumnWidthMode(listView, 2, guitk.constants.BCManualMode)
		    guitk.BCListViewSetColumnWidth(listView, 2, 40)
		    guitk.BCListViewAdjustColumn(listView, 3)  # Manual can also be adjusted
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewIsColumnHidden(lv: object, col: int) -> bool:

	"""

	Checks if column col of ListView lv is hidden.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	bool
		True if the column is hidden; False otherwise.

	See Also
	--------
	BCListViewHideColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Visibility Changed Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, True)
		    guitk.BCListViewSetColumnVisibilityChangedFunction(
		        listView, lvColumnVisibilityChanged, None
		    )
		    guitk.BCShow(window)
		
		
		def lvColumnVisibilityChanged(listView, col, visible, data):
		    headerText = guitk.BCListViewHeaderGetText(listView, col)
		    isHidden = guitk.BCListViewIsColumnHidden(listView, col)
		    print(
		        "ListView Column '{}', (id {}) IsHidden = {}".format(headerText, col, isHidden)
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewBlockUpdates(lv: object, block: bool) -> None:

	"""

	Restricts updates, repaints and info box updates for ListView lv.
	This functions is normally used to disable updates for a short period of time, for instance to avoid screen flicker or long delays during large changes.
	When updates un-blocked, an update will be triggered.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	block : bool
		set this parameter to True to block updates, or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewAreUpdatesBlocked

	"""

def BCListViewAreUpdatesBlocked(lv: object) -> bool:

	"""

	Returns True if updates are blocked for lv, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	Returns
	-------
	bool
		True if updates are blocked for lv, or False otherwise.

	See Also
	--------
	BCListViewBlockUpdates

	"""

def BCListViewHeaderSetIconFileName(lv: object, col: int, fileName: str) -> None:

	"""

	Sets the icon that will be displayed on the header of ListView lv at column col.
	If an item cell contains both icon and text, the icon is always displayed at the left of the text.
	If an empty string is passed into this function, the icon is cleared.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderSetStringRepresentation

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Header Formatting Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", ""], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewHeaderSetIconFileName(listView, 4, "logo_sdm.svg")
		    guitk.BCListViewHeaderSetColorLine(listView, 0, 255, 0, 0)
		    guitk.BCListViewHeaderSetStringRepresentation(listView, 4, "Alternative")
		    guitk.BCListViewHeaderSetForegroundColor(listView, 2, 255, 0, 0)
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    print(
		        "Notice that in the visibility header menu 'Alternative' text is displayed for column with Icon"
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetMovingEnabled(lv: object, enabled: bool) -> None:

	"""

	Sets whether the list view lv columns can be moved by the user.
	The default list view has this property enabled (columns can move).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	enabled : bool
		False to disable moving columns or True to enable it (the default)

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderIsMovingEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded \\nAssembly", "Small", "6")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetUniformRowHeights(listView, False)
		    guitk.BCListViewSetSaveColumnsEnabled(listView, True)
		    guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "lock_small.svg", "", lockColumnsFunct, listView
		    )
		    text = "Click on the button to unlock columns' movement."
		    guitk.BCAddToolTip(toolBtn, text)
		    guitk.BCListViewSetHeaderToolButton(listView, toolBtn)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def lockColumnsFunct(btn, listView):
		    if guitk.BCListViewHeaderIsMovingEnabled(listView):
		        guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		        guitk.BCButtonSetIconFileName(btn, "lock_small.svg")
		    else:
		        guitk.BCListViewHeaderSetMovingEnabled(listView, True)
		        guitk.BCButtonSetIconFileName(btn, "unlock_small.svg")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderIsMovingEnabled(lv: object) -> bool:

	"""

	Returns True if the columns can be moved by the user (by dragging header sections) otherwise returns False.
	The default list view has this property enabled (columns can move).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	Returns
	-------
	bool
		True if columns can be moved, otherwise returns False.

	See Also
	--------
	BCListViewHeaderSetMovingEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded \\nAssembly", "Small", "6")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetUniformRowHeights(listView, False)
		    guitk.BCListViewSetSaveColumnsEnabled(listView, True)
		    guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "lock_small.svg", "", lockColumnsFunct, listView
		    )
		    text = "Click on the button to unlock columns' movement."
		    guitk.BCAddToolTip(toolBtn, text)
		    guitk.BCListViewSetHeaderToolButton(listView, toolBtn)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def lockColumnsFunct(btn, listView):
		    if guitk.BCListViewHeaderIsMovingEnabled(listView):
		        guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		        guitk.BCButtonSetIconFileName(btn, "lock_small.svg")
		    else:
		        guitk.BCListViewHeaderSetMovingEnabled(listView, True)
		        guitk.BCButtonSetIconFileName(btn, "unlock_small.svg")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetItemExpandedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when an item of ListView lv is expanded.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView where the expanded item lives.

	funct : Callable
		the function that will be called. 
		See BC_LISTVIEW_ITEM_EXPANDED_FUNCTION for details.
		integer BC_LISTVIEW_ITEM_EXPANDED_FUNCTION(lv, item, data)
		The function to be called when an item of ListView lv is expanded.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem that is expanded.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemCollapsedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item [Expanded|Collapsed] Function Example",
		        guitk.constants.BCOnExitDestroy,
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], False)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    hexa = addShapeGroup(listView, "Hexagon", "6")
		    penta = addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    addShape(quad, "Parallelogram", "4")
		    addShape(quad, "Trapezoid", "4")
		    addShape(tria, "Acute", "3")
		    addShape(tria, "Isosceles", "3")
		    addShape(tria, "Right", "3")
		    guitk.BCListViewSetSortingColumn(listView, 1, False)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		    guitk.BCListViewSetExpandItemsButtonEnabled(listView, True)
		    guitk.BCListViewSetItemExpandedFunction(listView, itemExpanded, None)
		    guitk.BCListViewSetItemCollapsedFunction(listView, itemCollapsed, None)
		    guitk.BCShow(window)
		
		
		def itemExpanded(listView, item, data):
		    print(guitk.BCListViewItemGetText(item, 0) + " expanded!")
		    return 0
		
		
		def itemCollapsed(listView, item, data):
		    print(guitk.BCListViewItemGetText(item, 0) + " collapsed!")
		    return 0
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parent, name, sides):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetItemCollapsedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when an item of ListView lv is collapsed.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView where the collapsed item lives.

	funct : Callable
		the function that will be called. 
		See BC_LISTVIEW_ITEM_COLLAPSED_FUNCTION for details.
		integer BC_LISTVIEW_ITEM_COLLAPSED_FUNCTION(lv, item, data)
		The function to be called when an item of ListView lv is collapsed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem that is collapsed.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemExpandedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item [Expanded|Collapsed] Function Example",
		        guitk.constants.BCOnExitDestroy,
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], False)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    hexa = addShapeGroup(listView, "Hexagon", "6")
		    penta = addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    addShape(quad, "Parallelogram", "4")
		    addShape(quad, "Trapezoid", "4")
		    addShape(tria, "Acute", "3")
		    addShape(tria, "Isosceles", "3")
		    addShape(tria, "Right", "3")
		    guitk.BCListViewSetSortingColumn(listView, 1, False)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		    guitk.BCListViewSetExpandItemsButtonEnabled(listView, True)
		    guitk.BCListViewSetItemExpandedFunction(listView, itemExpanded, None)
		    guitk.BCListViewSetItemCollapsedFunction(listView, itemCollapsed, None)
		    guitk.BCShow(window)
		
		
		def itemExpanded(listView, item, data):
		    print(guitk.BCListViewItemGetText(item, 0) + " expanded!")
		    return 0
		
		
		def itemCollapsed(listView, item, data):
		    print(guitk.BCListViewItemGetText(item, 0) + " collapsed!")
		    return 0
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parent, name, sides):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewMoveColumn(lv: object, col: int, newPos: int) -> None:

	"""

	Moves column col to position newPos.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	newPos : int
		the new position where the moved column will be positioned.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetColumnMovedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Tree", guitk.constants.BCOnExitDestroy
		    )
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], False)
		    # create group A
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 1, "Group A31")
		    addPart(groupA, "Bumper", "A31_1001", "8")
		    addPart(groupA, "Decklid", "A31_1002", "12")
		    # create group B
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 1, "Group B12")
		    addPart(groupB, "Roof rack", "B12_1004", "6")
		    addPart(groupB, "Spoiler", "B12_1005", "2")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(treeView, 0, True)
		    # item expand/collapse controllers display only at first column ('Part name' in this case)
		    guitk.BCListViewSetRootIsDecorated(treeView, True)
		    guitk.BCListViewSetItemsExpanded(treeView, True)
		    guitk.BCListViewMoveColumn(treeView, 1, 0)
		    guitk.BCShow(window)
		
		
		def addPart(parentItem, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetItemSelectedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when an item of Listview lv is selected (only available in single selection mode).
	If selection changes from an item to another, the deselect function will operate first.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView where the selected item belongs to.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_ITEM_SELECTED_FUNCTION for details.
		integer BC_LISTVIEW_ITEM_SELECTED_FUNCTION(lv, item, data)
		The function to be called when an item of Listview lv is selected.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem that is selected.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemDeselectedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Inactive and Disabled Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Item Description"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    itemInactive = addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewItemSetInactive(itemInactive, True)
		    guitk.BCListViewItemSetText(itemInactive, 4, "Inactive item")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    itemDisabled = addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewItemSetEnabled(itemDisabled, False)
		    guitk.BCListViewItemSetText(itemDisabled, 4, "Disabled item")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, None)
		    guitk.BCListViewSetItemDeselectedFunction(listView, itemDeselected, None)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, printInactiveEnabled, None
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printInactiveEnabled(item, data):
		    print(
		        "Item ID={}: isInactive = {}, isEnabled = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemInactive(item),
		            guitk.BCListViewItemIsEnabled(item),
		        )
		    )
		    return 0
		
		
		def itemSelected(listView, item, data):
		    print(
		        "--------------\\nItem ID={} Selected!".format(
		            guitk.BCListViewItemGetText(item, 0)
		        )
		    )
		    return 0
		
		
		def itemDeselected(listView, item, data):
		    print("Item ID={} Deselected!".format(guitk.BCListViewItemGetText(item, 0)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetText(item, 4, "Regular Item")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetItemDeselectedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when an item of Listview lv is deselected (only available in single selection mode).
	If selection changes from an item to another, the deselect function will operate first.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView which the deselected item belongs to.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_ITEM_DESELECTED_FUNCTION for details.
		integer BC_LISTVIEW_ITEM_DESELECTED_FUNCTION(lv, item, data)
		The function to be called when an item of Listview lv is deselected.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem that is deselected.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemSelectedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Inactive and Disabled Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Item Description"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    itemInactive = addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewItemSetInactive(itemInactive, True)
		    guitk.BCListViewItemSetText(itemInactive, 4, "Inactive item")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    itemDisabled = addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewItemSetEnabled(itemDisabled, False)
		    guitk.BCListViewItemSetText(itemDisabled, 4, "Disabled item")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, None)
		    guitk.BCListViewSetItemDeselectedFunction(listView, itemDeselected, None)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, printInactiveEnabled, None
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printInactiveEnabled(item, data):
		    print(
		        "Item ID={}: isInactive = {}, isEnabled = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemInactive(item),
		            guitk.BCListViewItemIsEnabled(item),
		        )
		    )
		    return 0
		
		
		def itemSelected(listView, item, data):
		    print(
		        "--------------\\nItem ID={} Selected!".format(
		            guitk.BCListViewItemGetText(item, 0)
		        )
		    )
		    return 0
		
		
		def itemDeselected(listView, item, data):
		    print("Item ID={} Deselected!".format(guitk.BCListViewItemGetText(item, 0)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetText(item, 4, "Regular Item")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetSelectableColumn(lv: object, col: int, selectable: bool) -> None:

	"""

	Set the items of listview lv not to be selected when the user mouse presses on column col.
	The default list view has all columns selectable. If a column is non-selectable, the item is not selected when mouse pressed in specific column but mouse press function operates. Widgets inside column col operates normally. Is useful for switching checkBoxes on/off on a ListView without selection change the item. If heavily used, may produce not so user friendly environments.
	Do not conflict selectable column with the selection mode of a ListView.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	selectable : bool
		set False to disable selecting items and True to the default behavior.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetSelectable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Selected Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    for i in range(1, guitk.BCListViewColumns(listView)):
		        guitk.BCListViewSetSelectableColumn(listView, i, False)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Click item on ID column or press Space to select an item.",
		    )
		    if guitk.BCListViewGetSelectionMode(listView) != guitk.constants.BCMulti:
		        guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, printIsSelected, None)
		    guitk.BCListViewRestoreSortState(listView)
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnReverse = guitk.BCPushButtonCreate(
		        hBox1, "Reverse Selection", reverseSelectionAll, listView
		    )
		    btnAll = guitk.BCPushButtonCreate(
		        hBox1,
		        "Select All",
		        lambda b, listView: guitk.BCListViewSelectAll(listView),
		        listView,
		    )
		    btnClear = guitk.BCPushButtonCreate(
		        hBox1,
		        "Clear Selection",
		        lambda b, listView: guitk.BCListViewClearSelection(listView),
		        listView,
		    )
		    guitk.BCShow(window)
		
		
		def printIsSelected(listView, item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " isSelected = "
		        + str(guitk.BCListViewIsSelected(listView, item))
		    )
		    return 0
		
		
		def reverseSelectionAll(b, listView):
		    guitk.BCListViewInvertSelection(listView)
		    print("New Selected Count = {}".format(guitk.BCListViewCountSelected(listView)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSelectedItem(lv: object) -> object:

	"""

	Function is obsolete. Use BCListViewGetSelectedItem() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	object
		the selected item in BCSingle selection mode.

	"""

def BCListViewFindItem(lv: object, text: str, col: int, mode: int) -> object:

	"""

	Finds the first ListViewItem in column col, that matches text.
	The search starts from the current item, if the current item exists, otherwise it starts from the first ListViewItem. 
	Pass OR-ed together mode values in the BCEnumComparisonMode to control how the matching is performed.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	text : str
		the text in base of which the search will be performed.

	col : int
		the column index.

	mode : int
		the comparison mode. See BCEnumComparisonMode for details.
		
		guitk.constants BCEnumComparisonMode
		This enum type is used to set the string comparison mode when searching for an item. It can be used by BCListViewFindItem.
		 - guitk.constants.BCCaseSensitive
		The strings must match case sensitively.
		 - guitk.constants.BCBeginsWith
		The target string begins with the search string.
		 - guitk.constants.BCEndsWith
		The target string ends with the search string.
		 - guitk.constants.BCContains
		The target string contains the search string.
		 - guitk.constants.BCExactMatch
		The target and search strings must match exactly.

	Returns
	-------
	object
		the first ListViewItem that matches text, None otherwise.

	See Also
	--------
	BCListViewForEachItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Iterate", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    # Find the part Pillar 1003 button
		    buttonFrame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(buttonFrame, guitk.constants.BCHorizontal)
		    guitk.BCSpacerCreate(buttonFrame)
		    guitk.BCPushButtonCreate(
		        buttonFrame, "Find the part Pillar 1003", FindPillar1003ButtonClicked, listView
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def CheckForPillar1003(item, part1003List):
		    print("Checking item ", guitk.BCListViewItemGetText(item, 0))
		    if (
		        guitk.BCListViewItemGetText(item, 0) == "1003"
		        and guitk.BCListViewItemGetText(item, 1) == "Pillar"
		    ):
		        part1003List.append(item)
		        return 1  # I know no duplicate items so stop iterating
		    return 0  # keep searching
		
		
		def FindPillar1003ButtonClicked(button, listView):
		    # Using BCListViewFindItem
		    maybePillar = guitk.BCListViewFindItem(
		        listView, "1003", 0, guitk.constants.BCExactMatch
		    )
		    if maybePillar:
		        if guitk.BCListViewItemGetText(maybePillar, 1) == "Pillar":
		            print("Pillar 1003 was found using FindItem")
		
		    # Using iterate we can compare both id and name for each item
		    part1003List = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, CheckForPillar1003, part1003List
		    )
		    if len(part1003List):
		        print("Pillar 1003 was found.")
		        guitk.BCListViewSetSelected(listView, part1003List[0], True)
		    else:
		        print("Pillar 1003 was not found.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetMouseClickedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called whenever the user clicks (mouse pressed and mouse released) in ListView lv.
	Mouse press and click events can change the selected item(s), a user activity discoverable using BCListViewSetSelectionChangedFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function to be called. See BC_LISTVIEW_MOUSE_CLICKED_FUNCTION for details.
		integer BC_LISTVIEW_MOUSE_CLICKED_FUNCTION(lv, mb, item, col, data)
		The function to be called whenever the user clicks (mouse pressed and mouse released) in the list view.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		NOTE: Consider to check item existence since will be empty when mouse clicked on empty viewport area.
		
		Arguments
		          * lv : object
		                    the ListView.
		          * mb : int
		                    the mouse button pressed. See BCEnumButtonState for details.
		          * item : object
		                    the ListViewItem under the mouse when the button was clicked.
		          * col : int
		                    the ListView column under the mouse when the button double clicked.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetMousePressedFunction

	"""

def BCListViewGetCurrentItem(lv: object) -> object:

	"""

	Returns the current ListViewItem of ListView lv.
	The current item is the one with the focus and it might be None.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	object
		the current item of lv.

	See Also
	--------
	BCListViewSetCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetCurrentItem(lv: object, item: object=None) -> None:

	"""

	Sets the ListViewItem item to be the current item of ListView lv.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	item : object, optional
		the ListViewItem.

	Returns
	-------
	None

	See Also
	--------
	BCListViewGetCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSelectAll(lv: object) -> None:

	"""

	Selects all the items of the Listview lv.
	NOTE: This only works in the selection mode BCMulti.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	See Also
	--------
	BCListViewClearSelection

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Selected Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    for i in range(1, guitk.BCListViewColumns(listView)):
		        guitk.BCListViewSetSelectableColumn(listView, i, False)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Click item on ID column or press Space to select an item.",
		    )
		    if guitk.BCListViewGetSelectionMode(listView) != guitk.constants.BCMulti:
		        guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, printIsSelected, None)
		    guitk.BCListViewRestoreSortState(listView)
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnReverse = guitk.BCPushButtonCreate(
		        hBox1, "Reverse Selection", reverseSelectionAll, listView
		    )
		    btnAll = guitk.BCPushButtonCreate(
		        hBox1,
		        "Select All",
		        lambda b, listView: guitk.BCListViewSelectAll(listView),
		        listView,
		    )
		    btnClear = guitk.BCPushButtonCreate(
		        hBox1,
		        "Clear Selection",
		        lambda b, listView: guitk.BCListViewClearSelection(listView),
		        listView,
		    )
		    guitk.BCShow(window)
		
		
		def printIsSelected(listView, item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " isSelected = "
		        + str(guitk.BCListViewIsSelected(listView, item))
		    )
		    return 0
		
		
		def reverseSelectionAll(b, listView):
		    guitk.BCListViewInvertSelection(listView)
		    print("New Selected Count = {}".format(guitk.BCListViewCountSelected(listView)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetComboBox(item: object, col: int, vals: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets a combo box to be displayed in the ListViewItem item cell specified by the given column col.
	You can also use generic item widget functions BCListViewItemWidgetSetVisible(), BCListViewItemWidgetSetEnabled() and BCListViewItemWidgetDestroy().
	WARNING: Do not set any item cell contents (text, icon etc) to the same cell with ComboBox when using BCListViewSetItemComboBoxFrameDrawn().
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	vals : object
		a list of strings with which the ComboBox will be populated.

	funct : Callable
		a callback function that will be called when the user chooses an item. See BC_LISTVIEWITEM_COMBOBOX_ACTIVATED_FUNCTION for details.
		integer BC_LISTVIEWITEM_COMBOBOX_ACTIVATED_FUNCTION(item, col, index, data)
		The function to be called when the user chooses an item in the combo box.
		Note that the callback will be executed even when the choice is not changed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column in which the comboBox is found.
		          * index : int
		                    the index of the activated item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsComboBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Item Widgets", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Completed"], 0
		    )
		    item1 = addPart(listView, "1001", "Bumper")
		    guitk.BCListViewItemCheckBoxSetChecked(item1, 3, True)
		    item2 = addPart(listView, "1002", "Decklid")
		    # This will not trigger the ComboBox callback
		    guitk.BCListViewItemComboBoxSetCurrentItem(item2, 2, 1)
		    item3 = addPart(listView, "1003", "Pillar")
		    item4 = addPart(listView, "1004", "Roof rack")
		    guitk.BCListViewItemCheckBoxSetChecked(item4, 3, True)
		    # This will trigger the ComboBox callback:
		    guitk.BCListViewItemComboBoxSetCurrentItemExecuteActivatedCallBack(item4, 2, 2)
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name):
		    users = ["Alexander", "David", "George", "Sarah"]
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(item, 2, users, AssigneeChanged, None)
		    guitk.BCListViewItemSetCheckBox(item, 3, False, CompletedChanged, None)
		    return item
		
		
		def AssigneeChanged(item, col, index, data):
		    print("Assignee Changed!")
		    # UpdateDataOnAssigneeChanged()
		    return 0
		
		
		def CompletedChanged(item, col, state, data):
		    print("Completed Changed!")
		    # UpdateDataOnCompletedChanged()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetComboBoxAlwaysVisible(lv: object, visible: bool) -> None:

	"""

	Function is obsolete. Use BCListViewSetItemComboBoxFrameDrawn() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	visible : bool
		sets this parameter to 1 for the comboBoxes to be always visible, or 0 otherwise. If False is set the comboBoxes will only be visible upon ListViewItem selection.

	Returns
	-------
	None

	"""

def BCListViewComboBoxAlwaysVisible(lv: object) -> bool:

	"""

	Function is obsolete. Use BCListViewIsItemComboBoxFrameDrawn() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	bool
		True if the ComboBoxes are always visible, or False if only their current value is shown.

	"""

def BCListViewSetGridVisible(lv: object, visible: bool) -> None:

	"""

	Paints list view lv with grid lines between item cells (default off).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	visible : bool
		set 1 to show grid lines for lv or to 0 to hide the grid.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Grid Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    gridChkBox = guitk.BCCheckBoxCreate(window, "View Grid")
		    guitk.BCCheckBoxSetToggledFunction(gridChkBox, viewGrid, listView)
		    guitk.BCShow(window)
		
		
		def viewGrid(chkBox, state, listView):
		    guitk.BCListViewSetGridVisible(listView, state)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetHeaderToolButton(lv: object, toolButton: object) -> None:

	"""

	Inserts a button to the right of the header in ListView lv.
	The ListView takes ownership of the Button. It is recommended that you design and insert a small rectangular button with an icon. Do not use big text because a button with large width may overlap header columns. Your button coexists with header sections. 
	NOTE: The button will be reparented from its previous layout.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	toolButton : object
		the custom tool button to be incorporated.

	Returns
	-------
	None

	See Also
	--------
	BCToolButtonCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded \\nAssembly", "Small", "6")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetUniformRowHeights(listView, False)
		    guitk.BCListViewSetSaveColumnsEnabled(listView, True)
		    guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "lock_small.svg", "", lockColumnsFunct, listView
		    )
		    text = "Click on the button to unlock columns' movement."
		    guitk.BCAddToolTip(toolBtn, text)
		    guitk.BCListViewSetHeaderToolButton(listView, toolBtn)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def lockColumnsFunct(btn, listView):
		    if guitk.BCListViewHeaderIsMovingEnabled(listView):
		        guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		        guitk.BCButtonSetIconFileName(btn, "lock_small.svg")
		    else:
		        guitk.BCListViewHeaderSetMovingEnabled(listView, True)
		        guitk.BCButtonSetIconFileName(btn, "unlock_small.svg")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewTriggerUpdate(lv: object) -> None:

	"""

	Triggers a size, geometry and content update to ListView lv.
	Designed for special cases when managing large data sets. For example you may block list updates 
	during a loop and trigger updates at certain periods of time.
	NOTE: You might never use this function.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	Returns
	-------
	None

	See Also
	--------
	BCListViewBlockUpdates

	"""

def BCListViewSetAddItemsInReverseOrderEnabled(lv: object, enable: bool) -> None:

	"""

	Defines where a newly added item will be placed, first (default) or last.
	When adding an item as top level or item's child, it can be placed first (reverse order) or last (normal order).
	Reverse order is slower than normal, since intermediate items will internally update some of their data.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	enable : bool
		the standard list has this property true.

	Returns
	-------
	None

	See Also
	--------
	BCListViewAddTopLevelItem

	"""

def BCListViewBlockSelectionChangeFunctionOnMouseDragging(lv: object, single: bool) -> None:

	"""

	Set whether selection change function call is blocked, when selecting multiple items by dragging the mouse over them.
	The standard list has this property on. Has a meaning for lists with multiple item selection. 
	Selection change on right mouse press is not affected. Designed for cases where you have set an expensive function 
	in the selection change event and you want to avoid multiple function calls during selecting multiple items using mouse drag. 
	The selection change call back will be executed once when selection finished (mouse button released).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	single : bool
		set True to enable single selection on mouse drag or False (default) otherwise.

	Returns
	-------
	None

	"""

def BCListViewItemComboBoxInsertStrList(item: object, col: int, vals: object) -> None:

	"""

	Inserts the array of strings vals in the comboBox.
	NOTE: The comboBox is cleared before inserting any items.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	vals : object
		the array of strings. If you pass None here, you'll end up with an empty comboBox.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxIndexOf

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Confirm Selected Assignee"], 0
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    addPart(listView, "1004", "Roof rack")
		    addPart(listView, "1005", "Spoiler")
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    comboBoxCol = 2
		    checkBoxCol = 3
		    guitk.BCListViewItemSetComboBox(
		        item, comboBoxCol, "", comboBoxActivatedFunct, checkBoxCol
		    )
		    guitk.BCListViewItemComboBoxInsertStrList(item, comboBoxCol, users)
		    guitk.BCListViewItemComboBoxInsertItem(item, comboBoxCol, "Select Assignee", 0)
		    guitk.BCListViewItemSetCheckBox(
		        item, checkBoxCol, False, assigneeConfirmedFunct, comboBoxCol
		    )
		    guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, checkBoxCol):
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, col)
		    if curText == "Select Assignee":
		        # Disable CheckBox if no assignee is selected
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    else:
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, True)
		        curIndex = guitk.BCListViewItemComboBoxIndexOf(item, col, curText)
		        print(
		            "Selected assignee no."
		            + str(curIndex)
		            + ": "
		            + curText
		            + ". Select CheckBox to confirm."
		        )
		    return 0
		
		
		def assigneeConfirmedFunct(item, col, state, comboBoxCol):
		    guitk.BCListViewItemWidgetSetEnabled(item, comboBoxCol, not state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxSetCurrentText(item: object, col: int, text: str) -> None:

	"""

	Sets the text of the combobox's current item to text text;
	If the combobox contains an item with text equal to text, then that item becomes current. If
	not, in case the combobox is editable then it's lineEdit text is set to text without adding any new
	item. If it's not editable then the current item's text is replaced with the new text.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	text : str
		the new text to be shown.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxCurrentText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxCurrentText(item: object, col: int) -> str:

	"""

	Returns the current text of the comboBox found at column col of ListViewItem item.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	str
		the current text of the comboBox.

	See Also
	--------
	BCListViewItemComboBoxText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Confirm Selected Assignee"], 0
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    addPart(listView, "1004", "Roof rack")
		    addPart(listView, "1005", "Spoiler")
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    comboBoxCol = 2
		    checkBoxCol = 3
		    guitk.BCListViewItemSetComboBox(
		        item, comboBoxCol, "", comboBoxActivatedFunct, checkBoxCol
		    )
		    guitk.BCListViewItemComboBoxInsertStrList(item, comboBoxCol, users)
		    guitk.BCListViewItemComboBoxInsertItem(item, comboBoxCol, "Select Assignee", 0)
		    guitk.BCListViewItemSetCheckBox(
		        item, checkBoxCol, False, assigneeConfirmedFunct, comboBoxCol
		    )
		    guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, checkBoxCol):
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, col)
		    if curText == "Select Assignee":
		        # Disable CheckBox if no assignee is selected
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    else:
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, True)
		        curIndex = guitk.BCListViewItemComboBoxIndexOf(item, col, curText)
		        print(
		            "Selected assignee no."
		            + str(curIndex)
		            + ": "
		            + curText
		            + ". Select CheckBox to confirm."
		        )
		    return 0
		
		
		def assigneeConfirmedFunct(item, col, state, comboBoxCol):
		    guitk.BCListViewItemWidgetSetEnabled(item, comboBoxCol, not state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxText(item: object, col: int, index: int) -> str:

	"""

	Returns the text of the ListView's comboBox at position index, or None if index does not exist.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	index : int
		the item position.

	Returns
	-------
	str
		the current text of the comboBox, or None if index does not exist.

	See Also
	--------
	BCListViewItemComboBoxCurrentText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxInsertItem(item: object, col: int, text: str, index: int) -> None:

	"""

	Inserts a comboBox item with text text, at position index to a comboBox that belongs to ListViewItem item.
	The item will be appended if index is negative.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	text : str
		the text that will be inserted.

	index : int
		the index at which text will be inserted (-1 to append).

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxRemoveItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxRemoveItem(item: object, col: int, index: int) -> None:

	"""

	Removes the comboBox item at index index of the comboBox found at column col of ListViewItem item.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	index : int
		the index of the comboBox item to remove.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxSetCurrentItem(item: object, col: int, index: int) -> None:

	"""

	Sets the current item of the comboBox found at column col of ListViewItem item to be the item with index index.
	WARNING: this function doesn't trigger the activated callback set by the user.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	index : int
		the index of the item to which current will be set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Item Widgets", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Completed"], 0
		    )
		    item1 = addPart(listView, "1001", "Bumper")
		    guitk.BCListViewItemCheckBoxSetChecked(item1, 3, True)
		    item2 = addPart(listView, "1002", "Decklid")
		    # This will not trigger the ComboBox callback
		    guitk.BCListViewItemComboBoxSetCurrentItem(item2, 2, 1)
		    item3 = addPart(listView, "1003", "Pillar")
		    item4 = addPart(listView, "1004", "Roof rack")
		    guitk.BCListViewItemCheckBoxSetChecked(item4, 3, True)
		    # This will trigger the ComboBox callback:
		    guitk.BCListViewItemComboBoxSetCurrentItemExecuteActivatedCallBack(item4, 2, 2)
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name):
		    users = ["Alexander", "David", "George", "Sarah"]
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(item, 2, users, AssigneeChanged, None)
		    guitk.BCListViewItemSetCheckBox(item, 3, False, CompletedChanged, None)
		    return item
		
		
		def AssigneeChanged(item, col, index, data):
		    print("Assignee Changed!")
		    # UpdateDataOnAssigneeChanged()
		    return 0
		
		
		def CompletedChanged(item, col, state, data):
		    print("Completed Changed!")
		    # UpdateDataOnCompletedChanged()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxCurrentItem(item: object, col: int) -> int:

	"""

	Returns the index of the current item of the comboBox found at column col of ListViewItem item.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	int
		the index of the current item of the current item of the comboBox; -1 in case of error.

	See Also
	--------
	BCListViewItemComboBoxSetCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxCount(item: object, col: int) -> int:

	"""

	Returns the number of items in the comboBox found at column col of ListViewItem item.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	int
		the number of items in the comboBox.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsComboBox(item: object, col: int) -> bool:

	"""

	Returns True if the ListViewItem item cell displays a combo box at given column col, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	col : int
		the column index.

	Returns
	-------
	bool
		True if the ListViewItem item at column col is a comboBox, or False otherwise.

	See Also
	--------
	BCListViewItemSetComboBox

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, randint
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Is Some Widget Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        8,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "Radio",
		            "ComboBox",
		            "Progress",
		            "Button",
		        ],
		        False,
		    )
		    btnGroup = guitk.BCListViewButtonGroupCreate(listView, 4)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", btnGroup)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", btnGroup)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", btnGroup)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", btnGroup)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, printIsers, None)
		    guitk.BCShow(window)
		
		
		def printIsers(listView, item, data):
		    itemId = guitk.BCListViewItemGetText(item, 0)
		    for col in range(4, 8):
		        print(
		            "\\nItem ID={}, Column {} IsRadioButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsRadioButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsComboBox = {}".format(
		                itemId, col, guitk.BCListViewItemIsComboBox(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsProgressBar = {}".format(
		                itemId, col, guitk.BCListViewItemIsProgressBar(item, col)
		            )
		        )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured, btnGroup):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add widgets
		    guitk.BCListViewItemSetRadioButton(item, 4, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(btnGroup, item)
		    guitk.BCListViewItemSetComboBox(
		        item, 5, ["Triangles", "Ortho-Triangles", "Rectangles"], None, None
		    )
		    guitk.BCListViewItemSetProgressBar(item, 6)
		    guitk.BCListViewItemProgressBarSetProgress(item, 6, randint(0, 100))
		    guitk.BCListViewItemSetButton(item, 7, None, None)
		    guitk.BCListViewItemButtonSetText(item, 7, "Button")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewColumnPosition(lv: object, col: int) -> int:

	"""

	Returns the position of the column with the given index col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	int
		the position of the column with the given index or -1 if column index is invalid.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Simple Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - Auto Width", -1)
		    guitk.BCListViewAddColumn(listView, "Part name - Fixed Width", 400)
		    guitk.BCListViewAddColumn(listView, "Version - Resize Disabled", -1)
		    guitk.BCListViewSetColumnResizeEnabled(listView, 2, False)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Resized", 50)
		    guitk.BCListViewSetColumnWidth(listView, 3, 500)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    btnPrintStats = guitk.BCPushButtonCreate(
		        window, "Print Column Stats", printStats, listView
		    )
		    guitk.BCListViewSetColumnMovedFunction(listView, columnMoved, None)
		    guitk.BCListViewSetColumnResizedFunction(listView, columnResized, None)
		    guitk.BCWindowSetAcceptFunction(window, printStats, listView)
		    guitk.BCShow(window)
		
		
		def printStats(_, listView):
		    for col in range(guitk.BCListViewColumns(listView)):
		        print(
		            "Column {}: width={}, position={}".format(
		                col,
		                guitk.BCListViewColumnWidth(listView, col),
		                guitk.BCListViewColumnPosition(listView, col),
		            )
		        )
		    return 0
		
		
		def columnMoved(listView, col, fromPos, toPos, data):
		    print("Column {} moved position from: {} to: {}".format(col, fromPos, toPos))
		    return 0
		
		
		def columnResized(listView, col, oldSize, newSize, data):
		    print("Column {} resized from: {} to: {}".format(col, oldSize, newSize))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetSaveColumnsEnabled(lv: object, enable: bool) -> None:

	"""

	Set whether columns visual data will be stored to xml file or not depending on the value of enable.
	The column visual data stored are
	- width
	- position
	- visibility state (shown/hidden)
	Data stored with the given column text. If you have column with icon only (no text) use BCListViewHeaderSetStringRepresentation().
	The data that read from xml will be applied to your ListView just before the window is shown.
	WARNING: The width mode will be changed to "BCManualMode" for all columns.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	enable : bool
		set True to enable saving the column widths of ListView lv, otherwise set False.

	Returns
	-------
	None

	See Also
	--------
	BCListViewIsSaveColumnsEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded \\nAssembly", "Small", "6")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetUniformRowHeights(listView, False)
		    guitk.BCListViewSetSaveColumnsEnabled(listView, True)
		    guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "lock_small.svg", "", lockColumnsFunct, listView
		    )
		    text = "Click on the button to unlock columns' movement."
		    guitk.BCAddToolTip(toolBtn, text)
		    guitk.BCListViewSetHeaderToolButton(listView, toolBtn)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def lockColumnsFunct(btn, listView):
		    if guitk.BCListViewHeaderIsMovingEnabled(listView):
		        guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		        guitk.BCButtonSetIconFileName(btn, "lock_small.svg")
		    else:
		        guitk.BCListViewHeaderSetMovingEnabled(listView, True)
		        guitk.BCButtonSetIconFileName(btn, "unlock_small.svg")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewIsSaveColumnsEnabled(lv: object) -> bool:

	"""

	Returns whether columns visual data will be stored to xml file or not.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	bool
		True if the column widths of ListView will be saved, or False if they will not be saved.

	See Also
	--------
	BCListViewSetSaveColumnsEnabled

	"""

def BCListViewSetRenameItemPrecision(lv: object, prec: int) -> None:

	"""

	Sets the number of digits after the decimal point (precision) when renaming items that accept double. Default is 6 digits.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	prec : int
		the number of digits.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetDisplayDoubleDecimals

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Value"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", "2", "91.57")
		    addPart(listView, "1002", "Decklid", "1", "15.12")
		    createHeaderSideButtons(infoBox, listView, 2)
		    addPart(listView, "1003", "Pillar", "3", "62.03")
		    createHeaderSideButtons(infoBox, listView, 3)
		    guitk.BCListViewSetColumnDataType(listView, 2, guitk.constants.BCInt)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCDouble)
		    guitk.BCListViewSetRenameItemPrecision(listView, 3)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, quantity, value):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetText(item, 3, value)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def createHeaderSideButtons(infoBox, listView, col):
		    dict = {"listView": listView, "col": col, "infoBox": infoBox}
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "gear.svg", "", lambda btn, data: calculateFunct(btn, **data), dict
		    )
		    guitk.BCListViewHeaderSetColumnSideButton(listView, col, toolBtn)
		    guitk.BCListViewHeaderSetToolTip(listView, col, "Calculate Sum")
		
		
		def calculateFunct(btn, listView=0, col=0, infoBox=0):
		    isInt = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCInt
		    isDouble = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCDouble
		    rows = guitk.BCListViewTopLevelItemCount(listView)
		    total = 0
		    if isInt:
		        for row in range(rows):
		            total += guitk.BCListViewGetInt(listView, row, col)
		    elif isDouble:
		        for row in range(rows):
		            total += guitk.BCListViewGetDouble(listView, row, col)
		    text = (
		        "Sum of column '"
		        + guitk.BCListViewHeaderGetText(listView, col)
		        + "' is "
		        + str(total)
		    )
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewForEachItem(lv_or_item: object, flags: int, funct: Callable, data: Any=None) -> bool:

	"""

	Provides an easy way to iterate over the items in a ListView or a ListViewItem (children) and execute a callback function for each item.
	Iteration begins from first item and falls through, depending on flags.
	If you need to terminate the iteration return 1 at your callback.
	WARNING: Can not be used to delete items. If you need to delete items, create an array, fill it with the desired items 
	and delete them after iteration finished.
	WARNING: Using it with take/insert operations needs extra care and should be avoided.
	NOTE: This function will be executed even if call back functions are blocked for ListView.
	This function is not supported under VR mode.

	Parameters
	----------
	lv_or_item : object
		the ListView or ListViewItem.

	flags : int
		It is an integer value that is composed of BCEnumItemIteratorFlag OR'ed (i.e. added) together.
		
		guitk.constants BCEnumItemIteratorFlag
		This enum defines which ListView items will be iterated.
		 - guitk.constants.BCIterateAll
		If iterate over ListView these are all items while if iterate over ListViewItem these are all children (no matter the depth).
		 - guitk.constants.BCIterateSelected
		Selected items. Operates exclusive with BCIterateUnselected. A selected item can not be unselected at the same time.
		 - guitk.constants.BCIterateUnselected
		Non selected items. Operates exclusive with BCIterateSelected. A selected item can not be unselected at the same time.
		 - guitk.constants.BCIterateVisible
		Visible items (collapsed items are by default visible). Operates exclusive with BCIterateHidden, A visible item can not be hidden at the same time.
		 - guitk.constants.BCIterateHidden
		Hidden items (for example items that filtered). Note that collapsed items are by default visible. Operates exclusive with BCIterateVisible, A visible item can not be hidden at the same time.
		 - guitk.constants.BCIterateFirstLevel
		If iterate over ListView these are the top level items. If iterate over ListViewItem these are the first level children.

	funct : Callable
		the function that will be executed for each item during iteration. See BC_LISTVIEW_ITEM_ITERATE_FUNCTION for details.
		integer BC_LISTVIEW_ITEM_ITERATE_FUNCTION(item, data)
		The function to be executed for each item during iteration.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Return 1 to terminate items iteration or 0 to continue iterating.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	bool
		1 if the iteration terminated by the users' callback, 0 otherwise.

	See Also
	--------
	BCListViewFindItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Iterate", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    # Find the part Pillar 1003 button
		    buttonFrame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(buttonFrame, guitk.constants.BCHorizontal)
		    guitk.BCSpacerCreate(buttonFrame)
		    guitk.BCPushButtonCreate(
		        buttonFrame, "Find the part Pillar 1003", FindPillar1003ButtonClicked, listView
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def CheckForPillar1003(item, part1003List):
		    print("Checking item ", guitk.BCListViewItemGetText(item, 0))
		    if (
		        guitk.BCListViewItemGetText(item, 0) == "1003"
		        and guitk.BCListViewItemGetText(item, 1) == "Pillar"
		    ):
		        part1003List.append(item)
		        return 1  # I know no duplicate items so stop iterating
		    return 0  # keep searching
		
		
		def FindPillar1003ButtonClicked(button, listView):
		    # Using BCListViewFindItem
		    maybePillar = guitk.BCListViewFindItem(
		        listView, "1003", 0, guitk.constants.BCExactMatch
		    )
		    if maybePillar:
		        if guitk.BCListViewItemGetText(maybePillar, 1) == "Pillar":
		            print("Pillar 1003 was found using FindItem")
		
		    # Using iterate we can compare both id and name for each item
		    part1003List = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, CheckForPillar1003, part1003List
		    )
		    if len(part1003List):
		        print("Pillar 1003 was found.")
		        guitk.BCListViewSetSelected(listView, part1003List[0], True)
		    else:
		        print("Pillar 1003 was not found.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowCreate(type: int, message: str, modal: bool) -> object:

	"""

	Creates a dialog of type type that contains text message.
	After you created the message window you have to run BCMessageWindowExecute() for window to be shown.
	NOTE: Modal window grabs all input. No other window can be used until this message window is closed.
	This function is not supported under VR mode.

	Parameters
	----------
	type : int
		the dialog type. See BCEnumStylePixmap for details.
		
		guitk.constants BCEnumStylePixmap
		This enum represents a StylePixmap. A StylePixmap is a pixmap that can follow some
		existing GUI style or guideline. StylePixmap is used with BCLabelSetStylePixmap for example.
		 - guitk.constants.BCMessageBoxWarning
		the 'warning' icon.
		 - guitk.constants.BCMessageBoxCritical
		the 'critical' icon.
		 - guitk.constants.BCMessageBoxInformation
		the 'information' icon.
		 - guitk.constants.BCMessageBoxQuestion
		the 'question' icon.

	message : str
		the text of the BCMessageWindow.

	modal : bool
		sets whether the BCMessageWindow will be modal or not.

	Returns
	-------
	object
		the created BCMessageWindow.

	See Also
	--------
	BCMessageWindowExecute

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    messageWindow = guitk.BCMessageWindowCreate(
		        guitk.constants.BCMessageBoxWarning,
		        "Some <b>errors</b> have been detected.<br>Do you want to proceed?",
		        True,
		    )
		    guitk.BCMessageWindowSetAcceptButtonText(messageWindow, "Yes")
		    guitk.BCMessageWindowSetRejectButtonText(messageWindow, "No")
		    guitk.BCMessageWindowSetTextAlignment(
		        messageWindow, guitk.constants.BCAlignTop | guitk.constants.BCAlignHCenter
		    )
		    answer = guitk.BCMessageWindowExecute(messageWindow)
		    if answer == guitk.constants.BCRetKey:
		        print("Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Quitall")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowExecute(messageWindow: object) -> int:

	"""

	Shows the BCMessageWindow messageWindow and waits for the user's response (answer).
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	Returns
	-------
	int
		the user response. See BCEnumMessageWindowResult for details.
		BCEnumMessageWindowResult: This enum represents a BCMessageWindow result code. The result code is returned when the excecution of BCMessageWindow is finished.
		guitk.constants.BCQuitAll: this result code is returned when a non modal BCMessageWindow is forced to quit by an application's action.
		guitk.constants.BCEscKey: this result code is returned when the user rejects the BCMessageWindow (e.g. when pressing the [x] button, the Esc key or the Cancel button).
		guitk.constants.BCRetKey: this result code is returned when the user accepts the BCMessageWindow (e.g. when pressing the Return key or the OK button).

	See Also
	--------
	BCMessageWindowCreate

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    messageWindow = guitk.BCMessageWindowCreate(
		        guitk.constants.BCMessageBoxWarning,
		        "Some <b>errors</b> have been detected.<br>Do you want to proceed?",
		        True,
		    )
		    guitk.BCMessageWindowSetAcceptButtonText(messageWindow, "Yes")
		    guitk.BCMessageWindowSetRejectButtonText(messageWindow, "No")
		    guitk.BCMessageWindowSetTextAlignment(
		        messageWindow, guitk.constants.BCAlignTop | guitk.constants.BCAlignHCenter
		    )
		    answer = guitk.BCMessageWindowExecute(messageWindow)
		    if answer == guitk.constants.BCRetKey:
		        print("Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Quitall")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowSetAcceptButtonText(messageWindow: object, text: str) -> None:

	"""

	Customize accept button text of the dialog (default OK).
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	text : str
		the text to be displayed (default OK).

	Returns
	-------
	None

	See Also
	--------
	BCMessageWindowSetRejectButtonText

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    messageWindow = guitk.BCMessageWindowCreate(
		        guitk.constants.BCMessageBoxWarning,
		        "Some <b>errors</b> have been detected.<br>Do you want to proceed?",
		        True,
		    )
		    guitk.BCMessageWindowSetAcceptButtonText(messageWindow, "Yes")
		    guitk.BCMessageWindowSetRejectButtonText(messageWindow, "No")
		    guitk.BCMessageWindowSetTextAlignment(
		        messageWindow, guitk.constants.BCAlignTop | guitk.constants.BCAlignHCenter
		    )
		    answer = guitk.BCMessageWindowExecute(messageWindow)
		    if answer == guitk.constants.BCRetKey:
		        print("Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Quitall")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowSetRejectButtonText(messageWindow: object, text: str) -> None:

	"""

	Customize reject button text of the dialog (default Cancel).
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	text : str
		the text to be displayed (default Cancel).

	Returns
	-------
	None

	See Also
	--------
	BCMessageWindowSetAcceptButtonText

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    messageWindow = guitk.BCMessageWindowCreate(
		        guitk.constants.BCMessageBoxWarning,
		        "Some <b>errors</b> have been detected.<br>Do you want to proceed?",
		        True,
		    )
		    guitk.BCMessageWindowSetAcceptButtonText(messageWindow, "Yes")
		    guitk.BCMessageWindowSetRejectButtonText(messageWindow, "No")
		    guitk.BCMessageWindowSetTextAlignment(
		        messageWindow, guitk.constants.BCAlignTop | guitk.constants.BCAlignHCenter
		    )
		    answer = guitk.BCMessageWindowExecute(messageWindow)
		    if answer == guitk.constants.BCRetKey:
		        print("Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Quitall")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowSetAcceptButtonVisible(messageWindow: object, visible: bool) -> None:

	"""

	Sets whether the accept button of the dialog will be visible or not (default visible).
	Hiding the accept button is useful if you have cases where the user has no choice, i.e. can only confirm that something happened.
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	visible : bool
		set this parameter to 0 for the accept button to be hidden, otherwise 1.

	Returns
	-------
	None

	See Also
	--------
	BCMessageWindowSetRejectButtonVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Message Window Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCPushButtonCreate(window, "Click Me!", buttonPressedFunct, window)
		    guitk.BCPushButtonCreate(window, "Don't Click Me!", buttonPressedFunct, window)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		
		    guitk.BCShow(window)
		
		
		def buttonPressedFunct(b, window):
		    text = guitk.BCButtonText(b)
		    message = "You Pressed button: " + text
		    if text == "Don't Click Me!":
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxCritical, message, False
		        )
		    else:
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxInformation, message, False
		        )
		    guitk.BCMessageWindowSetExtraButton(msgWindow, "Accept All", 10)
		    guitk.BCMessageWindowSetAcceptButtonVisible(msgWindow, False)
		    guitk.BCMessageWindowSetRejectButtonVisible(msgWindow, False)
		    answer = guitk.BCMessageWindowExecute(msgWindow)
		    if answer == 10:
		        print("Message Window: Accept All")
		        guitk.BCWindowAccept(window)
		    elif answer == guitk.constants.BCRetKey:
		        print("Message Window: Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Message Window: Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Message Window: Quit All")
		    return 0
		
		
		def acceptFunction(window, data):
		    print("Main Window: Accept")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowSetRejectButtonVisible(messageWindow: object, visible: bool) -> None:

	"""

	Sets whether the reject button of the dialog will be visible or not (default visible).
	Hiding the reject button is useful if you have cases where the user has no choice, i.e. can only confirm that something happened.
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	visible : bool
		set this parameter to 0 for the reject button to be hidden, otherwise 1.

	Returns
	-------
	None

	See Also
	--------
	BCMessageWindowSetAcceptButtonVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Message Window Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCPushButtonCreate(window, "Click Me!", buttonPressedFunct, window)
		    guitk.BCPushButtonCreate(window, "Don't Click Me!", buttonPressedFunct, window)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		
		    guitk.BCShow(window)
		
		
		def buttonPressedFunct(b, window):
		    text = guitk.BCButtonText(b)
		    message = "You Pressed button: " + text
		    if text == "Don't Click Me!":
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxCritical, message, False
		        )
		    else:
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxInformation, message, False
		        )
		    guitk.BCMessageWindowSetExtraButton(msgWindow, "Accept All", 10)
		    guitk.BCMessageWindowSetAcceptButtonVisible(msgWindow, False)
		    guitk.BCMessageWindowSetRejectButtonVisible(msgWindow, False)
		    answer = guitk.BCMessageWindowExecute(msgWindow)
		    if answer == 10:
		        print("Message Window: Accept All")
		        guitk.BCWindowAccept(window)
		    elif answer == guitk.constants.BCRetKey:
		        print("Message Window: Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Message Window: Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Message Window: Quit All")
		    return 0
		
		
		def acceptFunction(window, data):
		    print("Main Window: Accept")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuCreate(w: object) -> object:

	"""

	Creates a BCMenu with parent w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the parent widget.

	Returns
	-------
	object
		The created BCMenu.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuPopup(pm: object) -> None:

	"""

	Pops up the BCMenu (i.e. it makes it visible).
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Destroy Selected", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    menu = guitk.BCPopupMenuCreate(listView)
		    guitk.BCPopupMenuInsertItem(menu, "Delete", DeleteSelectedItems, listView)
		    guitk.BCPopupMenuInsertSeparator(menu)
		    guitk.BCPopupMenuInsertItem(menu, "Update", None, None)
		    guitk.BCListViewSetMousePressedFunction(listView, ListViewMousePressed, menu)
		    guitk.BCShow(window)
		
		
		def DeleteSelectedItems(menu, id, listView):
		    # standard deletion with a single function as below
		    # guitk.BCListViewSelectedRemove(listView)
		    # or custom deletion with iteration
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    # silent mode (for example the selection change call back, if any, will not be triggerred)
		    guitk.BCBlockCallBackFunctions(listView, 1)
		    for item in items:
		        guitk.BCListViewItemDestroy(item)
		    guitk.BCBlockCallBackFunctions(listView, 0)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewMousePressed(listView, button, item, col, menu):
		    # do not popup on mouse button left or middle buttons
		    if button is not guitk.constants.BCRightButton:
		        return 0
		    # do not popup when press on empty viewport space
		    if not item:
		        return 0
		    guitk.BCPopupMenuPopup(menu)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuPopupToParentWidget(pm: object) -> None:

	"""

	Pops up the BCMenu based on the bottom-left position of its parent Widget (i.e. it makes it visible).
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup PopupToParent Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    popupBtn = guitk.BCPushButtonCreate(hBox, "Popup Button", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(popupBtn)
		    guitk.BCButtonSetPopup(popupBtn, popupMenu)
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Item" + str(i), None, None)
		    btn = guitk.BCPushButtonCreate(hBox, "Open Popup From Here", btnClicked, popupMenu)
		    guitk.BCShow(window)
		
		
		def btnClicked(btn, popupMenu):
		    guitk.BCPopupMenuPopupToParentWidget(popupMenu)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetItemCheckable(pm: object, id: int, checkable: bool) -> None:

	"""

	Sets item with id of BCMenu pm if as checkable if checkable is not zero, otherwise sets it as uncheckable.
	Checkable items work like toggling buttons, i.e. can be checked and unchecked.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the id of the item that will be checkable/uncheckable.

	checkable : bool
		set this parameter to True to make the item checkable, or to False to make it uncheckable.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuIsItemCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuIsItemCheckable(pm: object, id: int) -> bool:

	"""

	Returns True if item with id id is a checkable item; False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the id of the item whose checkable status is required.

	Returns
	-------
	bool
		True if item with id id is checkable; False otherwise.

	See Also
	--------
	BCPopupMenuSetItemCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetItemChecked(pm: object, id: int, checked: bool) -> None:

	"""

	Checks BCMenu item pm at id if checked is not zero, otherwise it unchecks it.
	WARNING: If this function is used on a non-checkable menu, it will first make it checkable and then set its checked status according to checked.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the id of the item that will be checked/unchecked.

	checked : bool
		set this parameter to True to check, or to False to uncheck the item.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuIsItemChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuIsItemChecked(pm: object, id: int) -> bool:

	"""

	Returns True if item with id id is checked; False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the id of the item whose check status is required.

	Returns
	-------
	bool
		True if item with id id is checked; False otherwise.

	See Also
	--------
	BCPopupMenuSetItemCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuInsertItem(pm: object, text: str, funct: Callable, data: Any=None) -> int:

	"""

	Inserts an item in the BCMenu pm.
	WARNING: funct will be called before the function set by BCPopupMenuSetActivatedFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	text : str
		the text that will be displayed (can be set to None).

	funct : Callable
		the function that will be called when the item is activated (can be set to None). See 
		BC_POPUPMENU_INSERT_ITEM_FUNCTION for details.
		integer BC_POPUPMENU_INSERT_ITEM_FUNCTION(pm, id, data)
		The function to be called when the item is activated (can be set to None).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * pm : object
		                    the BCMenu.
		          * id : int
		                    the id of the item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		pointer to any user data that are required by funct.

	Returns
	-------
	int
		the allocated id of the inserted item.

	See Also
	--------
	BCPopupMenuRemoveItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuInsertItemWithIcon(pm: object, text: str, fileName: str, funct: Callable, data: Any=None) -> int:

	"""

	Inserts an item in the BCMenu pm with icon fileName.
	WARNING: funct will be called before the function set by BCPopupMenuSetActivatedFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	text : str
		the text that will be displayed (can be set to None).

	fileName : str
		the filename of the icon that will be displayed before the text and will be toggled, if this pm is checkable. 
		Can be None.

	funct : Callable
		the function that will be called when the item is activated (can be set to None).
		See BC_POPUPMENU_INSERT_ITEM_FUNCTION for details.
		integer BC_POPUPMENU_INSERT_ITEM_FUNCTION(pm, id, data)
		The function to be called when the item is activated (can be set to None).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * pm : object
		                    the BCMenu.
		          * id : int
		                    the id of the item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data that are required by funct.

	Returns
	-------
	int
		the allocated id of the inserted item.

	See Also
	--------
	BCPopupMenuInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuInsertWidget(pm: object, w: object) -> int:

	"""

	Inserts a widget w in the BCMenu pm.
	Theoretically, any widget can be inserted into a popup menu. In practice, this only makes sense with certain widgets.
	WARNING: The ownership of the widget w is transfered to the BCMenu pm. If you clear the BCMenu, the widget will automatically be destroyed. Try not to use the widget w outside the BCMenu pm.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	w : object
		the widget to be inserted.

	Returns
	-------
	int
		the allocated id of the inserted widget, if is valid, -1 otherwise.

	See Also
	--------
	BCPopupMenuInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuInsertPopupMenu(pm: object, text: str, menu: object) -> int:

	"""

	Inserts a submenu menu in the BCMenu pm.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	text : str
		the text that will be displayed.

	menu : object
		the BCMenu that is the submenu.

	Returns
	-------
	int
		the allocated id of the inserted BCMenu.

	See Also
	--------
	BCPopupMenuInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuInsertPopupMenuWithIcon(pm: object, text: str, fileName: str, menu: object) -> int:

	"""

	Inserts a submenu menu in the BCMenu pm with an icon fileName.
	The icon is always placed to the left of the text.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	text : str
		the text that will be displayed.

	fileName : str
		the filename of the icon that will be displayed on the left of text.
		Can be None.

	menu : object
		the BCMenu that is the submenu.

	Returns
	-------
	int
		the allocated id of the inserted BCMenu.

	See Also
	--------
	BCPopupMenuInsertPopupMenu

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Clear and DestroyItems Example", guitk.constants.BCOnExitDestroy
		    )
		    gLayout = guitk.BCGridLayoutCreate(window, 2, 2)
		    btnSimple = guitk.BCPushButtonCreate(gLayout, "Simple Popup", None, None)
		    simplePopupMenu = guitk.BCPopupMenuCreate(btnSimple)
		    guitk.BCButtonSetPopup(btnSimple, simplePopupMenu)
		    btnClear = guitk.BCPushButtonCreate(
		        gLayout, "Clear Menu on the left", btnClearClicked, simplePopupMenu
		    )
		    guitk.BCGridLayoutAddWidget(gLayout, btnSimple, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, btnClear, 0, 1, guitk.constants.BCAlignAuto)
		
		    btnDouble = guitk.BCPushButtonCreate(gLayout, "Double Popup", None, None)
		    doublePopupMenu = guitk.BCPopupMenuCreate(btnDouble)
		    guitk.BCButtonSetPopup(btnDouble, doublePopupMenu)
		    encasedPopupMenu = guitk.BCPopupMenuCreate(doublePopupMenu)
		    guitk.BCPopupMenuSetAboutToShowFunction(encasedPopupMenu, pmAboutToShow, None)
		    guitk.BCPopupMenuInsertPopupMenuWithIcon(
		        doublePopupMenu, "Encased Menu", "info_small.svg", encasedPopupMenu
		    )
		    btnDestroy = guitk.BCPushButtonCreate(
		        gLayout, "Destroy MenuItems on the left", btnDestroyClicked, doublePopupMenu
		    )
		    guitk.BCGridLayoutAddWidget(gLayout, btnDouble, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, btnDestroy, 1, 1, guitk.constants.BCAlignAuto)
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(simplePopupMenu, "Item " + str(i), None, None)
		        guitk.BCPopupMenuInsertItem(
		            doublePopupMenu, "Outside item " + str(i), None, None
		        )
		        guitk.BCPopupMenuInsertItem(
		            encasedPopupMenu, "Inside item " + str(i), None, None
		        )
		
		    guitk.BCShow(window)
		
		
		def btnClearClicked(btn, popupMenu):
		    guitk.BCPopupMenuClear(popupMenu)
		    return 0
		
		
		def btnDestroyClicked(btn, popupMenu):
		    guitk.BCPopupMenuDestroyItems(popupMenu)
		    return 0
		
		
		def pmAboutToShow(popupMenu, data):
		    print("\\nUse PopupMenuDestroyItems to properly destroy the encapsulated Menu")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuRemoveItem(pm: object, id: int) -> None:

	"""

	Removes the item with ID id from the BCMenu.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the id of the item to be removed.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuRemoveItemAt, BCPopupMenuInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		NUM_ITEMS = 10
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Remove by Id Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    itemIds = [-1] * NUM_ITEMS
		    for i in range(NUM_ITEMS):
		        itemIds[i] = guitk.BCPopupMenuInsertItem(
		            popupMenu, "Item " + str(i), None, None
		        )
		    hBoxId = guitk.BCHBoxCreate(window)
		    btnRemoveId = guitk.BCPushButtonCreate(hBoxId, "Remove By Id:", None, None)
		    cmbIds = guitk.BCComboBoxCreate(hBoxId, [str(itemId) for itemId in itemIds])
		    guitk.BCButtonSetClickedFunction(btnRemoveId, removeSelectedId, (popupMenu, cmbIds))
		    guitk.BCShow(window)
		
		
		def removeSelectedId(btn, data):
		    popupMenu, cmb = data
		    if guitk.BCComboBoxCurrentText(cmb):
		        itemId = int(guitk.BCComboBoxCurrentText(cmb))
		        print("Removed " + guitk.BCPopupMenuText(popupMenu, itemId))
		        guitk.BCPopupMenuRemoveItem(popupMenu, itemId)
		        guitk.BCComboBoxRemoveItem(cmb, guitk.BCComboBoxCurrentItem(cmb))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuRemoveItemAt(pm: object, index: int) -> None:

	"""

	Removes the item with INDEX index from the BCMenu.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	index : int
		the index of the item to be removed.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuRemoveItem, BCPopupMenuInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		NUM_ITEMS = 10
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Remove by Index Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    for i in range(NUM_ITEMS):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Item " + str(i), None, None)
		    hBoxIndex = guitk.BCHBoxCreate(window)
		    btnRemoveIndex = guitk.BCPushButtonCreate(hBoxIndex, "Remove By Index:", None, None)
		    indexSpinBox = guitk.BCSpinBoxCreate(hBoxIndex)
		    guitk.BCSpinBoxSetMaxValue(indexSpinBox, NUM_ITEMS - 1)
		    guitk.BCButtonSetClickedFunction(
		        btnRemoveIndex, btnRemoveIndexClicked, (popupMenu, indexSpinBox)
		    )
		    guitk.BCShow(window)
		
		
		def btnRemoveIndexClicked(btn, data):
		    popupMenu, spinBox = data
		    index = guitk.BCSpinBoxGetInt(spinBox)
		    print("Removed " + guitk.BCPopupMenuTextAt(popupMenu, index))
		    guitk.BCPopupMenuRemoveItemAt(popupMenu, index)
		    newCount = guitk.BCPopupMenuCount(popupMenu)
		    if newCount:
		        guitk.BCSpinBoxSetMaxValue(spinBox, newCount - 1)
		    else:
		        guitk.BCSetEnabled(btn, False)
		        guitk.BCSetEnabled(spinBox, False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuText(pm: object, id: int) -> str:

	"""

	Returns the text of the item with ID id, or None if id does not exist.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the identifier of the item whose text is returned.

	Returns
	-------
	str
		the text of the item with ID id, or None if id does not exist.

	Examples
	--------
	::

		from sdm import guitk
		
		NUM_ITEMS = 10
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Remove by Id Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    itemIds = [-1] * NUM_ITEMS
		    for i in range(NUM_ITEMS):
		        itemIds[i] = guitk.BCPopupMenuInsertItem(
		            popupMenu, "Item " + str(i), None, None
		        )
		    hBoxId = guitk.BCHBoxCreate(window)
		    btnRemoveId = guitk.BCPushButtonCreate(hBoxId, "Remove By Id:", None, None)
		    cmbIds = guitk.BCComboBoxCreate(hBoxId, [str(itemId) for itemId in itemIds])
		    guitk.BCButtonSetClickedFunction(btnRemoveId, removeSelectedId, (popupMenu, cmbIds))
		    guitk.BCShow(window)
		
		
		def removeSelectedId(btn, data):
		    popupMenu, cmb = data
		    if guitk.BCComboBoxCurrentText(cmb):
		        itemId = int(guitk.BCComboBoxCurrentText(cmb))
		        print("Removed " + guitk.BCPopupMenuText(popupMenu, itemId))
		        guitk.BCPopupMenuRemoveItem(popupMenu, itemId)
		        guitk.BCComboBoxRemoveItem(cmb, guitk.BCComboBoxCurrentItem(cmb))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuTextAt(pm: object, index: int) -> str:

	"""

	Returns the text of the item of index index, or None if index is NOT in the range [0, BCPopupMenuCount()-1].
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	index : int
		the index of the item whose text is returned. Indexes begin from 0.

	Returns
	-------
	str
		the text of the item with index index, or None if index is out of range.

	Examples
	--------
	::

		from sdm import guitk
		
		NUM_ITEMS = 10
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Remove by Index Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    for i in range(NUM_ITEMS):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Item " + str(i), None, None)
		    hBoxIndex = guitk.BCHBoxCreate(window)
		    btnRemoveIndex = guitk.BCPushButtonCreate(hBoxIndex, "Remove By Index:", None, None)
		    indexSpinBox = guitk.BCSpinBoxCreate(hBoxIndex)
		    guitk.BCSpinBoxSetMaxValue(indexSpinBox, NUM_ITEMS - 1)
		    guitk.BCButtonSetClickedFunction(
		        btnRemoveIndex, btnRemoveIndexClicked, (popupMenu, indexSpinBox)
		    )
		    guitk.BCShow(window)
		
		
		def btnRemoveIndexClicked(btn, data):
		    popupMenu, spinBox = data
		    index = guitk.BCSpinBoxGetInt(spinBox)
		    print("Removed " + guitk.BCPopupMenuTextAt(popupMenu, index))
		    guitk.BCPopupMenuRemoveItemAt(popupMenu, index)
		    newCount = guitk.BCPopupMenuCount(popupMenu)
		    if newCount:
		        guitk.BCSpinBoxSetMaxValue(spinBox, newCount - 1)
		    else:
		        guitk.BCSetEnabled(btn, False)
		        guitk.BCSetEnabled(spinBox, False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetItemEnabled(pm: object, id: int, enabled: bool) -> None:

	"""

	Sets whether the item with ID id is enabled or not depending on the value of enabled.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the identifier of the item to be enabled/disabled.

	enabled : bool
		set this parameter to True to enable the item or False to disable it.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuIsItemEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuIsItemEnabled(pm: object, id: int) -> bool:

	"""

	Returns True if item with id id is enabled; False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the identifier of the item whose enabled/disabled status is asked.

	Returns
	-------
	bool
		True if item with id id is enabled; False otherwise.

	See Also
	--------
	BCPopupMenuSetItemEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Enabled and Visible Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Enabled Item", None, None)
		    idInvisible = guitk.BCPopupMenuInsertItem(popupMenu, "Invisible Item", None, None)
		    guitk.BCPopupMenuSetItemVisible(popupMenu, idInvisible, False)
		    idDisabled = guitk.BCPopupMenuInsertItem(popupMenu, "Disabled Item", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, idDisabled, False)
		
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, menuActivated, None)
		    for i in range(guitk.BCPopupMenuCount(popupMenu)):
		        itemText = "'" + guitk.BCPopupMenuTextAt(popupMenu, i) + "'"
		        itemId = guitk.BCPopupMenuIdAt(popupMenu, i)
		        print(
		            itemText
		            + " is enabled = "
		            + str(guitk.BCPopupMenuIsItemEnabled(popupMenu, itemId))
		        )
		        print(
		            itemText
		            + " is visible = "
		            + str(guitk.BCPopupMenuIsItemVisible(popupMenu, itemId))
		        )
		        # Notice that even disabled and invisible items can be activated programmatically
		        guitk.BCPopupMenuActivateItem(popupMenu, itemId)
		    guitk.BCShow(window)
		
		
		def menuActivated(popupMenu, id, data):
		    print(guitk.BCPopupMenuText(popupMenu, id) + " activated!\\n")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetItemVisible(pm: object, id: int, vis: bool) -> None:

	"""

	Sets whether the item with ID id is visible or not depending on the value of vis.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the identifier of the item to be visible or not.

	vis : bool
		set this parameter to True for the item to become visible or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuIsItemVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Enabled and Visible Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Enabled Item", None, None)
		    idInvisible = guitk.BCPopupMenuInsertItem(popupMenu, "Invisible Item", None, None)
		    guitk.BCPopupMenuSetItemVisible(popupMenu, idInvisible, False)
		    idDisabled = guitk.BCPopupMenuInsertItem(popupMenu, "Disabled Item", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, idDisabled, False)
		
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, menuActivated, None)
		    for i in range(guitk.BCPopupMenuCount(popupMenu)):
		        itemText = "'" + guitk.BCPopupMenuTextAt(popupMenu, i) + "'"
		        itemId = guitk.BCPopupMenuIdAt(popupMenu, i)
		        print(
		            itemText
		            + " is enabled = "
		            + str(guitk.BCPopupMenuIsItemEnabled(popupMenu, itemId))
		        )
		        print(
		            itemText
		            + " is visible = "
		            + str(guitk.BCPopupMenuIsItemVisible(popupMenu, itemId))
		        )
		        # Notice that even disabled and invisible items can be activated programmatically
		        guitk.BCPopupMenuActivateItem(popupMenu, itemId)
		    guitk.BCShow(window)
		
		
		def menuActivated(popupMenu, id, data):
		    print(guitk.BCPopupMenuText(popupMenu, id) + " activated!\\n")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuIsItemVisible(pm: object, id: int) -> bool:

	"""

	Returns True if item with id id is visible; False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the identifier of the item whose visibility status is asked.

	Returns
	-------
	bool
		True if item with id id is visible; False otherwise.

	See Also
	--------
	BCPopupMenuSetItemVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Enabled and Visible Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Enabled Item", None, None)
		    idInvisible = guitk.BCPopupMenuInsertItem(popupMenu, "Invisible Item", None, None)
		    guitk.BCPopupMenuSetItemVisible(popupMenu, idInvisible, False)
		    idDisabled = guitk.BCPopupMenuInsertItem(popupMenu, "Disabled Item", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, idDisabled, False)
		
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, menuActivated, None)
		    for i in range(guitk.BCPopupMenuCount(popupMenu)):
		        itemText = "'" + guitk.BCPopupMenuTextAt(popupMenu, i) + "'"
		        itemId = guitk.BCPopupMenuIdAt(popupMenu, i)
		        print(
		            itemText
		            + " is enabled = "
		            + str(guitk.BCPopupMenuIsItemEnabled(popupMenu, itemId))
		        )
		        print(
		            itemText
		            + " is visible = "
		            + str(guitk.BCPopupMenuIsItemVisible(popupMenu, itemId))
		        )
		        # Notice that even disabled and invisible items can be activated programmatically
		        guitk.BCPopupMenuActivateItem(popupMenu, itemId)
		    guitk.BCShow(window)
		
		
		def menuActivated(popupMenu, id, data):
		    print(guitk.BCPopupMenuText(popupMenu, id) + " activated!\\n")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuClear(pm: object) -> None:

	"""

	Clears the BCMenu pm from all its items.
	If you have sub menus inside pm, they will NOT be destroyed or cleared. You will have to remove/clear them manually.
	A good practice to handle sub menus is to create them with parent pm and destroy pm when needed (it will automatically destroy all children sub menus).
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuDestroyItems

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Clear and DestroyItems Example", guitk.constants.BCOnExitDestroy
		    )
		    gLayout = guitk.BCGridLayoutCreate(window, 2, 2)
		    btnSimple = guitk.BCPushButtonCreate(gLayout, "Simple Popup", None, None)
		    simplePopupMenu = guitk.BCPopupMenuCreate(btnSimple)
		    guitk.BCButtonSetPopup(btnSimple, simplePopupMenu)
		    btnClear = guitk.BCPushButtonCreate(
		        gLayout, "Clear Menu on the left", btnClearClicked, simplePopupMenu
		    )
		    guitk.BCGridLayoutAddWidget(gLayout, btnSimple, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, btnClear, 0, 1, guitk.constants.BCAlignAuto)
		
		    btnDouble = guitk.BCPushButtonCreate(gLayout, "Double Popup", None, None)
		    doublePopupMenu = guitk.BCPopupMenuCreate(btnDouble)
		    guitk.BCButtonSetPopup(btnDouble, doublePopupMenu)
		    encasedPopupMenu = guitk.BCPopupMenuCreate(doublePopupMenu)
		    guitk.BCPopupMenuSetAboutToShowFunction(encasedPopupMenu, pmAboutToShow, None)
		    guitk.BCPopupMenuInsertPopupMenuWithIcon(
		        doublePopupMenu, "Encased Menu", "info_small.svg", encasedPopupMenu
		    )
		    btnDestroy = guitk.BCPushButtonCreate(
		        gLayout, "Destroy MenuItems on the left", btnDestroyClicked, doublePopupMenu
		    )
		    guitk.BCGridLayoutAddWidget(gLayout, btnDouble, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, btnDestroy, 1, 1, guitk.constants.BCAlignAuto)
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(simplePopupMenu, "Item " + str(i), None, None)
		        guitk.BCPopupMenuInsertItem(
		            doublePopupMenu, "Outside item " + str(i), None, None
		        )
		        guitk.BCPopupMenuInsertItem(
		            encasedPopupMenu, "Inside item " + str(i), None, None
		        )
		
		    guitk.BCShow(window)
		
		
		def btnClearClicked(btn, popupMenu):
		    guitk.BCPopupMenuClear(popupMenu)
		    return 0
		
		
		def btnDestroyClicked(btn, popupMenu):
		    guitk.BCPopupMenuDestroyItems(popupMenu)
		    return 0
		
		
		def pmAboutToShow(popupMenu, data):
		    print("\\nUse PopupMenuDestroyItems to properly destroy the encapsulated Menu")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuDestroyItems(pm: object) -> None:

	"""

	Destroys the BCMenu pm all its items.
	If you have sub menus inside pm, they will  be destroyed or cleared.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuClear

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Clear and DestroyItems Example", guitk.constants.BCOnExitDestroy
		    )
		    gLayout = guitk.BCGridLayoutCreate(window, 2, 2)
		    btnSimple = guitk.BCPushButtonCreate(gLayout, "Simple Popup", None, None)
		    simplePopupMenu = guitk.BCPopupMenuCreate(btnSimple)
		    guitk.BCButtonSetPopup(btnSimple, simplePopupMenu)
		    btnClear = guitk.BCPushButtonCreate(
		        gLayout, "Clear Menu on the left", btnClearClicked, simplePopupMenu
		    )
		    guitk.BCGridLayoutAddWidget(gLayout, btnSimple, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, btnClear, 0, 1, guitk.constants.BCAlignAuto)
		
		    btnDouble = guitk.BCPushButtonCreate(gLayout, "Double Popup", None, None)
		    doublePopupMenu = guitk.BCPopupMenuCreate(btnDouble)
		    guitk.BCButtonSetPopup(btnDouble, doublePopupMenu)
		    encasedPopupMenu = guitk.BCPopupMenuCreate(doublePopupMenu)
		    guitk.BCPopupMenuSetAboutToShowFunction(encasedPopupMenu, pmAboutToShow, None)
		    guitk.BCPopupMenuInsertPopupMenuWithIcon(
		        doublePopupMenu, "Encased Menu", "info_small.svg", encasedPopupMenu
		    )
		    btnDestroy = guitk.BCPushButtonCreate(
		        gLayout, "Destroy MenuItems on the left", btnDestroyClicked, doublePopupMenu
		    )
		    guitk.BCGridLayoutAddWidget(gLayout, btnDouble, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(gLayout, btnDestroy, 1, 1, guitk.constants.BCAlignAuto)
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(simplePopupMenu, "Item " + str(i), None, None)
		        guitk.BCPopupMenuInsertItem(
		            doublePopupMenu, "Outside item " + str(i), None, None
		        )
		        guitk.BCPopupMenuInsertItem(
		            encasedPopupMenu, "Inside item " + str(i), None, None
		        )
		
		    guitk.BCShow(window)
		
		
		def btnClearClicked(btn, popupMenu):
		    guitk.BCPopupMenuClear(popupMenu)
		    return 0
		
		
		def btnDestroyClicked(btn, popupMenu):
		    guitk.BCPopupMenuDestroyItems(popupMenu)
		    return 0
		
		
		def pmAboutToShow(popupMenu, data):
		    print("\\nUse PopupMenuDestroyItems to properly destroy the encapsulated Menu")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetActivatedFunction(pm: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function that will be called when the BCMenu is activated (i.e. when an item is selected).
	Note that ActivatedFunction function will operate after AboutToHideFunction and the item's function.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu

	funct : Callable
		the function that will be called when the BCMenu pm is activated. See BC_POPUPMENU_ACTIVATED_FUNCTION for details.
		integer BC_POPUPMENU_ACTIVATED_FUNCTION(pm, id, data)
		The function to be called when BCMenu pm is activated.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * pm : object
		                    the BCMenu.
		          * id : int
		                    the id of the selected item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetAboutToShowFunction(pm: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function that will be called just before the BCMenu is displayed.
	This function can be used to set up the popup menu dynamically.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	funct : Callable
		the function to be called. See BC_POPUPMENU_ABOUTTOSHOW_FUNCTION for details.
		integer BC_POPUPMENU_ABOUTTOSHOW_FUNCTION(pm, data)
		The function to be called just before BCMenu pm is displayed.
		
		Use this function if you want to set up your menu dynamically.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * pm : object
		                    the BCMenu.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuSetAboutToHideFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetAboutToHideFunction(pm: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function that will be called just before the BCMenu is hidden.
	Note that aboutToHide function operates (when an item is selected) just before an item's function.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	funct : Callable
		the function to be called. See BC_POPUPMENU_ABOUTTOHIDE_FUNCTION for details.
		integer BC_POPUPMENU_ABOUTTOHIDE_FUNCTION(pm, data)
		The function to be called just before BCMenu pm is hidden.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * pm : object
		                    the BCMenu.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuSetAboutToShowFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuInsertSeparator(pm: object) -> int:

	"""

	Inserts a separator at the end of the BCMenu.
	A separator is simply a line that separates the items on the BCMenu.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	int
		the allocated id of the inserted separator.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuItemId(pm: object, label: str) -> int:

	"""

	Returns the id of the item with label label if pm contains label, or -1 otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	label : str
		the label that will be checked.

	Returns
	-------
	int
		the id of item with label label if pm contains it, or -1 otherwise.

	See Also
	--------
	BCPopupMenuWidgetItemId

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Items Activated Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    lineEdit = guitk.BCLineEditCreate(popupMenu, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Press Enter twice")
		    guitk.BCAddToolTip(
		        lineEdit,
		        "Widgets inside PopupMenu are activated by pressing Enter while they have focus",
		    )
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, editingFinished, None)
		    guitk.BCPopupMenuInsertWidget(popupMenu, lineEdit)
		    guitk.BCPopupMenuSetItemCheckable(
		        popupMenu,
		        guitk.BCPopupMenuInsertItem(popupMenu, "Toggle Item", None, None),
		        True,
		    )
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popupMenu, False)
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Item" + str(i), None, None)
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, printItem, lineEdit)
		    guitk.BCShow(window)
		
		
		def editingFinished(lineEdit, data):
		    print("LineEditEditingFinished Activated.")
		    return 0
		
		
		def printItem(popupMenu, id, widget):
		    if id == guitk.BCPopupMenuItemId(popupMenu, "Toggle Item"):
		        guitk.BCPopupMenuSetItemChecked(
		            popupMenu, id, not guitk.BCPopupMenuIsItemChecked(popupMenu, id)
		        )
		        print("Toggle Item Activated.")
		    elif id == guitk.BCPopupMenuWidgetItemId(popupMenu, widget):
		        print("Widget Activated.")
		    else:
		        print(guitk.BCPopupMenuText(popupMenu, id) + " Activated.")
		        guitk.BCPopupMenuClose(popupMenu)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuIdAt(pm: object, index: int) -> int:

	"""

	Returns the id of the BCMenu item at position index, or -1 if index is out of range.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	index : int
		the index of the BCMenu item.

	Returns
	-------
	int

	See Also
	--------
	BCPopupMenuItemId

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Enabled and Visible Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Enabled Item", None, None)
		    idInvisible = guitk.BCPopupMenuInsertItem(popupMenu, "Invisible Item", None, None)
		    guitk.BCPopupMenuSetItemVisible(popupMenu, idInvisible, False)
		    idDisabled = guitk.BCPopupMenuInsertItem(popupMenu, "Disabled Item", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, idDisabled, False)
		
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, menuActivated, None)
		    for i in range(guitk.BCPopupMenuCount(popupMenu)):
		        itemText = "'" + guitk.BCPopupMenuTextAt(popupMenu, i) + "'"
		        itemId = guitk.BCPopupMenuIdAt(popupMenu, i)
		        print(
		            itemText
		            + " is enabled = "
		            + str(guitk.BCPopupMenuIsItemEnabled(popupMenu, itemId))
		        )
		        print(
		            itemText
		            + " is visible = "
		            + str(guitk.BCPopupMenuIsItemVisible(popupMenu, itemId))
		        )
		        # Notice that even disabled and invisible items can be activated programmatically
		        guitk.BCPopupMenuActivateItem(popupMenu, itemId)
		    guitk.BCShow(window)
		
		
		def menuActivated(popupMenu, id, data):
		    print(guitk.BCPopupMenuText(popupMenu, id) + " activated!\\n")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuCount(pm: object) -> int:

	"""

	Returns the number of items in the menu.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	int
		the number of items.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCPopupMenu deletion example", guitk.constants.BCOnExitDestroy
		    )
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Item 1", None, None)
		    guitk.BCPopupMenuInsertItem(popup, "Item 2", None, None)
		    guitk.BCPopupMenuInsertItem(popup, "Item 3", None, None)
		    guitk.BCButtonSetPopup(button, popup)
		
		    guitk.BCPopupMenuSetDeletionEnabled(popup, True)
		    guitk.BCPopupMenuSetDeletionFunction(popup, popupDeletionFunc, None)
		
		    guitk.BCSpacerCreate(w)
		    guitk.BCShow(w)
		
		
		def popupDeletionFunc(pm, id, data):
		    if guitk.BCPopupMenuCount(pm) <= 1:
		        print("You must have at least one item in menu!")
		        return 0
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetHideOnCheckEnabled(pm: object, enabled: bool) -> None:

	"""

	Enable popup menu pm to remain open while you mouse toggle checkable items.
	If you disable this property the activated function for the item (if one was set) will run, but the menu will remain open. This property only operates for checkable menus and makes sense for large list of items. If the menu is not checkable, nothing happens. The default menu has this property true (hides when you check/uncheck an item).
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu to affect.

	enabled : bool
		set False to enable checking without menu to hide.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuSetItemCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCPopupMenu example", guitk.constants.BCOnExitDestroy)
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Toggle", None, None)
		    guitk.BCPopupMenuSetItemCheckable(popup, 0, True)
		    guitk.BCPopupMenuInsertItem(popup, "Disabled", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popup, 1, False)
		
		    guitk.BCPopupMenuInsertSeparator(popup)
		
		    # Create a popup menu with icons and insert it as a submenu
		    submenu = guitk.BCPopupMenuCreate(popup)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Cut", "edit_cut_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Copy", "edit_copy_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        submenu, "Paste", "edit_paste_small.svg", None, None
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Submenu", submenu)
		
		    le = guitk.BCLineEditCreate(popup, "")
		    guitk.BCLineEditSetPlaceholderText(le, "Insert Text")
		    guitk.BCLineEditSetEnterPressedFunction(le, lineEditEnterPressedFunc, None)
		    guitk.BCPopupMenuInsertWidget(popup, le)
		
		    guitk.BCPopupMenuSetAboutToShowFunction(popup, beforeDisplay, None)
		    guitk.BCPopupMenuSetAboutToHideFunction(popup, beforeHide, None)
		    guitk.BCPopupMenuSetActivatedFunction(popup, menuActivated, None)
		
		    guitk.BCButtonSetPopup(button, popup)
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popup, False)
		
		    guitk.BCSpacerCreate(w)
		
		    guitk.BCShow(w)
		
		
		def menuActivated(pm, id, data):
		    if guitk.BCPopupMenuIsItemCheckable(pm, id):
		        new_state = not guitk.BCPopupMenuIsItemChecked(pm, id)
		        guitk.BCPopupMenuSetItemChecked(pm, id, new_state)
		    print("Menu activated")
		    return 0
		
		
		def beforeDisplay(pm, data):
		    print("About to show popup menu")
		    return 0
		
		
		def beforeHide(pm, data):
		    print("About to hide popup menu")
		    return 0
		
		
		def lineEditEnterPressedFunc(le, data):
		    print("Text entered: ", guitk.BCLineEditGetText(le))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetDeletionFunction(pm: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when the highlighted popup item of BCMenu pm is deleted by
	pressing the delete key.
	NOTE: The callback function set by this function will be called only if deletion is enabled, which can
	be done by calling BCPopupMenuSetDeletionEnabled(). The default behaviour is to not allow the deletion.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	funct : Callable
		the function to be called. See BC_POPUPMENU_DELETION_FUNCTION for details.
		integer BC_POPUPMENU_DELETION_FUNCTION(pm, id, data)
		The function to be called when the item with id id of BCMenu pm is deleted by pressing the delete key.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * pm : object
		                    the BCMenu.
		          * id : int
		                    the id of the item to be deleted.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Return 1 to proceed with deletion of the item; 0 to deny it.

	data : Any, optional
		a pointer to anything that may be required in funct.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuSetDeletionEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCPopupMenu deletion example", guitk.constants.BCOnExitDestroy
		    )
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Item 1", None, None)
		    guitk.BCPopupMenuInsertItem(popup, "Item 2", None, None)
		    guitk.BCPopupMenuInsertItem(popup, "Item 3", None, None)
		    guitk.BCButtonSetPopup(button, popup)
		
		    guitk.BCPopupMenuSetDeletionEnabled(popup, True)
		    guitk.BCPopupMenuSetDeletionFunction(popup, popupDeletionFunc, None)
		
		    guitk.BCSpacerCreate(w)
		    guitk.BCShow(w)
		
		
		def popupDeletionFunc(pm, id, data):
		    if guitk.BCPopupMenuCount(pm) <= 1:
		        print("You must have at least one item in menu!")
		        return 0
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuSetDeletionEnabled(pm: object, enable: bool) -> None:

	"""

	Enable or disable the deletion of the highlighted popup item by pressing the delete key.
	If this option is enabled, a callback function can be set to be called uppon delete-key press. Set
	this function with BCPopupMenuSetDeletionFunction().
	NOTE: This property will reset to default (i.e. the item deletion is disabled), after BCPopupMenuClear() is called.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	enable : bool
		set this to True to enable this option; False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuDeletionEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCPopupMenu deletion example", guitk.constants.BCOnExitDestroy
		    )
		
		    button = guitk.BCPushButtonCreate(w, "Push me", None, None)
		
		    popup = guitk.BCPopupMenuCreate(button)
		    guitk.BCPopupMenuInsertItem(popup, "Item 1", None, None)
		    guitk.BCPopupMenuInsertItem(popup, "Item 2", None, None)
		    guitk.BCPopupMenuInsertItem(popup, "Item 3", None, None)
		    guitk.BCButtonSetPopup(button, popup)
		
		    guitk.BCPopupMenuSetDeletionEnabled(popup, True)
		    guitk.BCPopupMenuSetDeletionFunction(popup, popupDeletionFunc, None)
		
		    guitk.BCSpacerCreate(w)
		    guitk.BCShow(w)
		
		
		def popupDeletionFunc(pm, id, data):
		    if guitk.BCPopupMenuCount(pm) <= 1:
		        print("You must have at least one item in menu!")
		        return 0
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuDeletionEnabled(pm: object) -> bool:

	"""

	Returns True if deletion of the highlighted popup menu item is enabled by pressing the delete key. If not, returns False.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	bool
		True if deletion is enabled; False otherwise.

	See Also
	--------
	BCPopupMenuSetDeletionEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Deletion Enabled Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Deletion Disabled Popup", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    popupMenuInside = guitk.BCPopupMenuCreate(popupMenu)
		    guitk.BCPopupMenuSetDeletionEnabled(popupMenuInside, True)
		    guitk.BCPopupMenuInsertPopupMenu(
		        popupMenu, "Deletion Enabled Popup", popupMenuInside
		    )
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Outside item " + str(i), None, None)
		        guitk.BCPopupMenuInsertItem(
		            popupMenuInside, "Inside item " + str(i), None, None
		        )
		
		    print(
		        "Outside PopupMenu DeletionEnabled = "
		        + str(guitk.BCPopupMenuDeletionEnabled(popupMenu))
		    )
		    print(
		        "Inside PopupMenu DeletionEnabled = "
		        + str(guitk.BCPopupMenuDeletionEnabled(popupMenuInside))
		    )
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuActivateItem(pm: object, id: int) -> None:

	"""

	Activates the callback of the item with id id of the BCMenu pm.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the id of the item to be activated.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Enabled and Visible Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Enabled Item", None, None)
		    idInvisible = guitk.BCPopupMenuInsertItem(popupMenu, "Invisible Item", None, None)
		    guitk.BCPopupMenuSetItemVisible(popupMenu, idInvisible, False)
		    idDisabled = guitk.BCPopupMenuInsertItem(popupMenu, "Disabled Item", None, None)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, idDisabled, False)
		
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, menuActivated, None)
		    for i in range(guitk.BCPopupMenuCount(popupMenu)):
		        itemText = "'" + guitk.BCPopupMenuTextAt(popupMenu, i) + "'"
		        itemId = guitk.BCPopupMenuIdAt(popupMenu, i)
		        print(
		            itemText
		            + " is enabled = "
		            + str(guitk.BCPopupMenuIsItemEnabled(popupMenu, itemId))
		        )
		        print(
		            itemText
		            + " is visible = "
		            + str(guitk.BCPopupMenuIsItemVisible(popupMenu, itemId))
		        )
		        # Notice that even disabled and invisible items can be activated programmatically
		        guitk.BCPopupMenuActivateItem(popupMenu, itemId)
		    guitk.BCShow(window)
		
		
		def menuActivated(popupMenu, id, data):
		    print(guitk.BCPopupMenuText(popupMenu, id) + " activated!\\n")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCProgressBarCreate(p: object, steps: int) -> object:

	"""

	Creates a new BCProgressBar with parent p, and total steps steps.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	steps : int
		the totals steps

	Returns
	-------
	object
		the created BCProgressBar.

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Progress Bar Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    cb = guitk.BCCheckBoxCreate(w, "Display Percentage")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, toggleDisplayPercentageFunc, progressBar)
		    guitk.BCSpacerCreate(w)
		    rb = guitk.BCPushButtonCreate(w, "Reset", resetProgressBarClicked, progressBar)
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		    guitk.BCTimerStart(timer, 100, False)
		    guitk.BCSetUserDataKey(timer, "RESET_BUTTON", rb)
		    guitk.BCShow(w)
		
		
		def resetProgressBarClicked(b, data):
		    guitk.BCProgressBarReset(data)
		    return 0
		
		
		def timeoutFunc(timer, data):
		    progress = guitk.BCProgressBarProgress(data)
		    guitk.BCProgressBarSetProgress(data, progress + 1)
		    if progress >= 100:
		        guitk.BCTimerStop(timer)
		        rb = guitk.BCGetUserDataKey(timer, "RESET_BUTTON")
		        guitk.BCSetEnabled(rb, False)
		    return 0
		
		
		def toggleDisplayPercentageFunc(cb, state, data):
		    guitk.BCProgressBarSetPercentageVisible(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCProgressBarSetProgress(pb: object, progress: int) -> None:

	"""

	Sets the progress of the progress bar.
	This is the function that should be called inside the calculating loop.
	This function is not supported under VR mode.

	Parameters
	----------
	pb : object
		the BCProgressBar.

	progress : int
		the number of steps completed.

	Returns
	-------
	None

	See Also
	--------
	BCProgressBarSetTotalSteps

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Progress Bar Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    cb = guitk.BCCheckBoxCreate(w, "Display Percentage")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, toggleDisplayPercentageFunc, progressBar)
		    guitk.BCSpacerCreate(w)
		    rb = guitk.BCPushButtonCreate(w, "Reset", resetProgressBarClicked, progressBar)
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		    guitk.BCTimerStart(timer, 100, False)
		    guitk.BCSetUserDataKey(timer, "RESET_BUTTON", rb)
		    guitk.BCShow(w)
		
		
		def resetProgressBarClicked(b, data):
		    guitk.BCProgressBarReset(data)
		    return 0
		
		
		def timeoutFunc(timer, data):
		    progress = guitk.BCProgressBarProgress(data)
		    guitk.BCProgressBarSetProgress(data, progress + 1)
		    if progress >= 100:
		        guitk.BCTimerStop(timer)
		        rb = guitk.BCGetUserDataKey(timer, "RESET_BUTTON")
		        guitk.BCSetEnabled(rb, False)
		    return 0
		
		
		def toggleDisplayPercentageFunc(cb, state, data):
		    guitk.BCProgressBarSetPercentageVisible(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCProgressBarReset(pb: object) -> None:

	"""

	Resets the progress bar to show 0 completed steps. This function does not affect the total steps previously set.
	This function is not supported under VR mode.

	Parameters
	----------
	pb : object
		the BCProgressBar.

	Returns
	-------
	None

	See Also
	--------
	BCProgressBarSetProgress

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Progress Bar Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    cb = guitk.BCCheckBoxCreate(w, "Display Percentage")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, toggleDisplayPercentageFunc, progressBar)
		    guitk.BCSpacerCreate(w)
		    rb = guitk.BCPushButtonCreate(w, "Reset", resetProgressBarClicked, progressBar)
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		    guitk.BCTimerStart(timer, 100, False)
		    guitk.BCSetUserDataKey(timer, "RESET_BUTTON", rb)
		    guitk.BCShow(w)
		
		
		def resetProgressBarClicked(b, data):
		    guitk.BCProgressBarReset(data)
		    return 0
		
		
		def timeoutFunc(timer, data):
		    progress = guitk.BCProgressBarProgress(data)
		    guitk.BCProgressBarSetProgress(data, progress + 1)
		    if progress >= 100:
		        guitk.BCTimerStop(timer)
		        rb = guitk.BCGetUserDataKey(timer, "RESET_BUTTON")
		        guitk.BCSetEnabled(rb, False)
		    return 0
		
		
		def toggleDisplayPercentageFunc(cb, state, data):
		    guitk.BCProgressBarSetPercentageVisible(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCProgressBarSetTotalSteps(pb: object, steps: int) -> None:

	"""

	Sets the total steps of the progress bar.
	This function is not supported under VR mode.

	Parameters
	----------
	pb : object
		the BCProgressBar.

	steps : int
		the total number of steps.

	Returns
	-------
	None

	See Also
	--------
	BCProgressBarSetProgress

	Examples
	--------
	::

		from sdm import guitk
		
		TICKS_FOR_FULL = 1000
		MS_FOR_FULL = 10000
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        str(MS_FOR_FULL / 1000) + " sec ProgressBar Example",
		        guitk.constants.BCOnExitDestroy,
		    )
		    progressBar = guitk.BCProgressBarCreate(window, 5)
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox, "ProgressBar resolution")
		    sbinBox = guitk.BCSpinBoxCreate(hBox)
		    guitk.BCSpinBoxSetMaxValue(sbinBox, TICKS_FOR_FULL)
		    guitk.BCSpinBoxSetMinValue(sbinBox, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(sbinBox, sbValueChanged, progressBar)
		    guitk.BCSpinBoxSetValue(sbinBox, int(MS_FOR_FULL / 1000))
		    timer = guitk.BCTimerCreate(window)
		    guitk.BCSetUserDataKey(timer, "timerTicks", 0)
		    guitk.BCTimerStart(timer, int(MS_FOR_FULL / TICKS_FOR_FULL), False)
		    guitk.BCTimerSetTimeoutFunction(timer, timerTimeout, progressBar)
		    guitk.BCShow(window)
		
		
		def timerTimeout(timer, progressBar):
		    timerTicks = guitk.BCGetUserDataKey(timer, "timerTicks")
		    timerTicks += 1
		    percent = float(timerTicks % TICKS_FOR_FULL) / TICKS_FOR_FULL
		    stepsTaken = guitk.BCProgressBarProgress(progressBar)
		    maxSteps = guitk.BCProgressBarTotalSteps(progressBar)
		    if int(percent * maxSteps) != stepsTaken:
		        guitk.BCProgressBarSetProgress(progressBar, int(percent * maxSteps))
		    guitk.BCSetUserDataKey(timer, "timerTicks", timerTicks)
		    return 0
		
		
		def sbValueChanged(sbinBox, val, progressBar):
		    guitk.BCProgressBarSetTotalSteps(progressBar, val)
		    print("ProgressBar TotalSteps changed!")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCProgressBarTotalSteps(pb: object) -> int:

	"""

	Returns the total steps of pb.
	This function is not supported under VR mode.

	Parameters
	----------
	pb : object
		the BCProgressBar.

	Returns
	-------
	int

	See Also
	--------
	BCProgressBarProgress

	Examples
	--------
	::

		from sdm import guitk
		
		TICKS_FOR_FULL = 1000
		MS_FOR_FULL = 10000
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        str(MS_FOR_FULL / 1000) + " sec ProgressBar Example",
		        guitk.constants.BCOnExitDestroy,
		    )
		    progressBar = guitk.BCProgressBarCreate(window, 5)
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox, "ProgressBar resolution")
		    sbinBox = guitk.BCSpinBoxCreate(hBox)
		    guitk.BCSpinBoxSetMaxValue(sbinBox, TICKS_FOR_FULL)
		    guitk.BCSpinBoxSetMinValue(sbinBox, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(sbinBox, sbValueChanged, progressBar)
		    guitk.BCSpinBoxSetValue(sbinBox, int(MS_FOR_FULL / 1000))
		    timer = guitk.BCTimerCreate(window)
		    guitk.BCSetUserDataKey(timer, "timerTicks", 0)
		    guitk.BCTimerStart(timer, int(MS_FOR_FULL / TICKS_FOR_FULL), False)
		    guitk.BCTimerSetTimeoutFunction(timer, timerTimeout, progressBar)
		    guitk.BCShow(window)
		
		
		def timerTimeout(timer, progressBar):
		    timerTicks = guitk.BCGetUserDataKey(timer, "timerTicks")
		    timerTicks += 1
		    percent = float(timerTicks % TICKS_FOR_FULL) / TICKS_FOR_FULL
		    stepsTaken = guitk.BCProgressBarProgress(progressBar)
		    maxSteps = guitk.BCProgressBarTotalSteps(progressBar)
		    if int(percent * maxSteps) != stepsTaken:
		        guitk.BCProgressBarSetProgress(progressBar, int(percent * maxSteps))
		    guitk.BCSetUserDataKey(timer, "timerTicks", timerTicks)
		    return 0
		
		
		def sbValueChanged(sbinBox, val, progressBar):
		    guitk.BCProgressBarSetTotalSteps(progressBar, val)
		    print("ProgressBar TotalSteps changed!")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCProgressBarProgress(pb: object) -> int:

	"""

	Returns the progress (completed steps) of pb.
	This function is not supported under VR mode.

	Parameters
	----------
	pb : object
		the BCProgressBar.

	Returns
	-------
	int

	See Also
	--------
	BCProgressBarTotalSteps

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Progress Bar Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    cb = guitk.BCCheckBoxCreate(w, "Display Percentage")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, toggleDisplayPercentageFunc, progressBar)
		    guitk.BCSpacerCreate(w)
		    rb = guitk.BCPushButtonCreate(w, "Reset", resetProgressBarClicked, progressBar)
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		    guitk.BCTimerStart(timer, 100, False)
		    guitk.BCSetUserDataKey(timer, "RESET_BUTTON", rb)
		    guitk.BCShow(w)
		
		
		def resetProgressBarClicked(b, data):
		    guitk.BCProgressBarReset(data)
		    return 0
		
		
		def timeoutFunc(timer, data):
		    progress = guitk.BCProgressBarProgress(data)
		    guitk.BCProgressBarSetProgress(data, progress + 1)
		    if progress >= 100:
		        guitk.BCTimerStop(timer)
		        rb = guitk.BCGetUserDataKey(timer, "RESET_BUTTON")
		        guitk.BCSetEnabled(rb, False)
		    return 0
		
		
		def toggleDisplayPercentageFunc(cb, state, data):
		    guitk.BCProgressBarSetPercentageVisible(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCProgressBarSetPercentageVisible(pb: object, visible: bool) -> None:

	"""

	Sets whether the percentage of the completed steps will be displayed on the progress bar or not, depending on the value of visible.
	The percentage is visible by default.
	This function is not supported under VR mode.

	Parameters
	----------
	pb : object
		the BCProgressBar.

	visible : bool
		set this to True to show the percentage, or to False to hide it.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Progress Bar Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    cb = guitk.BCCheckBoxCreate(w, "Display Percentage")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, toggleDisplayPercentageFunc, progressBar)
		    guitk.BCSpacerCreate(w)
		    rb = guitk.BCPushButtonCreate(w, "Reset", resetProgressBarClicked, progressBar)
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		    guitk.BCTimerStart(timer, 100, False)
		    guitk.BCSetUserDataKey(timer, "RESET_BUTTON", rb)
		    guitk.BCShow(w)
		
		
		def resetProgressBarClicked(b, data):
		    guitk.BCProgressBarReset(data)
		    return 0
		
		
		def timeoutFunc(timer, data):
		    progress = guitk.BCProgressBarProgress(data)
		    guitk.BCProgressBarSetProgress(data, progress + 1)
		    if progress >= 100:
		        guitk.BCTimerStop(timer)
		        rb = guitk.BCGetUserDataKey(timer, "RESET_BUTTON")
		        guitk.BCSetEnabled(rb, False)
		    return 0
		
		
		def toggleDisplayPercentageFunc(cb, state, data):
		    guitk.BCProgressBarSetPercentageVisible(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRadioButtonCreate(p: object, text: str, funct: Callable, data: Any=None) -> object:

	"""

	Creates a BCRadioButton with parent p.
	It is recommended to be created with a BCButtonGroup as parent. RadioButtons by their nature are designed to operate exclusively 
	(when toggled, untoggle another radio button inside the same group). It is useless 
	to design multiple radio buttons and then try to copy the exclusive behaviour that 
	BCButtonGroup safely and easily provides. If you are trying to design radio buttons 
	outside of a BCButtonGroup, then probably you do not need to use BCRadioButtons at 
	all. When BCRadioButtons inserted to a BCButtonGroup they obtain exclusive property
	automatically. BCRadioButtons support pixmap as well as text.
	NOTE: In a ButtonGroup with mixed type of buttons (RadioButton, BCPushButton etc), a case which is not recommended,
	the exclusive property will be set for RadioButtons and not for any other type of button, even if we had
	set this property explicitly.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout

	text : str
		the text

	funct : Callable
		This callback is obsolete. Please avoid setting this callback.
		The proper way is to set the BCButtonGroupSetPressedFunction().

	data : Any, optional
		Obsolete parameter. Please pass  None

	Returns
	-------
	object
		the created BCRadioButton.

	See Also
	--------
	BCButtonGroupSetPressedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Simple ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		
		    bgroup = guitk.BCButtonGroupCreate(
		        window, "Color Group", guitk.constants.BCVertical
		    )
		
		    # BCButtonGroups with RadioButtons as elements have the exclusive property set enabled by default
		    redRadioButton = guitk.BCRadioButtonCreate(bgroup, "Red", None, None)
		    greenRadioButton = guitk.BCRadioButtonCreate(bgroup, "Green", None, None)
		    blueRadioButton = guitk.BCRadioButtonCreate(bgroup, "Blue", None, None)
		    guitk.BCRadioButtonSetChecked(redRadioButton, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, buttonGroupPressed, None)
		    guitk.BCSpacerCreate(window)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupPressed(bg, index, data):
		    colors = guitk.BCButtonGroupCount(bg)
		    print("There are " + str(colors) + " colors in button group")
		    print("Index is: " + str(index))
		    print("You have picked: ")
		    selectedRadioButton = guitk.BCButtonGroupFind(bg, index)
		    if selectedRadioButton:
		        print(guitk.BCRadioButtonText(selectedRadioButton))
		
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRadioButtonAddManagedWidget(rb: object, w: object, onAction: int, offAction: int) -> None:

	"""

	This function adds a widget to a list of widgets that are automatically managed when the radio button rb is set to on or off.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the RadioButton

	w : object
		the widget to manage.

	onAction : int
		the action to perform when the RadioButton is on.

	offAction : int
		the action to perform when the RadioButton is off.
		See BCEnumManagedAction property for details about actions.
		
		guitk.constants BCEnumManagedAction
		This enum type defines the action to be taken. The managed action is used with BCCheckBoxAddManagedWidget for example.
		 - guitk.constants.BCManagedEnable
		enables the widget.
		 - guitk.constants.BCManagedDisable
		disables the widget.
		 - guitk.constants.BCManagedHide
		hides the widget.
		 - guitk.constants.BCManagedShow
		shows the widget.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Managed RadioButton LineEdits Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    btnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Numeric Types", guitk.constants.BCVertical
		    )
		    intRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Integer [1,'inf']", None, None)
		    doubleRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Double [-1,1]", None, None)
		    guitk.BCButtonGroupSetPressedFunction(btnGroup, resetName, None)
		    vBox = guitk.BCVBoxCreate(hBox)
		    intLineEdit = guitk.BCLineEditCreateInt(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinLimitInt(intLineEdit, 1)
		    guitk.BCRadioButtonAddManagedWidget(
		        intRadioBtn,
		        intLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, passValidStatus, intRadioBtn)
		    doubleLineEdit = guitk.BCLineEditCreateDouble(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinMaxLimitDouble(doubleLineEdit, -1.0, 1.0)
		    guitk.BCRadioButtonAddManagedWidget(
		        doubleRadioBtn,
		        doubleLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, passValidStatus, doubleRadioBtn
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def resetName(btnGroup, id, data):
		    print("")
		    for i in range(guitk.BCButtonGroupCount(btnGroup)):
		        print(
		            "RadioButton id={} is checked={}".format(
		                i, guitk.BCRadioButtonIsChecked(guitk.BCButtonGroupFind(btnGroup, i))
		            )
		        )
		    otherId = not id
		    guitk.BCRadioButtonSetIconFileName(guitk.BCButtonGroupFind(btnGroup, otherId), "")
		    guitk.BCRadioButtonSetText(
		        guitk.BCButtonGroupFind(btnGroup, otherId),
		        "Integer [1,'inf']" if id else "Double [-1,1]",
		    )
		    return 0
		
		
		def passValidStatus(le, rb):
		    valid = guitk.BCLineEditValidate(le)
		    numType = (
		        "Integer [1,'inf']"
		        if "Integer" in guitk.BCRadioButtonText(rb)
		        else "Double [-1,1]"
		    )
		    guitk.BCRadioButtonSetText(rb, numType + (" - PASS" if valid else " - FAIL"))
		    guitk.BCRadioButtonSetIconFileName(
		        rb, "led_green_small.svg" if valid else "led_red_small.svg"
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRadioButtonSetChecked(rb: object, checked: bool) -> None:

	"""

	Sets RadioButton rb check state to checked.
	If you have placed RadioButtons into a ButtonGroup (recommended), 
	consider using BCButtonGroupSetButton() that also triggers respective ButtonGroup callbacks.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the RadioButton

	checked : bool
		set this parameter to True to set the radio button checked; False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCButtonGroupSetButton

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Simple ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		
		    bgroup = guitk.BCButtonGroupCreate(
		        window, "Color Group", guitk.constants.BCVertical
		    )
		
		    # BCButtonGroups with RadioButtons as elements have the exclusive property set enabled by default
		    redRadioButton = guitk.BCRadioButtonCreate(bgroup, "Red", None, None)
		    greenRadioButton = guitk.BCRadioButtonCreate(bgroup, "Green", None, None)
		    blueRadioButton = guitk.BCRadioButtonCreate(bgroup, "Blue", None, None)
		    guitk.BCRadioButtonSetChecked(redRadioButton, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, buttonGroupPressed, None)
		    guitk.BCSpacerCreate(window)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupPressed(bg, index, data):
		    colors = guitk.BCButtonGroupCount(bg)
		    print("There are " + str(colors) + " colors in button group")
		    print("Index is: " + str(index))
		    print("You have picked: ")
		    selectedRadioButton = guitk.BCButtonGroupFind(bg, index)
		    if selectedRadioButton:
		        print(guitk.BCRadioButtonText(selectedRadioButton))
		
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRadioButtonIsChecked(rb: object) -> bool:

	"""

	Returns True if RadioButton rb is checked; otherwise returns False.
	If you have placed RadioButtons into a ButtonGroup (recommended),
	consider using BCButtonGroupId() that actually gets the id of the current selected RadioButton.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the RadioButton

	Returns
	-------
	bool
		the check state of the RadioButton rb

	See Also
	--------
	BCButtonGroupId

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Managed RadioButton LineEdits Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    btnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Numeric Types", guitk.constants.BCVertical
		    )
		    intRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Integer [1,'inf']", None, None)
		    doubleRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Double [-1,1]", None, None)
		    guitk.BCButtonGroupSetPressedFunction(btnGroup, resetName, None)
		    vBox = guitk.BCVBoxCreate(hBox)
		    intLineEdit = guitk.BCLineEditCreateInt(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinLimitInt(intLineEdit, 1)
		    guitk.BCRadioButtonAddManagedWidget(
		        intRadioBtn,
		        intLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, passValidStatus, intRadioBtn)
		    doubleLineEdit = guitk.BCLineEditCreateDouble(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinMaxLimitDouble(doubleLineEdit, -1.0, 1.0)
		    guitk.BCRadioButtonAddManagedWidget(
		        doubleRadioBtn,
		        doubleLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, passValidStatus, doubleRadioBtn
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def resetName(btnGroup, id, data):
		    print("")
		    for i in range(guitk.BCButtonGroupCount(btnGroup)):
		        print(
		            "RadioButton id={} is checked={}".format(
		                i, guitk.BCRadioButtonIsChecked(guitk.BCButtonGroupFind(btnGroup, i))
		            )
		        )
		    otherId = not id
		    guitk.BCRadioButtonSetIconFileName(guitk.BCButtonGroupFind(btnGroup, otherId), "")
		    guitk.BCRadioButtonSetText(
		        guitk.BCButtonGroupFind(btnGroup, otherId),
		        "Integer [1,'inf']" if id else "Double [-1,1]",
		    )
		    return 0
		
		
		def passValidStatus(le, rb):
		    valid = guitk.BCLineEditValidate(le)
		    numType = (
		        "Integer [1,'inf']"
		        if "Integer" in guitk.BCRadioButtonText(rb)
		        else "Double [-1,1]"
		    )
		    guitk.BCRadioButtonSetText(rb, numType + (" - PASS" if valid else " - FAIL"))
		    guitk.BCRadioButtonSetIconFileName(
		        rb, "led_green_small.svg" if valid else "led_red_small.svg"
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRadioButtonSetIconFileName(rb: object, fileName: str) -> None:

	"""

	Sets the icon of the RadioButton rb.
	Icon is displayed between the check indicator and the text.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the RadioButton

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCIconIsValid

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Managed RadioButton LineEdits Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    btnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Numeric Types", guitk.constants.BCVertical
		    )
		    intRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Integer [1,'inf']", None, None)
		    doubleRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Double [-1,1]", None, None)
		    guitk.BCButtonGroupSetPressedFunction(btnGroup, resetName, None)
		    vBox = guitk.BCVBoxCreate(hBox)
		    intLineEdit = guitk.BCLineEditCreateInt(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinLimitInt(intLineEdit, 1)
		    guitk.BCRadioButtonAddManagedWidget(
		        intRadioBtn,
		        intLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, passValidStatus, intRadioBtn)
		    doubleLineEdit = guitk.BCLineEditCreateDouble(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinMaxLimitDouble(doubleLineEdit, -1.0, 1.0)
		    guitk.BCRadioButtonAddManagedWidget(
		        doubleRadioBtn,
		        doubleLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, passValidStatus, doubleRadioBtn
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def resetName(btnGroup, id, data):
		    print("")
		    for i in range(guitk.BCButtonGroupCount(btnGroup)):
		        print(
		            "RadioButton id={} is checked={}".format(
		                i, guitk.BCRadioButtonIsChecked(guitk.BCButtonGroupFind(btnGroup, i))
		            )
		        )
		    otherId = not id
		    guitk.BCRadioButtonSetIconFileName(guitk.BCButtonGroupFind(btnGroup, otherId), "")
		    guitk.BCRadioButtonSetText(
		        guitk.BCButtonGroupFind(btnGroup, otherId),
		        "Integer [1,'inf']" if id else "Double [-1,1]",
		    )
		    return 0
		
		
		def passValidStatus(le, rb):
		    valid = guitk.BCLineEditValidate(le)
		    numType = (
		        "Integer [1,'inf']"
		        if "Integer" in guitk.BCRadioButtonText(rb)
		        else "Double [-1,1]"
		    )
		    guitk.BCRadioButtonSetText(rb, numType + (" - PASS" if valid else " - FAIL"))
		    guitk.BCRadioButtonSetIconFileName(
		        rb, "led_green_small.svg" if valid else "led_red_small.svg"
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRadioButtonSetText(rb: object, text: str) -> None:

	"""

	Sets the text displayed on RadioButton rb.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the RadioButton

	text : str
		the text

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Managed RadioButton LineEdits Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    btnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Numeric Types", guitk.constants.BCVertical
		    )
		    intRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Integer [1,'inf']", None, None)
		    doubleRadioBtn = guitk.BCRadioButtonCreate(btnGroup, "Double [-1,1]", None, None)
		    guitk.BCButtonGroupSetPressedFunction(btnGroup, resetName, None)
		    vBox = guitk.BCVBoxCreate(hBox)
		    intLineEdit = guitk.BCLineEditCreateInt(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinLimitInt(intLineEdit, 1)
		    guitk.BCRadioButtonAddManagedWidget(
		        intRadioBtn,
		        intLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(intLineEdit, passValidStatus, intRadioBtn)
		    doubleLineEdit = guitk.BCLineEditCreateDouble(vBox, guitk.constants.blank)
		    guitk.BCLineEditSetMinMaxLimitDouble(doubleLineEdit, -1.0, 1.0)
		    guitk.BCRadioButtonAddManagedWidget(
		        doubleRadioBtn,
		        doubleLineEdit,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCLineEditSetEnterPressedFunction(
		        doubleLineEdit, passValidStatus, doubleRadioBtn
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def resetName(btnGroup, id, data):
		    print("")
		    for i in range(guitk.BCButtonGroupCount(btnGroup)):
		        print(
		            "RadioButton id={} is checked={}".format(
		                i, guitk.BCRadioButtonIsChecked(guitk.BCButtonGroupFind(btnGroup, i))
		            )
		        )
		    otherId = not id
		    guitk.BCRadioButtonSetIconFileName(guitk.BCButtonGroupFind(btnGroup, otherId), "")
		    guitk.BCRadioButtonSetText(
		        guitk.BCButtonGroupFind(btnGroup, otherId),
		        "Integer [1,'inf']" if id else "Double [-1,1]",
		    )
		    return 0
		
		
		def passValidStatus(le, rb):
		    valid = guitk.BCLineEditValidate(le)
		    numType = (
		        "Integer [1,'inf']"
		        if "Integer" in guitk.BCRadioButtonText(rb)
		        else "Double [-1,1]"
		    )
		    guitk.BCRadioButtonSetText(rb, numType + (" - PASS" if valid else " - FAIL"))
		    guitk.BCRadioButtonSetIconFileName(
		        rb, "led_green_small.svg" if valid else "led_red_small.svg"
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRadioButtonText(rb: object) -> str:

	"""

	Returns the text of button rb.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the RadioButton

	Returns
	-------
	str
		the text.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Simple ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		
		    bgroup = guitk.BCButtonGroupCreate(
		        window, "Color Group", guitk.constants.BCVertical
		    )
		
		    # BCButtonGroups with RadioButtons as elements have the exclusive property set enabled by default
		    redRadioButton = guitk.BCRadioButtonCreate(bgroup, "Red", None, None)
		    greenRadioButton = guitk.BCRadioButtonCreate(bgroup, "Green", None, None)
		    blueRadioButton = guitk.BCRadioButtonCreate(bgroup, "Blue", None, None)
		    guitk.BCRadioButtonSetChecked(redRadioButton, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, buttonGroupPressed, None)
		    guitk.BCSpacerCreate(window)
		
		    guitk.BCShow(window)
		
		
		def buttonGroupPressed(bg, index, data):
		    colors = guitk.BCButtonGroupCount(bg)
		    print("There are " + str(colors) + " colors in button group")
		    print("Index is: " + str(index))
		    print("You have picked: ")
		    selectedRadioButton = guitk.BCButtonGroupFind(bg, index)
		    if selectedRadioButton:
		        print(guitk.BCRadioButtonText(selectedRadioButton))
		
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSeparatorCreate(p: object) -> object:

	"""

	Creates a styled line to visually separate controls on a window.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the newly created separator frame.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Separator", guitk.constants.BCOnExitDestroy)
		    guitk.BCPushButtonCreate(window, "Button", None, None)
		    separator = guitk.BCSeparatorCreate(window)
		    guitk.BCSeparatorSetOrientation(separator, guitk.constants.BCHorizontal)
		    guitk.BCCheckBoxCreate(window, "CheckBox")
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSeparatorSetOrientation(s: object, o: int) -> None:

	"""

	Sets the orientation of the Separator s to o.

	Parameters
	----------
	s : object
		the separator.

	o : int
		the orientation of the separator. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Separator", guitk.constants.BCOnExitDestroy)
		    guitk.BCPushButtonCreate(window, "Button", None, None)
		    separator = guitk.BCSeparatorCreate(window)
		    guitk.BCSeparatorSetOrientation(separator, guitk.constants.BCHorizontal)
		    guitk.BCCheckBoxCreate(window, "CheckBox")
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderCreate(p: object, min: int, max: int, step: int, value: int, o: int) -> object:

	"""

	Creates a BCSlider.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	min : int
		the minimum allowed value for the slider.

	max : int
		the maximum allowed value for the slider.

	step : int
		the step for the slider.

	value : int
		the initial value to which the slider will be set.

	o : int
		the orientation of the slider. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	Returns
	-------
	object
		the newly created BCSlider

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetValue(sl: object, value: int) -> None:

	"""

	Sets the current value of slider sl to value.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	value : int
		the new value to which the slider will be set.

	Returns
	-------
	None

	See Also
	--------
	BCSliderValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetValueNoCallback(sl: object, value: int) -> None:

	"""

	Sets the current value of slider sl to value without calling the callback.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	value : int
		the new value to which the slider will be set.

	Returns
	-------
	None

	See Also
	--------
	BCSliderSetValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderValue(sl: object) -> int:

	"""

	Returns the current value of the slider sl.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		the value of the slider.

	See Also
	--------
	BCSliderSetValue

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetMinValue(sl: object, min: int) -> None:

	"""

	Sets the minimum value of the slider.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	min : int
		the minimum value of the slider.

	Returns
	-------
	None

	See Also
	--------
	BCSliderMinValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderMinValue(sl: object) -> int:

	"""

	Gets the minimum value of the slider.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		the minimum value of the slider

	See Also
	--------
	BCSliderSetMinValue

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetMaxValue(sl: object, max: int) -> None:

	"""

	Sets the maximum value of the slider.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	max : int
		the maximum value of the slider.

	Returns
	-------
	None

	See Also
	--------
	BCSliderMaxValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderMaxValue(sl: object) -> int:

	"""

	Gets the maximum value of the slider.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		the maximum value of the slider

	See Also
	--------
	BCSliderSetMaxValue

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetLineStep(sl: object, step: int) -> None:

	"""

	Sets the line step.
	The line step is the smaller of two natural steps by which the slider position changes.
	Typically corresponds to the user pressing an arrow key.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	step : int
		the line step of the slider.

	Returns
	-------
	None

	See Also
	--------
	BCSliderLineStep

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderLineStep(sl: object) -> int:

	"""

	Returns the line step.
	The line step is the smaller of two natural steps by which the slider position changes.
	Typically corresponds to the user pressing an arrow key
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		the line step of slider.

	See Also
	--------
	BCSliderSetLineStep

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetPageStep(sl: object, step: int) -> None:

	"""

	Sets the page step.
	The page step is the larger of two natural steps by which the slider position changes.
	Typically corresponds to the user pressing the PageUp or PageDown keys.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	step : int
		the page step of the slider.

	Returns
	-------
	None

	See Also
	--------
	BCSliderPageStep

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderPageStep(sl: object) -> int:

	"""

	Returns the page step.
	The page step is the larger of two natural steps by which the slider position changes.
	Typically corresponds to the user pressing the PageUp or PageDown keys.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		the page step of slider.

	See Also
	--------
	BCSliderSetPageStep

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetValueChangedFunction(sl: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called every time the value of the slider changes.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	funct : Callable
		the function that will be called when the value of the slider changes. 
		See BC_SLIDER_VALUE_CHANGED_FUNCTION for details.
		integer BC_SLIDER_VALUE_CHANGED_FUNCTION(sl, val, data)
		The function to be called every time the value of the slider changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * sl : object
		                    the BCSlider.
		          * val : int
		                    the new slider value.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct. If data is not required,
		it should be set to None.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetTickmarks(sl: object, ticks: int) -> None:

	"""

	Sets tickmarks setting for BCSlider sl.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the BCSlider.

	ticks : int
		the tickmark setting. See BCEnumTickmarks property for details.
		
		guitk.constants BCEnumTickmarks
		This enum specifies where the tickmarks of a BCSlider are to be drawn relative to the slider's groove and the handle the user
		moves. It is used in BCSliderSetTickmarks.
		 - guitk.constants.BCTicksNoMarks
		No tickmarks are drawn.
		 - guitk.constants.BCTicksAbove
		Draw tickmarks above the (horizontal) slider.
		 - guitk.constants.BCTicksBelow
		Draw tickmarks below the (horizontal) slider.
		 - guitk.constants.BCTicksLeft
		Draw tickmarks to the left of the (vertical) slider.
		 - guitk.constants.BCTicksRight
		Draw tickmarks to the right of the (vertical) slider.
		 - guitk.constants.BCTicksBoth
		Draw tickmarks on both sides of the groove.

	Returns
	-------
	None

	See Also
	--------
	BCSliderSetTickmarksInterval

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetTickmarksInterval(sl: object, interval: int) -> None:

	"""

	Sets the interval between tickmarks.
	NOTE: This is a value interval, not a pixel interval. If it is 0, the BCSlider will choose between line step and page step. The initial value of the interval is 0.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the BCSlider.

	interval : int
		the interval between tickmarks.

	Returns
	-------
	None

	See Also
	--------
	BCSliderSetTickmarks

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCSlider example", guitk.constants.BCOnExitDestroy)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    # Create a horizontal slider with 0 minimum, 50 maximum values, 5 step and 20 current value
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Tickmarks Position", guitk.constants.BCVertical)
		    guitk.BCRadioButtonCreate(bg, "No Tickmarks", None, None)
		    guitk.BCRadioButtonCreate(bg, "Above", None, None)
		    guitk.BCRadioButtonCreate(bg, "Below", None, None)
		    guitk.BCRadioButtonCreate(bg, "Both", None, None)
		    guitk.BCButtonGroupSetButton(bg, 2)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    guitk.BCButtonGroupSetClickedFunction(bg, setSliderTickmarks, slider)
		
		    vright = guitk.BCBoxLayoutCreate(l, guitk.constants.BCVertical)
		
		    tickInterval = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(tickInterval, 1)
		    guitk.BCSpinBoxSetMaxValue(tickInterval, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(tickInterval, setTickInterval, slider)
		
		    lineStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(lineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(lineStep, 10)
		    guitk.BCSpinBoxSetValueChangedFunction(lineStep, setLineStep, slider)
		    lineStepValue = guitk.BCSliderLineStep(slider)
		    guitk.BCSpinBoxSetValue(lineStep, lineStepValue)
		    guitk.BCAddToolTip(
		        lineStep,
		        "The small step by which the position of the slider changes.\\nActivated by pressing the arrow keys.",
		    )
		
		    pageStep = guitk.BCSpinBoxCreate(vright)
		    guitk.BCSpinBoxSetMinValue(pageStep, 1)
		    guitk.BCSpinBoxSetMaxValue(pageStep, 20)
		    guitk.BCSpinBoxSetValueChangedFunction(pageStep, setPageStep, slider)
		    pageStepValue = guitk.BCSliderPageStep(slider)
		    guitk.BCSpinBoxSetValue(pageStep, pageStepValue)
		    guitk.BCAddToolTip(
		        pageStep,
		        "The large step by which the position of the slider changes.\\nActivated by pressing the PageUp/PageDown keys.",
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Tick interval"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    guitk.BCGridLayoutAddWidget(grid, tickInterval, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Line step"), 2, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, lineStep, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(grid, "Page step"), 3, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCGridLayoutAddWidget(grid, pageStep, 3, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 5, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        6,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 6, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(vl)
		    guitk.BCShow(w)
		
		
		def setSliderTickmarks(bg, buttonIndex, slider):
		    if buttonIndex == 0:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksNoMarks)
		    elif buttonIndex == 1:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksAbove)
		    elif buttonIndex == 2:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBelow)
		    elif buttonIndex == 3:
		        guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		    return 0
		
		
		def setTickInterval(spin, value, slider):
		    guitk.BCSliderSetTickmarksInterval(slider, value)
		    return 0
		
		
		def setLineStep(spin, value, slider):
		    guitk.BCSliderSetLineStep(slider, value)
		    return 0
		
		
		def setPageStep(spin, value, slider):
		    guitk.BCSliderSetPageStep(slider, value)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderEnableBoundaries(sl: object, enable: int) -> None:

	"""

	Enables the boundaries for BCSlider sl.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the BCSlider.

	enable : int
		0 or 1 whether boundaries for BCSlider sl should be enabled.

	Returns
	-------
	None

	See Also
	--------
	BCSliderSetStartBoundValue

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCSlider boundaries example", guitk.constants.BCOnExitDestroy
		    )
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Bounds", guitk.constants.BCVertical)
		    bounds = guitk.BCCheckBoxCreate(bg, "Bounds")
		    guitk.BCCheckBoxSetToggledFunction(bounds, sliderSetBounds, slider)
		    boundsExceed = guitk.BCCheckBoxCreate(bg, "Exceed Bounds")
		    guitk.BCCheckBoxSetToggledFunction(boundsExceed, sliderSetExceedBounds, slider)
		    guitk.BCCheckBoxAddManagedWidget(
		        bounds,
		        boundsExceed,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 1, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        2,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 2, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Start bound : "),
		        3,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_start_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_start_bound_label, 3, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetStartBoundChangedFunction(
		        slider, sliderValueChanged, value_start_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "End bound : "),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_end_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_end_bound_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetEndBoundChangedFunction(
		        slider, sliderValueChanged, value_end_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 5, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(w)
		    guitk.BCShow(w)
		
		
		def sliderSetBounds(cb, state, slider):
		    guitk.BCSliderEnableBoundaries(slider, state)
		    return 0
		
		
		def sliderSetExceedBounds(cb, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetStartBoundValue(sl: object, val: int) -> None:

	"""

	Sets the starting boundary value for BCSlider sl.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the BCSlider.

	val : int
		the new value to which the starting boundary for BCSlider sl will be set.

	Returns
	-------
	None

	See Also
	--------
	BCSliderSetEndBoundValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetEndBoundValue(sl: object, val: int) -> None:

	"""

	Sets the ending boundary value for BCSlider sl.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the BCSlider.

	val : int
		the new value to which the ending boundary for BCSlider sl will be set.

	Returns
	-------
	None

	See Also
	--------
	BCSliderSetStartBoundValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderStartBoundValue(sl: object) -> int:

	"""

	Gets the starting boundary value of the slider.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		the starting boundary value of the slider.

	See Also
	--------
	BCSliderSetStartBoundValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderEndBoundValue(sl: object) -> int:

	"""

	Gets the ending boundary value of the slider.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		the ending boundary value of the slider.

	See Also
	--------
	BCSliderSetEndBoundValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetExceedBounds(sl: object, exceed: int) -> None:

	"""

	Sets the slider to exceed the boundaries.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the BCSlider.

	exceed : int
		set 1 to exceed the boundaries, or 0 otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCSliderExceedBounds

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCSlider boundaries example", guitk.constants.BCOnExitDestroy
		    )
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Bounds", guitk.constants.BCVertical)
		    bounds = guitk.BCCheckBoxCreate(bg, "Bounds")
		    guitk.BCCheckBoxSetToggledFunction(bounds, sliderSetBounds, slider)
		    boundsExceed = guitk.BCCheckBoxCreate(bg, "Exceed Bounds")
		    guitk.BCCheckBoxSetToggledFunction(boundsExceed, sliderSetExceedBounds, slider)
		    guitk.BCCheckBoxAddManagedWidget(
		        bounds,
		        boundsExceed,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 1, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        2,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 2, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Start bound : "),
		        3,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_start_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_start_bound_label, 3, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetStartBoundChangedFunction(
		        slider, sliderValueChanged, value_start_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "End bound : "),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_end_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_end_bound_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetEndBoundChangedFunction(
		        slider, sliderValueChanged, value_end_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 5, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(w)
		    guitk.BCShow(w)
		
		
		def sliderSetBounds(cb, state, slider):
		    guitk.BCSliderEnableBoundaries(slider, state)
		    return 0
		
		
		def sliderSetExceedBounds(cb, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderExceedBounds(sl: object) -> int:

	"""

	Returns whether the slider can exceed the boundaries or not.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	Returns
	-------
	int
		1 if the slider can exceed the boundaries, or 0 otherwise.

	See Also
	--------
	BCSliderSetExceedBounds

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetStartBoundChangedFunction(sl: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called every time the starting boundary value of the slider changes.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	funct : Callable
		the function that will be called when the starting boundary value of the slider changes. 
		See BC_SLIDER_START_BOUND_CHANGED_FUNCTION for details.
		integer BC_SLIDER_START_BOUND_CHANGED_FUNCTION(sl, val, data)
		The function to be called every time the starting boundary value of the slider changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * sl : object
		                    the BCSlider.
		          * val : int
		                    the new slider starting boundary value.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct. If data is not required,
		it should be set to None.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCSlider boundaries example", guitk.constants.BCOnExitDestroy
		    )
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Bounds", guitk.constants.BCVertical)
		    bounds = guitk.BCCheckBoxCreate(bg, "Bounds")
		    guitk.BCCheckBoxSetToggledFunction(bounds, sliderSetBounds, slider)
		    boundsExceed = guitk.BCCheckBoxCreate(bg, "Exceed Bounds")
		    guitk.BCCheckBoxSetToggledFunction(boundsExceed, sliderSetExceedBounds, slider)
		    guitk.BCCheckBoxAddManagedWidget(
		        bounds,
		        boundsExceed,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 1, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        2,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 2, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Start bound : "),
		        3,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_start_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_start_bound_label, 3, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetStartBoundChangedFunction(
		        slider, sliderValueChanged, value_start_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "End bound : "),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_end_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_end_bound_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetEndBoundChangedFunction(
		        slider, sliderValueChanged, value_end_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 5, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(w)
		    guitk.BCShow(w)
		
		
		def sliderSetBounds(cb, state, slider):
		    guitk.BCSliderEnableBoundaries(slider, state)
		    return 0
		
		
		def sliderSetExceedBounds(cb, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSliderSetEndBoundChangedFunction(sl: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called every time the ending boundary value of the slider changes.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the slider.

	funct : Callable
		the function that will be called when the ending boundary value of the slider changes. 
		See BC_SLIDER_END_BOUND_CHANGED_FUNCTION for details.
		integer BC_SLIDER_END_BOUND_CHANGED_FUNCTION(sl, val, data)
		The function to be called every time the ending boundary value of the slider changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * sl : object
		                    the BCSlider.
		          * val : int
		                    the new slider ending boundary value.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct. If data is not required,
		it should be set to None.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCSlider boundaries example", guitk.constants.BCOnExitDestroy
		    )
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    slider = guitk.BCSliderCreate(vl, 0, 50, 5, 20, guitk.constants.BCHorizontal)
		    guitk.BCSliderSetTickmarks(slider, guitk.constants.BCTicksBoth)
		
		    l = guitk.BCBoxLayoutCreate(vl, guitk.constants.BCHorizontal)
		    bg = guitk.BCButtonGroupCreate(l, "Bounds", guitk.constants.BCVertical)
		    bounds = guitk.BCCheckBoxCreate(bg, "Bounds")
		    guitk.BCCheckBoxSetToggledFunction(bounds, sliderSetBounds, slider)
		    boundsExceed = guitk.BCCheckBoxCreate(bg, "Exceed Bounds")
		    guitk.BCCheckBoxSetToggledFunction(boundsExceed, sliderSetExceedBounds, slider)
		    guitk.BCCheckBoxAddManagedWidget(
		        bounds,
		        boundsExceed,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    grid = guitk.BCGridLayoutCreate(l, 6, 2)
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Min value :"),
		        1,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    min_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMinValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, min_value_label, 1, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Max value :"),
		        2,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    max_value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderMaxValue(slider)))
		    guitk.BCGridLayoutAddWidget(
		        grid, max_value_label, 2, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Start bound : "),
		        3,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_start_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_start_bound_label, 3, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetStartBoundChangedFunction(
		        slider, sliderValueChanged, value_start_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "End bound : "),
		        4,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_end_bound_label = guitk.BCLabelCreate(grid, "")
		    guitk.BCGridLayoutAddWidget(
		        grid, value_end_bound_label, 4, 2, guitk.constants.BCAlignRight
		    )
		    guitk.BCSliderSetEndBoundChangedFunction(
		        slider, sliderValueChanged, value_end_bound_label
		    )
		    guitk.BCGridLayoutAddWidget(
		        grid,
		        guitk.BCLabelCreate(grid, "Current value : "),
		        5,
		        1,
		        guitk.constants.BCAlignAuto,
		    )
		    value_label = guitk.BCLabelCreate(grid, str(guitk.BCSliderValue(slider)))
		    guitk.BCGridLayoutAddWidget(grid, value_label, 5, 2, guitk.constants.BCAlignRight)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, value_label)
		
		    guitk.BCSpacerCreate(w)
		    guitk.BCShow(w)
		
		
		def sliderSetBounds(cb, state, slider):
		    guitk.BCSliderEnableBoundaries(slider, state)
		    return 0
		
		
		def sliderSetExceedBounds(cb, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, label):
		    guitk.BCLabelSetText(label, str(value))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpacerCreate(p: object) -> object:

	"""

	Creates a blank space, with minimum width and height equal to 5 pixels.
	Spacer is not a widget.
	Spacer inside a horizontal layout gets expanding horizontal policy. Geometry and size policy can be modified any time using BCSpacerChangeSize().
	WARNING: Spacer should be placed inside a layout or inside a widget that has a layout. If you pass widget without a layout as spacer parent, the behaviour is undefined.

	Parameters
	----------
	p : object
		layout or widget with a layout.

	Returns
	-------
	object
		the created Spacer.

	See Also
	--------
	BCSpacerChangeSize

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Spacer", guitk.constants.BCOnExitDestroy)
		    guitk.BCPushButtonCreate(window, "Button", None, None)
		    spacer = guitk.BCSpacerCreate(window)
		    guitk.BCSpacerChangeSize(
		        spacer,
		        10,
		        100,
		        guitk.constants.BCMinimumExpanding,
		        guitk.constants.BCMinimumExpanding,
		    )
		    guitk.BCCheckBoxCreate(window, "CheckBox")
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpacerChangeSize(spc: object, w: int, h: int, sizepolicy_h: int, sizepolicy_v: int) -> None:

	"""

	Changes Spacer spc to have preferred width w, height h, horizontal size policy sizepolicy_h and vertical size policy sizepolicy_v.

	Parameters
	----------
	spc : object
		the Spacer.

	w : int
		the preferred width.

	h : int
		the preferred height.

	sizepolicy_h : int
		the horizontal SizePolicy (default: BCExpanding).

	sizepolicy_v : int
		the vertical SizePolicy (default: BCExpanding).
		See BCEnumSizePolicy for details about size policy.
		
		guitk.constants BCEnumSizePolicy
		This enum type holds the default layout behavior of the widget.
		If there is a BCBoxLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such BCBoxLayout, the result of this function is used.
		 - guitk.constants.BCFixed
		this is the default widget policy. The size hint is the only acceptable alternative, so the widget can never grow or shrink (e.g. the vertical direction of a push button).
		 - guitk.constants.BCMinimum
		the size hint is minimal, and sufficient. The widget can be expanded, but there is no advantage to it being larger (e.g. the horizontal direction of a push button). It cannot be smaller than the size provided by size hint.
		 - guitk.constants.BCMaximum
		the size hint is a maximum. The widget can be shrunk any amount without detriment if other widgets need the space (e.g. a separator line). It cannot be larger than the size provided by size hint.
		 - guitk.constants.BCPreferred
		the size hint is best, but the widget can be shrunk and still be useful. The widget can be expanded, but there is no advantage to it being larger than size hint.
		 - guitk.constants.BCExpanding
		the size hint is a sensible size, but the widget can be shrunk and still be useful. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCMinimumExpanding
		the size hint is minimal, and sufficient. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a slider).
		 - guitk.constants.BCIgnored
		the size hint is ignored. The widget will get as much space as possible.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Spacer", guitk.constants.BCOnExitDestroy)
		    guitk.BCPushButtonCreate(window, "Button", None, None)
		    spacer = guitk.BCSpacerCreate(window)
		    guitk.BCSpacerChangeSize(
		        spacer,
		        10,
		        100,
		        guitk.constants.BCMinimumExpanding,
		        guitk.constants.BCMinimumExpanding,
		    )
		    guitk.BCCheckBoxCreate(window, "CheckBox")
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxCreate(p: object) -> object:

	"""

	Creates a SpinBox in parent p that accepts integers with minimum 0, maximum 100 and line step 1.

	Parameters
	----------
	p : object
		The parent widget or layout.

	Returns
	-------
	object
		The created BCSpinBox.

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 4
		    cols = 2
		    # Set Components of the window
		    w = guitk.BCWindowCreate("SpinBox Values Example", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox")
		    sb = guitk.BCSpinBoxCreate(grid)
		    minlb = guitk.BCLabelCreate(grid, "Min Value")
		    maxlb = guitk.BCLabelCreate(grid, "Max Value")
		    steplb = guitk.BCLabelCreate(grid, "Step")
		    chmintb = guitk.BCLineEditCreateInt(grid, 0)
		    chmaxtb = guitk.BCLineEditCreateInt(grid, 100)
		    chsteptb = guitk.BCLineEditCreateInt(grid, 1)
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, guitk.BCLineEditGetInt(chmintb))
		    guitk.BCSpinBoxSetMaxValue(sb, guitk.BCLineEditGetInt(chmaxtb))
		    guitk.BCSpinBoxSetLineStep(sb, guitk.BCLineEditGetInt(chsteptb))
		
		    # Set Functions
		    guitk.BCLineEditSetEnterPressedFunction(chmintb, LineEditMinValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chmaxtb, LineEditMaxValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chsteptb, LineEditStepValueChanged, sb)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, minlb, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, maxlb, 2, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, steplb, 3, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmintb, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmaxtb, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chsteptb, 3, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, 0)
		
		    guitk.BCShow(w)
		
		
		def LineEditMinValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    max_value = guitk.BCSpinBoxMaxValue(data)
		    if value <= max_value:
		        guitk.BCSpinBoxSetMinValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMinValue(data, max_value)
		        guitk.BCLineEditSetInt(le, max_value)
		    return 0
		
		
		def LineEditMaxValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    min_value = guitk.BCSpinBoxMinValue(data)
		    if value >= min_value:
		        guitk.BCSpinBoxSetMaxValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMaxValue(data, min_value)
		        guitk.BCLineEditSetInt(le, min_value)
		    return 0
		
		
		def LineEditStepValueChanged(le, data):
		    guitk.BCSpinBoxSetLineStep(data, guitk.BCLineEditGetInt(le))
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxCreateDouble(p: object, min: float, max: float, step: float, decimals: int) -> object:

	"""

	Creates a SpinBox in parent p, that accepts float/double values.

	Parameters
	----------
	p : object
		The parent widget or layout.

	min : float
		The minimum allowed value.

	max : float
		The maximum allowed value.

	step : float
		The step.

	decimals : int
		the number of displayed decimals.

	Returns
	-------
	object
		The created BCSpinBox.

	See Also
	--------
	BCSpinBoxCreate

	"""

def BCSpinBoxGetText(sb: object) -> str:

	"""

	Returns the text of BCSpinBox sb.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	str
		the text of the BCSpinBox without any prefix or suffix.

	See Also
	--------
	BCSpinBoxGetInt

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SpinBox with LineStep Example", guitk.constants.BCOnExitDestroy
		    )
		    fLayout0 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout0, guitk.BCLabelCreate(fLayout0, "SpinBox"))
		    spinBoxMain = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxMain, -20)
		    guitk.BCSpinBoxSetMaxValue(spinBoxMain, 20)
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxMain, printMe, None)
		    guitk.BCFlowLayoutInsert(fLayout0, spinBoxMain)
		
		    fLayout1 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout1, guitk.BCLabelCreate(fLayout1, "LineStep"))
		    spinBoxLineStep = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxLineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(
		        spinBoxLineStep,
		        guitk.BCSpinBoxMaxValue(spinBoxMain) - guitk.BCSpinBoxMinValue(spinBoxMain),
		    )
		    guitk.BCSpinBoxSetValue(spinBoxLineStep, guitk.BCSpinBoxGetLineStep(spinBoxMain))
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxLineStep, changeLineStep, spinBoxMain)
		    guitk.BCFlowLayoutInsert(fLayout1, spinBoxLineStep)
		
		    chkBoxRelease = guitk.BCCheckBoxCreate(window, "Trigger Callback on Mouse Release")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxRelease, changeRelease, spinBoxMain)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printMe(spinBox, value, data):
		    print(
		        "Main SpinBox value changed!\\nLineStep = "
		        + str(guitk.BCSpinBoxGetLineStep(spinBox))
		        + ", Value = "
		        + guitk.BCSpinBoxGetText(spinBox)
		    )
		    return 0
		
		
		def changeLineStep(spinBox, value, spinBoxMain):
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, value)
		    return 0
		
		
		def changeRelease(chkBox, state, spinBoxMain):
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBoxMain, state)
		    print(
		        "ValueChangedOnMouseRelease = "
		        + str(guitk.BCSpinBoxValueChangedOnMouseRelease(spinBoxMain))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxGetInt(sb: object) -> int:

	"""

	Returns the text of the BCSpinBox sb in int format.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	int
		the value of the BCSpinBox.

	See Also
	--------
	BCSpinBoxGetText

	Examples
	--------
	::

		from sdm import guitk
		
		NUM_ITEMS = 10
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Remove by Index Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    for i in range(NUM_ITEMS):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Item " + str(i), None, None)
		    hBoxIndex = guitk.BCHBoxCreate(window)
		    btnRemoveIndex = guitk.BCPushButtonCreate(hBoxIndex, "Remove By Index:", None, None)
		    indexSpinBox = guitk.BCSpinBoxCreate(hBoxIndex)
		    guitk.BCSpinBoxSetMaxValue(indexSpinBox, NUM_ITEMS - 1)
		    guitk.BCButtonSetClickedFunction(
		        btnRemoveIndex, btnRemoveIndexClicked, (popupMenu, indexSpinBox)
		    )
		    guitk.BCShow(window)
		
		
		def btnRemoveIndexClicked(btn, data):
		    popupMenu, spinBox = data
		    index = guitk.BCSpinBoxGetInt(spinBox)
		    print("Removed " + guitk.BCPopupMenuTextAt(popupMenu, index))
		    guitk.BCPopupMenuRemoveItemAt(popupMenu, index)
		    newCount = guitk.BCPopupMenuCount(popupMenu)
		    if newCount:
		        guitk.BCSpinBoxSetMaxValue(spinBox, newCount - 1)
		    else:
		        guitk.BCSetEnabled(btn, False)
		        guitk.BCSetEnabled(spinBox, False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxGetDouble(sb: object) -> float:

	"""

	Returns the text of the BCSpinBox sb in double format.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	float
		the value of the BCSpinBox.

	See Also
	--------
	BCSpinBoxGetText

	"""

def BCSpinBoxSetDoubleValue(sb: object, value: float) -> None:

	"""

	Sets the double value of spin box sb to value value.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	value : float
		the new double value of the BCSpinBox.

	Returns
	-------
	None

	"""

def BCSpinBoxSetMinValueDouble(sb: object, min: float) -> None:

	"""

	Sets the minimum double value of the spin box.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	min : float
		the minimum double value of the spin box.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxMinValueDouble

	"""

def BCSpinBoxMinValueDouble(sb: object) -> float:

	"""

	Gets the minimum double value of the spin box.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	float
		the minimum double value of the spin box.

	See Also
	--------
	BCSpinBoxSetMinValueDouble

	"""

def BCSpinBoxSetMaxValueDouble(sb: object, max: float) -> None:

	"""

	Sets the maximum double value of the spin box.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	max : float
		the maximum double value of the spin box.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxMaxValueDouble

	"""

def BCSpinBoxMaxValueDouble(sb: object) -> float:

	"""

	Gets the maximum double value of the spin box.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	float
		the maximum double value of the spin box

	See Also
	--------
	BCSpinBoxSetMaxValueDouble

	"""

def BCSpinBoxSetStepAndDigits(sb: object, step: float, digits: int) -> None:

	"""

	Sets the stepping value of the spin box and the number of digits to display.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	step : float
		the stepping in double format

	digits : int
		the number of digits to display

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxSetMaxValueDouble

	"""

def BCSpinBoxGetDigits(sb: object) -> int:

	"""

	Returns the number of digits to display.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	int
		the number of digits to display.

	See Also
	--------
	BCSpinBoxSetStepAndDigits

	"""

def BCSpinBoxSetMinValue(sb: object, min: int) -> None:

	"""

	Sets the minimum integer value of the spin box (default 0).

	Parameters
	----------
	sb : object
		the BCSpinBox.

	min : int
		the minimum integer value of the spin box.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxMinValue

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 4
		    cols = 2
		    # Set Components of the window
		    w = guitk.BCWindowCreate("SpinBox Values Example", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox")
		    sb = guitk.BCSpinBoxCreate(grid)
		    minlb = guitk.BCLabelCreate(grid, "Min Value")
		    maxlb = guitk.BCLabelCreate(grid, "Max Value")
		    steplb = guitk.BCLabelCreate(grid, "Step")
		    chmintb = guitk.BCLineEditCreateInt(grid, 0)
		    chmaxtb = guitk.BCLineEditCreateInt(grid, 100)
		    chsteptb = guitk.BCLineEditCreateInt(grid, 1)
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, guitk.BCLineEditGetInt(chmintb))
		    guitk.BCSpinBoxSetMaxValue(sb, guitk.BCLineEditGetInt(chmaxtb))
		    guitk.BCSpinBoxSetLineStep(sb, guitk.BCLineEditGetInt(chsteptb))
		
		    # Set Functions
		    guitk.BCLineEditSetEnterPressedFunction(chmintb, LineEditMinValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chmaxtb, LineEditMaxValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chsteptb, LineEditStepValueChanged, sb)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, minlb, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, maxlb, 2, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, steplb, 3, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmintb, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmaxtb, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chsteptb, 3, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, 0)
		
		    guitk.BCShow(w)
		
		
		def LineEditMinValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    max_value = guitk.BCSpinBoxMaxValue(data)
		    if value <= max_value:
		        guitk.BCSpinBoxSetMinValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMinValue(data, max_value)
		        guitk.BCLineEditSetInt(le, max_value)
		    return 0
		
		
		def LineEditMaxValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    min_value = guitk.BCSpinBoxMinValue(data)
		    if value >= min_value:
		        guitk.BCSpinBoxSetMaxValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMaxValue(data, min_value)
		        guitk.BCLineEditSetInt(le, min_value)
		    return 0
		
		
		def LineEditStepValueChanged(le, data):
		    guitk.BCSpinBoxSetLineStep(data, guitk.BCLineEditGetInt(le))
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxMinValue(sb: object) -> int:

	"""

	Gets the minimum integer value of the spin box.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	int
		the minimum integer value of the spin box.

	See Also
	--------
	BCSpinBoxSetMinValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SpinBox with LineStep Example", guitk.constants.BCOnExitDestroy
		    )
		    fLayout0 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout0, guitk.BCLabelCreate(fLayout0, "SpinBox"))
		    spinBoxMain = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxMain, -20)
		    guitk.BCSpinBoxSetMaxValue(spinBoxMain, 20)
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxMain, printMe, None)
		    guitk.BCFlowLayoutInsert(fLayout0, spinBoxMain)
		
		    fLayout1 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout1, guitk.BCLabelCreate(fLayout1, "LineStep"))
		    spinBoxLineStep = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxLineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(
		        spinBoxLineStep,
		        guitk.BCSpinBoxMaxValue(spinBoxMain) - guitk.BCSpinBoxMinValue(spinBoxMain),
		    )
		    guitk.BCSpinBoxSetValue(spinBoxLineStep, guitk.BCSpinBoxGetLineStep(spinBoxMain))
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxLineStep, changeLineStep, spinBoxMain)
		    guitk.BCFlowLayoutInsert(fLayout1, spinBoxLineStep)
		
		    chkBoxRelease = guitk.BCCheckBoxCreate(window, "Trigger Callback on Mouse Release")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxRelease, changeRelease, spinBoxMain)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printMe(spinBox, value, data):
		    print(
		        "Main SpinBox value changed!\\nLineStep = "
		        + str(guitk.BCSpinBoxGetLineStep(spinBox))
		        + ", Value = "
		        + guitk.BCSpinBoxGetText(spinBox)
		    )
		    return 0
		
		
		def changeLineStep(spinBox, value, spinBoxMain):
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, value)
		    return 0
		
		
		def changeRelease(chkBox, state, spinBoxMain):
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBoxMain, state)
		    print(
		        "ValueChangedOnMouseRelease = "
		        + str(guitk.BCSpinBoxValueChangedOnMouseRelease(spinBoxMain))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetMaxValue(sb: object, max: int) -> None:

	"""

	Sets the maximum integer value of the spin box (default 100).

	Parameters
	----------
	sb : object
		the BCSpinBox.

	max : int
		the maximum integer value of the spin box.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxMaxValue

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 4
		    cols = 2
		    # Set Components of the window
		    w = guitk.BCWindowCreate("SpinBox Values Example", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox")
		    sb = guitk.BCSpinBoxCreate(grid)
		    minlb = guitk.BCLabelCreate(grid, "Min Value")
		    maxlb = guitk.BCLabelCreate(grid, "Max Value")
		    steplb = guitk.BCLabelCreate(grid, "Step")
		    chmintb = guitk.BCLineEditCreateInt(grid, 0)
		    chmaxtb = guitk.BCLineEditCreateInt(grid, 100)
		    chsteptb = guitk.BCLineEditCreateInt(grid, 1)
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, guitk.BCLineEditGetInt(chmintb))
		    guitk.BCSpinBoxSetMaxValue(sb, guitk.BCLineEditGetInt(chmaxtb))
		    guitk.BCSpinBoxSetLineStep(sb, guitk.BCLineEditGetInt(chsteptb))
		
		    # Set Functions
		    guitk.BCLineEditSetEnterPressedFunction(chmintb, LineEditMinValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chmaxtb, LineEditMaxValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chsteptb, LineEditStepValueChanged, sb)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, minlb, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, maxlb, 2, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, steplb, 3, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmintb, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmaxtb, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chsteptb, 3, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, 0)
		
		    guitk.BCShow(w)
		
		
		def LineEditMinValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    max_value = guitk.BCSpinBoxMaxValue(data)
		    if value <= max_value:
		        guitk.BCSpinBoxSetMinValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMinValue(data, max_value)
		        guitk.BCLineEditSetInt(le, max_value)
		    return 0
		
		
		def LineEditMaxValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    min_value = guitk.BCSpinBoxMinValue(data)
		    if value >= min_value:
		        guitk.BCSpinBoxSetMaxValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMaxValue(data, min_value)
		        guitk.BCLineEditSetInt(le, min_value)
		    return 0
		
		
		def LineEditStepValueChanged(le, data):
		    guitk.BCSpinBoxSetLineStep(data, guitk.BCLineEditGetInt(le))
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxMaxValue(sb: object) -> int:

	"""

	Gets the maximum integer value of the spin box.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	int
		the maximum integer value of the spin box

	See Also
	--------
	BCSpinBoxSetMaxValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SpinBox with LineStep Example", guitk.constants.BCOnExitDestroy
		    )
		    fLayout0 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout0, guitk.BCLabelCreate(fLayout0, "SpinBox"))
		    spinBoxMain = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxMain, -20)
		    guitk.BCSpinBoxSetMaxValue(spinBoxMain, 20)
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxMain, printMe, None)
		    guitk.BCFlowLayoutInsert(fLayout0, spinBoxMain)
		
		    fLayout1 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout1, guitk.BCLabelCreate(fLayout1, "LineStep"))
		    spinBoxLineStep = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxLineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(
		        spinBoxLineStep,
		        guitk.BCSpinBoxMaxValue(spinBoxMain) - guitk.BCSpinBoxMinValue(spinBoxMain),
		    )
		    guitk.BCSpinBoxSetValue(spinBoxLineStep, guitk.BCSpinBoxGetLineStep(spinBoxMain))
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxLineStep, changeLineStep, spinBoxMain)
		    guitk.BCFlowLayoutInsert(fLayout1, spinBoxLineStep)
		
		    chkBoxRelease = guitk.BCCheckBoxCreate(window, "Trigger Callback on Mouse Release")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxRelease, changeRelease, spinBoxMain)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printMe(spinBox, value, data):
		    print(
		        "Main SpinBox value changed!\\nLineStep = "
		        + str(guitk.BCSpinBoxGetLineStep(spinBox))
		        + ", Value = "
		        + guitk.BCSpinBoxGetText(spinBox)
		    )
		    return 0
		
		
		def changeLineStep(spinBox, value, spinBoxMain):
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, value)
		    return 0
		
		
		def changeRelease(chkBox, state, spinBoxMain):
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBoxMain, state)
		    print(
		        "ValueChangedOnMouseRelease = "
		        + str(guitk.BCSpinBoxValueChangedOnMouseRelease(spinBoxMain))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetLineStep(sb: object, step: int) -> None:

	"""

	Sets the line step to step (default 1).
	When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the line step.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	step : int
		the line step of spinbox.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxGetLineStep

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 4
		    cols = 2
		    # Set Components of the window
		    w = guitk.BCWindowCreate("SpinBox Values Example", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox")
		    sb = guitk.BCSpinBoxCreate(grid)
		    minlb = guitk.BCLabelCreate(grid, "Min Value")
		    maxlb = guitk.BCLabelCreate(grid, "Max Value")
		    steplb = guitk.BCLabelCreate(grid, "Step")
		    chmintb = guitk.BCLineEditCreateInt(grid, 0)
		    chmaxtb = guitk.BCLineEditCreateInt(grid, 100)
		    chsteptb = guitk.BCLineEditCreateInt(grid, 1)
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, guitk.BCLineEditGetInt(chmintb))
		    guitk.BCSpinBoxSetMaxValue(sb, guitk.BCLineEditGetInt(chmaxtb))
		    guitk.BCSpinBoxSetLineStep(sb, guitk.BCLineEditGetInt(chsteptb))
		
		    # Set Functions
		    guitk.BCLineEditSetEnterPressedFunction(chmintb, LineEditMinValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chmaxtb, LineEditMaxValueChanged, sb)
		    guitk.BCLineEditSetEnterPressedFunction(chsteptb, LineEditStepValueChanged, sb)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, minlb, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, maxlb, 2, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, steplb, 3, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmintb, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chmaxtb, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, chsteptb, 3, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, 0)
		
		    guitk.BCShow(w)
		
		
		def LineEditMinValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    max_value = guitk.BCSpinBoxMaxValue(data)
		    if value <= max_value:
		        guitk.BCSpinBoxSetMinValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMinValue(data, max_value)
		        guitk.BCLineEditSetInt(le, max_value)
		    return 0
		
		
		def LineEditMaxValueChanged(le, data):
		    value = guitk.BCLineEditGetInt(le)
		    min_value = guitk.BCSpinBoxMinValue(data)
		    if value >= min_value:
		        guitk.BCSpinBoxSetMaxValue(data, value)
		    else:
		        guitk.BCSpinBoxSetMaxValue(data, min_value)
		        guitk.BCLineEditSetInt(le, min_value)
		    return 0
		
		
		def LineEditStepValueChanged(le, data):
		    guitk.BCSpinBoxSetLineStep(data, guitk.BCLineEditGetInt(le))
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxGetLineStep(sb: object) -> int:

	"""

	Returns the line step of BCSpinBox sb.
	When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the line step.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	int
		the line step of BCSpinBox.

	See Also
	--------
	BCSpinBoxSetLineStep

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SpinBox with LineStep Example", guitk.constants.BCOnExitDestroy
		    )
		    fLayout0 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout0, guitk.BCLabelCreate(fLayout0, "SpinBox"))
		    spinBoxMain = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxMain, -20)
		    guitk.BCSpinBoxSetMaxValue(spinBoxMain, 20)
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxMain, printMe, None)
		    guitk.BCFlowLayoutInsert(fLayout0, spinBoxMain)
		
		    fLayout1 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout1, guitk.BCLabelCreate(fLayout1, "LineStep"))
		    spinBoxLineStep = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxLineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(
		        spinBoxLineStep,
		        guitk.BCSpinBoxMaxValue(spinBoxMain) - guitk.BCSpinBoxMinValue(spinBoxMain),
		    )
		    guitk.BCSpinBoxSetValue(spinBoxLineStep, guitk.BCSpinBoxGetLineStep(spinBoxMain))
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxLineStep, changeLineStep, spinBoxMain)
		    guitk.BCFlowLayoutInsert(fLayout1, spinBoxLineStep)
		
		    chkBoxRelease = guitk.BCCheckBoxCreate(window, "Trigger Callback on Mouse Release")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxRelease, changeRelease, spinBoxMain)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printMe(spinBox, value, data):
		    print(
		        "Main SpinBox value changed!\\nLineStep = "
		        + str(guitk.BCSpinBoxGetLineStep(spinBox))
		        + ", Value = "
		        + guitk.BCSpinBoxGetText(spinBox)
		    )
		    return 0
		
		
		def changeLineStep(spinBox, value, spinBoxMain):
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, value)
		    return 0
		
		
		def changeRelease(chkBox, state, spinBoxMain):
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBoxMain, state)
		    print(
		        "ValueChangedOnMouseRelease = "
		        + str(guitk.BCSpinBoxValueChangedOnMouseRelease(spinBoxMain))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetWrapping(sb: object, on: bool) -> None:

	"""

	Sets whether it is possible to step the value from the highest value to the lowest value and vice versa to on.
	If you have a range of 0..100 and wrapping is off when the user reaches 100 and presses the Up Arrow nothing will happen; but if wrapping is on the value will change from 100 to 0, then to 1, etc. When wrapping is on, navigating past the highest value takes you to the lowest and vice versa.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	on : bool
		holds whether it is possible to step the value from the highest value to the lowest value and vice versa.By default, wrapping is turned off.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxWrapping

	"""

def BCSpinBoxWrapping(sb: object) -> bool:

	"""

	Returns the wrapping behavior of BCSpinBox sb.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	bool
		True if it is possible to step the value from the highest value to the lowest value and vice versa; otherwise returns False.

	See Also
	--------
	BCSpinBoxSetWrapping

	"""

def BCSpinBoxSetValueChangedFunction(sb: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called every time the value of the spin box changes.
	Use this function when you have integer values.

	Parameters
	----------
	sb : object
		the BCSpinBox

	funct : Callable
		the function that will be called when the value of the BCSpinBox changes. See BC_SPINBOX_VALUE_CHANGED_FUNCTION for details.
		integer BC_SPINBOX_VALUE_CHANGED_FUNCTION(sb, val, data)
		The function to be called every time the integer value of the spinbox changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * sb : object
		                    the BCSpinBox.
		          * val : int
		                    the new spinbox value.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything required by funct. If data is not required, it should be set to None.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxSetDoubleValueChangedFunction

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 2
		    cols = 3
		    # Set Components of the window
		    w = guitk.BCWindowCreate(
		        "SpinBox Suffix Prefix Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox:")
		    sb = guitk.BCSpinBoxCreate(grid)
		
		    cbonrelease = guitk.BCCheckBoxCreate(grid, "Verify on SpinBox Release")
		    guitk.BCAddToolTip(
		        cbonrelease, "Value will be accepted only on release of SpinBox."
		    )
		    prefix = guitk.BCCheckBoxCreate(grid, "Prefix")
		    suffix = guitk.BCCheckBoxCreate(grid, "Suffix")
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, 1)
		    guitk.BCSpinBoxSetMaxValue(sb, 100)
		    guitk.BCSpinBoxSetLineStep(sb, 1)
		
		    # Set Functions
		    guitk.BCCheckBoxSetToggledFunction(cbonrelease, SpinBoxVerifyOnRelease, sb)
		    guitk.BCCheckBoxSetToggledFunction(prefix, PrefixIsChecked, sb)
		    guitk.BCCheckBoxSetToggledFunction(suffix, SuffixIsChecked, sb)
		    guitk.BCSpinBoxSetValueChangedFunction(sb, SpinBoxValueChanged, None)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, cbonrelease, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, prefix, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, suffix, 1, 2, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		
		    guitk.BCShow(w)
		
		
		def SpinBoxVerifyOnRelease(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, True)
		    else:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, False)
		    return 0
		
		
		def SpinBoxValueChanged(sb, val, data):
		    print("The value is : %d" % val)
		    return 0
		
		
		def PrefixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetPrefix(data, "prefix")
		    else:
		        guitk.BCSpinBoxSetPrefix(data, "")
		    return 0
		
		
		def SuffixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetSuffix(data, "Suffix")
		    else:
		        guitk.BCSpinBoxSetSuffix(data, "")
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetDoubleValueChangedFunction(sb: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called every time the value of the spin box changes.
	Use this function when you have double values.

	Parameters
	----------
	sb : object
		the BCSpinBox

	funct : Callable
		the function that will be called when the value of the BCSpinBox changes. 
		See BC_SPINBOX_DOUBLE_VALUE_CHANGED_FUNCTION for details.
		integer BC_SPINBOX_DOUBLE_VALUE_CHANGED_FUNCTION(sb, val, data)
		The function to be called every time the double value of the spinbox changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * sb : object
		                    the BCSpinBox.
		          * val : float
		                    the new spinbox value.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct. 
		If data is not required, it should be set to None.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxSetValueChangedFunction

	"""

def BCSpinBoxSetValueChangedOnMouseRelease(sb: object, onMouseRelease: bool) -> None:

	"""

	Sets whether BCSpinBox's sb value changed callback will be called only on mouse release or not.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	onMouseRelease : bool
		set this parameter to True for sb so that value changed callback will be called only on mouse release, or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxValueChangedOnMouseRelease

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 2
		    cols = 3
		    # Set Components of the window
		    w = guitk.BCWindowCreate(
		        "SpinBox Suffix Prefix Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox:")
		    sb = guitk.BCSpinBoxCreate(grid)
		
		    cbonrelease = guitk.BCCheckBoxCreate(grid, "Verify on SpinBox Release")
		    guitk.BCAddToolTip(
		        cbonrelease, "Value will be accepted only on release of SpinBox."
		    )
		    prefix = guitk.BCCheckBoxCreate(grid, "Prefix")
		    suffix = guitk.BCCheckBoxCreate(grid, "Suffix")
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, 1)
		    guitk.BCSpinBoxSetMaxValue(sb, 100)
		    guitk.BCSpinBoxSetLineStep(sb, 1)
		
		    # Set Functions
		    guitk.BCCheckBoxSetToggledFunction(cbonrelease, SpinBoxVerifyOnRelease, sb)
		    guitk.BCCheckBoxSetToggledFunction(prefix, PrefixIsChecked, sb)
		    guitk.BCCheckBoxSetToggledFunction(suffix, SuffixIsChecked, sb)
		    guitk.BCSpinBoxSetValueChangedFunction(sb, SpinBoxValueChanged, None)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, cbonrelease, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, prefix, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, suffix, 1, 2, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		
		    guitk.BCShow(w)
		
		
		def SpinBoxVerifyOnRelease(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, True)
		    else:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, False)
		    return 0
		
		
		def SpinBoxValueChanged(sb, val, data):
		    print("The value is : %d" % val)
		    return 0
		
		
		def PrefixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetPrefix(data, "prefix")
		    else:
		        guitk.BCSpinBoxSetPrefix(data, "")
		    return 0
		
		
		def SuffixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetSuffix(data, "Suffix")
		    else:
		        guitk.BCSpinBoxSetSuffix(data, "")
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxValueChangedOnMouseRelease(sb: object) -> bool:

	"""

	Returns whether BCSpinBox's sb value changed callback will be called only on mouse release or not.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	Returns
	-------
	bool
		True if value changed callback will be called only on mouse release, or False otherwise.

	See Also
	--------
	BCSpinBoxSetValueChangedOnMouseRelease

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SpinBox with LineStep Example", guitk.constants.BCOnExitDestroy
		    )
		    fLayout0 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout0, guitk.BCLabelCreate(fLayout0, "SpinBox"))
		    spinBoxMain = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxMain, -20)
		    guitk.BCSpinBoxSetMaxValue(spinBoxMain, 20)
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxMain, printMe, None)
		    guitk.BCFlowLayoutInsert(fLayout0, spinBoxMain)
		
		    fLayout1 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout1, guitk.BCLabelCreate(fLayout1, "LineStep"))
		    spinBoxLineStep = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxLineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(
		        spinBoxLineStep,
		        guitk.BCSpinBoxMaxValue(spinBoxMain) - guitk.BCSpinBoxMinValue(spinBoxMain),
		    )
		    guitk.BCSpinBoxSetValue(spinBoxLineStep, guitk.BCSpinBoxGetLineStep(spinBoxMain))
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxLineStep, changeLineStep, spinBoxMain)
		    guitk.BCFlowLayoutInsert(fLayout1, spinBoxLineStep)
		
		    chkBoxRelease = guitk.BCCheckBoxCreate(window, "Trigger Callback on Mouse Release")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxRelease, changeRelease, spinBoxMain)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printMe(spinBox, value, data):
		    print(
		        "Main SpinBox value changed!\\nLineStep = "
		        + str(guitk.BCSpinBoxGetLineStep(spinBox))
		        + ", Value = "
		        + guitk.BCSpinBoxGetText(spinBox)
		    )
		    return 0
		
		
		def changeLineStep(spinBox, value, spinBoxMain):
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, value)
		    return 0
		
		
		def changeRelease(chkBox, state, spinBoxMain):
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBoxMain, state)
		    print(
		        "ValueChangedOnMouseRelease = "
		        + str(guitk.BCSpinBoxValueChangedOnMouseRelease(spinBoxMain))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetValue(sb: object, value: int) -> None:

	"""

	Sets the value of spin box sb to value value.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	value : int
		the new value of the BCSpinBox.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxSetDoubleValue

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SpinBox with LineStep Example", guitk.constants.BCOnExitDestroy
		    )
		    fLayout0 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout0, guitk.BCLabelCreate(fLayout0, "SpinBox"))
		    spinBoxMain = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxMain, -20)
		    guitk.BCSpinBoxSetMaxValue(spinBoxMain, 20)
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, 2)
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxMain, printMe, None)
		    guitk.BCFlowLayoutInsert(fLayout0, spinBoxMain)
		
		    fLayout1 = guitk.BCFlowLayoutCreate(window)
		    guitk.BCFlowLayoutInsert(fLayout1, guitk.BCLabelCreate(fLayout1, "LineStep"))
		    spinBoxLineStep = guitk.BCSpinBoxCreate(window)
		    guitk.BCSpinBoxSetMinValue(spinBoxLineStep, 1)
		    guitk.BCSpinBoxSetMaxValue(
		        spinBoxLineStep,
		        guitk.BCSpinBoxMaxValue(spinBoxMain) - guitk.BCSpinBoxMinValue(spinBoxMain),
		    )
		    guitk.BCSpinBoxSetValue(spinBoxLineStep, guitk.BCSpinBoxGetLineStep(spinBoxMain))
		    guitk.BCSpinBoxSetValueChangedFunction(spinBoxLineStep, changeLineStep, spinBoxMain)
		    guitk.BCFlowLayoutInsert(fLayout1, spinBoxLineStep)
		
		    chkBoxRelease = guitk.BCCheckBoxCreate(window, "Trigger Callback on Mouse Release")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxRelease, changeRelease, spinBoxMain)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printMe(spinBox, value, data):
		    print(
		        "Main SpinBox value changed!\\nLineStep = "
		        + str(guitk.BCSpinBoxGetLineStep(spinBox))
		        + ", Value = "
		        + guitk.BCSpinBoxGetText(spinBox)
		    )
		    return 0
		
		
		def changeLineStep(spinBox, value, spinBoxMain):
		    guitk.BCSpinBoxSetLineStep(spinBoxMain, value)
		    return 0
		
		
		def changeRelease(chkBox, state, spinBoxMain):
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBoxMain, state)
		    print(
		        "ValueChangedOnMouseRelease = "
		        + str(guitk.BCSpinBoxValueChangedOnMouseRelease(spinBoxMain))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetSuffix(sb: object, text: str) -> None:

	"""

	Sets the suffix of BCSpinBox sb to text.
	The suffix is appended at the end of the displayed value. Typical use is to display a unit of measurement or a currency symbol. For example: 
	sb-&gt;setSuffix( " km" );
	To turn off the suffix display, set this property to an empty string. The default is no suffix.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	text : str
		the new suffix.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxSetPrefix

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 2
		    cols = 3
		    # Set Components of the window
		    w = guitk.BCWindowCreate(
		        "SpinBox Suffix Prefix Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox:")
		    sb = guitk.BCSpinBoxCreate(grid)
		
		    cbonrelease = guitk.BCCheckBoxCreate(grid, "Verify on SpinBox Release")
		    guitk.BCAddToolTip(
		        cbonrelease, "Value will be accepted only on release of SpinBox."
		    )
		    prefix = guitk.BCCheckBoxCreate(grid, "Prefix")
		    suffix = guitk.BCCheckBoxCreate(grid, "Suffix")
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, 1)
		    guitk.BCSpinBoxSetMaxValue(sb, 100)
		    guitk.BCSpinBoxSetLineStep(sb, 1)
		
		    # Set Functions
		    guitk.BCCheckBoxSetToggledFunction(cbonrelease, SpinBoxVerifyOnRelease, sb)
		    guitk.BCCheckBoxSetToggledFunction(prefix, PrefixIsChecked, sb)
		    guitk.BCCheckBoxSetToggledFunction(suffix, SuffixIsChecked, sb)
		    guitk.BCSpinBoxSetValueChangedFunction(sb, SpinBoxValueChanged, None)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, cbonrelease, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, prefix, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, suffix, 1, 2, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		
		    guitk.BCShow(w)
		
		
		def SpinBoxVerifyOnRelease(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, True)
		    else:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, False)
		    return 0
		
		
		def SpinBoxValueChanged(sb, val, data):
		    print("The value is : %d" % val)
		    return 0
		
		
		def PrefixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetPrefix(data, "prefix")
		    else:
		        guitk.BCSpinBoxSetPrefix(data, "")
		    return 0
		
		
		def SuffixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetSuffix(data, "Suffix")
		    else:
		        guitk.BCSpinBoxSetSuffix(data, "")
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetPrefix(sb: object, text: str) -> None:

	"""

	Sets the prefix of BCSpinBox sb to text.
	The prefix is prepended to the start of the displayed value. Typical use is to display a unit of measurement or a currency symbol. For example:
	sb-&gt;setPrefix( "$" );
	To turn off the prefix display, set this property to an empty string. The default is no prefix.

	Parameters
	----------
	sb : object
		the BCSpinBox.

	text : str
		the new prefix.

	Returns
	-------
	None

	See Also
	--------
	BCSpinBoxSetSuffix

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    rows = 2
		    cols = 3
		    # Set Components of the window
		    w = guitk.BCWindowCreate(
		        "SpinBox Suffix Prefix Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(w, rows, cols)
		    lb = guitk.BCLabelCreate(grid, "Value of SpinBox:")
		    sb = guitk.BCSpinBoxCreate(grid)
		
		    cbonrelease = guitk.BCCheckBoxCreate(grid, "Verify on SpinBox Release")
		    guitk.BCAddToolTip(
		        cbonrelease, "Value will be accepted only on release of SpinBox."
		    )
		    prefix = guitk.BCCheckBoxCreate(grid, "Prefix")
		    suffix = guitk.BCCheckBoxCreate(grid, "Suffix")
		
		    # Initialize Values
		    guitk.BCSpinBoxSetMinValue(sb, 1)
		    guitk.BCSpinBoxSetMaxValue(sb, 100)
		    guitk.BCSpinBoxSetLineStep(sb, 1)
		
		    # Set Functions
		    guitk.BCCheckBoxSetToggledFunction(cbonrelease, SpinBoxVerifyOnRelease, sb)
		    guitk.BCCheckBoxSetToggledFunction(prefix, PrefixIsChecked, sb)
		    guitk.BCCheckBoxSetToggledFunction(suffix, SuffixIsChecked, sb)
		    guitk.BCSpinBoxSetValueChangedFunction(sb, SpinBoxValueChanged, None)
		
		    # Create Grid
		    guitk.BCGridLayoutAddWidget(grid, lb, 0, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, sb, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, cbonrelease, 1, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, prefix, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(grid, suffix, 1, 2, guitk.constants.BCAlignAuto)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		
		    guitk.BCShow(w)
		
		
		def SpinBoxVerifyOnRelease(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, True)
		    else:
		        guitk.BCSpinBoxSetValueChangedOnMouseRelease(data, False)
		    return 0
		
		
		def SpinBoxValueChanged(sb, val, data):
		    print("The value is : %d" % val)
		    return 0
		
		
		def PrefixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetPrefix(data, "prefix")
		    else:
		        guitk.BCSpinBoxSetPrefix(data, "")
		    return 0
		
		
		def SuffixIsChecked(cb, state, data):
		    if state:
		        guitk.BCSpinBoxSetSuffix(data, "Suffix")
		    else:
		        guitk.BCSpinBoxSetSuffix(data, "")
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSpinBoxSetFixedDigitsNumber(sb: object, numDigits: int) -> None:

	"""

	Sets the width of the spinbox sb to the width that numDigits hold.
	Use this function if you want for example to design a spinBox with sensible width that accepts only two digits (values from 0 to 99).

	Parameters
	----------
	sb : object
		the BCSpinBox.

	numDigits : int
		the number of characters.

	Returns
	-------
	None

	"""

def BCSplitterCreate(p: object, o: int) -> object:

	"""

	Creates a new BCSplitter.
	Note that BCSplitter automatically saves the sizes of the managed widgets in xml file.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout of the BCSplitter.

	o : int
		the orientation of the BCSplitter. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	Returns
	-------
	object
		the created BCSplitter.

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def setSplitterOrientation(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCHorizontal)
		    elif index == 1:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCVertical)
		    return 0
		
		
		def setSplitterHandleWidth(spinBox, value, splitter):
		    guitk.BCSplitterSetHandleWidth(splitter, value)
		    return 0
		
		
		def collapsibleStateChanged(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, True)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, True)
		    elif index == 1:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, False)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, False)
		    return 0
		
		
		def main():
		    global labelA
		    global labelB
		    window = guitk.BCWindowCreate("Example Splitter", guitk.constants.BCOnExitDestroy)
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    labelA = guitk.BCLabelCreate(splitter, "Frame A")
		    guitk.BCSetBackgroundColor(labelA, 255, 235, 215)
		    labelB = guitk.BCLabelCreate(splitter, "Frame B")
		    guitk.BCSetBackgroundColor(labelB, 215, 235, 255)
		
		    optionsLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    orient = guitk.BCButtonGroupCreate(
		        optionsLayout, "Orientation", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(orient, "Horizontal", None, None)
		    guitk.BCRadioButtonCreate(orient, "Vertical", None, None)
		    guitk.BCButtonGroupSetButton(orient, 0)
		    guitk.BCButtonGroupSetPressedFunction(orient, setSplitterOrientation, splitter)
		
		    bgroup = guitk.BCButtonGroupCreate(
		        optionsLayout, "Resize mode", guitk.constants.BCVertical
		    )
		    shrinkToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can shrink until hidden", None, None
		    )
		    shrinkNotToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can not shrink until hidden", None, None
		    )
		    guitk.BCRadioButtonSetChecked(shrinkToHidden, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, collapsibleStateChanged, splitter)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Handle width")
		    spin = guitk.BCSpinBoxCreate(hl)
		    guitk.BCSpinBoxSetMinValue(spin, 1)
		    guitk.BCSpinBoxSetMaxValue(spin, 25)
		    guitk.BCSpinBoxSetValue(spin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, setSplitterHandleWidth, splitter)
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterSetCollapsible(sp: object, w: object, collapse: bool) -> None:

	"""

	Checks whether a widget w is a child of BCSplitter sp and sets it collapsible or not.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	w : object
		the widget, child of sp.

	collapse : bool
		values are False if the widget should not be collapsible, otherwise True (default).

	Returns
	-------
	None

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def setSplitterOrientation(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCHorizontal)
		    elif index == 1:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCVertical)
		    return 0
		
		
		def setSplitterHandleWidth(spinBox, value, splitter):
		    guitk.BCSplitterSetHandleWidth(splitter, value)
		    return 0
		
		
		def collapsibleStateChanged(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, True)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, True)
		    elif index == 1:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, False)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, False)
		    return 0
		
		
		def main():
		    global labelA
		    global labelB
		    window = guitk.BCWindowCreate("Example Splitter", guitk.constants.BCOnExitDestroy)
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    labelA = guitk.BCLabelCreate(splitter, "Frame A")
		    guitk.BCSetBackgroundColor(labelA, 255, 235, 215)
		    labelB = guitk.BCLabelCreate(splitter, "Frame B")
		    guitk.BCSetBackgroundColor(labelB, 215, 235, 255)
		
		    optionsLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    orient = guitk.BCButtonGroupCreate(
		        optionsLayout, "Orientation", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(orient, "Horizontal", None, None)
		    guitk.BCRadioButtonCreate(orient, "Vertical", None, None)
		    guitk.BCButtonGroupSetButton(orient, 0)
		    guitk.BCButtonGroupSetPressedFunction(orient, setSplitterOrientation, splitter)
		
		    bgroup = guitk.BCButtonGroupCreate(
		        optionsLayout, "Resize mode", guitk.constants.BCVertical
		    )
		    shrinkToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can shrink until hidden", None, None
		    )
		    shrinkNotToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can not shrink until hidden", None, None
		    )
		    guitk.BCRadioButtonSetChecked(shrinkToHidden, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, collapsibleStateChanged, splitter)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Handle width")
		    spin = guitk.BCSpinBoxCreate(hl)
		    guitk.BCSpinBoxSetMinValue(spin, 1)
		    guitk.BCSpinBoxSetMaxValue(spin, 25)
		    guitk.BCSpinBoxSetValue(spin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, setSplitterHandleWidth, splitter)
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterMoveToFirst(sp: object, w: object) -> None:

	"""

	Moves to the beginning (top or left, depending on the orientation of the BCSplitter) a certain widget.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	w : object
		the widget, child of sp.

	Returns
	-------
	None

	See Also
	--------
	BCSplitterMoveToLast

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter ResizeMode Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    splitterFrameCreate(splitter, "Frame A - stretch 0\\n(Keep Size)")
		    guitk.BCSplitterSetStretchFactor(splitter, 0, 0)
		    splitterFrameCreate(splitter, "Frame B - stretch 1")
		    guitk.BCSplitterSetStretchFactor(splitter, 1, 1)
		    frameC = splitterFrameCreate(splitter, "Frame C - stretch 2")
		    guitk.BCSplitterSetWidgetStretchFactor(splitter, frameC, 2)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def splitterFrameCreate(splitter, text):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(bLayout, text), guitk.constants.BCAlignCenter
		    )
		    hBox = guitk.BCHBoxCreate(bLayout)
		    guitk.BCPushButtonCreate(hBox, "Move First", moveToFirst, (splitter, frame))
		    guitk.BCPushButtonCreate(hBox, "Move Last", moveToLast, (splitter, frame))
		    return frame
		
		
		def moveToFirst(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToFirst(splitter, frame)
		    return 0
		
		
		def moveToLast(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToLast(splitter, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterMoveToLast(sp: object, w: object) -> None:

	"""

	Moves to the end (bottom or right, depending on the orientation of the BCSplitter) a certain widget.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	w : object
		the widget, child of sp.

	Returns
	-------
	None

	See Also
	--------
	BCSplitterMoveToFirst

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter ResizeMode Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    splitterFrameCreate(splitter, "Frame A - stretch 0\\n(Keep Size)")
		    guitk.BCSplitterSetStretchFactor(splitter, 0, 0)
		    splitterFrameCreate(splitter, "Frame B - stretch 1")
		    guitk.BCSplitterSetStretchFactor(splitter, 1, 1)
		    frameC = splitterFrameCreate(splitter, "Frame C - stretch 2")
		    guitk.BCSplitterSetWidgetStretchFactor(splitter, frameC, 2)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def splitterFrameCreate(splitter, text):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(bLayout, text), guitk.constants.BCAlignCenter
		    )
		    hBox = guitk.BCHBoxCreate(bLayout)
		    guitk.BCPushButtonCreate(hBox, "Move First", moveToFirst, (splitter, frame))
		    guitk.BCPushButtonCreate(hBox, "Move Last", moveToLast, (splitter, frame))
		    return frame
		
		
		def moveToFirst(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToFirst(splitter, frame)
		    return 0
		
		
		def moveToLast(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToLast(splitter, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterSetHandleWidth(sp: object, width: int) -> None:

	"""

	Sets the width of the handle of the BCSplitter
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	width : int
		the new width in pixels.

	Returns
	-------
	None

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def setSplitterOrientation(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCHorizontal)
		    elif index == 1:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCVertical)
		    return 0
		
		
		def setSplitterHandleWidth(spinBox, value, splitter):
		    guitk.BCSplitterSetHandleWidth(splitter, value)
		    return 0
		
		
		def collapsibleStateChanged(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, True)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, True)
		    elif index == 1:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, False)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, False)
		    return 0
		
		
		def main():
		    global labelA
		    global labelB
		    window = guitk.BCWindowCreate("Example Splitter", guitk.constants.BCOnExitDestroy)
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    labelA = guitk.BCLabelCreate(splitter, "Frame A")
		    guitk.BCSetBackgroundColor(labelA, 255, 235, 215)
		    labelB = guitk.BCLabelCreate(splitter, "Frame B")
		    guitk.BCSetBackgroundColor(labelB, 215, 235, 255)
		
		    optionsLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    orient = guitk.BCButtonGroupCreate(
		        optionsLayout, "Orientation", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(orient, "Horizontal", None, None)
		    guitk.BCRadioButtonCreate(orient, "Vertical", None, None)
		    guitk.BCButtonGroupSetButton(orient, 0)
		    guitk.BCButtonGroupSetPressedFunction(orient, setSplitterOrientation, splitter)
		
		    bgroup = guitk.BCButtonGroupCreate(
		        optionsLayout, "Resize mode", guitk.constants.BCVertical
		    )
		    shrinkToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can shrink until hidden", None, None
		    )
		    shrinkNotToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can not shrink until hidden", None, None
		    )
		    guitk.BCRadioButtonSetChecked(shrinkToHidden, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, collapsibleStateChanged, splitter)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Handle width")
		    spin = guitk.BCSpinBoxCreate(hl)
		    guitk.BCSpinBoxSetMinValue(spin, 1)
		    guitk.BCSpinBoxSetMaxValue(spin, 25)
		    guitk.BCSpinBoxSetValue(spin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, setSplitterHandleWidth, splitter)
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterSetResizeMode(sp: object, w: object, mode: int) -> None:

	"""

	Function is obsolete. Use BCSplitterSetWidgetStretchFactor() instead, using stretch: 0 for BCKeepSize, 1 otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	w : object
		the widget, child of sp.

	mode : int
		the resize mode. See BCEnumResizeMode for details.
		
		guitk.constants BCEnumResizeMode
		This enum type describes how BCSplitter will resize each of its child widgets. Resize mode is used with BCSplitterSetResizeMode().
		 - guitk.constants.BCResizeAuto
		the widget will be resized according to the stretch factors set in its sizePolicy().
		 - guitk.constants.BCResizeStretch
		the widget will be resized when the splitter itself is resized.
		 - guitk.constants.BCResizeKeepSize
		BCSplitter will try to keep the widget's size unchanged.
		 - guitk.constants.BCResizeFollowSizeHint
		BCSplitter will resize the widget when the widget's size hint changes.

	Returns
	-------
	None

	"""

def BCSplitterSetOrientation(sp: object, o: int) -> None:

	"""

	Sets the orientation of BCSplitter vertical or horizontal with the BCVertical and BCHorizontal respectively.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter whose the orientation changes

	o : int
		the orientation, BCVertical or BCHorizontal

	Returns
	-------
	None

	Examples
	--------
	::

		# PYTHON script
		import os
		import sdm
		from sdm import guitk
		
		
		def setSplitterOrientation(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCHorizontal)
		    elif index == 1:
		        guitk.BCSplitterSetOrientation(splitter, guitk.constants.BCVertical)
		    return 0
		
		
		def setSplitterHandleWidth(spinBox, value, splitter):
		    guitk.BCSplitterSetHandleWidth(splitter, value)
		    return 0
		
		
		def collapsibleStateChanged(bg, index, splitter):
		    if index == 0:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, True)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, True)
		    elif index == 1:
		        guitk.BCSplitterSetCollapsible(splitter, labelA, False)
		        guitk.BCSplitterSetCollapsible(splitter, labelB, False)
		    return 0
		
		
		def main():
		    global labelA
		    global labelB
		    window = guitk.BCWindowCreate("Example Splitter", guitk.constants.BCOnExitDestroy)
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    labelA = guitk.BCLabelCreate(splitter, "Frame A")
		    guitk.BCSetBackgroundColor(labelA, 255, 235, 215)
		    labelB = guitk.BCLabelCreate(splitter, "Frame B")
		    guitk.BCSetBackgroundColor(labelB, 215, 235, 255)
		
		    optionsLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    orient = guitk.BCButtonGroupCreate(
		        optionsLayout, "Orientation", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(orient, "Horizontal", None, None)
		    guitk.BCRadioButtonCreate(orient, "Vertical", None, None)
		    guitk.BCButtonGroupSetButton(orient, 0)
		    guitk.BCButtonGroupSetPressedFunction(orient, setSplitterOrientation, splitter)
		
		    bgroup = guitk.BCButtonGroupCreate(
		        optionsLayout, "Resize mode", guitk.constants.BCVertical
		    )
		    shrinkToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can shrink until hidden", None, None
		    )
		    shrinkNotToHidden = guitk.BCRadioButtonCreate(
		        bgroup, "Frames can not shrink until hidden", None, None
		    )
		    guitk.BCRadioButtonSetChecked(shrinkToHidden, True)
		    guitk.BCButtonGroupSetPressedFunction(bgroup, collapsibleStateChanged, splitter)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "Handle width")
		    spin = guitk.BCSpinBoxCreate(hl)
		    guitk.BCSpinBoxSetMinValue(spin, 1)
		    guitk.BCSpinBoxSetMaxValue(spin, 25)
		    guitk.BCSpinBoxSetValue(spin, 4)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, setSplitterHandleWidth, splitter)
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStatusBarCreate(p: object) -> object:

	"""

	Creates a StatusBar with parent p.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created StatusBar.

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCStatusBar Example", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    perm = guitk.BCPushButtonCreate(hl, "Permanent", None, None)
		    timed = guitk.BCPushButtonCreate(hl, "Timed (2 seconds)", None, None)
		    clear = guitk.BCToolButtonCreate(hl, "clean_small.svg", "Clear", None, None)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    sizeGrip = guitk.BCCheckBoxCreate(vl, "Size Grip")
		    guitk.BCCheckBoxSetChecked(sizeGrip, True)
		
		    guitk.BCSpacerCreate(w)
		    statusBar = guitk.BCStatusBarCreate(w)
		
		    guitk.BCButtonSetClickedFunction(perm, setPermanentMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(timed, setTempMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(clear, clearMessage, statusBar)
		    guitk.BCCheckBoxSetToggledFunction(sizeGrip, setSizeGrip, statusBar)
		
		    guitk.BCStatusBarAddWidget(statusBar, clear, True)
		
		    guitk.BCShow(w)
		
		
		def setPermanentMessage(b, statusBar):
		    guitk.BCStatusBarMessage(statusBar, "Status Bar : Permanent Message")
		    return 0
		
		
		def setTempMessage(b, statusBar):
		    guitk.BCStatusBarTimedMessage(statusBar, "Status Bar : Timed Message 2000ms", 2000)
		    return 0
		
		
		def clearMessage(b, statusBar):
		    guitk.BCStatusBarClear(statusBar)
		    return 0
		
		
		def setSizeGrip(b, state, statusBar):
		    guitk.BCStatusBarSetSizeGripEnabled(statusBar, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStatusBarAddWidget(sb: object, w: object, permanent: bool) -> None:

	"""

	Adds widget w to StatusBar sb.
	w is permanently visible if permanent is True and may be obscured by temporary messages if permanent is False.
	Most of times it should be set to False. Also, if permanent is set to True, w is located at the far right of the status bar.
	If permanent is False (the default), widget is located just to the left of the first permanent widget.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the StatusBar.

	w : object
		the widget that will be added.

	permanent : bool
		set this parameter to True or False for setting if the widget w should be permanently visible or not, respectively.

	Returns
	-------
	None

	See Also
	--------
	BCStatusBarRemoveWidget

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCStatusBar Example", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    perm = guitk.BCPushButtonCreate(hl, "Permanent", None, None)
		    timed = guitk.BCPushButtonCreate(hl, "Timed (2 seconds)", None, None)
		    clear = guitk.BCToolButtonCreate(hl, "clean_small.svg", "Clear", None, None)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    sizeGrip = guitk.BCCheckBoxCreate(vl, "Size Grip")
		    guitk.BCCheckBoxSetChecked(sizeGrip, True)
		
		    guitk.BCSpacerCreate(w)
		    statusBar = guitk.BCStatusBarCreate(w)
		
		    guitk.BCButtonSetClickedFunction(perm, setPermanentMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(timed, setTempMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(clear, clearMessage, statusBar)
		    guitk.BCCheckBoxSetToggledFunction(sizeGrip, setSizeGrip, statusBar)
		
		    guitk.BCStatusBarAddWidget(statusBar, clear, True)
		
		    guitk.BCShow(w)
		
		
		def setPermanentMessage(b, statusBar):
		    guitk.BCStatusBarMessage(statusBar, "Status Bar : Permanent Message")
		    return 0
		
		
		def setTempMessage(b, statusBar):
		    guitk.BCStatusBarTimedMessage(statusBar, "Status Bar : Timed Message 2000ms", 2000)
		    return 0
		
		
		def clearMessage(b, statusBar):
		    guitk.BCStatusBarClear(statusBar)
		    return 0
		
		
		def setSizeGrip(b, state, statusBar):
		    guitk.BCStatusBarSetSizeGripEnabled(statusBar, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStatusBarRemoveWidget(sb: object, w: object) -> None:

	"""

	Removes widget w from StatusBar sb.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the StatusBar.

	w : object
		the widget that will be removed.

	Returns
	-------
	None

	See Also
	--------
	BCStatusBarAddWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "StatusBar Remove Widget Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCSpacerCreate(window)
		    statusBar = guitk.BCStatusBarCreate(window)
		
		    toolBtnClear = guitk.BCToolButtonCreate(
		        statusBar, "clear_small.svg", "Clear", clearMessage, statusBar
		    )
		    guitk.BCStatusBarMessage(statusBar, "Permanent message")
		    guitk.BCStatusBarAddWidget(statusBar, toolBtnClear, True)
		
		    guitk.BCShow(window)
		
		
		def clearMessage(btn, statusBar):
		    guitk.BCStatusBarClear(statusBar)
		    guitk.BCStatusBarRemoveWidget(statusBar, btn)
		    guitk.BCDestroyLater(btn)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStatusBarMessage(sb: object, message: str) -> None:

	"""

	Shows message on the status bar sb.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the StatusBar.

	message : str
		the text that will be displayed.

	Returns
	-------
	None

	See Also
	--------
	BCStatusBarTimedMessage

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCStatusBar Example", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    perm = guitk.BCPushButtonCreate(hl, "Permanent", None, None)
		    timed = guitk.BCPushButtonCreate(hl, "Timed (2 seconds)", None, None)
		    clear = guitk.BCToolButtonCreate(hl, "clean_small.svg", "Clear", None, None)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    sizeGrip = guitk.BCCheckBoxCreate(vl, "Size Grip")
		    guitk.BCCheckBoxSetChecked(sizeGrip, True)
		
		    guitk.BCSpacerCreate(w)
		    statusBar = guitk.BCStatusBarCreate(w)
		
		    guitk.BCButtonSetClickedFunction(perm, setPermanentMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(timed, setTempMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(clear, clearMessage, statusBar)
		    guitk.BCCheckBoxSetToggledFunction(sizeGrip, setSizeGrip, statusBar)
		
		    guitk.BCStatusBarAddWidget(statusBar, clear, True)
		
		    guitk.BCShow(w)
		
		
		def setPermanentMessage(b, statusBar):
		    guitk.BCStatusBarMessage(statusBar, "Status Bar : Permanent Message")
		    return 0
		
		
		def setTempMessage(b, statusBar):
		    guitk.BCStatusBarTimedMessage(statusBar, "Status Bar : Timed Message 2000ms", 2000)
		    return 0
		
		
		def clearMessage(b, statusBar):
		    guitk.BCStatusBarClear(statusBar)
		    return 0
		
		
		def setSizeGrip(b, state, statusBar):
		    guitk.BCStatusBarSetSizeGripEnabled(statusBar, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStatusBarTimedMessage(sb: object, message: str, ms: int) -> None:

	"""

	Shows message on the status bar sb for ms milliseconds. Then message is removed.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the StatusBar.

	message : str
		the text that will be displayed.

	ms : int
		the time period for which message will be displayed in milliseconds.

	Returns
	-------
	None

	See Also
	--------
	BCStatusBarMessage

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCStatusBar Example", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    perm = guitk.BCPushButtonCreate(hl, "Permanent", None, None)
		    timed = guitk.BCPushButtonCreate(hl, "Timed (2 seconds)", None, None)
		    clear = guitk.BCToolButtonCreate(hl, "clean_small.svg", "Clear", None, None)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    sizeGrip = guitk.BCCheckBoxCreate(vl, "Size Grip")
		    guitk.BCCheckBoxSetChecked(sizeGrip, True)
		
		    guitk.BCSpacerCreate(w)
		    statusBar = guitk.BCStatusBarCreate(w)
		
		    guitk.BCButtonSetClickedFunction(perm, setPermanentMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(timed, setTempMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(clear, clearMessage, statusBar)
		    guitk.BCCheckBoxSetToggledFunction(sizeGrip, setSizeGrip, statusBar)
		
		    guitk.BCStatusBarAddWidget(statusBar, clear, True)
		
		    guitk.BCShow(w)
		
		
		def setPermanentMessage(b, statusBar):
		    guitk.BCStatusBarMessage(statusBar, "Status Bar : Permanent Message")
		    return 0
		
		
		def setTempMessage(b, statusBar):
		    guitk.BCStatusBarTimedMessage(statusBar, "Status Bar : Timed Message 2000ms", 2000)
		    return 0
		
		
		def clearMessage(b, statusBar):
		    guitk.BCStatusBarClear(statusBar)
		    return 0
		
		
		def setSizeGrip(b, state, statusBar):
		    guitk.BCStatusBarSetSizeGripEnabled(statusBar, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStatusBarClear(sb: object) -> None:

	"""

	Removes any message is currently being shown.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the StatusBar.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCStatusBar Example", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    perm = guitk.BCPushButtonCreate(hl, "Permanent", None, None)
		    timed = guitk.BCPushButtonCreate(hl, "Timed (2 seconds)", None, None)
		    clear = guitk.BCToolButtonCreate(hl, "clean_small.svg", "Clear", None, None)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    sizeGrip = guitk.BCCheckBoxCreate(vl, "Size Grip")
		    guitk.BCCheckBoxSetChecked(sizeGrip, True)
		
		    guitk.BCSpacerCreate(w)
		    statusBar = guitk.BCStatusBarCreate(w)
		
		    guitk.BCButtonSetClickedFunction(perm, setPermanentMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(timed, setTempMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(clear, clearMessage, statusBar)
		    guitk.BCCheckBoxSetToggledFunction(sizeGrip, setSizeGrip, statusBar)
		
		    guitk.BCStatusBarAddWidget(statusBar, clear, True)
		
		    guitk.BCShow(w)
		
		
		def setPermanentMessage(b, statusBar):
		    guitk.BCStatusBarMessage(statusBar, "Status Bar : Permanent Message")
		    return 0
		
		
		def setTempMessage(b, statusBar):
		    guitk.BCStatusBarTimedMessage(statusBar, "Status Bar : Timed Message 2000ms", 2000)
		    return 0
		
		
		def clearMessage(b, statusBar):
		    guitk.BCStatusBarClear(statusBar)
		    return 0
		
		
		def setSizeGrip(b, state, statusBar):
		    guitk.BCStatusBarSetSizeGripEnabled(statusBar, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCStatusBarSetSizeGripEnabled(sb: object, enabled: bool) -> None:

	"""

	Sets whether size grip (arrow at bottom right that resize window) is enabled.
	This function is not supported under VR mode.

	Parameters
	----------
	sb : object
		the StatusBar.

	enabled : bool
		set False to hide the size grip or True to show it (default).

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCStatusBar Example", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    perm = guitk.BCPushButtonCreate(hl, "Permanent", None, None)
		    timed = guitk.BCPushButtonCreate(hl, "Timed (2 seconds)", None, None)
		    clear = guitk.BCToolButtonCreate(hl, "clean_small.svg", "Clear", None, None)
		
		    vl = guitk.BCBoxLayoutCreate(w, guitk.constants.BCVertical)
		    sizeGrip = guitk.BCCheckBoxCreate(vl, "Size Grip")
		    guitk.BCCheckBoxSetChecked(sizeGrip, True)
		
		    guitk.BCSpacerCreate(w)
		    statusBar = guitk.BCStatusBarCreate(w)
		
		    guitk.BCButtonSetClickedFunction(perm, setPermanentMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(timed, setTempMessage, statusBar)
		    guitk.BCButtonSetClickedFunction(clear, clearMessage, statusBar)
		    guitk.BCCheckBoxSetToggledFunction(sizeGrip, setSizeGrip, statusBar)
		
		    guitk.BCStatusBarAddWidget(statusBar, clear, True)
		
		    guitk.BCShow(w)
		
		
		def setPermanentMessage(b, statusBar):
		    guitk.BCStatusBarMessage(statusBar, "Status Bar : Permanent Message")
		    return 0
		
		
		def setTempMessage(b, statusBar):
		    guitk.BCStatusBarTimedMessage(statusBar, "Status Bar : Timed Message 2000ms", 2000)
		    return 0
		
		
		def clearMessage(b, statusBar):
		    guitk.BCStatusBarClear(statusBar)
		    return 0
		
		
		def setSizeGrip(b, state, statusBar):
		    guitk.BCStatusBarSetSizeGripEnabled(statusBar, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableCreate(p: object, numRows: int, numCols: int) -> object:

	"""

	Creates a BCTable (like spreadsheet).
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	numRows : int
		the number of rows.

	numCols : int
		the number of columns.

	Returns
	-------
	object
		the created BCTable.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetCellValueDouble(t: object, row: int, col: int, val: float) -> None:

	"""

	Inserts the double value val in BCTable t at row row and column col.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable where the value will be inserted.

	row : int
		the row.

	col : int
		the column.

	val : float
		the double value.

	Returns
	-------
	None

	See Also
	--------
	BCTableGetCellValueDouble

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableGetCellValueDouble(t: object, row: int, col: int) -> bool:

	"""

	Gets the value of the BCTable t at row row and column col.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable from which the value will be extracted.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	bool
		A tuple with two items:
		First item is value True on success False otherwise.
		Second item is the requested double value. On failure it will be 0.

	See Also
	--------
	BCTableSetCellValueDouble

	"""

def BCTableNumCols(t: object) -> int:

	"""

	Returns the number of columns in BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	Returns
	-------
	int
		the number of columns for the given BCTable.

	See Also
	--------
	BCTableNumRows

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable selection example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		    guitk.BCTableSetSelectionMode(table, guitk.constants.BCTableNoSelection)
		
		    reset = guitk.BCPushButtonCreate(w, "Reset background color", resetColorFunc, table)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    guitk.BCTableSetCellsBackgroundColor(t, row, row, col, col, 0, 255, 0)
		    return 0
		
		
		def resetColorFunc(b, table):
		    num_rows = guitk.BCTableNumRows(table)
		    num_cols = guitk.BCTableNumCols(table)
		    guitk.BCTableResetCellsBackgroundColor(table, 0, num_rows - 1, 0, num_cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableNumRows(t: object) -> int:

	"""

	Returns the number of rows in BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	Returns
	-------
	int
		the number of rows for the given BCTable.

	See Also
	--------
	BCTableNumCols

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable selection example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		    guitk.BCTableSetSelectionMode(table, guitk.constants.BCTableNoSelection)
		
		    reset = guitk.BCPushButtonCreate(w, "Reset background color", resetColorFunc, table)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    guitk.BCTableSetCellsBackgroundColor(t, row, row, col, col, 0, 255, 0)
		    return 0
		
		
		def resetColorFunc(b, table):
		    num_rows = guitk.BCTableNumRows(table)
		    num_cols = guitk.BCTableNumCols(table)
		    guitk.BCTableResetCellsBackgroundColor(table, 0, num_rows - 1, 0, num_cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetNumCols(t: object, numCols: int) -> None:

	"""

	Sets the number of columns in BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	numCols : int
		the number of columns for the given BCTable.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetNumRows

	"""

def BCTableSetNumRows(t: object, numRows: int) -> None:

	"""

	Sets the number of rows in BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	numRows : int
		the number of rows for the given BCTable.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetNumCols

	"""

def BCTableSetCellWidget(t: object, row: int, col: int, w: object) -> None:

	"""

	Sets widget w to occupy the space of cell at row row and column col.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	col : int
		the column.

	w : object
		the widget (BCComboBox, BCCheckBox, BCButton etc.).

	Returns
	-------
	None

	See Also
	--------
	BCTableGetCellWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableGetCellWidget(t: object, row: int, col: int) -> object:

	"""

	Returns the widget that was set with BCTableSetCellWidget() at row row and column col. If no widget exists None is returned.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	object
		the widget at row row and column col or None if no widget is found.

	See Also
	--------
	BCTableSetCellWidget

	"""

def BCTableClearCellWidget(t: object, row: int, col: int) -> None:

	"""

	Removes the widget (if there is one) set for the cell at row, col.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetCellWidget

	"""

def BCTableSetRowHeight(t: object, row: int, height: int) -> None:

	"""

	Sets the height of row row in BCTable t to height pixels.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	height : int
		the new height for row row.

	Returns
	-------
	None

	See Also
	--------
	BCTableRowHeight

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCTable Adjust 'More' example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, 2, 2)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableSetColumnAcceptsText(table, 1, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableSetText(table, 0, 0, "item A0\\nThree line\\ntext")
		    guitk.BCTableSetText(table, 1, 0, "item B0 loooooong item")
		    guitk.BCTableSetText(table, 0, 1, "item A1")
		    guitk.BCTableSetText(table, 1, 1, "item B1\\nTwo lines")
		    btnMyAdjust = guitk.BCPushButtonCreate(
		        window, "My Adjust Sizes", btnAdjustClicked, table
		    )
		    guitk.BCShow(window)
		
		
		def btnAdjustClicked(btn, table):
		    numRows = guitk.BCTableNumRows(table)
		    numCols = guitk.BCTableNumCols(table)
		    for r in range(numRows):
		        guitk.BCTableAdjustRow(table, r)
		        newHeight = guitk.BCTableRowHeight(table, r) + 10  # Add something more
		        guitk.BCTableSetRowHeight(table, r, newHeight)
		        print("row {} new height {}".format(r, newHeight))
		    for c in range(numCols):
		        guitk.BCTableAdjustColumn(table, c)
		        newWidth = guitk.BCTableColumnWidth(table, c) + 10  # Add something more
		        guitk.BCTableSetColumnWidth(table, r, newWidth)
		        print("Column {} new width {}".format(c, newWidth + 2))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableRowHeight(t: object, row: int) -> int:

	"""

	Returns the height of row row in BCTable t in pixels.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	Returns
	-------
	int
		the height of row row in BCTable t.

	See Also
	--------
	BCTableSetRowHeight

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCTable Adjust 'More' example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, 2, 2)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableSetColumnAcceptsText(table, 1, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableSetText(table, 0, 0, "item A0\\nThree line\\ntext")
		    guitk.BCTableSetText(table, 1, 0, "item B0 loooooong item")
		    guitk.BCTableSetText(table, 0, 1, "item A1")
		    guitk.BCTableSetText(table, 1, 1, "item B1\\nTwo lines")
		    btnMyAdjust = guitk.BCPushButtonCreate(
		        window, "My Adjust Sizes", btnAdjustClicked, table
		    )
		    guitk.BCShow(window)
		
		
		def btnAdjustClicked(btn, table):
		    numRows = guitk.BCTableNumRows(table)
		    numCols = guitk.BCTableNumCols(table)
		    for r in range(numRows):
		        guitk.BCTableAdjustRow(table, r)
		        newHeight = guitk.BCTableRowHeight(table, r) + 10  # Add something more
		        guitk.BCTableSetRowHeight(table, r, newHeight)
		        print("row {} new height {}".format(r, newHeight))
		    for c in range(numCols):
		        guitk.BCTableAdjustColumn(table, c)
		        newWidth = guitk.BCTableColumnWidth(table, c) + 10  # Add something more
		        guitk.BCTableSetColumnWidth(table, r, newWidth)
		        print("Column {} new width {}".format(c, newWidth + 2))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetColumnWidth(t: object, col: int, width: int) -> None:

	"""

	Sets the width of column col in BCTable t, to width pixels.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	width : int
		the new width for column col

	Returns
	-------
	None

	See Also
	--------
	BCTableColumnWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCTable Adjust 'More' example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, 2, 2)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableSetColumnAcceptsText(table, 1, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableSetText(table, 0, 0, "item A0\\nThree line\\ntext")
		    guitk.BCTableSetText(table, 1, 0, "item B0 loooooong item")
		    guitk.BCTableSetText(table, 0, 1, "item A1")
		    guitk.BCTableSetText(table, 1, 1, "item B1\\nTwo lines")
		    btnMyAdjust = guitk.BCPushButtonCreate(
		        window, "My Adjust Sizes", btnAdjustClicked, table
		    )
		    guitk.BCShow(window)
		
		
		def btnAdjustClicked(btn, table):
		    numRows = guitk.BCTableNumRows(table)
		    numCols = guitk.BCTableNumCols(table)
		    for r in range(numRows):
		        guitk.BCTableAdjustRow(table, r)
		        newHeight = guitk.BCTableRowHeight(table, r) + 10  # Add something more
		        guitk.BCTableSetRowHeight(table, r, newHeight)
		        print("row {} new height {}".format(r, newHeight))
		    for c in range(numCols):
		        guitk.BCTableAdjustColumn(table, c)
		        newWidth = guitk.BCTableColumnWidth(table, c) + 10  # Add something more
		        guitk.BCTableSetColumnWidth(table, r, newWidth)
		        print("Column {} new width {}".format(c, newWidth + 2))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableColumnWidth(t: object, col: int) -> int:

	"""

	Returns the width of column col in BCTable t in pixels.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	Returns
	-------
	int
		the width of column col in BCTable t.

	See Also
	--------
	BCTableSetColumnWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCTable Adjust 'More' example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, 2, 2)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableSetColumnAcceptsText(table, 1, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableSetText(table, 0, 0, "item A0\\nThree line\\ntext")
		    guitk.BCTableSetText(table, 1, 0, "item B0 loooooong item")
		    guitk.BCTableSetText(table, 0, 1, "item A1")
		    guitk.BCTableSetText(table, 1, 1, "item B1\\nTwo lines")
		    btnMyAdjust = guitk.BCPushButtonCreate(
		        window, "My Adjust Sizes", btnAdjustClicked, table
		    )
		    guitk.BCShow(window)
		
		
		def btnAdjustClicked(btn, table):
		    numRows = guitk.BCTableNumRows(table)
		    numCols = guitk.BCTableNumCols(table)
		    for r in range(numRows):
		        guitk.BCTableAdjustRow(table, r)
		        newHeight = guitk.BCTableRowHeight(table, r) + 10  # Add something more
		        guitk.BCTableSetRowHeight(table, r, newHeight)
		        print("row {} new height {}".format(r, newHeight))
		    for c in range(numCols):
		        guitk.BCTableAdjustColumn(table, c)
		        newWidth = guitk.BCTableColumnWidth(table, c) + 10  # Add something more
		        guitk.BCTableSetColumnWidth(table, r, newWidth)
		        print("Column {} new width {}".format(c, newWidth + 2))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableShowColumn(t: object, col: int, show: bool) -> None:

	"""

	Shows or hides column col, depending on the value of show.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	show : bool
		set this parameter to False to hide, or True to show the column col.

	Returns
	-------
	None

	See Also
	--------
	BCTableShowRow

	"""

def BCTableSetColumnsSorting(t: object, sort: bool, wholeRows: bool) -> None:

	"""

	Sorts a column when clicked on columns header, depending on the value of sort.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	sort : bool
		set this parameter to True and the sort indicator is shown. After a click on the header of a column sorts that column.

	wholeRows : bool
		if set this parameter to True entire rows are sorted otherwise only cells in the column are sorted.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable headers example", guitk.constants.BCOnExitDestroy)
		    table = guitk.BCTableCreate(w, 3, 2)
		
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    guitk.BCTableSetColumnReadOnly(table, 0, True)
		    guitk.BCTableSetColumnReadOnly(table, 1, True)
		    guitk.BCTableSetMaxRows(table, 3)
		
		    cb = guitk.BCCheckBoxCreate(w, "Show headers")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableShowHeadersFunc, table)
		
		    cb = guitk.BCCheckBoxCreate(w, "Headers resize")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableResizeHeadersEnableFunc, table)
		
		    guitk.BCTableSetColumnsSorting(table, True, True)
		
		    guitk.BCShow(w)
		
		
		def tableShowHeadersFunc(cb, state, table):
		    guitk.BCTableShowHeader(table, guitk.constants.BCVertical, state)
		    guitk.BCTableShowHeader(table, guitk.constants.BCHorizontal, state)
		    return 0
		
		
		def tableResizeHeadersEnableFunc(cb, state, table):
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCVertical, state
		    )
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCHorizontal, state
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableIsColumnHidden(t: object, col: int) -> bool:

	"""

	Returns True if column col is hidden, otherwise returns False.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	Returns
	-------
	bool
		True in case col is hidden; False otherwise.

	See Also
	--------
	BCTableShowColumn

	"""

def BCTableShowRow(t: object, row: int, show: bool) -> None:

	"""

	Shows or hides row row, depending on the value of show.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	show : bool
		set this parameter to False to hide, or True to show the row row.

	Returns
	-------
	None

	See Also
	--------
	BCTableShowColumn

	"""

def BCTableIsRowHidden(t: object, row: int) -> bool:

	"""

	Returns True if row row is hidden, otherwise returns False.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	Returns
	-------
	bool
		True in case row is hidden; False otherwise.

	See Also
	--------
	BCTableShowRow

	"""

def BCTableSelectRow(t: object, row: int) -> None:

	"""

	Selects row row from BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row to be selected.

	Returns
	-------
	None

	See Also
	--------
	BCTableSelectColumn

	"""

def BCTableIsRowSelected(t: object, row: int, full: bool) -> bool:

	"""

	Returns True if row row is selected, otherwise returns False.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	full : bool
		set this parameter to False if at least one cell in the row needs to be selected to consider the row selected, or True if every cell in the row need to be selected to consider the row selected.

	Returns
	-------
	bool
		True if row row is selected, otherwise returns False.

	See Also
	--------
	BCTableIsColumnSelected

	"""

def BCTableSelectColumn(t: object, col: int) -> None:

	"""

	Selects column col from BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column to be selected.

	Returns
	-------
	None

	See Also
	--------
	BCTableSelectRow

	"""

def BCTableIsColumnSelected(t: object, col: int, full: bool) -> bool:

	"""

	Returns True if column col is selected, otherwise returns False.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	full : bool
		set this parameter to False if at least one cell in the column needs to be selected to consider the column selected, or True if every cell in the column needs to be selected to consider the column selected.

	Returns
	-------
	bool
		True if column col is selected, otherwise returns False.

	See Also
	--------
	BCTableIsRowSelected

	"""

def BCTableSetRowStretchable(t: object, row: int, stretchable: bool) -> None:

	"""

	Sets whether row row should be stretchable or not, depending on the value of stretchable.
	NOTE: If stretchable is set to True, then row row will not be resizable by the user and all available space will be filled.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	stretchable : bool
		set this parameter to True for row row to be stretchable, or to False (default) otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetColumnStretchable

	"""

def BCTableSetColumnStretchable(t: object, col: int, stretchable: bool) -> None:

	"""

	Sets whether column col should be stretchable or not, depending on the value of stretchable.
	NOTE: If stretchable is set to True, then column col will not be resizable by the user and all available space will be filled.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	stretchable : bool
		set this parameter to True for column col to be stretchable, or to False (default) otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetRowStretchable

	"""

def BCTableSetRowLabels(t: object, labels: object) -> None:

	"""

	Sets the labels labels show on the left header of the table.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	labels : object
		array of strings that will be displayed on the header.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetColumnLabels

	Examples
	--------
	::

		from sdm import guitk
		
		PART_DATA = [
		    ["1001", "Bumper", "3A", "South Korea"],
		    ["1002", "Decklid", "4A", "Germany"],
		    ["1003", "Pillar", "4A", "Turkey"],
		    ["1004", "Roof rack", "3A", "South Korea"],
		]
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Table ReadOnly and Row Align Example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, len(PART_DATA), len(PART_DATA[0]))
		    rows = guitk.BCTableNumRows(table)
		    guitk.BCTableSetColumnLabels(
		        table, ["ID", "Part name", "Version", "Manufactured", "Align"]
		    )
		    guitk.BCTableSetRowLabels(table, [str(row + 1) for row in range(rows)])
		    # Set all columns to accept text
		    for col in range(guitk.BCTableNumCols(table)):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		    # Start adding data
		    for row, part in enumerate(PART_DATA):
		        for col, text in enumerate(part):
		            guitk.BCTableSetText(table, row, col, text)
		
		    guitk.BCPushButtonCreate(
		        window, "Toggle current column read-only", toggleColumnReadOnly, table
		    )
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row left",
		        alignText,
		        (table, guitk.constants.BCAlignLeft),
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row right",
		        alignText,
		        (table, guitk.constants.BCAlignRight),
		    )
		    guitk.BCShow(window)
		
		
		def toggleColumnReadOnly(btn, table):
		    col = guitk.BCTableCurrentColumn(table)
		    guitk.BCTableSetColumnReadOnly(
		        table, col, not guitk.BCTableIsColumnReadOnly(table, col)
		    )
		    return 0
		
		
		def alignText(btn, data):
		    table, horizontalAlignment = data
		    row = guitk.BCTableCurrentRow(table)
		    guitk.BCTableSetRowAlignment(
		        table, row, guitk.constants.BCAlignVCenter | horizontalAlignment
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetColumnLabels(t: object, labels: object) -> None:

	"""

	Sets the labels labels show on the top header of the table.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	labels : object
		array of strings that will be displayed on the header.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetRowLabels

	Examples
	--------
	::

		from sdm import guitk
		
		PART_DATA = [
		    ["1001", "Bumper", "3A", "South Korea"],
		    ["1002", "Decklid", "4A", "Germany"],
		    ["1003", "Pillar", "4A", "Turkey"],
		    ["1004", "Roof rack", "3A", "South Korea"],
		]
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Table ReadOnly and Row Align Example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, len(PART_DATA), len(PART_DATA[0]))
		    rows = guitk.BCTableNumRows(table)
		    guitk.BCTableSetColumnLabels(
		        table, ["ID", "Part name", "Version", "Manufactured", "Align"]
		    )
		    guitk.BCTableSetRowLabels(table, [str(row + 1) for row in range(rows)])
		    # Set all columns to accept text
		    for col in range(guitk.BCTableNumCols(table)):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		    # Start adding data
		    for row, part in enumerate(PART_DATA):
		        for col, text in enumerate(part):
		            guitk.BCTableSetText(table, row, col, text)
		
		    guitk.BCPushButtonCreate(
		        window, "Toggle current column read-only", toggleColumnReadOnly, table
		    )
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row left",
		        alignText,
		        (table, guitk.constants.BCAlignLeft),
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row right",
		        alignText,
		        (table, guitk.constants.BCAlignRight),
		    )
		    guitk.BCShow(window)
		
		
		def toggleColumnReadOnly(btn, table):
		    col = guitk.BCTableCurrentColumn(table)
		    guitk.BCTableSetColumnReadOnly(
		        table, col, not guitk.BCTableIsColumnReadOnly(table, col)
		    )
		    return 0
		
		
		def alignText(btn, data):
		    table, horizontalAlignment = data
		    row = guitk.BCTableCurrentRow(table)
		    guitk.BCTableSetRowAlignment(
		        table, row, guitk.constants.BCAlignVCenter | horizontalAlignment
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableHeaderSetLabel(t: object, o: int, section: int, text: str) -> None:

	"""

	Sets the label of a specific section of a header of BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	o : int
		specifies the header by its orientation. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	section : int
		the section of the header of which the label will be set.

	text : str
		the text that the label will be set to.

	Returns
	-------
	None

	See Also
	--------
	BCTableHeaderLabel

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableHeaderLabel(t: object, o: int, section: int) -> str:

	"""

	Returns the label displayed at section section of the header of the BCTable t specified by the orientation o.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	o : int
		specifies the header by its orientation. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	section : int
		the section of the header of which the label will be returned.

	Returns
	-------
	str
		the label displayed at section section of the header of BCTable t specified by the orientation o.

	See Also
	--------
	BCTableHeaderSetLabel

	"""

def BCTableHeaderSetClickEnabled(t: object, o: int, section: int, enabled: bool) -> None:

	"""

	Sets whether section section of header of BCTable t can be clicked or not, depending on the value enabled.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	o : int
		specifies the header by its orientation. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	section : int
		the section of the header that will be set.

	enabled : bool
		set this parameter to True to enable click on section section, or False to disable it.

	Returns
	-------
	None

	"""

def BCTableHeaderSetResizeEnabled(t: object, o: int, section: int, enabled: bool) -> None:

	"""

	Sets whether section section of the header of the BCTable t with orientation o can be resized by the user or not.
	WARNING: Do not use this function for sections that are not already created!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	o : int
		specifies the header by its orientation.
		See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	section : int
		the section of the header that will be set.

	enabled : bool
		set this parameter to True (default) to enable resizing on the section section, or False to disable it.

	Returns
	-------
	None

	See Also
	--------
	BCTableHeaderSetResizeEnabledAllSections

	"""

def BCTableHeaderSetResizeEnabledAllSections(t: object, o: int, enabled: bool) -> None:

	"""

	Sets whether the sections of the header of the BCTable t with orientation o can be resized by the user or not.
	NOTE: This function applies for the whole header, this is, all the sections that are already created and the sections that
	will be created in the future.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	o : int
		specifies the header by its orientation. See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	enabled : bool
		set this parameter to True to enable resizing on the section section, or False to disable it.

	Returns
	-------
	None

	See Also
	--------
	BCTableHeaderSetResizeEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable headers example", guitk.constants.BCOnExitDestroy)
		    table = guitk.BCTableCreate(w, 3, 2)
		
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    guitk.BCTableSetColumnReadOnly(table, 0, True)
		    guitk.BCTableSetColumnReadOnly(table, 1, True)
		    guitk.BCTableSetMaxRows(table, 3)
		
		    cb = guitk.BCCheckBoxCreate(w, "Show headers")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableShowHeadersFunc, table)
		
		    cb = guitk.BCCheckBoxCreate(w, "Headers resize")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableResizeHeadersEnableFunc, table)
		
		    guitk.BCTableSetColumnsSorting(table, True, True)
		
		    guitk.BCShow(w)
		
		
		def tableShowHeadersFunc(cb, state, table):
		    guitk.BCTableShowHeader(table, guitk.constants.BCVertical, state)
		    guitk.BCTableShowHeader(table, guitk.constants.BCHorizontal, state)
		    return 0
		
		
		def tableResizeHeadersEnableFunc(cb, state, table):
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCVertical, state
		    )
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCHorizontal, state
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableShowHeader(t: object, o: int, show: bool) -> None:

	"""

	Shows or hides either the horizontal or vertical header of BCTable t, depending on the value of show.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	o : int
		use this parameter to specify which header to show/hide by its orientation.
		See BCEnumOrientation for details.
		
		guitk.constants BCEnumOrientation
		This type is used to signify an object's orientation. Orientation is used with BCButtonGroupCreate for example.
		 - guitk.constants.BCHorizontal
		sets horizontal orientation.
		 - guitk.constants.BCVertical
		sets vertical orientation.

	show : bool
		set this parameter to True to show a header, or to False to hide it.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable headers example", guitk.constants.BCOnExitDestroy)
		    table = guitk.BCTableCreate(w, 3, 2)
		
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    guitk.BCTableSetColumnReadOnly(table, 0, True)
		    guitk.BCTableSetColumnReadOnly(table, 1, True)
		    guitk.BCTableSetMaxRows(table, 3)
		
		    cb = guitk.BCCheckBoxCreate(w, "Show headers")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableShowHeadersFunc, table)
		
		    cb = guitk.BCCheckBoxCreate(w, "Headers resize")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableResizeHeadersEnableFunc, table)
		
		    guitk.BCTableSetColumnsSorting(table, True, True)
		
		    guitk.BCShow(w)
		
		
		def tableShowHeadersFunc(cb, state, table):
		    guitk.BCTableShowHeader(table, guitk.constants.BCVertical, state)
		    guitk.BCTableShowHeader(table, guitk.constants.BCHorizontal, state)
		    return 0
		
		
		def tableResizeHeadersEnableFunc(cb, state, table):
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCVertical, state
		    )
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCHorizontal, state
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetLeftMargin(t: object, pixels: int) -> None:

	"""

	Sets the left margin to be pixels wide.
	WARNING: This function is obsolete! It works only for pixels set to zero, which hides the
	vertical header on the left of the table. Use BCTableShowHeader() function.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	pixels : int
		the new width in pixels.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetTopMargin

	"""

def BCTableSetTopMargin(t: object, pixels: int) -> None:

	"""

	Sets the top margin to be pixels high.
	WARNING: This function is obsolete! It works only for pixels set to zero, which hides the
	horizontal header on the top of the table. Use BCTableShowHeader() function.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	pixels : int
		the new height in pixels.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetLeftMargin

	"""

def BCTableSetMouseClickedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when mouse button clicked inside table t (will not run if click on empty area).
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called on mouse button click.
		See BC_TABLE_MOUSE_CLICKED_FUNCTION for details.
		integer BC_TABLE_MOUSE_CLICKED_FUNCTION(t, mb, row, col, data)
		The function to be called when the mouse button is clicked inside table cell.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * mb : int
		                    the mouse button clicked (left is 1, right is 2 and middle is 4).
		          * row : int
		                    the row of the table clicked.
		          * col : int
		                    the column of the table clicked.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCTableEnableRightPressMenu

	"""

def BCTableSetMousePressedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when mouse button pressed inside table t (operates on empty area as well).
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called on mouse button press.
		See BC_TABLE_MOUSE_PRESSED_FUNCTION for details.
		integer BC_TABLE_MOUSE_PRESSED_FUNCTION(t, mb, row, col, data)
		The function to be called when the mouse button pressed inside table (operates on empty area as well).
		If you press on empty area below last row you will receive -1 (the same for column).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * mb : int
		                    the mouse button pressed (left is 1, right is 2 and middle is 4).
		          * row : int
		                    the row of the table pressed.
		          * col : int
		                    the column of the table pressed.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetMouseClickedFunction

	"""

def BCTableSetHeaderMousePressedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the horizontal header of the table mouse pressed.
	The default table behavior (row or col selection) on left click on header will operate as well.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable to affect.

	funct : Callable
		the function that will be called on mouse button press on header.
		See BC_TABLE_HEADER_MOUSE_PRESSED_FUNCTION for details.
		integer BC_TABLE_HEADER_MOUSE_PRESSED_FUNCTION(t, mb, columnIndex, data)
		The function to be called when the left mouse button is clicked on the header of the column with index columnIndex.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * mb : int
		                    the mouse button pressed (left is 1, right is 2 and middle is 4).
		          * columnIndex : int
		                    the index of the column clicked.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCTableEnableRightPressMenu

	"""

def BCTableSetSelectionMode(t: object, mode: int) -> None:

	"""

	Sets the current selection mode to mode.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	mode : int
		the selection mode. See BCEnumTableSelectionMode 
		for details.
		
		guitk.constants BCEnumTableSelectionMode
		This enum type defines the selection mode of the cells of a BCTable. Selecton is used
		at BCTableSetSelectionMode().
		 - guitk.constants.BCTableNoSelection
		no cell can be selected by the user.
		 - guitk.constants.BCTableMulti
		When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. If the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item. Multiple items can be selected by dragging the mouse over them
		 - guitk.constants.BCTableSingle
		the user may only select a single range of cells.
		 - guitk.constants.BCTableContiguous
		When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item.
		 - guitk.constants.BCTableSingleRow
		The user may select one row at once.
		 - guitk.constants.BCTableMultiRow
		The user may select multiple rows.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable selection example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		    guitk.BCTableSetSelectionMode(table, guitk.constants.BCTableNoSelection)
		
		    reset = guitk.BCPushButtonCreate(w, "Reset background color", resetColorFunc, table)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    guitk.BCTableSetCellsBackgroundColor(t, row, row, col, col, 0, 255, 0)
		    return 0
		
		
		def resetColorFunc(b, table):
		    num_rows = guitk.BCTableNumRows(table)
		    num_cols = guitk.BCTableNumCols(table)
		    guitk.BCTableResetCellsBackgroundColor(table, 0, num_rows - 1, 0, num_cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetColumnReadOnly(t: object, col: int, readOnly: bool) -> None:

	"""

	Sets whether column col is read only or not.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	readOnly : bool
		set this parameter to True to set column col as read only, or False to set it editable.

	Returns
	-------
	None

	See Also
	--------
	BCTableIsColumnReadOnly

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable headers example", guitk.constants.BCOnExitDestroy)
		    table = guitk.BCTableCreate(w, 3, 2)
		
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    guitk.BCTableSetColumnReadOnly(table, 0, True)
		    guitk.BCTableSetColumnReadOnly(table, 1, True)
		    guitk.BCTableSetMaxRows(table, 3)
		
		    cb = guitk.BCCheckBoxCreate(w, "Show headers")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableShowHeadersFunc, table)
		
		    cb = guitk.BCCheckBoxCreate(w, "Headers resize")
		    guitk.BCCheckBoxSetChecked(cb, True)
		    guitk.BCCheckBoxSetToggledFunction(cb, tableResizeHeadersEnableFunc, table)
		
		    guitk.BCTableSetColumnsSorting(table, True, True)
		
		    guitk.BCShow(w)
		
		
		def tableShowHeadersFunc(cb, state, table):
		    guitk.BCTableShowHeader(table, guitk.constants.BCVertical, state)
		    guitk.BCTableShowHeader(table, guitk.constants.BCHorizontal, state)
		    return 0
		
		
		def tableResizeHeadersEnableFunc(cb, state, table):
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCVertical, state
		    )
		    guitk.BCTableHeaderSetResizeEnabledAllSections(
		        table, guitk.constants.BCHorizontal, state
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableIsColumnReadOnly(t: object, col: int) -> bool:

	"""

	Returns True if column col is read only, otherwise returns False.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	Returns
	-------
	bool
		True if col is read-only; False otherwise.

	See Also
	--------
	BCTableSetColumnReadOnly

	Examples
	--------
	::

		from sdm import guitk
		
		PART_DATA = [
		    ["1001", "Bumper", "3A", "South Korea"],
		    ["1002", "Decklid", "4A", "Germany"],
		    ["1003", "Pillar", "4A", "Turkey"],
		    ["1004", "Roof rack", "3A", "South Korea"],
		]
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Table ReadOnly and Row Align Example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, len(PART_DATA), len(PART_DATA[0]))
		    rows = guitk.BCTableNumRows(table)
		    guitk.BCTableSetColumnLabels(
		        table, ["ID", "Part name", "Version", "Manufactured", "Align"]
		    )
		    guitk.BCTableSetRowLabels(table, [str(row + 1) for row in range(rows)])
		    # Set all columns to accept text
		    for col in range(guitk.BCTableNumCols(table)):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		    # Start adding data
		    for row, part in enumerate(PART_DATA):
		        for col, text in enumerate(part):
		            guitk.BCTableSetText(table, row, col, text)
		
		    guitk.BCPushButtonCreate(
		        window, "Toggle current column read-only", toggleColumnReadOnly, table
		    )
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row left",
		        alignText,
		        (table, guitk.constants.BCAlignLeft),
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row right",
		        alignText,
		        (table, guitk.constants.BCAlignRight),
		    )
		    guitk.BCShow(window)
		
		
		def toggleColumnReadOnly(btn, table):
		    col = guitk.BCTableCurrentColumn(table)
		    guitk.BCTableSetColumnReadOnly(
		        table, col, not guitk.BCTableIsColumnReadOnly(table, col)
		    )
		    return 0
		
		
		def alignText(btn, data):
		    table, horizontalAlignment = data
		    row = guitk.BCTableCurrentRow(table)
		    guitk.BCTableSetRowAlignment(
		        table, row, guitk.constants.BCAlignVCenter | horizontalAlignment
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetRowReadOnly(t: object, row: int, readOnly: bool) -> None:

	"""

	Sets whether row row is read only or not.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	readOnly : bool
		set this parameter to True to set row row as read only, or False to set it editable.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetColumnReadOnly

	"""

def BCTableRowReadOnly(t: object, row: int) -> bool:

	"""

	Returns True if row row is read only, otherwise returns False.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	Returns
	-------
	bool
		True if row is read-only; False otherwise.

	See Also
	--------
	BCTableSetColumnReadOnly

	"""

def BCTableInsertColumns(t: object, col: int, count: int) -> None:

	"""

	Inserts count empty columns at column col. Also clears the selection(s).
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column where the new columns will be added.

	count : int
		the number of new columns that will be added.

	Returns
	-------
	None

	See Also
	--------
	BCTableInsertRows

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable manipulation example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetReadOnly(table, True)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button1 = guitk.BCPushButtonCreate(blayout, "Insert row", insertRowFunc, table)
		    button2 = guitk.BCPushButtonCreate(blayout, "Insert column", insertColFunc, table)
		    button3 = guitk.BCPushButtonCreate(blayout, "Remove row", removeRowFunc, table)
		    button4 = guitk.BCPushButtonCreate(blayout, "Remove column", removeColFunc, table)
		
		    guitk.BCShow(w)
		
		
		def insertRowFunc(b, table):
		    guitk.BCTableInsertRows(table, 0, 1)
		    return 0
		
		
		def insertColFunc(b, table):
		    guitk.BCTableInsertColumns(table, 0, 1)
		    return 0
		
		
		def removeRowFunc(b, table):
		    rows = guitk.BCTableNumRows(table)
		    if rows > 1:
		        guitk.BCTableRemoveRow(table, rows - 1)
		    return 0
		
		
		def removeColFunc(b, table):
		    cols = guitk.BCTableNumCols(table)
		    if cols > 1:
		        guitk.BCTableRemoveColumn(table, cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableInsertRows(t: object, row: int, count: int) -> None:

	"""

	Inserts count empty rows at row index row. Also clears the selection(s).
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row index where the new rows will be added.

	count : int
		the number of new rows that will be added.

	Returns
	-------
	None

	See Also
	--------
	BCTableInsertColumns

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable manipulation example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetReadOnly(table, True)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button1 = guitk.BCPushButtonCreate(blayout, "Insert row", insertRowFunc, table)
		    button2 = guitk.BCPushButtonCreate(blayout, "Insert column", insertColFunc, table)
		    button3 = guitk.BCPushButtonCreate(blayout, "Remove row", removeRowFunc, table)
		    button4 = guitk.BCPushButtonCreate(blayout, "Remove column", removeColFunc, table)
		
		    guitk.BCShow(w)
		
		
		def insertRowFunc(b, table):
		    guitk.BCTableInsertRows(table, 0, 1)
		    return 0
		
		
		def insertColFunc(b, table):
		    guitk.BCTableInsertColumns(table, 0, 1)
		    return 0
		
		
		def removeRowFunc(b, table):
		    rows = guitk.BCTableNumRows(table)
		    if rows > 1:
		        guitk.BCTableRemoveRow(table, rows - 1)
		    return 0
		
		
		def removeColFunc(b, table):
		    cols = guitk.BCTableNumCols(table)
		    if cols > 1:
		        guitk.BCTableRemoveColumn(table, cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableRemoveRow(t: object, row: int) -> None:

	"""

	Removes the row row from table t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the section number of the row that will be removed.

	Returns
	-------
	None

	See Also
	--------
	BCTableRemoveColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable manipulation example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetReadOnly(table, True)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button1 = guitk.BCPushButtonCreate(blayout, "Insert row", insertRowFunc, table)
		    button2 = guitk.BCPushButtonCreate(blayout, "Insert column", insertColFunc, table)
		    button3 = guitk.BCPushButtonCreate(blayout, "Remove row", removeRowFunc, table)
		    button4 = guitk.BCPushButtonCreate(blayout, "Remove column", removeColFunc, table)
		
		    guitk.BCShow(w)
		
		
		def insertRowFunc(b, table):
		    guitk.BCTableInsertRows(table, 0, 1)
		    return 0
		
		
		def insertColFunc(b, table):
		    guitk.BCTableInsertColumns(table, 0, 1)
		    return 0
		
		
		def removeRowFunc(b, table):
		    rows = guitk.BCTableNumRows(table)
		    if rows > 1:
		        guitk.BCTableRemoveRow(table, rows - 1)
		    return 0
		
		
		def removeColFunc(b, table):
		    cols = guitk.BCTableNumCols(table)
		    if cols > 1:
		        guitk.BCTableRemoveColumn(table, cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableRemoveColumn(t: object, col: int) -> None:

	"""

	Removes column col from table t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the section number of the column that will be removed.

	Returns
	-------
	None

	See Also
	--------
	BCTableRemoveRow

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable manipulation example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetReadOnly(table, True)
		
		    blayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    button1 = guitk.BCPushButtonCreate(blayout, "Insert row", insertRowFunc, table)
		    button2 = guitk.BCPushButtonCreate(blayout, "Insert column", insertColFunc, table)
		    button3 = guitk.BCPushButtonCreate(blayout, "Remove row", removeRowFunc, table)
		    button4 = guitk.BCPushButtonCreate(blayout, "Remove column", removeColFunc, table)
		
		    guitk.BCShow(w)
		
		
		def insertRowFunc(b, table):
		    guitk.BCTableInsertRows(table, 0, 1)
		    return 0
		
		
		def insertColFunc(b, table):
		    guitk.BCTableInsertColumns(table, 0, 1)
		    return 0
		
		
		def removeRowFunc(b, table):
		    rows = guitk.BCTableNumRows(table)
		    if rows > 1:
		        guitk.BCTableRemoveRow(table, rows - 1)
		    return 0
		
		
		def removeColFunc(b, table):
		    cols = guitk.BCTableNumCols(table)
		    if cols > 1:
		        guitk.BCTableRemoveColumn(table, cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableAdjustColumn(t: object, col: int) -> None:

	"""

	Resizes column col so that the column width is wide enough to display the widest visible item in the column.
	NOTE: Like when double-clicking a header handler in a BCTable, the width of the column will become wide enough to
	fully display all visible items but not all items col contains!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the number of the column that will be adjusted.

	Returns
	-------
	None

	See Also
	--------
	BCTableAdjustRow

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCTable Adjust 'More' example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, 2, 2)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableSetColumnAcceptsText(table, 1, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableSetText(table, 0, 0, "item A0\\nThree line\\ntext")
		    guitk.BCTableSetText(table, 1, 0, "item B0 loooooong item")
		    guitk.BCTableSetText(table, 0, 1, "item A1")
		    guitk.BCTableSetText(table, 1, 1, "item B1\\nTwo lines")
		    btnMyAdjust = guitk.BCPushButtonCreate(
		        window, "My Adjust Sizes", btnAdjustClicked, table
		    )
		    guitk.BCShow(window)
		
		
		def btnAdjustClicked(btn, table):
		    numRows = guitk.BCTableNumRows(table)
		    numCols = guitk.BCTableNumCols(table)
		    for r in range(numRows):
		        guitk.BCTableAdjustRow(table, r)
		        newHeight = guitk.BCTableRowHeight(table, r) + 10  # Add something more
		        guitk.BCTableSetRowHeight(table, r, newHeight)
		        print("row {} new height {}".format(r, newHeight))
		    for c in range(numCols):
		        guitk.BCTableAdjustColumn(table, c)
		        newWidth = guitk.BCTableColumnWidth(table, c) + 10  # Add something more
		        guitk.BCTableSetColumnWidth(table, r, newWidth)
		        print("Column {} new width {}".format(c, newWidth + 2))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableAdjustRow(t: object, row: int) -> None:

	"""

	Resizes row row so that the row height is tall enough to display the tallest item the row contains.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the number of the row that will be adjusted.

	Returns
	-------
	None

	See Also
	--------
	BCTableAdjustColumn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCTable Adjust 'More' example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, 2, 2)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableSetColumnAcceptsText(table, 1, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableSetText(table, 0, 0, "item A0\\nThree line\\ntext")
		    guitk.BCTableSetText(table, 1, 0, "item B0 loooooong item")
		    guitk.BCTableSetText(table, 0, 1, "item A1")
		    guitk.BCTableSetText(table, 1, 1, "item B1\\nTwo lines")
		    btnMyAdjust = guitk.BCPushButtonCreate(
		        window, "My Adjust Sizes", btnAdjustClicked, table
		    )
		    guitk.BCShow(window)
		
		
		def btnAdjustClicked(btn, table):
		    numRows = guitk.BCTableNumRows(table)
		    numCols = guitk.BCTableNumCols(table)
		    for r in range(numRows):
		        guitk.BCTableAdjustRow(table, r)
		        newHeight = guitk.BCTableRowHeight(table, r) + 10  # Add something more
		        guitk.BCTableSetRowHeight(table, r, newHeight)
		        print("row {} new height {}".format(r, newHeight))
		    for c in range(numCols):
		        guitk.BCTableAdjustColumn(table, c)
		        newWidth = guitk.BCTableColumnWidth(table, c) + 10  # Add something more
		        guitk.BCTableSetColumnWidth(table, r, newWidth)
		        print("Column {} new width {}".format(c, newWidth + 2))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableBlockAutoAdjustColumns(t: object, block: bool) -> None:

	"""

	Blocks/unblocks the auto-adjust of the columns of BCTable t after altering the text of a cell.
	This function is very useful in case you want to alter the text of many cells in a loop without losing in performance.
	
	WARNING: The auto-adjustment applies only when the text changes programmatically.
	NOTE: Keep in mind that after unblocking the auto-adjust feature, you are responsible to re-adjust the columns
	affected, either by calling BCTableAdjustColumn or by moving/double-clicking the corresponding header handler.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	block : bool
		set this to 1 to block auto-adjust columns feature; 0 otherwise. By default, this value is 0.

	Returns
	-------
	None

	See Also
	--------
	BCTableAdjustColumn

	"""

def BCTableIsBlockedAutoAdjustColumns(t: object) -> bool:

	"""

	Returns whether auto-adjust of the columns of BCTable t is blocked.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	Returns
	-------
	bool
		1 if auto-adjust of the columns of BCTable t is blocked; 0 otherwise.

	See Also
	--------
	BCTableBlockAutoAdjustColumns

	"""

def BCTableSetText(t: object, row: int, col: int, text: str) -> None:

	"""

	Sets the text in the cell at row row and column col to text.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	col : int
		the column.

	text : str
		the text that the cell will display.

	Returns
	-------
	None

	See Also
	--------
	BCTableText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableText(t: object, row: int, col: int) -> str:

	"""

	Returns the text at row row and column col, or None if row/col does not exist.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	str
		the text at row row and column col, or None if row/col does not exist.

	See Also
	--------
	BCTableSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableHeaderSetIndexChangedFunction() -> None:

	"""

	Sets the function that will be called when the index of a header section changes.
	
	NOTE: Currently the moving/swaping of rows and columns is not available. Using this function has no effect.
	This function is not supported under VR mode.

	Returns
	-------
	None

	"""

def BCTableCurrentColumn(t: object) -> int:

	"""

	Returns the index number of the current column of BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	Returns
	-------
	int
		the index number of the current column.

	See Also
	--------
	BCTableCurrentRow

	Examples
	--------
	::

		from sdm import guitk
		
		PART_DATA = [
		    ["1001", "Bumper", "3A", "South Korea"],
		    ["1002", "Decklid", "4A", "Germany"],
		    ["1003", "Pillar", "4A", "Turkey"],
		    ["1004", "Roof rack", "3A", "South Korea"],
		]
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Table ReadOnly and Row Align Example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, len(PART_DATA), len(PART_DATA[0]))
		    rows = guitk.BCTableNumRows(table)
		    guitk.BCTableSetColumnLabels(
		        table, ["ID", "Part name", "Version", "Manufactured", "Align"]
		    )
		    guitk.BCTableSetRowLabels(table, [str(row + 1) for row in range(rows)])
		    # Set all columns to accept text
		    for col in range(guitk.BCTableNumCols(table)):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		    # Start adding data
		    for row, part in enumerate(PART_DATA):
		        for col, text in enumerate(part):
		            guitk.BCTableSetText(table, row, col, text)
		
		    guitk.BCPushButtonCreate(
		        window, "Toggle current column read-only", toggleColumnReadOnly, table
		    )
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row left",
		        alignText,
		        (table, guitk.constants.BCAlignLeft),
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row right",
		        alignText,
		        (table, guitk.constants.BCAlignRight),
		    )
		    guitk.BCShow(window)
		
		
		def toggleColumnReadOnly(btn, table):
		    col = guitk.BCTableCurrentColumn(table)
		    guitk.BCTableSetColumnReadOnly(
		        table, col, not guitk.BCTableIsColumnReadOnly(table, col)
		    )
		    return 0
		
		
		def alignText(btn, data):
		    table, horizontalAlignment = data
		    row = guitk.BCTableCurrentRow(table)
		    guitk.BCTableSetRowAlignment(
		        table, row, guitk.constants.BCAlignVCenter | horizontalAlignment
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableCurrentRow(t: object) -> int:

	"""

	Returns the index number of the current row of BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	Returns
	-------
	int
		the index number of the current row.

	See Also
	--------
	BCTableCurrentColumn

	Examples
	--------
	::

		from sdm import guitk
		
		PART_DATA = [
		    ["1001", "Bumper", "3A", "South Korea"],
		    ["1002", "Decklid", "4A", "Germany"],
		    ["1003", "Pillar", "4A", "Turkey"],
		    ["1004", "Roof rack", "3A", "South Korea"],
		]
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Table ReadOnly and Row Align Example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, len(PART_DATA), len(PART_DATA[0]))
		    rows = guitk.BCTableNumRows(table)
		    guitk.BCTableSetColumnLabels(
		        table, ["ID", "Part name", "Version", "Manufactured", "Align"]
		    )
		    guitk.BCTableSetRowLabels(table, [str(row + 1) for row in range(rows)])
		    # Set all columns to accept text
		    for col in range(guitk.BCTableNumCols(table)):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		    # Start adding data
		    for row, part in enumerate(PART_DATA):
		        for col, text in enumerate(part):
		            guitk.BCTableSetText(table, row, col, text)
		
		    guitk.BCPushButtonCreate(
		        window, "Toggle current column read-only", toggleColumnReadOnly, table
		    )
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row left",
		        alignText,
		        (table, guitk.constants.BCAlignLeft),
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row right",
		        alignText,
		        (table, guitk.constants.BCAlignRight),
		    )
		    guitk.BCShow(window)
		
		
		def toggleColumnReadOnly(btn, table):
		    col = guitk.BCTableCurrentColumn(table)
		    guitk.BCTableSetColumnReadOnly(
		        table, col, not guitk.BCTableIsColumnReadOnly(table, col)
		    )
		    return 0
		
		
		def alignText(btn, data):
		    table, horizontalAlignment = data
		    row = guitk.BCTableCurrentRow(table)
		    guitk.BCTableSetRowAlignment(
		        table, row, guitk.constants.BCAlignVCenter | horizontalAlignment
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetBeginEditFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Set a function to be called when editing of a cell starts.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called. See BC_TABLE_BEGIN_EDIT_FUNCTION for details.
		integer BC_TABLE_BEGIN_EDIT_FUNCTION(t, row, col, replace, data)
		The function to be called when in-place editing of the cell at row row and column col starts.
		Note that each cell has an editor (something like a lineEdit) which is used as a medium for editing the cell.
		If replace is 1 editor initializes empty (for example when you are moving with arrow keys in a table and edit an already full cell). If replace is 0 this means that the editor will be initialized with the cell's content, if any (for example if you mouse doubleClick an already full cell). Editor's contents will be copied to the cell if for example you press Enter (or mouse click outside table), and will not be copied if you cancel by pressing Esc.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * row : int
		                    the row of the cell.
		          * col : int
		                    the column of the cell.
		          * replace : int
		                    if 1 the editor will start empty; otherwise it will be initialized with the cell's content (if any).
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetEndEditFunction

	"""

def BCTableSetEndEditFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when editing of a cell ends.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called. See BC_TABLE_END_EDIT_FUNCTION for details.
		integer BC_TABLE_END_EDIT_FUNCTION(t, row, col, accept, replace, data)
		This function will be called when in-place editing of the cell at row row and column col ends.
		Note that each cell has an editor (something like a lineEdit) which is used as a medium for editing the cell.
		If accept is 1 the editor's text considered valid and will be copied to the current cell. If the user cancels the editor accept is 0 and the contents of the cell are left unchanged. If replace is 1 this editor initializes empty (for example when you are moving with arrow keys in a table and edit an already full cell). If replace is 0 this means that the editor will be initialized with the cell's content, if any (for example if you mouse doubleClick an already full cell). 
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * row : int
		                    the row of the cell.
		          * col : int
		                    the column of the cell.
		          * accept : int
		                    1 if the entered text has considered valid and will be copied to the cell, or 0 otherwise.
		          * replace : int
		                    if 1 the editor will start empty; otherwise it will be initialized with the cell's content (if any).
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetBeginEditFunction

	"""

def BCTableSetNumberOfRowsChangedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Set a function to be called when the number of rows has been changed.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called. See BC_TABLE_NUMBER_OF_ROWS_CHANGED_FUNCTION for details.
		integer BC_TABLE_NUMBER_OF_ROWS_CHANGED_FUNCTION(t, data)
		The function to be called when the number of BCTable's rows has been changed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetNumberOfColumnsChangedFunction

	"""

def BCTableSetNumberOfColumnsChangedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Set a function to be called when the number of columns has been changed.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called. See BC_TABLE_NUMBER_OF_COLUMNS_CHANGED_FUNCTION for details.
		integer BC_TABLE_NUMBER_OF_COLUMNS_CHANGED_FUNCTION(t, data)
		The function to be called when the number of BCTable's columns has been changed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetNumberOfRowsChangedFunction

	"""

def BCTableSetCurrentCellChangedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function to run when the current cell of t has changed.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called when cell has changed. See BC_TABLE_CURRENT_CELL_CHANGED_FUNCTION for details.
		integer BC_TABLE_CURRENT_CELL_CHANGED_FUNCTION(t, row, col, data)
		The function to be called when the current cell has changed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * row : int
		                    the new current row.
		          * col : int
		                    the new current column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetRowInsertEnabled(t: object, enable: bool) -> None:

	"""

	Set if the user will be able to insert new rows using keyboard events.
	The default table enables the user to insert new rows.
	New rows in BCTables can be inserted by pressing Tab when current focused cell is the bottom right most cell, or by pressing Return when the current focused is on the last (bottom) row of the table.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	enable : bool
		set False to disable inserting new rows, otherwise set True.

	Returns
	-------
	None

	"""

def BCTableSetMaxRows(t: object, maxRows: int) -> None:

	"""

	Sets the maximun number of rows allowed to be inserted in BCTable t.
	Rows can be inserted when pressing Enter and current cell is at last row.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	maxRows : int
		the maximun number of rows for the given BCTable.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetMaxCols

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetMaxCols(t: object, maxCols: int) -> None:

	"""

	Sets the maximun number of columns allowed to be inserted in BCTable t.
	One way to insert columns is via column menu (add item enabled).
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	maxCols : int
		the maximun number of columns for the given BCTable.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetMaxRows

	"""

def BCTableSetReadOnly(t: object, readOnly: bool) -> None:

	"""

	Sets whether the BCTable t is to be read-only to readOnly.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	readOnly : bool
		True to set BCTable t to be read-only, otherwise False to set BCTable t to be editable.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetColumnReadOnly

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetValueChangedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the user changes the value in a cell.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called on value changed event.
		See BC_TABLE_VALUE_CHANGED_FUNCTION for details.
		integer BC_TABLE_VALUE_CHANGED_FUNCTION(t, row, col, data)
		The function to be called when the user changes the value in the cell.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * row : int
		                    the row of the cell in which the user changed the value.
		          * col : int
		                    the column of the cell in which the user changed the value.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		a pointer to any data required by funct.

	Returns
	-------
	None

	"""

def BCTableSetColumnAcceptsText(t: object, col: int, val: bool) -> None:

	"""

	Sets the ability to enter non numeric text in the tables' fields.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	col : int
		the column.

	val : bool
		set this parameter to True to enable text entry, or False to disable text entry.

	Returns
	-------
	None

	See Also
	--------
	BCTableColumnAcceptsText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableColumnAcceptsText(t: object, col: int) -> bool:

	"""

	Returns True if text entry is enabled for the field of BCTable t, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	col : int
		the column index

	Returns
	-------
	bool
		True if text entry is enabled, False if text entry is disabled.

	See Also
	--------
	BCTableSetColumnAcceptsText

	"""

def BCTableGetPopupMenu(t: object) -> object:

	"""

	Returns the popup menu created.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	Returns
	-------
	object
		the default popup menu created.

	"""

def BCTableSetColumnMenuActivatedFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when the column popup menu is activated, i.e. an item is selected.
	The function will be called right after the change of visibility status of the column.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	funct : Callable
		the function that will be called. See
		BC_TABLE_COLUMN_MENU_ACTIVATED_FUNCTION for details.
		integer BC_TABLE_COLUMN_MENU_ACTIVATED_FUNCTION(t, column, data)
		The function to be called when the user activates the column popup menu of the table.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable.
		          * column : int
		                    the column which will show/hide on activation of popup menu.
		          * data : Any
		                    anything that may be required in this function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		a pointer to any data required by funct.

	Returns
	-------
	None

	"""

def BCTableSetColumnAlignment(t: object, col: int, alignment: int) -> None:

	"""

	Sets the cells alignment of the column col to alignment.
	NOTE: Column alignment has higher priority than row's one. This means that if, for a cell, has been set
	row and column alignment, then its column alignment will be used, independetly of which one has been set most recently!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	col : int
		the column.

	alignment : int
		the alignment that will be set. It is an integer value that is composed of
		BCEnumAlignment OR'ed together. See BCEnumAlignment for details. For convenience, if
		alignment doesn't contains any vertical-type value (i.e. BCAlignTop or BCAlignBottom), alignment gets OR'ed with BCAlignVCenter.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetRowAlignment

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCTable example", guitk.constants.BCOnExitDestroy)
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetColumnAcceptsText(table, 0, True)
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 0, "Column 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 1, "Column 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCHorizontal, 2, "Column 3")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 0, "Row 1")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 1, "Row 2")
		    guitk.BCTableHeaderSetLabel(table, guitk.constants.BCVertical, 2, "Row 3")
		
		    guitk.BCTableSetText(table, 0, 0, "item A")
		    guitk.BCTableSetText(table, 1, 0, "item B")
		    guitk.BCTableSetText(table, 2, 0, "item C")
		    guitk.BCTableSetCellValueDouble(table, 0, 1, 1.11)
		    guitk.BCTableSetCellValueDouble(table, 1, 1, 2.22)
		    guitk.BCTableSetCellValueDouble(table, 2, 1, 3.33)
		
		    cb1 = guitk.BCCheckBoxCreate(table, "")
		    cb2 = guitk.BCCheckBoxCreate(table, "")
		    cb3 = guitk.BCCheckBoxCreate(table, "")
		    guitk.BCTableSetCellWidget(table, 0, 2, cb1)
		    guitk.BCTableSetCellWidget(table, 1, 2, cb2)
		    guitk.BCTableSetCellWidget(table, 2, 2, cb3)
		
		    guitk.BCTableSetColumnAlignment(table, 0, guitk.constants.BCAlignRight)
		    guitk.BCTableSetReadOnly(table, True)
		    guitk.BCTableSetMaxRows(table, 6)
		
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    print("Current cell: ", row, ",", col)
		    text = guitk.BCTableText(t, row, col)
		    print("Content: ", text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetRowAlignment(t: object, row: int, alignment: int) -> None:

	"""

	Sets the cells alignment of the row row to alignment.
	NOTE: Column alignment has higher priority than row's one. This means that if, for a cell, has been set
	row and column alignment, then its column alignment will be used, independetly of which one has been set most recently!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	alignment : int
		the alignment that will be set. It is an integer value that is composed of
		BCEnumAlignment OR'ed together. See BCEnumAlignment for details. For convenience, if
		alignment doesn't contains any vertical-type value (i.e. BCAlignTop or BCAlignBottom), alignment gets OR'ed with BCAlignVCenter.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetColumnAlignment

	Examples
	--------
	::

		from sdm import guitk
		
		PART_DATA = [
		    ["1001", "Bumper", "3A", "South Korea"],
		    ["1002", "Decklid", "4A", "Germany"],
		    ["1003", "Pillar", "4A", "Turkey"],
		    ["1004", "Roof rack", "3A", "South Korea"],
		]
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Table ReadOnly and Row Align Example", guitk.constants.BCOnExitDestroy
		    )
		    table = guitk.BCTableCreate(window, len(PART_DATA), len(PART_DATA[0]))
		    rows = guitk.BCTableNumRows(table)
		    guitk.BCTableSetColumnLabels(
		        table, ["ID", "Part name", "Version", "Manufactured", "Align"]
		    )
		    guitk.BCTableSetRowLabels(table, [str(row + 1) for row in range(rows)])
		    # Set all columns to accept text
		    for col in range(guitk.BCTableNumCols(table)):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		    # Start adding data
		    for row, part in enumerate(PART_DATA):
		        for col, text in enumerate(part):
		            guitk.BCTableSetText(table, row, col, text)
		
		    guitk.BCPushButtonCreate(
		        window, "Toggle current column read-only", toggleColumnReadOnly, table
		    )
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row left",
		        alignText,
		        (table, guitk.constants.BCAlignLeft),
		    )
		    guitk.BCPushButtonCreate(
		        hBoxFooter,
		        "Align current row right",
		        alignText,
		        (table, guitk.constants.BCAlignRight),
		    )
		    guitk.BCShow(window)
		
		
		def toggleColumnReadOnly(btn, table):
		    col = guitk.BCTableCurrentColumn(table)
		    guitk.BCTableSetColumnReadOnly(
		        table, col, not guitk.BCTableIsColumnReadOnly(table, col)
		    )
		    return 0
		
		
		def alignText(btn, data):
		    table, horizontalAlignment = data
		    row = guitk.BCTableCurrentRow(table)
		    guitk.BCTableSetRowAlignment(
		        table, row, guitk.constants.BCAlignVCenter | horizontalAlignment
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetCreate(p: object) -> object:

	"""

	Creates a BCTabWidget.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created BCTabWidget.

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetAddTab(tw: object, w: object, label: str) -> None:

	"""

	Adds a tab with the given widget w as a page and label label to the BCTabWidget tw.
	Newly added tab becomes the current tab.
	If you add tab after show, you may cause flicker.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the widget to append as a page to the added tab.

	label : str
		the title of the new tab.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetRemoveTab

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetInsertTab(tw: object, w: object, label: str, index: int) -> None:

	"""

	Inserts a tab with the given widget w as a page to the BCTabWidget at position index.
	Newly inserted tab becomes the current tab.
	If you insert tab after show, you may cause flicker.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the widget to insert as a page to the inserted tab.

	label : str
		the title of the new tab.

	index : int
		If index is out of range, the tab is simply appended. Otherwise it is inserted at the specified position.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetRemoveTab

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Tab Widget Insert Example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Initial Tab")
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnSetNext = guitk.BCPushButtonCreate(
		        hBox1, "Go to Next", btnSetNextClicked, tabWidget
		    )
		    btnInsert = guitk.BCPushButtonCreate(
		        hBox1, "Insert Here", btnInsertClicked, tabWidget
		    )
		    guitk.BCSetUserDataKey(btnInsert, "newCounter", 0)
		    btnRemove = guitk.BCPushButtonCreate(hBox1, "Remove", btnRemoveClicked, tabWidget)
		    guitk.BCShow(window)
		
		
		def btnSetNextClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        newIndex = (
		            guitk.BCTabWidgetIndexOf(
		                tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget)
		            )
		            + 1
		        ) % guitk.BCTabWidgetCount(tabWidget)
		        guitk.BCTabWidgetSetCurrentTab(
		            tabWidget, guitk.BCTabWidgetGetTab(tabWidget, newIndex)
		        )
		    return 0
		
		
		def btnInsertClicked(btn, tabWidget):
		    index = (
		        guitk.BCTabWidgetIndexOf(tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget))
		        if guitk.BCTabWidgetCount(tabWidget)
		        else 0
		    )
		    counter = guitk.BCGetUserDataKey(btn, "newCounter")
		    guitk.BCSetUserDataKey(btn, "newCounter", counter + 1)
		    guitk.BCTabWidgetInsertTab(
		        tabWidget, guitk.BCFrameCreate(tabWidget), "New Tab " + str(counter), index
		    )
		    return 0
		
		
		def btnRemoveClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        current = guitk.BCTabWidgetGetCurrentTab(tabWidget)
		        guitk.BCTabWidgetRemoveTab(tabWidget, current)
		        guitk.BCDestroyLater(current)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetRemoveTab(tw: object, w: object) -> None:

	"""

	Removes the tab containing the page widget w from the BCTabWidget tw.
	
	NOTE: The page widget w itself is not deleted. Use BCDestroy() if you want to delete it.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget contained in the tab that we want to remove from the stack.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetAddTab

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Tab Widget Insert Example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Initial Tab")
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnSetNext = guitk.BCPushButtonCreate(
		        hBox1, "Go to Next", btnSetNextClicked, tabWidget
		    )
		    btnInsert = guitk.BCPushButtonCreate(
		        hBox1, "Insert Here", btnInsertClicked, tabWidget
		    )
		    guitk.BCSetUserDataKey(btnInsert, "newCounter", 0)
		    btnRemove = guitk.BCPushButtonCreate(hBox1, "Remove", btnRemoveClicked, tabWidget)
		    guitk.BCShow(window)
		
		
		def btnSetNextClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        newIndex = (
		            guitk.BCTabWidgetIndexOf(
		                tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget)
		            )
		            + 1
		        ) % guitk.BCTabWidgetCount(tabWidget)
		        guitk.BCTabWidgetSetCurrentTab(
		            tabWidget, guitk.BCTabWidgetGetTab(tabWidget, newIndex)
		        )
		    return 0
		
		
		def btnInsertClicked(btn, tabWidget):
		    index = (
		        guitk.BCTabWidgetIndexOf(tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget))
		        if guitk.BCTabWidgetCount(tabWidget)
		        else 0
		    )
		    counter = guitk.BCGetUserDataKey(btn, "newCounter")
		    guitk.BCSetUserDataKey(btn, "newCounter", counter + 1)
		    guitk.BCTabWidgetInsertTab(
		        tabWidget, guitk.BCFrameCreate(tabWidget), "New Tab " + str(counter), index
		    )
		    return 0
		
		
		def btnRemoveClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        current = guitk.BCTabWidgetGetCurrentTab(tabWidget)
		        guitk.BCTabWidgetRemoveTab(tabWidget, current)
		        guitk.BCDestroyLater(current)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetTabMovingEnabled(tw: object, enable: bool) -> None:

	"""

	Enables or disables (default) tab repositioning.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	enable : bool
		set value True to enable repositioning or False to disable it.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetCurrentTab(tw: object, w: object) -> None:

	"""

	Sets the tab containing the page widget w as the current tab of the BCTabWidget tw.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget contained by the tab we want to focus on.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetGetCurrentTab

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Tab Widget Insert Example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Initial Tab")
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnSetNext = guitk.BCPushButtonCreate(
		        hBox1, "Go to Next", btnSetNextClicked, tabWidget
		    )
		    btnInsert = guitk.BCPushButtonCreate(
		        hBox1, "Insert Here", btnInsertClicked, tabWidget
		    )
		    guitk.BCSetUserDataKey(btnInsert, "newCounter", 0)
		    btnRemove = guitk.BCPushButtonCreate(hBox1, "Remove", btnRemoveClicked, tabWidget)
		    guitk.BCShow(window)
		
		
		def btnSetNextClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        newIndex = (
		            guitk.BCTabWidgetIndexOf(
		                tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget)
		            )
		            + 1
		        ) % guitk.BCTabWidgetCount(tabWidget)
		        guitk.BCTabWidgetSetCurrentTab(
		            tabWidget, guitk.BCTabWidgetGetTab(tabWidget, newIndex)
		        )
		    return 0
		
		
		def btnInsertClicked(btn, tabWidget):
		    index = (
		        guitk.BCTabWidgetIndexOf(tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget))
		        if guitk.BCTabWidgetCount(tabWidget)
		        else 0
		    )
		    counter = guitk.BCGetUserDataKey(btn, "newCounter")
		    guitk.BCSetUserDataKey(btn, "newCounter", counter + 1)
		    guitk.BCTabWidgetInsertTab(
		        tabWidget, guitk.BCFrameCreate(tabWidget), "New Tab " + str(counter), index
		    )
		    return 0
		
		
		def btnRemoveClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        current = guitk.BCTabWidgetGetCurrentTab(tabWidget)
		        guitk.BCTabWidgetRemoveTab(tabWidget, current)
		        guitk.BCDestroyLater(current)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetGetCurrentTab(tw: object) -> object:

	"""

	Gets the page widget contained by the current tab of the BCTabWidget.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	Returns
	-------
	object
		the page widget of the current tab of the BCTabWidget.

	See Also
	--------
	BCTabWidgetSetCurrentTab

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		
		    le = guitk.BCLineEditCreate(window, "New title of the current tab")
		    guitk.BCLineEditSetEnterPressedFunction(le, ChangeCurrentTabLabel, tabWidget)
		
		    guitk.BCTabWidgetSetTabsClosableEnabled(
		        tabWidget, 1, guitk.constants.BCOnExitDestroy, TabWidgetButtonPressed, le
		    )
		
		    guitk.BCShow(window)
		
		
		def ChangeCurrentTabLabel(le, data):
		    text = guitk.BCLineEditGetText(le)
		    currentTab = guitk.BCTabWidgetGetCurrentTab(data)
		    guitk.BCTabWidgetSetTabLabel(data, currentTab, text)
		    return 1  # The accept function of the main window will not operate
		
		
		# if the last tab is deleted, disable the LineEdit
		def TabWidgetButtonPressed(tabWidget, tab, le):
		    count = guitk.BCTabWidgetCount(tabWidget)
		    if count < 2:
		        guitk.BCSetEnabled(le, False)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetTabLabel(tw: object, w: object, label: str) -> None:

	"""

	Sets the title of tab containing the page widget w of the BCTabWidget tw to label.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget contained by the tab whose title we want to set.

	label : str
		the string of the title (label) that will be set.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetGetTabLabel

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		
		    le = guitk.BCLineEditCreate(window, "New title of the current tab")
		    guitk.BCLineEditSetEnterPressedFunction(le, ChangeCurrentTabLabel, tabWidget)
		
		    guitk.BCTabWidgetSetTabsClosableEnabled(
		        tabWidget, 1, guitk.constants.BCOnExitDestroy, TabWidgetButtonPressed, le
		    )
		
		    guitk.BCShow(window)
		
		
		def ChangeCurrentTabLabel(le, data):
		    text = guitk.BCLineEditGetText(le)
		    currentTab = guitk.BCTabWidgetGetCurrentTab(data)
		    guitk.BCTabWidgetSetTabLabel(data, currentTab, text)
		    return 1  # The accept function of the main window will not operate
		
		
		# if the last tab is deleted, disable the LineEdit
		def TabWidgetButtonPressed(tabWidget, tab, le):
		    count = guitk.BCTabWidgetCount(tabWidget)
		    if count < 2:
		        guitk.BCSetEnabled(le, False)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetGetTabLabel(tw: object, w: object) -> str:

	"""

	Gets the title of the tab containing page widget w of the BCTabWidget.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget of the tab whose title we want to get.

	Returns
	-------
	str
		a string of the title (label) of the tab.

	See Also
	--------
	BCTabWidgetSetTabLabel

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TabWidget ShowTabBar Example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    guitk.BCTabWidgetAddTab(tabWidget, frameWithLabelCreate(tabWidget), "Tab A")
		    guitk.BCTabWidgetAddTab(tabWidget, frameWithLabelCreate(tabWidget), "Tab B")
		    chkBox = guitk.BCCheckBoxCreate(window, "Hide Tab Bar")
		    guitk.BCCheckBoxSetToggledFunction(chkBox, hideTabBar, tabWidget)
		    guitk.BCShow(window)
		
		
		def frameWithLabelCreate(tabWidget):
		    frame = guitk.BCFrameCreate(tabWidget)
		    bLay = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    label = guitk.BCLabelCreate(bLay, "Label")
		    guitk.BCBoxLayoutInsert(bLay, label, -1)
		    guitk.BCSetUserDataKey(frame, "nameLabel", label)
		    return frame
		
		
		def hideTabBar(chkBox, state, tabWidget):
		    tab = guitk.BCTabWidgetGetCurrentTab(tabWidget)
		    guitk.BCTabWidgetShowTabBar(tabWidget, not state)
		    label = guitk.BCGetUserDataKey(tab, "nameLabel")
		    guitk.BCLabelSetText(
		        label, guitk.BCTabWidgetGetTabLabel(tabWidget, tab) if state else "Label"
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetCurrentChangedFunction(tw: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the current tab changes.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	funct : Callable
		the function that will be called. See BC_TABWIDGET_CURRENT_CHANGED_FUNCTION for details.
		integer BC_TABWIDGET_CURRENT_CHANGED_FUNCTION(tw, oldTab, newTab, data)
		The function to be called when the current tab changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * tw : object
		                    the BCTabWidget.
		          * oldTab : object
		                    the old tab widget.
		          * newTab : object
		                    the new tab widget.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetCount(tw: object) -> int:

	"""

	Returns the number of tabs in BCTabWidget tw.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	Returns
	-------
	int
		the number of tabs in a BCTabWidget.

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		
		    le = guitk.BCLineEditCreate(window, "New title of the current tab")
		    guitk.BCLineEditSetEnterPressedFunction(le, ChangeCurrentTabLabel, tabWidget)
		
		    guitk.BCTabWidgetSetTabsClosableEnabled(
		        tabWidget, 1, guitk.constants.BCOnExitDestroy, TabWidgetButtonPressed, le
		    )
		
		    guitk.BCShow(window)
		
		
		def ChangeCurrentTabLabel(le, data):
		    text = guitk.BCLineEditGetText(le)
		    currentTab = guitk.BCTabWidgetGetCurrentTab(data)
		    guitk.BCTabWidgetSetTabLabel(data, currentTab, text)
		    return 1  # The accept function of the main window will not operate
		
		
		# if the last tab is deleted, disable the LineEdit
		def TabWidgetButtonPressed(tabWidget, tab, le):
		    count = guitk.BCTabWidgetCount(tabWidget)
		    if count < 2:
		        guitk.BCSetEnabled(le, False)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetIndexOf(tw: object, w: object) -> int:

	"""

	Returns the index position of the tab containing the page widget w in BCTabWidget tw or -1 if widget cannot be found.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget.

	Returns
	-------
	int
		the index position of the tab containing the page widget w, or -1 if the widget cannot be found.

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetGetTab(tw: object, index: int) -> object:

	"""

	Returns the page widget of the tab at index index of BCTabWidget or None if index is out of range.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	index : int
		the index.

	Returns
	-------
	object
		the page widget of tab at index index.

	See Also
	--------
	BCTabWidgetTabGetTabWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Tab Widget Insert Example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Initial Tab")
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnSetNext = guitk.BCPushButtonCreate(
		        hBox1, "Go to Next", btnSetNextClicked, tabWidget
		    )
		    btnInsert = guitk.BCPushButtonCreate(
		        hBox1, "Insert Here", btnInsertClicked, tabWidget
		    )
		    guitk.BCSetUserDataKey(btnInsert, "newCounter", 0)
		    btnRemove = guitk.BCPushButtonCreate(hBox1, "Remove", btnRemoveClicked, tabWidget)
		    guitk.BCShow(window)
		
		
		def btnSetNextClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        newIndex = (
		            guitk.BCTabWidgetIndexOf(
		                tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget)
		            )
		            + 1
		        ) % guitk.BCTabWidgetCount(tabWidget)
		        guitk.BCTabWidgetSetCurrentTab(
		            tabWidget, guitk.BCTabWidgetGetTab(tabWidget, newIndex)
		        )
		    return 0
		
		
		def btnInsertClicked(btn, tabWidget):
		    index = (
		        guitk.BCTabWidgetIndexOf(tabWidget, guitk.BCTabWidgetGetCurrentTab(tabWidget))
		        if guitk.BCTabWidgetCount(tabWidget)
		        else 0
		    )
		    counter = guitk.BCGetUserDataKey(btn, "newCounter")
		    guitk.BCSetUserDataKey(btn, "newCounter", counter + 1)
		    guitk.BCTabWidgetInsertTab(
		        tabWidget, guitk.BCFrameCreate(tabWidget), "New Tab " + str(counter), index
		    )
		    return 0
		
		
		def btnRemoveClicked(btn, tabWidget):
		    if guitk.BCTabWidgetCount(tabWidget):
		        current = guitk.BCTabWidgetGetCurrentTab(tabWidget)
		        guitk.BCTabWidgetRemoveTab(tabWidget, current)
		        guitk.BCDestroyLater(current)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetTabGetTabWidget(w: object) -> object:

	"""

	Returns the BCTabWidget of page widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the page widget contained in a tab of a BCTabWidget.

	Returns
	-------
	object
		the parent BCTabWidget.

	See Also
	--------
	BCTabWidgetGetTab

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TabWidget Rename Tab Example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    for i in range(5):
		        tab = createRenameFrame(tabWidget)
		        guitk.BCTabWidgetAddTab(tabWidget, tab, "Tab " + str(i))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def createRenameFrame(parent):
		    frame = guitk.BCFrameCreate(parent)
		    fLayout = guitk.BCFlowLayoutCreate(frame)
		    guitk.BCFlowLayoutInsert(fLayout, guitk.BCLabelCreate(fLayout, "Set Name: "))
		    lineEdit = guitk.BCLineEditCreate(fLayout, "")
		    guitk.BCFlowLayoutInsert(fLayout, lineEdit)
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, setTabName, frame)
		    return frame
		
		
		def setTabName(lineEdit, tab):
		    newTabName = guitk.BCLineEditGetText(lineEdit)
		    tabWidget = guitk.BCTabWidgetTabGetTabWidget(tab)
		    guitk.BCTabWidgetSetTabLabel(tabWidget, tab, newTabName)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetTabBarAutoHideEnabled(tw: object, enable: bool) -> None:

	"""

	Use this function to enable or disable auto hide feature of the tab bar when only one tab exists.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	enable : bool
		set this parameter to True to enable the auto hide feature, False to disable it.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetShowTabBar

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetTabButtonFunctionAndIcons(tw: object, act: int, funct: Callable, data: Any, enabledIcon: str, disabledIcon: str, focusedIcon: str, pressedIcon: str) -> None:

	"""

	Function is obsolete. Use BCTabWidgetSetTabsClosableEnabled() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	act : int
		the action to be taken when an icon is clicked and the user function returns 1 (e.g. you can hide or delete the tab).

	funct : Callable
		the user function that will be called. See BC_TABWIDGET_BUTTON_SET_FUNCTION for details.
		integer BC_TABWIDGET_BUTTON_SET_FUNCTION(tw, tab, data)
		The function to be called when a pixmap with a callback function is needed to be created on a tab of a BCTabWidget.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * tw : object
		                    the BCTabWidget.
		          * tab : object
		                    the current tab (i.e. the created widget that made tab).
		          * data : Any
		                    anything that may be required in function.
		
		Return: Return 1 in case you want to run the action set; 0 otherwise.

	data : Any
		any user data that will be used by funct.

	enabledIcon : str
		the icon that will be shown on the tab when the tab is selected.

	disabledIcon : str
		the icon that will be shown on the tab when the tab is not selected.

	focusedIcon : str
		the icon that will be shown on the tab when the mouse is over that icon (highlighted).

	pressedIcon : str
		the icon that will be shown on the tab when the mouse is pressed on that icon.

	Returns
	-------
	None

	"""

def BCTabWidgetSetTabIconFileName(tw: object, w: object, fileName: str) -> None:

	"""

	Sets the icon that will be displayed on the tab containing page widget w to be the one specified by fileName.
	
	This icon is shown on the left of the tab's title and it may be different for different tabs.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget contained by the tab, in which the icon will be shown.

	fileName : str
		the filename of the icon.
		If you pass an empty string here, the icon (if any) will not show any more.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetSetTabButtonFunctionAndIcons

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetShowTabBar(tw: object, show: bool) -> None:

	"""

	Shows or hides the tabBar of a BCTabWidget.
	NOTE: If the auto hide-tabBar feature is enabled and there is only one tab left, calling this function to show the tabBar has no effect.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	show : bool
		set this to True to show the tabBar; False to hide it.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetSetTabBarAutoHideEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TabWidget ShowTabBar Example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    guitk.BCTabWidgetAddTab(tabWidget, frameWithLabelCreate(tabWidget), "Tab A")
		    guitk.BCTabWidgetAddTab(tabWidget, frameWithLabelCreate(tabWidget), "Tab B")
		    chkBox = guitk.BCCheckBoxCreate(window, "Hide Tab Bar")
		    guitk.BCCheckBoxSetToggledFunction(chkBox, hideTabBar, tabWidget)
		    guitk.BCShow(window)
		
		
		def frameWithLabelCreate(tabWidget):
		    frame = guitk.BCFrameCreate(tabWidget)
		    bLay = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    label = guitk.BCLabelCreate(bLay, "Label")
		    guitk.BCBoxLayoutInsert(bLay, label, -1)
		    guitk.BCSetUserDataKey(frame, "nameLabel", label)
		    return frame
		
		
		def hideTabBar(chkBox, state, tabWidget):
		    tab = guitk.BCTabWidgetGetCurrentTab(tabWidget)
		    guitk.BCTabWidgetShowTabBar(tabWidget, not state)
		    label = guitk.BCGetUserDataKey(tab, "nameLabel")
		    guitk.BCLabelSetText(
		        label, guitk.BCTabWidgetGetTabLabel(tabWidget, tab) if state else "Label"
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetTabEnabled(tw: object, w: object, enabled: bool) -> None:

	"""

	Enables or disables the tab of BCTabWidget tw, containing the page widget w.
	Note that even a disabled tab may be visible. If the tab is visible already, BCTabWidget will not hide it; if all tabs are disabled, BCTabWidget will show one of them.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget contained by the tab to be enabled/disabled.

	enabled : bool
		set True to enable or False to disable.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetGetCurrentTab

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetIsTabEnabled(tw: object, w: object) -> bool:

	"""

	Returns True if the tab containing page widget w is enabled or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget contained by the tab to be checked.

	Returns
	-------
	bool
		True if the tab tab is enabled or False otherwise.

	See Also
	--------
	BCTabWidgetGetCurrentTab

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TabWidget IsTabEnabled example", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    tabA = guitk.BCFrameCreate(tabWidget)
		    guitk.BCTabWidgetAddTab(tabWidget, tabA, "Tab A")
		    tabB = guitk.BCFrameCreate(tabWidget)
		    guitk.BCTabWidgetAddTab(tabWidget, tabB, "Tab B")
		    tabC = guitk.BCFrameCreate(tabWidget)
		    guitk.BCTabWidgetAddTab(tabWidget, tabC, "Tab C")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, tabB, False)
		    for tab in [tabA, tabB, tabC]:
		        tabLabel = guitk.BCTabWidgetGetTabLabel(tabWidget, tab)
		        tabEnabled = guitk.BCTabWidgetIsTabEnabled(tabWidget, tab)
		        print("'{}' isEnabled = {}".format(tabLabel, tabEnabled))
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetEnableMiddleClickCloseTab(tw: object, enable: bool) -> None:

	"""

	Enables or disables closing tabs of BCTabWidget tw using mouse middle click.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	enable : bool
		set True to enable or False to disable.

	Returns
	-------
	None

	See Also
	--------
	BCTabWidgetIsEnabledMiddleClickCloseTab

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetIsEnabledMiddleClickCloseTab(tw: object) -> int:

	"""

	Returns 1 if closing tabs with mouse middle click is enabled or 0 otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	Returns
	-------
	int
		1 if closing tabs with mouse middle click is enabled or 0 otherwise.

	See Also
	--------
	BCTabWidgetEnableMiddleClickCloseTab

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TabWidget MiddleClickClose", guitk.constants.BCOnExitDestroy
		    )
		    tabWidget = guitk.BCTabWidgetCreate(window)
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Tab A")
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Tab B")
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Tab C")
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Tab D")
		    guitk.BCTabWidgetAddTab(tabWidget, guitk.BCFrameCreate(tabWidget), "Tab E")
		    btn = guitk.BCPushButtonCreate(
		        window, "Toggle Close on Middle-Click", toggleMiddleClick, tabWidget
		    )
		    guitk.BCShow(window)
		
		
		def toggleMiddleClick(btn, tabWidget):
		    previousState = guitk.BCTabWidgetIsEnabledMiddleClickCloseTab(tabWidget)
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(tabWidget, not previousState)
		    print("TabWidgetIsEnableMiddleClickCloseTab changed to " + str(not previousState))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetToolTip(tw: object, index: int, tip: str) -> None:

	"""

	Sets the tool tip (balloon help) for the tab at index position index to tip.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	index : int
		the index of tab.

	tip : str
		the text to be displayed at balloon help.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, redTab, "led_red_small.svg")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, orangeTab, "led_orange_small.svg")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, yellowTab, "led_yellow_small.svg")
		
		    blackTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(blackTab, 0, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, blackTab, "Black (disabled)")
		    guitk.BCTabWidgetSetTabIconFileName(tabWidget, blackTab, "led_gray_small.svg")
		    guitk.BCTabWidgetSetTabEnabled(tabWidget, blackTab, False)
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 3, "Black frame (disabled)")
		
		    guitk.BCTabWidgetSetCurrentChangedFunction(
		        tabWidget, TabWidgetCurrentTabChanged, None
		    )
		
		    # Tab properties
		    prop = guitk.BCCheckBoxCreate(window, "Auto hide")
		    guitk.BCAddToolTip(prop, "When enabled, hides the tab bar if a single page exists")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetAutoHideEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Tabs moving")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetSetMovingEnabled, tabWidget)
		
		    prop = guitk.BCCheckBoxCreate(window, "Close on mouse middle")
		    guitk.BCCheckBoxSetToggledFunction(prop, TabWidgetCloseOnMouseMiddle, tabWidget)
		
		    guitk.BCShow(window)
		
		
		def TabWidgetCurrentTabChanged(tabWidget, oldTab, newTab, data):
		    old_index = guitk.BCTabWidgetIndexOf(tabWidget, oldTab)
		    new_index = guitk.BCTabWidgetIndexOf(tabWidget, newTab)
		    print("CurrentTabChanged. Old index:", old_index, "new index :", new_index)
		    return 0
		
		
		def TabWidgetSetAutoHideEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabBarAutoHideEnabled(data, state)
		    return 0
		
		
		def TabWidgetSetMovingEnabled(cb, state, data):
		    guitk.BCTabWidgetSetTabMovingEnabled(data, state)
		    return 0
		
		
		def TabWidgetCloseOnMouseMiddle(cb, state, data):
		    guitk.BCTabWidgetEnableMiddleClickCloseTab(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserCreate(p: object) -> object:

	"""

	Creates a BCTextBrowser, i.e. a BCTextEdit in read-only mode with hypertext navigation.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		The created BCTextBrowser

	See Also
	--------
	BCTextEditCreate

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserSource(tb: object) -> str:

	"""

	Returns the name of the displayed document of BCTextBrowser tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCTextBrowser.

	Returns
	-------
	str
		the BCTextBrowser's name of the displayed document.

	See Also
	--------
	BCTextBrowserSetSource

	"""

def BCTextBrowserSetSource(tb: object, name: str) -> None:

	"""

	Sets the name of the displayed document of BCTextBrowser tb to name.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the TextBrowser.

	name : str
		the name of the displayed document.

	Returns
	-------
	None

	See Also
	--------
	BCTextBrowserSource

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserBackward(tb: object) -> None:

	"""

	Changes the document displayed to the previous document in the list of documents built by navigating links.
	Does nothing if there is no previous document.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the TextBrowser.

	Returns
	-------
	None

	See Also
	--------
	BCTextBrowserForward

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserForward(tb: object) -> None:

	"""

	Changes the document displayed to the next document in the list of documents built by navigating links.
	Does nothing if there is no next document.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the TextBrowser.

	Returns
	-------
	None

	See Also
	--------
	BCTextBrowserBackward

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserHome(tb: object) -> None:

	"""

	Changes the document displayed to be the first document the browser displayed.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the TextBrowser.

	Returns
	-------
	None

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserReload(tb: object) -> None:

	"""

	Reloads the current set source.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the TextBrowser.

	Returns
	-------
	None

	See Also
	--------
	BCTextBrowserHome

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserGetText(tb: object) -> str:

	"""

	Returns the text of BCTextBrowser tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the TextBrowser.

	Returns
	-------
	str
		the text of the BCTextBrowser.

	See Also
	--------
	BCTextBrowserGetSelectedText

	"""

def BCTextBrowserGetParagraphText(tb: object, paragraph: int) -> str:

	"""

	Returns the text of paragraph with index paragraph for tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCTextBrowser.

	paragraph : int
		the index of the paragraph to be tested.

	Returns
	-------
	str
		The text of paragraph with index paragraph.

	See Also
	--------
	BCTextBrowserGetText

	"""

def BCTextBrowserGetSelectedText(tb: object) -> str:

	"""

	Returns the selected text within TextBrowser tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCTextBrowser.

	Returns
	-------
	str
		the selected text.

	See Also
	--------
	BCTextBrowserGetText

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextBrowserSetLinkClickedFunction(tb: object, funct: Callable, data: Any=None) -> None:

	"""

	Set a function that will be called when the user clicks an anchor in the BCTextBrowser tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCTextBrowser.

	funct : Callable
		the callback function that is called when the link is clicked.
		See BC_TEXTBROWSER_LINK_CLICKED_FUNCTION for details.
		integer BC_TEXTBROWSER_LINK_CLICKED_FUNCTION(tb, link, data)
		The function to be called when the user clicks a link.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * tb : object
		                    the BCTextBrowser.
		          * link : str
		                    the value of the href.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in function funct.

	Returns
	-------
	None

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example TextBrowser", guitk.constants.BCOnExitDestroy
		    )
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		
		    tb = guitk.BCTextBrowserCreate(window)
		
		    pbHome = guitk.BCToolButtonCreate(hl, "home.svg", "", homeButtonPressed, tb)
		
		    pbBack = guitk.BCToolButtonCreate(hl, "arrow_left.svg", "", backButtonPressed, tb)
		
		    pbForward = guitk.BCToolButtonCreate(
		        hl, "arrow_right.svg", "", forwardButtonPressed, tb
		    )
		
		    urlLineEdit = guitk.BCLineEditPathCreate(
		        hl,
		        guitk.constants.BCHistoryFiles,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example_TextBrowser",
		    )
		    guitk.BCLineEditPathAddFilter(urlLineEdit, "HTML", "**.html")
		    guitk.BCLineEditPathSetDialogEnterEnabled(urlLineEdit, True)
		    guitk.BCLineEditPathSetEnterPressedFunction(urlLineEdit, urlFunction, tb)
		
		    pbReload = guitk.BCToolButtonCreate(hl, "reload.svg", "", reloadButtonPressed, tb)
		
		    pbCopySelected = guitk.BCToolButtonCreate(
		        hl, "edit_copy.svg", "", copyselectedButtonPressed, tb
		    )
		    guitk.BCAddToolTip(pbCopySelected, "Copy Selected")
		
		    guitk.BCTextBrowserSetLinkClickedFunction(tb, clickedFunction, 0)
		    guitk.BCShow(window)
		
		
		def clickedFunction(tb, link, data):
		    print(link)
		    return 0
		
		
		def homeButtonPressed(b, data):
		    guitk.BCTextBrowserHome(data)
		    return 0
		
		
		def backButtonPressed(b, data):
		    guitk.BCTextBrowserBackward(data)
		    return 0
		
		
		def forwardButtonPressed(b, data):
		    guitk.BCTextBrowserForward(data)
		    return 0
		
		
		def reloadButtonPressed(b, data):
		    guitk.BCTextBrowserReload(data)
		    print("Page reloaded.")
		    return 0
		
		
		def copyselectedButtonPressed(b, data):
		    print("The selected text is: ")
		    print(guitk.BCTextBrowserGetSelectedText(data))
		    return 0
		
		
		def urlFunction(le, data):
		    path = guitk.BCLineEditGetText(le)
		    url = "file:///"
		    url += path
		    guitk.BCTextBrowserSetSource(data, url)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditCreate(p: object, text: str) -> object:

	"""

	Creates a new BCTextEdit.
	BCTextEdits are used to display and/or edit multiple lines of text. If only one line of
	text is required, consider using BCLineEditCreate().
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	text : str
		the initial text that the BCTextEdit will display.

	Returns
	-------
	object
		The created BCTextEdit

	See Also
	--------
	BCLineEditCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetText(te: object) -> str:

	"""

	Returns the text of BCTextEdit te.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	str
		the text of the BCTextEdit.

	See Also
	--------
	BCTextEditSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetText(te: object, text: str) -> None:

	"""

	Sets the text of BCTextEdit te to be text.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	text : str
		the new text that will be displayed in BCTextEdit te.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditAppendParagraph

	"""

def BCTextEditInsert(te: object, text: str) -> None:

	"""

	Inserts text at the current cursor position of BCTextEdit te.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	text : str
		the new text that will be inserted in BCTextEdit te.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditAppendParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Find/Insert example", guitk.constants.BCOnExitDestroy
		    )
		    hBoxTop = guitk.BCHBoxCreate(window)
		    findLineEdit = guitk.BCLineEditCreate(hBoxTop, "")
		    caseSensitiveChkBox = guitk.BCCheckBoxCreate(hBoxTop, "Match Case")
		    guitk.BCLineEditSetPlaceholderText(findLineEdit, "Find...")
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCLineEditSetEnterPressedFunction(
		        findLineEdit, find, (textEdit, caseSensitiveChkBox)
		    )
		    insertLineEdit = guitk.BCLineEditCreate(window, "")
		    guitk.BCLineEditSetPlaceholderText(insertLineEdit, "Text to insert...")
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnInsert = guitk.BCPushButtonCreate(
		        hBoxFooter, "Insert", insert, (textEdit, insertLineEdit)
		    )
		    btnPrepend = guitk.BCPushButtonCreate(
		        hBoxFooter, "Insert at beginning", insertAtBegin, (textEdit, insertLineEdit)
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def find(lineEdit, data):
		    textEdit, caseSensitiveChkBox = data
		    caseSensitive = guitk.BCCheckBoxIsChecked(caseSensitiveChkBox)
		    wholeWord = False
		    forwardDirection = True
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    start = currentSelection[-2:]
		    if not guitk.BCTextEditFind(
		        textEdit,
		        guitk.BCLineEditGetText(lineEdit),
		        caseSensitive,
		        wholeWord,
		        forwardDirection,
		        *start
		    )[0]:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateError, 1)
		        guitk.BCLineEditSetTextChangeFunction(lineEdit, resetState, None)
		    return 0
		
		
		def resetState(lineEdit, text, data):
		    guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateNone, 1)
		    guitk.BCLineEditSetTextChangeFunction(lineEdit, None, None)
		    return 0
		
		
		def insert(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditInsert(textEdit, guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		def insertAtBegin(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditInsertAt(textEdit, guitk.BCLineEditGetText(lineEdit), 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditInsertAt(te: object, text: str, para: int, index: int) -> None:

	"""

	Inserts text in the paragraph para of BCTextEdit te at position index.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	text : str
		the new text that will be inserted in paragraph of BCTextEdit te.

	para : int
		the index of the paragraph which the text will be inserted.

	index : int
		the position in the paragraph which the text will be inserted.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditAppendParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Find/Insert example", guitk.constants.BCOnExitDestroy
		    )
		    hBoxTop = guitk.BCHBoxCreate(window)
		    findLineEdit = guitk.BCLineEditCreate(hBoxTop, "")
		    caseSensitiveChkBox = guitk.BCCheckBoxCreate(hBoxTop, "Match Case")
		    guitk.BCLineEditSetPlaceholderText(findLineEdit, "Find...")
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCLineEditSetEnterPressedFunction(
		        findLineEdit, find, (textEdit, caseSensitiveChkBox)
		    )
		    insertLineEdit = guitk.BCLineEditCreate(window, "")
		    guitk.BCLineEditSetPlaceholderText(insertLineEdit, "Text to insert...")
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnInsert = guitk.BCPushButtonCreate(
		        hBoxFooter, "Insert", insert, (textEdit, insertLineEdit)
		    )
		    btnPrepend = guitk.BCPushButtonCreate(
		        hBoxFooter, "Insert at beginning", insertAtBegin, (textEdit, insertLineEdit)
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def find(lineEdit, data):
		    textEdit, caseSensitiveChkBox = data
		    caseSensitive = guitk.BCCheckBoxIsChecked(caseSensitiveChkBox)
		    wholeWord = False
		    forwardDirection = True
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    start = currentSelection[-2:]
		    if not guitk.BCTextEditFind(
		        textEdit,
		        guitk.BCLineEditGetText(lineEdit),
		        caseSensitive,
		        wholeWord,
		        forwardDirection,
		        *start
		    )[0]:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateError, 1)
		        guitk.BCLineEditSetTextChangeFunction(lineEdit, resetState, None)
		    return 0
		
		
		def resetState(lineEdit, text, data):
		    guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateNone, 1)
		    guitk.BCLineEditSetTextChangeFunction(lineEdit, None, None)
		    return 0
		
		
		def insert(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditInsert(textEdit, guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		def insertAtBegin(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditInsertAt(textEdit, guitk.BCLineEditGetText(lineEdit), 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetBold(te: object, val: bool) -> None:

	"""

	If val is not zero, this function sets the current format to bold.
	When this function is called with val set to 1, any text appended to the text of te will be displayed in bold format.
	If it is called later with val set to 0, bold format is disabled, and any text appended is displayed normally.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	val : bool
		True to set bold format, or False to unset bold format.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditSetItalic

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetItalic(te: object, val: bool) -> None:

	"""

	If val is not zero, this function sets the current format to italic.
	When this function is called with val set to 1, any text appended to the text of te will be displayed in italic format. 
	If it is called later with val set to False, italic format is disabled, and any text appended is displayed normally.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	val : bool
		True to set italic format, or False to unset italic format.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditSetBold

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetUnderline(te: object, val: bool) -> None:

	"""

	If val is not zero, this function sets the current format to underline.
	When this function is called with val set to True, any text appended to the text of te will be displayed in underline format.
	If it is called later with val set to False, underline format is disabled, and any text appended is displayed normally.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	val : bool
		True to set underline format, or False to unset underline format.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditSetItalic

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetSelectedText(te: object) -> str:

	"""

	Returns the selected text within BCTextEdit te.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	str
		the selected text.

	See Also
	--------
	BCTextEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetReadOnly(te: object, readOnly: bool) -> None:

	"""

	Sets the text of the BCTextEdit te as read-only or not according to readOnly.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	readOnly : bool
		set it to False if you don't want the BCTextEdit to be Read-Only. Otherwise set it to True.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditIsReadOnly

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 1", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    chkBoxReadOnly = guitk.BCCheckBoxCreate(hBoxFooter, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReadOnly, setReadOnly, textEdit)
		    chkBoxBlockUpdates = guitk.BCCheckBoxCreate(hBoxFooter, "Block Updates")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxBlockUpdates, blockUpdates, textEdit)
		    chkBoxClear = guitk.BCCheckBoxCreate(hBoxFooter, "Clear Option")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxClear, setClearOption, textEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setReadOnly(cb, state, textEdit):
		    guitk.BCTextEditSetReadOnly(textEdit, state)
		    print("ReadOnly set to: " + str(guitk.BCTextEditIsReadOnly(textEdit)))
		    return 0
		
		
		def blockUpdates(cb, state, textEdit):
		    guitk.BCTextEditBlockUpdates(textEdit, state)
		    print("BlockUpdates set to: " + str(guitk.BCTextEditAreUpdatesBlocked(textEdit)))
		    return 0
		
		
		def setClearOption(cb, state, textEdit):
		    guitk.BCTextEditSetClearOptionVisible(textEdit, state)
		    print(
		        "Context Menu Clear Option is Visible = "
		        + str(guitk.BCTextEditClearOptionVisible(textEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditIsReadOnly(te: object) -> bool:

	"""

	informs about the readOnly state of the BCTextEdit te.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	bool
		True if the BCTextEdit is readOnly, False otherwise.

	See Also
	--------
	BCTextEditSetReadOnly

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 1", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    chkBoxReadOnly = guitk.BCCheckBoxCreate(hBoxFooter, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReadOnly, setReadOnly, textEdit)
		    chkBoxBlockUpdates = guitk.BCCheckBoxCreate(hBoxFooter, "Block Updates")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxBlockUpdates, blockUpdates, textEdit)
		    chkBoxClear = guitk.BCCheckBoxCreate(hBoxFooter, "Clear Option")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxClear, setClearOption, textEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setReadOnly(cb, state, textEdit):
		    guitk.BCTextEditSetReadOnly(textEdit, state)
		    print("ReadOnly set to: " + str(guitk.BCTextEditIsReadOnly(textEdit)))
		    return 0
		
		
		def blockUpdates(cb, state, textEdit):
		    guitk.BCTextEditBlockUpdates(textEdit, state)
		    print("BlockUpdates set to: " + str(guitk.BCTextEditAreUpdatesBlocked(textEdit)))
		    return 0
		
		
		def setClearOption(cb, state, textEdit):
		    guitk.BCTextEditSetClearOptionVisible(textEdit, state)
		    print(
		        "Context Menu Clear Option is Visible = "
		        + str(guitk.BCTextEditClearOptionVisible(textEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditFind(te: object, expr: str, cs: bool, wo: bool, forward: bool, para: int=0, index: int=0) -> bool:

	"""

	Finds the next occurrence of the string, expr. Returns True if expr was found; otherwise returns False.
	If para and index are both 0 the search begins from the current cursor position. If para and index are both not 0, the search begins from the index character position in the para paragraph.
	Please note that this function will make the next occurrence of the string (if found) the current selection, and will thus modify the cursor position.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	expr : str
		the string to find in te.

	cs : bool
		if cs is True the search is case sensitive, otherwise it is case insensitive.

	wo : bool
		if wo is True the search looks for whole word matches only; otherwise it searches for any matching text.

	forward : bool
		if forward is True the search works forward from the starting position to the end of the text, otherwise it works backwards to the beginning of the text.

	para : int, optional
		the BCTextEdit's paragraph where the cursor will start the search from.

	index : int, optional
		the position in para where the cursor will be start the search from.

	Returns
	-------
	bool
		The function returns a tupple with 3 items:
		ret[0] can be True or False whether the expression was found or not. 
		ret[1] is the number of the paragraph in which the first character of the match was found. 
		ret[2] is the index position of that character within the paragraph.
		
		WARNING: If expr is not found, the returned index and paragraph are undefined.

	See Also
	--------
	BCTextEditEnsureCursorVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Find/Insert example", guitk.constants.BCOnExitDestroy
		    )
		    hBoxTop = guitk.BCHBoxCreate(window)
		    findLineEdit = guitk.BCLineEditCreate(hBoxTop, "")
		    caseSensitiveChkBox = guitk.BCCheckBoxCreate(hBoxTop, "Match Case")
		    guitk.BCLineEditSetPlaceholderText(findLineEdit, "Find...")
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCLineEditSetEnterPressedFunction(
		        findLineEdit, find, (textEdit, caseSensitiveChkBox)
		    )
		    insertLineEdit = guitk.BCLineEditCreate(window, "")
		    guitk.BCLineEditSetPlaceholderText(insertLineEdit, "Text to insert...")
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnInsert = guitk.BCPushButtonCreate(
		        hBoxFooter, "Insert", insert, (textEdit, insertLineEdit)
		    )
		    btnPrepend = guitk.BCPushButtonCreate(
		        hBoxFooter, "Insert at beginning", insertAtBegin, (textEdit, insertLineEdit)
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def find(lineEdit, data):
		    textEdit, caseSensitiveChkBox = data
		    caseSensitive = guitk.BCCheckBoxIsChecked(caseSensitiveChkBox)
		    wholeWord = False
		    forwardDirection = True
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    start = currentSelection[-2:]
		    if not guitk.BCTextEditFind(
		        textEdit,
		        guitk.BCLineEditGetText(lineEdit),
		        caseSensitive,
		        wholeWord,
		        forwardDirection,
		        *start
		    )[0]:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateError, 1)
		        guitk.BCLineEditSetTextChangeFunction(lineEdit, resetState, None)
		    return 0
		
		
		def resetState(lineEdit, text, data):
		    guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateNone, 1)
		    guitk.BCLineEditSetTextChangeFunction(lineEdit, None, None)
		    return 0
		
		
		def insert(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditInsert(textEdit, guitk.BCLineEditGetText(lineEdit))
		    return 0
		
		
		def insertAtBegin(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditInsertAt(textEdit, guitk.BCLineEditGetText(lineEdit), 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetCursorPosition(te: object, paragraph: int, index: int) -> None:

	"""

	Sets the cursor to position index in paragraph paragraph.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the BCTextEdit's paragraph where the cursor will be set.

	index : int
		the position in paragraph where the cursor will be set.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditEnsureCursorVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 2", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		    # For each widget below set Focus policy to BCNoFocus for display purposes
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnTop = guitk.BCPushButtonCreate(
		        hBoxFooter, "Cursor to Top", setCursorTop, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnTop, guitk.constants.BCNoFocus)
		    btnBottom = guitk.BCPushButtonCreate(
		        hBoxFooter, "Scroll to Bottom", scrollDown, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnBottom, guitk.constants.BCNoFocus)
		    btnEnsureVisible = guitk.BCPushButtonCreate(
		        hBoxFooter, "Ensure Cursor Visible", ensureVisible, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnEnsureVisible, guitk.constants.BCNoFocus)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setCursorTop(b, textEdit):
		    guitk.BCTextEditSetCursorPosition(textEdit, 0, 0)
		    return 0
		
		
		def scrollDown(b, textEdit):
		    guitk.BCTextEditScrollToBottom(textEdit)
		    return 0
		
		
		def ensureVisible(b, textEdit):
		    guitk.BCTextEditEnsureCursorVisible(textEdit)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetCursorPositionChangedFunction(te: object, funct: Callable, data: Any=None) -> None:

	"""

	Set a function that will be called when the cursor of the BCTextEdit te changes position. The te may also be a read-only BCTextEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	funct : Callable
		the callback function that is called when the cursor changes position.
		See BC_TEXTEDIT_CURSOR_POS_CHANGED_FUNCTION for details.
		integer BC_TEXTEDIT_CURSOR_POS_CHANGED_FUNCTION(te, para, pos, data)
		The function to be called when the position of the cursor changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * te : object
		                    the BCTextEdit.
		          * para : int
		                    the current paragraph.
		          * pos : int
		                    the character position within the paragraph.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in function funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 2", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		    # For each widget below set Focus policy to BCNoFocus for display purposes
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnTop = guitk.BCPushButtonCreate(
		        hBoxFooter, "Cursor to Top", setCursorTop, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnTop, guitk.constants.BCNoFocus)
		    btnBottom = guitk.BCPushButtonCreate(
		        hBoxFooter, "Scroll to Bottom", scrollDown, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnBottom, guitk.constants.BCNoFocus)
		    btnEnsureVisible = guitk.BCPushButtonCreate(
		        hBoxFooter, "Ensure Cursor Visible", ensureVisible, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnEnsureVisible, guitk.constants.BCNoFocus)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setCursorTop(b, textEdit):
		    guitk.BCTextEditSetCursorPosition(textEdit, 0, 0)
		    return 0
		
		
		def scrollDown(b, textEdit):
		    guitk.BCTextEditScrollToBottom(textEdit)
		    return 0
		
		
		def ensureVisible(b, textEdit):
		    guitk.BCTextEditEnsureCursorVisible(textEdit)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditEnsureCursorVisible(te: object) -> None:

	"""

	Ensures that the cursor is visible by scrolling the text edit if necessary.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 2", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		    # For each widget below set Focus policy to BCNoFocus for display purposes
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnTop = guitk.BCPushButtonCreate(
		        hBoxFooter, "Cursor to Top", setCursorTop, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnTop, guitk.constants.BCNoFocus)
		    btnBottom = guitk.BCPushButtonCreate(
		        hBoxFooter, "Scroll to Bottom", scrollDown, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnBottom, guitk.constants.BCNoFocus)
		    btnEnsureVisible = guitk.BCPushButtonCreate(
		        hBoxFooter, "Ensure Cursor Visible", ensureVisible, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnEnsureVisible, guitk.constants.BCNoFocus)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setCursorTop(b, textEdit):
		    guitk.BCTextEditSetCursorPosition(textEdit, 0, 0)
		    return 0
		
		
		def scrollDown(b, textEdit):
		    guitk.BCTextEditScrollToBottom(textEdit)
		    return 0
		
		
		def ensureVisible(b, textEdit):
		    guitk.BCTextEditEnsureCursorVisible(textEdit)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditClear(te: object) -> None:

	"""

	Deletes all the text in the BCTextEdit te.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetWordWrap(te: object, wordWrap: int) -> None:

	"""

	Sets the word wrap mode of the BCTextEdit te to wordWrap.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	wordWrap : int
		the word wrap mode.
		See BCEnumWordWrap for details.
		
		guitk.constants BCEnumWordWrap
		This enum defines the BCTextEdit's word wrap modes
		 - guitk.constants.BCNoWrap
		Do not wrap the text. This is the default.
		 - guitk.constants.BCWidgetWidth
		Wrap the text at the current width of the widget. Wrapping is at whitespace by default; this can be changed with BCTextEditSetWrapPolicy().
		 - guitk.constants.BCFixedPixelWidth
		Wrap the text at a fixed number of pixels from the widget's left side. The number of pixels is set with BCTextEditSetWrapColumnOrWidth()
		 - guitk.constants.BCFixedColumnWidth
		Wrap the text at a fixed number of character columns from the widget's left side. The number of characters is set with BCTextEditSetWrapColumnOrWidth(). This is useful if you need formatted text that can also be displayed gracefully on devices with monospaced fonts, for example a standard VT100 terminal, where you might set wrapColumnOrWidth() to 80.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetWrapPolicy(te: object, wrapPolicy: int) -> None:

	"""

	Sets the word wrap policy of the BCTextEdit te to wrapPolicy (default BCWrapAtWordBoundaryOrAnywhere).
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	wrapPolicy : int
		the word wrap policy.
		See BCEnumWrapPolicy for details.
		
		guitk.constants BCEnumWrapPolicy
		This enum defines where text can be wrapped in word wrap mode.
		 - guitk.constants.BCManualWrap
		Text is not wrapped at all.
		 - guitk.constants.BCWordWrap
		Text is wrapped at word boundaries.
		 - guitk.constants.BCWrapAnywhere
		Text can be wrapped at any point on a line, even if it occurs in the middle of a word.
		 - guitk.constants.BCWrapAtWordBoundaryOrAnywhere
		If possible, wrapping occurs at a word boundary; otherwise it will occur at the appropriate point on the line, even in the middle of a word.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Wrap Example", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window,
		        "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmode tempor\\n\\n"
		        * 10,
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    wrapPolicyBtnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Wrap Policy", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(wrapPolicyBtnGroup, "BCManualWrap", None, None)
		    guitk.BCRadioButtonCreate(wrapPolicyBtnGroup, "BCWordWrap", None, None)
		    guitk.BCRadioButtonCreate(wrapPolicyBtnGroup, "BCWrapAnywhere", None, None)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(
		            wrapPolicyBtnGroup, "BCWrapAtWordBoundaryOrAnywhere", None, None
		        ),
		        True,
		    )
		    guitk.BCButtonGroupSetPressedFunction(wrapPolicyBtnGroup, setWrapPolicy, textEdit)
		
		    wrapModeBtnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Wrap Mode", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCNoWrap", None, None), True
		    )
		    guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCWidgetWidth", None, None)
		    guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCFixedPixelWidth", None, None)
		    guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCFixedColumnWidth", None, None)
		    columnOrPixelWidthSpinBox = guitk.BCSpinBoxCreate(wrapModeBtnGroup)
		    guitk.BCSpinBoxSetMaxValue(columnOrPixelWidthSpinBox, 2000)
		    guitk.BCSpinBoxSetMinValue(columnOrPixelWidthSpinBox, 1)
		    guitk.BCSetEnabled(columnOrPixelWidthSpinBox, False)
		    guitk.BCSpinBoxSetValueChangedFunction(
		        columnOrPixelWidthSpinBox, setWrapWidth, textEdit
		    )
		    guitk.BCButtonGroupSetPressedFunction(
		        wrapModeBtnGroup, setWrapWidthContext, (textEdit, columnOrPixelWidthSpinBox)
		    )
		
		    guitk.BCWindowSetInitGeometry(window, 100, 100, 380, 600)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setWrapPolicy(btnGroup, id, textEdit):
		    newWrapPolicy = eval(
		        "guitk.constants."
		        + guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    )
		    guitk.BCTextEditSetWrapPolicy(textEdit, newWrapPolicy)
		    return 0
		
		
		def setWrapWidthContext(btnGroup, id, data):
		    textEdit, spinBox = data
		    newWrap = eval(
		        "guitk.constants."
		        + guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    )
		    spinBoxEnabled = False
		    guitk.BCTextEditSetWordWrap(textEdit, newWrap)
		    if (
		        newWrap == guitk.constants.BCFixedPixelWidth
		        or newWrap == guitk.constants.BCFixedColumnWidth
		    ):
		        guitk.BCSpinBoxSetMinValue(
		            spinBox, 30
		        ) if newWrap == guitk.constants.BCFixedPixelWidth else guitk.BCSpinBoxSetMinValue(
		            spinBox, 1
		        )
		        guitk.BCTextEditSetWrapColumnOrWidth(textEdit, guitk.BCSpinBoxGetInt(spinBox))
		        spinBoxEnabled = True
		    guitk.BCSetEnabled(spinBox, spinBoxEnabled)
		    return 0
		
		
		def setWrapWidth(spinBox, val, textEdit):
		    guitk.BCTextEditSetWrapColumnOrWidth(textEdit, val)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetWrapColumnOrWidth(te: object, wrapPos: int) -> None:

	"""

	Sets the position (in pixels or columns depending on the BCEnumWordWrap mode) where text will be wrapped.
	This function is applicable when BCTextEditSetWordWrap() has been called with either BCFixedPixelWidth or
	BCFixedColumnWidth as wrap mode, setting the pixel or column position of wrap width respectively.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	wrapPos : int
		The position in pixels or columns, where the text will be wrapped.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditSetWordWrap

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Wrap Example", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window,
		        "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmode tempor\\n\\n"
		        * 10,
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    wrapPolicyBtnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Wrap Policy", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonCreate(wrapPolicyBtnGroup, "BCManualWrap", None, None)
		    guitk.BCRadioButtonCreate(wrapPolicyBtnGroup, "BCWordWrap", None, None)
		    guitk.BCRadioButtonCreate(wrapPolicyBtnGroup, "BCWrapAnywhere", None, None)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(
		            wrapPolicyBtnGroup, "BCWrapAtWordBoundaryOrAnywhere", None, None
		        ),
		        True,
		    )
		    guitk.BCButtonGroupSetPressedFunction(wrapPolicyBtnGroup, setWrapPolicy, textEdit)
		
		    wrapModeBtnGroup = guitk.BCButtonGroupCreate(
		        hBox, "Wrap Mode", guitk.constants.BCVertical
		    )
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCNoWrap", None, None), True
		    )
		    guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCWidgetWidth", None, None)
		    guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCFixedPixelWidth", None, None)
		    guitk.BCRadioButtonCreate(wrapModeBtnGroup, "BCFixedColumnWidth", None, None)
		    columnOrPixelWidthSpinBox = guitk.BCSpinBoxCreate(wrapModeBtnGroup)
		    guitk.BCSpinBoxSetMaxValue(columnOrPixelWidthSpinBox, 2000)
		    guitk.BCSpinBoxSetMinValue(columnOrPixelWidthSpinBox, 1)
		    guitk.BCSetEnabled(columnOrPixelWidthSpinBox, False)
		    guitk.BCSpinBoxSetValueChangedFunction(
		        columnOrPixelWidthSpinBox, setWrapWidth, textEdit
		    )
		    guitk.BCButtonGroupSetPressedFunction(
		        wrapModeBtnGroup, setWrapWidthContext, (textEdit, columnOrPixelWidthSpinBox)
		    )
		
		    guitk.BCWindowSetInitGeometry(window, 100, 100, 380, 600)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setWrapPolicy(btnGroup, id, textEdit):
		    newWrapPolicy = eval(
		        "guitk.constants."
		        + guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    )
		    guitk.BCTextEditSetWrapPolicy(textEdit, newWrapPolicy)
		    return 0
		
		
		def setWrapWidthContext(btnGroup, id, data):
		    textEdit, spinBox = data
		    newWrap = eval(
		        "guitk.constants."
		        + guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    )
		    spinBoxEnabled = False
		    guitk.BCTextEditSetWordWrap(textEdit, newWrap)
		    if (
		        newWrap == guitk.constants.BCFixedPixelWidth
		        or newWrap == guitk.constants.BCFixedColumnWidth
		    ):
		        guitk.BCSpinBoxSetMinValue(
		            spinBox, 30
		        ) if newWrap == guitk.constants.BCFixedPixelWidth else guitk.BCSpinBoxSetMinValue(
		            spinBox, 1
		        )
		        guitk.BCTextEditSetWrapColumnOrWidth(textEdit, guitk.BCSpinBoxGetInt(spinBox))
		        spinBoxEnabled = True
		    guitk.BCSetEnabled(spinBox, spinBoxEnabled)
		    return 0
		
		
		def setWrapWidth(spinBox, val, textEdit):
		    guitk.BCTextEditSetWrapColumnOrWidth(textEdit, val)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditScrollToBottom(te: object) -> None:

	"""

	Scrolls to the bottom of the document and does formatting if required.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 2", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		    # For each widget below set Focus policy to BCNoFocus for display purposes
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnTop = guitk.BCPushButtonCreate(
		        hBoxFooter, "Cursor to Top", setCursorTop, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnTop, guitk.constants.BCNoFocus)
		    btnBottom = guitk.BCPushButtonCreate(
		        hBoxFooter, "Scroll to Bottom", scrollDown, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnBottom, guitk.constants.BCNoFocus)
		    btnEnsureVisible = guitk.BCPushButtonCreate(
		        hBoxFooter, "Ensure Cursor Visible", ensureVisible, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnEnsureVisible, guitk.constants.BCNoFocus)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setCursorTop(b, textEdit):
		    guitk.BCTextEditSetCursorPosition(textEdit, 0, 0)
		    return 0
		
		
		def scrollDown(b, textEdit):
		    guitk.BCTextEditScrollToBottom(textEdit)
		    return 0
		
		
		def ensureVisible(b, textEdit):
		    guitk.BCTextEditEnsureCursorVisible(textEdit)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetVisibleWidth(te: object) -> int:

	"""

	Returns the visible width of BCTextEdit te.
	Recall that BCTextEdit may obtain horizontal scrollbar, if applied text exceeds visible limits. 
	When scrollbar is hidden, visible width equals to the width of the BCTextEdit's BCScrollView.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit to be measured.

	Returns
	-------
	int
		the BCTextEdit's visible width.

	See Also
	--------
	BCTextEditGetContentsWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetVisibleHeight(te: object) -> int:

	"""

	Returns the visible height of BCTextEdit te.
	Recall that BCTextEdit may obtain vertical scrollbar, if applied text exceeds visible limits. 
	When scrollbar is hidden, visible height equals to the height of the BCTextEdit's BCScrollView.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit to be measured.

	Returns
	-------
	int
		the BCTextEdit's visible height.

	See Also
	--------
	BCTextEditGetContentsHeight

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetContentsWidth(te: object) -> int:

	"""

	Returns the contents width of BCTextEdit te.
	This is the least width where horizontal scrollbar is not visible.
	Imagine you have a BCTextEdit with horizontal scrollbar visible.
	In order to find out how much your widget have to grow for the horizontal scrollbar to disappear, calculate contentsWidth-visibleWidth.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit to be measured.

	Returns
	-------
	int
		the horizontal total amount of content.

	See Also
	--------
	BCTextEditGetVisibleWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetContentsHeight(te: object) -> int:

	"""

	Returns the contents height of BCTextEdit te.
	This is the height in pixels where vertical scrollbar is not visible.
	Imagine you have a BCTextEdit with vertical scrollbar visible.
	In order to find out how much your widget have to grow for the vertical scrollbar to disappear, calculate contentsWidth-visibleWidth.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit to be measured.

	Returns
	-------
	int
		the vertical total amount of content.

	See Also
	--------
	BCTextEditGetVisibleHeight

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetInfo(te: object, info: str) -> None:

	"""

	Function is obsolete. Use BCTextEditSetPlaceholderText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	info : str
		the text to be displayed.

	Returns
	-------
	None

	"""

def BCTextEditAppendParagraph(te: object, txt: str) -> None:

	"""

	Appends a new paragraph with text txt to the end of the BCTextEdit te.
	The difference with insertParagraph is that undo/redo history in BCTextEdit is cleared by this function, and no history is kept for appends, which makes them faster.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	txt : str
		the text to be appended.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditInsertParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraphs example", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCTextEditSetReadOnly(textEdit, True)
		    paragraphBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph", guitk.constants.BCVertical
		    )
		    newParagraphLineEdit = guitk.BCLineEditCreate(paragraphBtnGroup, "")
		    guitk.BCLineEditSetPlaceholderText(newParagraphLineEdit, "New Paragraph Text")
		    hBox = guitk.BCHBoxCreate(paragraphBtnGroup)
		    data = (textEdit, newParagraphLineEdit)
		    guitk.BCPushButtonCreate(hBox, "Append", appendPara, data)
		    guitk.BCPushButtonCreate(hBox, "Insert", insertPara, data)
		    guitk.BCPushButtonCreate(hBox, "Get Current", getParaText, data)
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrentPara, textEdit)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def appendPara(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditAppendParagraph(textEdit, guitk.BCLineEditGetText(lineEdit))
		    print(
		        "Paragraph Appended. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def insertPara(btn, data):
		    textEdit, lineEdit = data
		    insertPosition = guitk.BCTextEditGetSelection(textEdit)[0]
		    guitk.BCTextEditInsertParagraph(
		        textEdit, guitk.BCLineEditGetText(lineEdit), insertPosition
		    )
		    print(
		        "Paragraph Inserted. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def getParaText(btn, data):
		    textEdit, lineEdit = data
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    text = ""
		    for paragraph in range(curSelection[0], curSelection[-2] + 1):
		        text += guitk.BCTextEditGetParagraphText(textEdit, paragraph)
		    guitk.BCLineEditSetText(lineEdit, text)
		    return 0
		
		
		def removeCurrentPara(btn, textEdit):
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(curSelection[-2], curSelection[0] - 1, -1):
		        guitk.BCTextEditRemoveParagraph(textEdit, paragraph)
		    print(
		        "Paragraph(s) Removed. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditInsertParagraph(te: object, txt: str, paragraph: int) -> None:

	"""

	Inserts a new paragraph with text txt after the paragraph paragraph.
	The difference with appendParagraph is that undo/redo history in BCTextEdit is kept by
	this function, which makes it slower.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	txt : str
		the text to be inserted.

	paragraph : int
		the index of the paragraph after which the text will be inserted.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditAppendParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraphs example", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCTextEditSetReadOnly(textEdit, True)
		    paragraphBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph", guitk.constants.BCVertical
		    )
		    newParagraphLineEdit = guitk.BCLineEditCreate(paragraphBtnGroup, "")
		    guitk.BCLineEditSetPlaceholderText(newParagraphLineEdit, "New Paragraph Text")
		    hBox = guitk.BCHBoxCreate(paragraphBtnGroup)
		    data = (textEdit, newParagraphLineEdit)
		    guitk.BCPushButtonCreate(hBox, "Append", appendPara, data)
		    guitk.BCPushButtonCreate(hBox, "Insert", insertPara, data)
		    guitk.BCPushButtonCreate(hBox, "Get Current", getParaText, data)
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrentPara, textEdit)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def appendPara(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditAppendParagraph(textEdit, guitk.BCLineEditGetText(lineEdit))
		    print(
		        "Paragraph Appended. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def insertPara(btn, data):
		    textEdit, lineEdit = data
		    insertPosition = guitk.BCTextEditGetSelection(textEdit)[0]
		    guitk.BCTextEditInsertParagraph(
		        textEdit, guitk.BCLineEditGetText(lineEdit), insertPosition
		    )
		    print(
		        "Paragraph Inserted. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def getParaText(btn, data):
		    textEdit, lineEdit = data
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    text = ""
		    for paragraph in range(curSelection[0], curSelection[-2] + 1):
		        text += guitk.BCTextEditGetParagraphText(textEdit, paragraph)
		    guitk.BCLineEditSetText(lineEdit, text)
		    return 0
		
		
		def removeCurrentPara(btn, textEdit):
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(curSelection[-2], curSelection[0] - 1, -1):
		        guitk.BCTextEditRemoveParagraph(textEdit, paragraph)
		    print(
		        "Paragraph(s) Removed. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditRemoveParagraph(te: object, paragraph: int) -> None:

	"""

	Removes the paragraph paragraph.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the index of the paragraph to be removed.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditAppendParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraphs example", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCTextEditSetReadOnly(textEdit, True)
		    paragraphBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph", guitk.constants.BCVertical
		    )
		    newParagraphLineEdit = guitk.BCLineEditCreate(paragraphBtnGroup, "")
		    guitk.BCLineEditSetPlaceholderText(newParagraphLineEdit, "New Paragraph Text")
		    hBox = guitk.BCHBoxCreate(paragraphBtnGroup)
		    data = (textEdit, newParagraphLineEdit)
		    guitk.BCPushButtonCreate(hBox, "Append", appendPara, data)
		    guitk.BCPushButtonCreate(hBox, "Insert", insertPara, data)
		    guitk.BCPushButtonCreate(hBox, "Get Current", getParaText, data)
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrentPara, textEdit)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def appendPara(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditAppendParagraph(textEdit, guitk.BCLineEditGetText(lineEdit))
		    print(
		        "Paragraph Appended. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def insertPara(btn, data):
		    textEdit, lineEdit = data
		    insertPosition = guitk.BCTextEditGetSelection(textEdit)[0]
		    guitk.BCTextEditInsertParagraph(
		        textEdit, guitk.BCLineEditGetText(lineEdit), insertPosition
		    )
		    print(
		        "Paragraph Inserted. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def getParaText(btn, data):
		    textEdit, lineEdit = data
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    text = ""
		    for paragraph in range(curSelection[0], curSelection[-2] + 1):
		        text += guitk.BCTextEditGetParagraphText(textEdit, paragraph)
		    guitk.BCLineEditSetText(lineEdit, text)
		    return 0
		
		
		def removeCurrentPara(btn, textEdit):
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(curSelection[-2], curSelection[0] - 1, -1):
		        guitk.BCTextEditRemoveParagraph(textEdit, paragraph)
		    print(
		        "Paragraph(s) Removed. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetParagraphBackgroundColor(te: object, paragraph: int, r: int, g: int, b: int) -> None:

	"""

	Sets the RGB values for the background color of paragraph paragraph to be r, g and b.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the index of the paragraph to be affected.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	See Also
	--------
	BCTextEditClearParagraphBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraph Colors", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    colorBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph Color", guitk.constants.BCHorizontal
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Background", setParaBackground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Foreground", setParaForeground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Background", resetParaBackground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Foreground", resetParaForeground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(255, 255, 255)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphBackgroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def setParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(0, 0, 0)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphForegroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def resetParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphBackgroundColor(textEdit, paragraph)
		    return 0
		
		
		def resetParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphForegroundColor(textEdit, paragraph)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditClearParagraphBackgroundColor(te: object, paragraph: int) -> None:

	"""

	Sets the background color of paragraph paragraph to the default.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the index of the paragraph to be affected.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditSetParagraphBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraph Colors", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    colorBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph Color", guitk.constants.BCHorizontal
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Background", setParaBackground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Foreground", setParaForeground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Background", resetParaBackground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Foreground", resetParaForeground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(255, 255, 255)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphBackgroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def setParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(0, 0, 0)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphForegroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def resetParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphBackgroundColor(textEdit, paragraph)
		    return 0
		
		
		def resetParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphForegroundColor(textEdit, paragraph)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetParagraphs(te: object) -> int:

	"""

	Returns the number of paragraphs in the te.
	Recall that an empty textedit is always considered to have one paragraph, so 1 is returned in this case.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	int
		The number of paragraphs.

	See Also
	--------
	BCTextEditGetLinesOfParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraphs example", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCTextEditSetReadOnly(textEdit, True)
		    paragraphBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph", guitk.constants.BCVertical
		    )
		    newParagraphLineEdit = guitk.BCLineEditCreate(paragraphBtnGroup, "")
		    guitk.BCLineEditSetPlaceholderText(newParagraphLineEdit, "New Paragraph Text")
		    hBox = guitk.BCHBoxCreate(paragraphBtnGroup)
		    data = (textEdit, newParagraphLineEdit)
		    guitk.BCPushButtonCreate(hBox, "Append", appendPara, data)
		    guitk.BCPushButtonCreate(hBox, "Insert", insertPara, data)
		    guitk.BCPushButtonCreate(hBox, "Get Current", getParaText, data)
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrentPara, textEdit)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def appendPara(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditAppendParagraph(textEdit, guitk.BCLineEditGetText(lineEdit))
		    print(
		        "Paragraph Appended. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def insertPara(btn, data):
		    textEdit, lineEdit = data
		    insertPosition = guitk.BCTextEditGetSelection(textEdit)[0]
		    guitk.BCTextEditInsertParagraph(
		        textEdit, guitk.BCLineEditGetText(lineEdit), insertPosition
		    )
		    print(
		        "Paragraph Inserted. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def getParaText(btn, data):
		    textEdit, lineEdit = data
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    text = ""
		    for paragraph in range(curSelection[0], curSelection[-2] + 1):
		        text += guitk.BCTextEditGetParagraphText(textEdit, paragraph)
		    guitk.BCLineEditSetText(lineEdit, text)
		    return 0
		
		
		def removeCurrentPara(btn, textEdit):
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(curSelection[-2], curSelection[0] - 1, -1):
		        guitk.BCTextEditRemoveParagraph(textEdit, paragraph)
		    print(
		        "Paragraph(s) Removed. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetLinesOfParagraph(te: object, paragraph: int) -> int:

	"""

	Returns the number of lines that paragraph paragraph has.
	The function returns -1 if there is no paragraph with index paragraph.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the index of the paragraph to be affected.

	Returns
	-------
	int
		The number of lines for paragraph.

	See Also
	--------
	BCTextEditGetParagraphs

	"""

def BCTextEditGetParagraphText(te: object, paragraph: int) -> str:

	"""

	Returns the text of paragraph with index paragraph for te.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the index of the paragraph to be tested.

	Returns
	-------
	str
		The text of paragraph with index paragraph.

	See Also
	--------
	BCTextEditGetLinesOfParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraphs example", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    guitk.BCTextEditSetReadOnly(textEdit, True)
		    paragraphBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph", guitk.constants.BCVertical
		    )
		    newParagraphLineEdit = guitk.BCLineEditCreate(paragraphBtnGroup, "")
		    guitk.BCLineEditSetPlaceholderText(newParagraphLineEdit, "New Paragraph Text")
		    hBox = guitk.BCHBoxCreate(paragraphBtnGroup)
		    data = (textEdit, newParagraphLineEdit)
		    guitk.BCPushButtonCreate(hBox, "Append", appendPara, data)
		    guitk.BCPushButtonCreate(hBox, "Insert", insertPara, data)
		    guitk.BCPushButtonCreate(hBox, "Get Current", getParaText, data)
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrentPara, textEdit)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def appendPara(btn, data):
		    textEdit, lineEdit = data
		    guitk.BCTextEditAppendParagraph(textEdit, guitk.BCLineEditGetText(lineEdit))
		    print(
		        "Paragraph Appended. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def insertPara(btn, data):
		    textEdit, lineEdit = data
		    insertPosition = guitk.BCTextEditGetSelection(textEdit)[0]
		    guitk.BCTextEditInsertParagraph(
		        textEdit, guitk.BCLineEditGetText(lineEdit), insertPosition
		    )
		    print(
		        "Paragraph Inserted. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		def getParaText(btn, data):
		    textEdit, lineEdit = data
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    text = ""
		    for paragraph in range(curSelection[0], curSelection[-2] + 1):
		        text += guitk.BCTextEditGetParagraphText(textEdit, paragraph)
		    guitk.BCLineEditSetText(lineEdit, text)
		    return 0
		
		
		def removeCurrentPara(btn, textEdit):
		    curSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(curSelection[-2], curSelection[0] - 1, -1):
		        guitk.BCTextEditRemoveParagraph(textEdit, paragraph)
		    print(
		        "Paragraph(s) Removed. New Paragraph Count = {}".format(
		            guitk.BCTextEditGetParagraphs(textEdit)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditGetSelection(te: object) -> None:

	"""

	Provides information about the selected text inside BCTextEdit.
	If there is no selection, all ints are set to -1.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	Returns
	-------
	None
		A tuple with 4 items:
		First item is the number of the paragraph in which the selection begins.
		Second item is the index at which the selection begins within the beginning paragraph.
		Third item is the number of the paragraph in which the selection ends.
		Fourth item is the index at which the selection ends within the ending paragraph.

	See Also
	--------
	BCTextEditGetLinesOfParagraph

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 2", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		    # For each widget below set Focus policy to BCNoFocus for display purposes
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    btnTop = guitk.BCPushButtonCreate(
		        hBoxFooter, "Cursor to Top", setCursorTop, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnTop, guitk.constants.BCNoFocus)
		    btnBottom = guitk.BCPushButtonCreate(
		        hBoxFooter, "Scroll to Bottom", scrollDown, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnBottom, guitk.constants.BCNoFocus)
		    btnEnsureVisible = guitk.BCPushButtonCreate(
		        hBoxFooter, "Ensure Cursor Visible", ensureVisible, textEdit
		    )
		    guitk.BCSetFocusPolicy(btnEnsureVisible, guitk.constants.BCNoFocus)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setCursorTop(b, textEdit):
		    guitk.BCTextEditSetCursorPosition(textEdit, 0, 0)
		    return 0
		
		
		def scrollDown(b, textEdit):
		    guitk.BCTextEditScrollToBottom(textEdit)
		    return 0
		
		
		def ensureVisible(b, textEdit):
		    guitk.BCTextEditEnsureCursorVisible(textEdit)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditBlockUpdates(te: object, block: bool) -> None:

	"""

	Restricts updates and repaints for BCTextEdit te.
	This function is normally used to disable updates for a short period of time, for instance to avoid screen flicker or long delays during setting a large text.
	NOTE: Does not block callback functions. To do so, use BCBlockCallBackFunctions()
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	block : bool
		set this parameter to True to block updates, or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditAreUpdatesBlocked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 1", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    chkBoxReadOnly = guitk.BCCheckBoxCreate(hBoxFooter, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReadOnly, setReadOnly, textEdit)
		    chkBoxBlockUpdates = guitk.BCCheckBoxCreate(hBoxFooter, "Block Updates")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxBlockUpdates, blockUpdates, textEdit)
		    chkBoxClear = guitk.BCCheckBoxCreate(hBoxFooter, "Clear Option")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxClear, setClearOption, textEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setReadOnly(cb, state, textEdit):
		    guitk.BCTextEditSetReadOnly(textEdit, state)
		    print("ReadOnly set to: " + str(guitk.BCTextEditIsReadOnly(textEdit)))
		    return 0
		
		
		def blockUpdates(cb, state, textEdit):
		    guitk.BCTextEditBlockUpdates(textEdit, state)
		    print("BlockUpdates set to: " + str(guitk.BCTextEditAreUpdatesBlocked(textEdit)))
		    return 0
		
		
		def setClearOption(cb, state, textEdit):
		    guitk.BCTextEditSetClearOptionVisible(textEdit, state)
		    print(
		        "Context Menu Clear Option is Visible = "
		        + str(guitk.BCTextEditClearOptionVisible(textEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditAreUpdatesBlocked(te: object) -> bool:

	"""

	Returns True if updates are blocked for te, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit

	Returns
	-------
	bool
		True if updates are blocked for te, or False otherwise.

	See Also
	--------
	BCTextEditBlockUpdates

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 1", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    chkBoxReadOnly = guitk.BCCheckBoxCreate(hBoxFooter, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReadOnly, setReadOnly, textEdit)
		    chkBoxBlockUpdates = guitk.BCCheckBoxCreate(hBoxFooter, "Block Updates")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxBlockUpdates, blockUpdates, textEdit)
		    chkBoxClear = guitk.BCCheckBoxCreate(hBoxFooter, "Clear Option")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxClear, setClearOption, textEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setReadOnly(cb, state, textEdit):
		    guitk.BCTextEditSetReadOnly(textEdit, state)
		    print("ReadOnly set to: " + str(guitk.BCTextEditIsReadOnly(textEdit)))
		    return 0
		
		
		def blockUpdates(cb, state, textEdit):
		    guitk.BCTextEditBlockUpdates(textEdit, state)
		    print("BlockUpdates set to: " + str(guitk.BCTextEditAreUpdatesBlocked(textEdit)))
		    return 0
		
		
		def setClearOption(cb, state, textEdit):
		    guitk.BCTextEditSetClearOptionVisible(textEdit, state)
		    print(
		        "Context Menu Clear Option is Visible = "
		        + str(guitk.BCTextEditClearOptionVisible(textEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetMonospaceFont(te: object, mono: bool) -> None:

	"""

	This function forces the BCTextEdit te to display its text with the application's current monospace font.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit

	mono : bool
		set this parameter to True to force the BCTextEdit to display its text with the application's current monospace font.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditMonospaceFont

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditMonospaceFont(te: object) -> bool:

	"""

	Informs whether the BCTextEdit te displays currently its text with monospace font.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit

	Returns
	-------
	bool
		True if BCTextEdit te displays currently its text with monospace font or False otherwise.

	See Also
	--------
	BCTextEditSetMonospaceFont

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTimerCreate(p: object) -> object:

	"""

	Creates a Timer.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the newly created Timer.

	See Also
	--------
	BCTimerSingleShot

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Timer Example", guitk.constants.BCOnExitDestroy)
		
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    guitk.BCProgressBarSetProgress(progressBar, 0)
		    guitk.BCSpacerCreate(w)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    rb = guitk.BCPushButtonCreate(hlayout, "Start timer", startStopTimer, timer)
		    sht = guitk.BCPushButtonCreate(
		        hlayout, "Single shot timer", startSingleShotTimer, progressBar
		    )
		
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hlayout, "Time interval : ")
		    spin = guitk.BCSpinBoxCreate(hlayout)
		    guitk.BCSpinBoxSetMinValue(spin, 0)
		    guitk.BCSpinBoxSetMaxValue(spin, 5000)
		    guitk.BCSpinBoxSetLineStep(spin, 100)
		    guitk.BCSpinBoxSetValue(spin, 100)
		    guitk.BCLabelCreate(hlayout, "msec")
		    guitk.BCSetUserDataKey(progressBar, "TIMEOUT", spin)
		    guitk.BCSetUserDataKey(timer, "TIMEOUT", spin)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, intervalChangedFunc, timer)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def startStopTimer(b, timer):
		    if guitk.BCTimerIsActive(timer) == True:
		        guitk.BCTimerStop(timer)
		        guitk.BCButtonSetText(b, "Start timer")
		    else:
		        spin = guitk.BCGetUserDataKey(timer, "TIMEOUT")
		        interval = guitk.BCSpinBoxGetInt(spin)
		        guitk.BCTimerStart(timer, interval, False)
		        guitk.BCButtonSetText(b, "Stop timer")
		    return 0
		
		
		def startSingleShotTimer(b, progressBar):
		    spin = guitk.BCGetUserDataKey(progressBar, "TIMEOUT")
		    interval = guitk.BCSpinBoxGetInt(spin)
		    guitk.BCTimerSingleShot(interval, timeoutSingleshotFunc, progressBar)
		    return 0
		
		
		def intervalChangedFunc(sb, val, timer):
		    guitk.BCTimerChangeInterval(timer, val)
		    return 0
		
		
		def timeoutFunc(timer, progressBar):
		    return setProgress(progressBar)
		
		
		def timeoutSingleshotFunc(progressBar):
		    return setProgress(progressBar)
		
		
		def setProgress(progressBar):
		    progress = guitk.BCProgressBarProgress(progressBar)
		    guitk.BCProgressBarSetProgress(progressBar, progress + 1)
		    if progress >= 100:
		        guitk.BCProgressBarSetProgress(progressBar, 0)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTimerStart(timer: object, ms: int, singleShot: bool) -> int:

	"""

	Starts the timer and lets it run for ms milliseconds.
	This function is not supported under VR mode.

	Parameters
	----------
	timer : object
		the timer.

	ms : int
		the timer interval that the timer is required to run.

	singleShot : bool
		set this parameter to True for the timer to be a single shot timer, or False otherwise. If singleShot is True, the timer will be activated only once; otherwise it will continue until it is stopped.

	Returns
	-------
	int
		the id of the timer.

	See Also
	--------
	BCTimerStop

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Timer Example", guitk.constants.BCOnExitDestroy)
		
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    guitk.BCProgressBarSetProgress(progressBar, 0)
		    guitk.BCSpacerCreate(w)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    rb = guitk.BCPushButtonCreate(hlayout, "Start timer", startStopTimer, timer)
		    sht = guitk.BCPushButtonCreate(
		        hlayout, "Single shot timer", startSingleShotTimer, progressBar
		    )
		
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hlayout, "Time interval : ")
		    spin = guitk.BCSpinBoxCreate(hlayout)
		    guitk.BCSpinBoxSetMinValue(spin, 0)
		    guitk.BCSpinBoxSetMaxValue(spin, 5000)
		    guitk.BCSpinBoxSetLineStep(spin, 100)
		    guitk.BCSpinBoxSetValue(spin, 100)
		    guitk.BCLabelCreate(hlayout, "msec")
		    guitk.BCSetUserDataKey(progressBar, "TIMEOUT", spin)
		    guitk.BCSetUserDataKey(timer, "TIMEOUT", spin)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, intervalChangedFunc, timer)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def startStopTimer(b, timer):
		    if guitk.BCTimerIsActive(timer) == True:
		        guitk.BCTimerStop(timer)
		        guitk.BCButtonSetText(b, "Start timer")
		    else:
		        spin = guitk.BCGetUserDataKey(timer, "TIMEOUT")
		        interval = guitk.BCSpinBoxGetInt(spin)
		        guitk.BCTimerStart(timer, interval, False)
		        guitk.BCButtonSetText(b, "Stop timer")
		    return 0
		
		
		def startSingleShotTimer(b, progressBar):
		    spin = guitk.BCGetUserDataKey(progressBar, "TIMEOUT")
		    interval = guitk.BCSpinBoxGetInt(spin)
		    guitk.BCTimerSingleShot(interval, timeoutSingleshotFunc, progressBar)
		    return 0
		
		
		def intervalChangedFunc(sb, val, timer):
		    guitk.BCTimerChangeInterval(timer, val)
		    return 0
		
		
		def timeoutFunc(timer, progressBar):
		    return setProgress(progressBar)
		
		
		def timeoutSingleshotFunc(progressBar):
		    return setProgress(progressBar)
		
		
		def setProgress(progressBar):
		    progress = guitk.BCProgressBarProgress(progressBar)
		    guitk.BCProgressBarSetProgress(progressBar, progress + 1)
		    if progress >= 100:
		        guitk.BCProgressBarSetProgress(progressBar, 0)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTimerIsActive(timer: object) -> bool:

	"""

	Returns True if timer timer is active, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	timer : object
		the timer.

	Returns
	-------
	bool
		True if timer is active, or False if it is not.

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Timer Example", guitk.constants.BCOnExitDestroy)
		
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    guitk.BCProgressBarSetProgress(progressBar, 0)
		    guitk.BCSpacerCreate(w)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    rb = guitk.BCPushButtonCreate(hlayout, "Start timer", startStopTimer, timer)
		    sht = guitk.BCPushButtonCreate(
		        hlayout, "Single shot timer", startSingleShotTimer, progressBar
		    )
		
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hlayout, "Time interval : ")
		    spin = guitk.BCSpinBoxCreate(hlayout)
		    guitk.BCSpinBoxSetMinValue(spin, 0)
		    guitk.BCSpinBoxSetMaxValue(spin, 5000)
		    guitk.BCSpinBoxSetLineStep(spin, 100)
		    guitk.BCSpinBoxSetValue(spin, 100)
		    guitk.BCLabelCreate(hlayout, "msec")
		    guitk.BCSetUserDataKey(progressBar, "TIMEOUT", spin)
		    guitk.BCSetUserDataKey(timer, "TIMEOUT", spin)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, intervalChangedFunc, timer)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def startStopTimer(b, timer):
		    if guitk.BCTimerIsActive(timer) == True:
		        guitk.BCTimerStop(timer)
		        guitk.BCButtonSetText(b, "Start timer")
		    else:
		        spin = guitk.BCGetUserDataKey(timer, "TIMEOUT")
		        interval = guitk.BCSpinBoxGetInt(spin)
		        guitk.BCTimerStart(timer, interval, False)
		        guitk.BCButtonSetText(b, "Stop timer")
		    return 0
		
		
		def startSingleShotTimer(b, progressBar):
		    spin = guitk.BCGetUserDataKey(progressBar, "TIMEOUT")
		    interval = guitk.BCSpinBoxGetInt(spin)
		    guitk.BCTimerSingleShot(interval, timeoutSingleshotFunc, progressBar)
		    return 0
		
		
		def intervalChangedFunc(sb, val, timer):
		    guitk.BCTimerChangeInterval(timer, val)
		    return 0
		
		
		def timeoutFunc(timer, progressBar):
		    return setProgress(progressBar)
		
		
		def timeoutSingleshotFunc(progressBar):
		    return setProgress(progressBar)
		
		
		def setProgress(progressBar):
		    progress = guitk.BCProgressBarProgress(progressBar)
		    guitk.BCProgressBarSetProgress(progressBar, progress + 1)
		    if progress >= 100:
		        guitk.BCProgressBarSetProgress(progressBar, 0)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTimerChangeInterval(timer: object, ms: int) -> None:

	"""

	Changes the time interval for the given timer.
	This function is not supported under VR mode.

	Parameters
	----------
	timer : object
		the timer

	ms : int
		the new interval in milliseconds.

	Returns
	-------
	None

	See Also
	--------
	BCTimerStart

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Timer Example", guitk.constants.BCOnExitDestroy)
		
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    guitk.BCProgressBarSetProgress(progressBar, 0)
		    guitk.BCSpacerCreate(w)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    rb = guitk.BCPushButtonCreate(hlayout, "Start timer", startStopTimer, timer)
		    sht = guitk.BCPushButtonCreate(
		        hlayout, "Single shot timer", startSingleShotTimer, progressBar
		    )
		
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hlayout, "Time interval : ")
		    spin = guitk.BCSpinBoxCreate(hlayout)
		    guitk.BCSpinBoxSetMinValue(spin, 0)
		    guitk.BCSpinBoxSetMaxValue(spin, 5000)
		    guitk.BCSpinBoxSetLineStep(spin, 100)
		    guitk.BCSpinBoxSetValue(spin, 100)
		    guitk.BCLabelCreate(hlayout, "msec")
		    guitk.BCSetUserDataKey(progressBar, "TIMEOUT", spin)
		    guitk.BCSetUserDataKey(timer, "TIMEOUT", spin)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, intervalChangedFunc, timer)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def startStopTimer(b, timer):
		    if guitk.BCTimerIsActive(timer) == True:
		        guitk.BCTimerStop(timer)
		        guitk.BCButtonSetText(b, "Start timer")
		    else:
		        spin = guitk.BCGetUserDataKey(timer, "TIMEOUT")
		        interval = guitk.BCSpinBoxGetInt(spin)
		        guitk.BCTimerStart(timer, interval, False)
		        guitk.BCButtonSetText(b, "Stop timer")
		    return 0
		
		
		def startSingleShotTimer(b, progressBar):
		    spin = guitk.BCGetUserDataKey(progressBar, "TIMEOUT")
		    interval = guitk.BCSpinBoxGetInt(spin)
		    guitk.BCTimerSingleShot(interval, timeoutSingleshotFunc, progressBar)
		    return 0
		
		
		def intervalChangedFunc(sb, val, timer):
		    guitk.BCTimerChangeInterval(timer, val)
		    return 0
		
		
		def timeoutFunc(timer, progressBar):
		    return setProgress(progressBar)
		
		
		def timeoutSingleshotFunc(progressBar):
		    return setProgress(progressBar)
		
		
		def setProgress(progressBar):
		    progress = guitk.BCProgressBarProgress(progressBar)
		    guitk.BCProgressBarSetProgress(progressBar, progress + 1)
		    if progress >= 100:
		        guitk.BCProgressBarSetProgress(progressBar, 0)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTimerStop(timer: object) -> None:

	"""

	Stops timer timer.
	This function is not supported under VR mode.

	Parameters
	----------
	timer : object
		the timer

	Returns
	-------
	None

	See Also
	--------
	BCTimerStart

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Timer Example", guitk.constants.BCOnExitDestroy)
		
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    guitk.BCProgressBarSetProgress(progressBar, 0)
		    guitk.BCSpacerCreate(w)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    rb = guitk.BCPushButtonCreate(hlayout, "Start timer", startStopTimer, timer)
		    sht = guitk.BCPushButtonCreate(
		        hlayout, "Single shot timer", startSingleShotTimer, progressBar
		    )
		
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hlayout, "Time interval : ")
		    spin = guitk.BCSpinBoxCreate(hlayout)
		    guitk.BCSpinBoxSetMinValue(spin, 0)
		    guitk.BCSpinBoxSetMaxValue(spin, 5000)
		    guitk.BCSpinBoxSetLineStep(spin, 100)
		    guitk.BCSpinBoxSetValue(spin, 100)
		    guitk.BCLabelCreate(hlayout, "msec")
		    guitk.BCSetUserDataKey(progressBar, "TIMEOUT", spin)
		    guitk.BCSetUserDataKey(timer, "TIMEOUT", spin)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, intervalChangedFunc, timer)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def startStopTimer(b, timer):
		    if guitk.BCTimerIsActive(timer) == True:
		        guitk.BCTimerStop(timer)
		        guitk.BCButtonSetText(b, "Start timer")
		    else:
		        spin = guitk.BCGetUserDataKey(timer, "TIMEOUT")
		        interval = guitk.BCSpinBoxGetInt(spin)
		        guitk.BCTimerStart(timer, interval, False)
		        guitk.BCButtonSetText(b, "Stop timer")
		    return 0
		
		
		def startSingleShotTimer(b, progressBar):
		    spin = guitk.BCGetUserDataKey(progressBar, "TIMEOUT")
		    interval = guitk.BCSpinBoxGetInt(spin)
		    guitk.BCTimerSingleShot(interval, timeoutSingleshotFunc, progressBar)
		    return 0
		
		
		def intervalChangedFunc(sb, val, timer):
		    guitk.BCTimerChangeInterval(timer, val)
		    return 0
		
		
		def timeoutFunc(timer, progressBar):
		    return setProgress(progressBar)
		
		
		def timeoutSingleshotFunc(progressBar):
		    return setProgress(progressBar)
		
		
		def setProgress(progressBar):
		    progress = guitk.BCProgressBarProgress(progressBar)
		    guitk.BCProgressBarSetProgress(progressBar, progress + 1)
		    if progress >= 100:
		        guitk.BCProgressBarSetProgress(progressBar, 0)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTimerSetTimeoutFunction(timer: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be executed on timer timeout.
	This function is not supported under VR mode.

	Parameters
	----------
	timer : object
		the timer.

	funct : Callable
		the function that will be executed on timer timeout. See BC_TIMER_TIMEOUT_FUNCTION for details.
		integer BC_TIMER_TIMEOUT_FUNCTION(timer, data)
		The function to be called on timer timeout.
		
		Arguments
		          * timer : object
		                    the timer.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Timer Example", guitk.constants.BCOnExitDestroy)
		
		    timer = guitk.BCTimerCreate(w)
		    guitk.BCSpacerCreate(w)
		    progressBar = guitk.BCProgressBarCreate(w, 100)
		    guitk.BCProgressBarSetProgress(progressBar, 0)
		    guitk.BCSpacerCreate(w)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    rb = guitk.BCPushButtonCreate(hlayout, "Start timer", startStopTimer, timer)
		    sht = guitk.BCPushButtonCreate(
		        hlayout, "Single shot timer", startSingleShotTimer, progressBar
		    )
		
		    guitk.BCTimerSetTimeoutFunction(timer, timeoutFunc, progressBar)
		
		    hlayout = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hlayout, "Time interval : ")
		    spin = guitk.BCSpinBoxCreate(hlayout)
		    guitk.BCSpinBoxSetMinValue(spin, 0)
		    guitk.BCSpinBoxSetMaxValue(spin, 5000)
		    guitk.BCSpinBoxSetLineStep(spin, 100)
		    guitk.BCSpinBoxSetValue(spin, 100)
		    guitk.BCLabelCreate(hlayout, "msec")
		    guitk.BCSetUserDataKey(progressBar, "TIMEOUT", spin)
		    guitk.BCSetUserDataKey(timer, "TIMEOUT", spin)
		    guitk.BCSpinBoxSetValueChangedFunction(spin, intervalChangedFunc, timer)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def startStopTimer(b, timer):
		    if guitk.BCTimerIsActive(timer) == True:
		        guitk.BCTimerStop(timer)
		        guitk.BCButtonSetText(b, "Start timer")
		    else:
		        spin = guitk.BCGetUserDataKey(timer, "TIMEOUT")
		        interval = guitk.BCSpinBoxGetInt(spin)
		        guitk.BCTimerStart(timer, interval, False)
		        guitk.BCButtonSetText(b, "Stop timer")
		    return 0
		
		
		def startSingleShotTimer(b, progressBar):
		    spin = guitk.BCGetUserDataKey(progressBar, "TIMEOUT")
		    interval = guitk.BCSpinBoxGetInt(spin)
		    guitk.BCTimerSingleShot(interval, timeoutSingleshotFunc, progressBar)
		    return 0
		
		
		def intervalChangedFunc(sb, val, timer):
		    guitk.BCTimerChangeInterval(timer, val)
		    return 0
		
		
		def timeoutFunc(timer, progressBar):
		    return setProgress(progressBar)
		
		
		def timeoutSingleshotFunc(progressBar):
		    return setProgress(progressBar)
		
		
		def setProgress(progressBar):
		    progress = guitk.BCProgressBarProgress(progressBar)
		    guitk.BCProgressBarSetProgress(progressBar, progress + 1)
		    if progress >= 100:
		        guitk.BCProgressBarSetProgress(progressBar, 0)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTimerSingleShot(ms: int, funct: Callable, data: Any=None) -> None:

	"""

	Fires a single shot timer for ms milliseconds and runs funct when it times out.
	It is very convenient to use this function because you do not need to bother with a Timer object.
	This function is heavily used when GUI objects are deleted inside a callback function.
	This function is not supported under VR mode.

	Parameters
	----------
	ms : int
		the interval for which the timer will run (in milliseconds). As a special case, a BCTimer with timeout 0 times out as soon as all the events in the window system's event queue have been processed.

	funct : Callable
		the function that will run on timer timeout. 
		See BC_TIMER_SINGLE_SHOT_FUNCTION for details.
		integer BC_TIMER_SINGLE_SHOT_FUNCTION(data)
		The function to be called on a given time interval.
		
		Arguments
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Main Window", guitk.constants.BCOnExitDestroy)
		    guitk.BCDialogButtonBoxCreate(window)
		    guitk.BCTimerSingleShot(0, timerFunct, None)
		    print("TimerSingleShot will be triggered after 'Main Window' is shown")
		    guitk.BCShow(window)
		    print("'Main Window' closed")
		
		
		def timerFunct(data):
		    window = guitk.BCWindowCreate("Second Window", guitk.constants.BCOnExitDestroy)
		    guitk.BCDialogButtonBoxCreate(window)
		    guitk.BCShow(window)
		    print("'Second Window' closed")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxCreate(p: object) -> object:

	"""

	Creates a new BCToolBox with parent p.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created BCToolBox.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tool Box", guitk.constants.BCOnExitDestroy)
		
		    toolbox = guitk.BCToolBoxCreate(window)
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCPushButtonCreate(frame, "Button 1", None)
		    guitk.BCPushButtonCreate(frame, "Button 2", None)
		    guitk.BCPushButtonCreate(frame, "Button 3", None)
		    guitk.BCSpacerCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Buttons")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLineEditCreate(frame, "Line Edit")
		    guitk.BCSpinBoxCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Input")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCButtonGroupCreate(frame, "ButtonGroup", guitk.constants.BCVertical)
		    guitk.BCFrameCreate(frame)
		    guitk.BCFrameSetShadow(frame, guitk.constants.BCRaised)
		    guitk.BCFrameSetShape(frame, guitk.constants.BCPanel)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Containers")
		    guitk.BCToolBoxSetItemToolTip(toolbox, 2, "This is a container item")
		    guitk.BCToolBoxSetItemEnabled(toolbox, 2, False)
		
		    listView = guitk.BCListViewCreate(toolbox, 2, ["Column 1", "Column 2"], True)
		    for i in range(4):
		        item = guitk.BCListViewAddTopLevelItem(listView)
		        guitk.BCListViewItemSetText(item, 0, "Item " + str(i))
		        guitk.BCListVIewItemSetText(item, 1, "val" + str(i))
		        guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCToolBoxAddItem(toolbox, listView, "View")
		
		    guitk.BCToolBoxSetCurrentChangedFunction(toolbox, toolboxChanged, None)
		    guitk.BCToolBoxSetCurrentIndex(toolbox, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunct, None)
		    guitk.BCShow(window)
		
		
		def acceptFunct(window, data):
		    return 0
		
		
		def toolboxChanged(tb, index, data):
		    itemCount = guitk.BCToolBoxCount(tb)
		    print("Total Items are: " + str(itemCount))
		    print("ToolBox Current changed to item: " + str(guitk.BCToolBoxCurrentIndex(tb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxAddItem(tb: object, w: object, label: str) -> None:

	"""

	Adds item w which is a widget to the end of BCToolBox tb and sets its
	label to label.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	w : object
		the widget that will be added to tb.

	label : str
		the label of the added item.

	Returns
	-------
	None

	See Also
	--------
	BCToolBoxInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tool Box", guitk.constants.BCOnExitDestroy)
		
		    toolbox = guitk.BCToolBoxCreate(window)
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCPushButtonCreate(frame, "Button 1", None)
		    guitk.BCPushButtonCreate(frame, "Button 2", None)
		    guitk.BCPushButtonCreate(frame, "Button 3", None)
		    guitk.BCSpacerCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Buttons")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLineEditCreate(frame, "Line Edit")
		    guitk.BCSpinBoxCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Input")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCButtonGroupCreate(frame, "ButtonGroup", guitk.constants.BCVertical)
		    guitk.BCFrameCreate(frame)
		    guitk.BCFrameSetShadow(frame, guitk.constants.BCRaised)
		    guitk.BCFrameSetShape(frame, guitk.constants.BCPanel)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Containers")
		    guitk.BCToolBoxSetItemToolTip(toolbox, 2, "This is a container item")
		    guitk.BCToolBoxSetItemEnabled(toolbox, 2, False)
		
		    listView = guitk.BCListViewCreate(toolbox, 2, ["Column 1", "Column 2"], True)
		    for i in range(4):
		        item = guitk.BCListViewAddTopLevelItem(listView)
		        guitk.BCListViewItemSetText(item, 0, "Item " + str(i))
		        guitk.BCListVIewItemSetText(item, 1, "val" + str(i))
		        guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCToolBoxAddItem(toolbox, listView, "View")
		
		    guitk.BCToolBoxSetCurrentChangedFunction(toolbox, toolboxChanged, None)
		    guitk.BCToolBoxSetCurrentIndex(toolbox, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunct, None)
		    guitk.BCShow(window)
		
		
		def acceptFunct(window, data):
		    return 0
		
		
		def toolboxChanged(tb, index, data):
		    itemCount = guitk.BCToolBoxCount(tb)
		    print("Total Items are: " + str(itemCount))
		    print("ToolBox Current changed to item: " + str(guitk.BCToolBoxCurrentIndex(tb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxInsertItem(tb: object, w: object, label: str, index: int) -> None:

	"""

	Inserts item w into BCToolBox tb at index index. It also sets its label to label.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	w : object
		the widget that will be inserted to tb.

	label : str
		the label of the inserted item.

	index : int
		the index at which w will be inserted.if index is out of range then the widget will be inserted at the bottom of the BCToolbox tb.

	Returns
	-------
	None

	See Also
	--------
	BCToolBoxAddItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ToolBox Insert/Remove Colored Frames Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(hBox, "Insert Here", insertHere, [toolBox, 0])
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrent, toolBox)
		    guitk.BCShow(window)
		
		
		def insertHere(b, data):
		    toolBox = data[0]
		    frameId = data[1]
		    data[1] = data[1] + 1
		    frame = guitk.BCFrameCreate(toolBox)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCBoxLayoutInsert(
		        bLayout, guitk.BCLabelCreate(bLayout, "Frame {} contents".format(frameId)), -1
		    )
		    currentIndex = guitk.BCToolBoxCurrentIndex(toolBox)
		    guitk.BCToolBoxInsertItem(toolBox, frame, "Frame " + str(frameId), currentIndex)
		    print(
		        "Item inserted at index={}. Current ToolBoxCount={}".format(
		            currentIndex, guitk.BCToolBoxCount(toolBox)
		        )
		    )
		    return 0
		
		
		def removeCurrent(b, toolBox):
		    frameToRemove = guitk.BCToolBoxCurrentItem(toolBox)
		    if frameToRemove:
		        guitk.BCToolBoxRemoveItem(toolBox, frameToRemove)
		        guitk.BCDestroyLater(frameToRemove)
		        print(
		            "Current Item removed. Current ToolBoxCount={}".format(
		                guitk.BCToolBoxCount(toolBox)
		            )
		        )
		    else:
		        print("No Current Item to remove.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxRemoveItem(tb: object, w: object) -> None:

	"""

	Removes item w from BCToolBox tb.
	NOTE: The item w is not deleted. To delete it, use BCDestroyLater() after removing it.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	w : object
		the widget that will be removed from tb.

	Returns
	-------
	None

	See Also
	--------
	BCToolBoxAddItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ToolBox Insert/Remove Colored Frames Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(hBox, "Insert Here", insertHere, [toolBox, 0])
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrent, toolBox)
		    guitk.BCShow(window)
		
		
		def insertHere(b, data):
		    toolBox = data[0]
		    frameId = data[1]
		    data[1] = data[1] + 1
		    frame = guitk.BCFrameCreate(toolBox)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCBoxLayoutInsert(
		        bLayout, guitk.BCLabelCreate(bLayout, "Frame {} contents".format(frameId)), -1
		    )
		    currentIndex = guitk.BCToolBoxCurrentIndex(toolBox)
		    guitk.BCToolBoxInsertItem(toolBox, frame, "Frame " + str(frameId), currentIndex)
		    print(
		        "Item inserted at index={}. Current ToolBoxCount={}".format(
		            currentIndex, guitk.BCToolBoxCount(toolBox)
		        )
		    )
		    return 0
		
		
		def removeCurrent(b, toolBox):
		    frameToRemove = guitk.BCToolBoxCurrentItem(toolBox)
		    if frameToRemove:
		        guitk.BCToolBoxRemoveItem(toolBox, frameToRemove)
		        guitk.BCDestroyLater(frameToRemove)
		        print(
		            "Current Item removed. Current ToolBoxCount={}".format(
		                guitk.BCToolBoxCount(toolBox)
		            )
		        )
		    else:
		        print("No Current Item to remove.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxSetItemEnabled(tb: object, index: int, enabled: bool) -> None:

	"""

	Sets whether the item at index index is enabled or not.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	index : int
		the index of the item that will be set.

	enabled : bool
		set this parameter to True to enable the item, or False to disable it.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tool Box", guitk.constants.BCOnExitDestroy)
		
		    toolbox = guitk.BCToolBoxCreate(window)
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCPushButtonCreate(frame, "Button 1", None)
		    guitk.BCPushButtonCreate(frame, "Button 2", None)
		    guitk.BCPushButtonCreate(frame, "Button 3", None)
		    guitk.BCSpacerCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Buttons")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLineEditCreate(frame, "Line Edit")
		    guitk.BCSpinBoxCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Input")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCButtonGroupCreate(frame, "ButtonGroup", guitk.constants.BCVertical)
		    guitk.BCFrameCreate(frame)
		    guitk.BCFrameSetShadow(frame, guitk.constants.BCRaised)
		    guitk.BCFrameSetShape(frame, guitk.constants.BCPanel)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Containers")
		    guitk.BCToolBoxSetItemToolTip(toolbox, 2, "This is a container item")
		    guitk.BCToolBoxSetItemEnabled(toolbox, 2, False)
		
		    listView = guitk.BCListViewCreate(toolbox, 2, ["Column 1", "Column 2"], True)
		    for i in range(4):
		        item = guitk.BCListViewAddTopLevelItem(listView)
		        guitk.BCListViewItemSetText(item, 0, "Item " + str(i))
		        guitk.BCListVIewItemSetText(item, 1, "val" + str(i))
		        guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCToolBoxAddItem(toolbox, listView, "View")
		
		    guitk.BCToolBoxSetCurrentChangedFunction(toolbox, toolboxChanged, None)
		    guitk.BCToolBoxSetCurrentIndex(toolbox, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunct, None)
		    guitk.BCShow(window)
		
		
		def acceptFunct(window, data):
		    return 0
		
		
		def toolboxChanged(tb, index, data):
		    itemCount = guitk.BCToolBoxCount(tb)
		    print("Total Items are: " + str(itemCount))
		    print("ToolBox Current changed to item: " + str(guitk.BCToolBoxCurrentIndex(tb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxSetItemToolTip(tb: object, index: int, tip: str) -> None:

	"""

	Sets the tool tip of the item at index index to tip.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	index : int
		the index of the item that will be set.

	tip : str
		the text that will be displayed as the item's tool tip.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tool Box", guitk.constants.BCOnExitDestroy)
		
		    toolbox = guitk.BCToolBoxCreate(window)
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCPushButtonCreate(frame, "Button 1", None)
		    guitk.BCPushButtonCreate(frame, "Button 2", None)
		    guitk.BCPushButtonCreate(frame, "Button 3", None)
		    guitk.BCSpacerCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Buttons")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLineEditCreate(frame, "Line Edit")
		    guitk.BCSpinBoxCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Input")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCButtonGroupCreate(frame, "ButtonGroup", guitk.constants.BCVertical)
		    guitk.BCFrameCreate(frame)
		    guitk.BCFrameSetShadow(frame, guitk.constants.BCRaised)
		    guitk.BCFrameSetShape(frame, guitk.constants.BCPanel)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Containers")
		    guitk.BCToolBoxSetItemToolTip(toolbox, 2, "This is a container item")
		    guitk.BCToolBoxSetItemEnabled(toolbox, 2, False)
		
		    listView = guitk.BCListViewCreate(toolbox, 2, ["Column 1", "Column 2"], True)
		    for i in range(4):
		        item = guitk.BCListViewAddTopLevelItem(listView)
		        guitk.BCListViewItemSetText(item, 0, "Item " + str(i))
		        guitk.BCListVIewItemSetText(item, 1, "val" + str(i))
		        guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCToolBoxAddItem(toolbox, listView, "View")
		
		    guitk.BCToolBoxSetCurrentChangedFunction(toolbox, toolboxChanged, None)
		    guitk.BCToolBoxSetCurrentIndex(toolbox, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunct, None)
		    guitk.BCShow(window)
		
		
		def acceptFunct(window, data):
		    return 0
		
		
		def toolboxChanged(tb, index, data):
		    itemCount = guitk.BCToolBoxCount(tb)
		    print("Total Items are: " + str(itemCount))
		    print("ToolBox Current changed to item: " + str(guitk.BCToolBoxCurrentIndex(tb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxSetItemLabel(tb: object, item: object, label: str) -> None:

	"""

	Sets the title of toolBoxItem w of the BCToolBox tb to label.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	item : object
		the toolBoxItem whose title we want to set.

	label : str
		the string that will be set as title to the toolBoxItem item.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Move Button ToolBox Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    favorites = frameWithMoveButtonsCreate(toolBox, [], "")
		    guitk.BCSetUserDataKey(favorites, "nItems", 0)
		    hotPoints = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Insert", "Project", "Parametrical", "Delete"], "Points: "
		    )
		    cons = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Paste", "Release", "Fill Hole"], "Cons: "
		    )
		    faces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Cut", "Delete", "Undelete"], "Faces: "
		    )
		    surfaces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Coons", "Fit", "Extend"], "Surfaces: "
		    )
		    guitk.BCToolBoxAddItem(toolBox, favorites, "Favorites 0")
		    guitk.BCToolBoxAddItem(toolBox, hotPoints, "Hot Points")
		    guitk.BCToolBoxAddItem(toolBox, cons, "Cons")
		    guitk.BCToolBoxAddItem(toolBox, faces, "Faces")
		    guitk.BCToolBoxAddItem(toolBox, surfaces, "Surfaces")
		    print(
		        "Favorites index = {}\\nHot Points index = {}\\nCons index = {}\\nFaces index = {}\\nSurfacesIndex = {}".format(
		            guitk.BCToolBoxIndexOf(toolBox, favorites),
		            guitk.BCToolBoxIndexOf(toolBox, hotPoints),
		            guitk.BCToolBoxIndexOf(toolBox, cons),
		            guitk.BCToolBoxIndexOf(toolBox, faces),
		            guitk.BCToolBoxIndexOf(toolBox, surfaces),
		        )
		    )
		    guitk.BCShow(window)
		
		
		def frameWithMoveButtonsCreate(toolBox, btnsStrList, prefix):
		    frame = guitk.BCFrameCreate(toolBox)
		    fLayout = guitk.BCFlowLayoutCreate(frame)
		    for btnText in btnsStrList:
		        toolBtn = guitk.BCToolButtonCreate(toolBox, "", btnText, printMe, toolBox)
		        popupMenu = guitk.BCPopupMenuCreate(toolBtn)
		        guitk.BCButtonSetPopup(toolBtn, popupMenu)
		        guitk.BCPopupMenuInsertItem(
		            popupMenu,
		            "Move to favorites",
		            moveButtonToFavorites,
		            (fLayout, toolBox, toolBtn, prefix),
		        )
		        guitk.BCFlowLayoutInsert(fLayout, toolBtn)
		    return frame
		
		
		def printMe(b, toolBox):
		    print(
		        "'{}' Clicked! Current Index = {}".format(
		            guitk.BCButtonText(b), guitk.BCToolBoxCurrentIndex(toolBox)
		        )
		    )
		    return 0
		
		
		def moveButtonToFavorites(popupMenu, id, data):
		    fLayout, toolBox, toolBtn, prefix = data
		    favorites = guitk.BCToolBoxItem(toolBox, 0)
		    guitk.BCFlowLayoutRemove(fLayout, toolBtn)
		    position = guitk.BCGetUserDataKey(favorites, "nItems")
		    favoritesFLayout = guitk.BCLayout(favorites)
		    guitk.BCFlowLayoutInsert(favoritesFLayout, toolBtn)
		    guitk.BCSetUserDataKey(favorites, "nItems", position + 1)
		    guitk.BCToolBoxSetItemLabel(toolBox, favorites, "Favorites " + str(position + 1))
		    guitk.BCToolBoxSetCurrentItem(toolBox, favorites)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, id, False)
		    guitk.BCButtonSetText(toolBtn, prefix + guitk.BCButtonText(toolBtn))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxCurrentItem(tb: object) -> object:

	"""

	Returns the current item of BCToolBox tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	Returns
	-------
	object
		the current item of tb.

	See Also
	--------
	BCToolBoxSetCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ToolBox Insert/Remove Colored Frames Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(hBox, "Insert Here", insertHere, [toolBox, 0])
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrent, toolBox)
		    guitk.BCShow(window)
		
		
		def insertHere(b, data):
		    toolBox = data[0]
		    frameId = data[1]
		    data[1] = data[1] + 1
		    frame = guitk.BCFrameCreate(toolBox)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCBoxLayoutInsert(
		        bLayout, guitk.BCLabelCreate(bLayout, "Frame {} contents".format(frameId)), -1
		    )
		    currentIndex = guitk.BCToolBoxCurrentIndex(toolBox)
		    guitk.BCToolBoxInsertItem(toolBox, frame, "Frame " + str(frameId), currentIndex)
		    print(
		        "Item inserted at index={}. Current ToolBoxCount={}".format(
		            currentIndex, guitk.BCToolBoxCount(toolBox)
		        )
		    )
		    return 0
		
		
		def removeCurrent(b, toolBox):
		    frameToRemove = guitk.BCToolBoxCurrentItem(toolBox)
		    if frameToRemove:
		        guitk.BCToolBoxRemoveItem(toolBox, frameToRemove)
		        guitk.BCDestroyLater(frameToRemove)
		        print(
		            "Current Item removed. Current ToolBoxCount={}".format(
		                guitk.BCToolBoxCount(toolBox)
		            )
		        )
		    else:
		        print("No Current Item to remove.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxCurrentIndex(tb: object) -> int:

	"""

	Returns the index of the current item of BCToolBox tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	Returns
	-------
	int
		the index of the current item.

	See Also
	--------
	BCToolBoxSetCurrentIndex

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ToolBox Insert/Remove Colored Frames Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(hBox, "Insert Here", insertHere, [toolBox, 0])
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrent, toolBox)
		    guitk.BCShow(window)
		
		
		def insertHere(b, data):
		    toolBox = data[0]
		    frameId = data[1]
		    data[1] = data[1] + 1
		    frame = guitk.BCFrameCreate(toolBox)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCBoxLayoutInsert(
		        bLayout, guitk.BCLabelCreate(bLayout, "Frame {} contents".format(frameId)), -1
		    )
		    currentIndex = guitk.BCToolBoxCurrentIndex(toolBox)
		    guitk.BCToolBoxInsertItem(toolBox, frame, "Frame " + str(frameId), currentIndex)
		    print(
		        "Item inserted at index={}. Current ToolBoxCount={}".format(
		            currentIndex, guitk.BCToolBoxCount(toolBox)
		        )
		    )
		    return 0
		
		
		def removeCurrent(b, toolBox):
		    frameToRemove = guitk.BCToolBoxCurrentItem(toolBox)
		    if frameToRemove:
		        guitk.BCToolBoxRemoveItem(toolBox, frameToRemove)
		        guitk.BCDestroyLater(frameToRemove)
		        print(
		            "Current Item removed. Current ToolBoxCount={}".format(
		                guitk.BCToolBoxCount(toolBox)
		            )
		        )
		    else:
		        print("No Current Item to remove.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxSetCurrentItem(tb: object, w: object) -> None:

	"""

	Sets the current item of BCToolBox tb to be w.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	w : object
		the new current item.

	Returns
	-------
	None

	See Also
	--------
	BCToolBoxSetCurrentIndex

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Move Button ToolBox Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    favorites = frameWithMoveButtonsCreate(toolBox, [], "")
		    guitk.BCSetUserDataKey(favorites, "nItems", 0)
		    hotPoints = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Insert", "Project", "Parametrical", "Delete"], "Points: "
		    )
		    cons = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Paste", "Release", "Fill Hole"], "Cons: "
		    )
		    faces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Cut", "Delete", "Undelete"], "Faces: "
		    )
		    surfaces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Coons", "Fit", "Extend"], "Surfaces: "
		    )
		    guitk.BCToolBoxAddItem(toolBox, favorites, "Favorites 0")
		    guitk.BCToolBoxAddItem(toolBox, hotPoints, "Hot Points")
		    guitk.BCToolBoxAddItem(toolBox, cons, "Cons")
		    guitk.BCToolBoxAddItem(toolBox, faces, "Faces")
		    guitk.BCToolBoxAddItem(toolBox, surfaces, "Surfaces")
		    print(
		        "Favorites index = {}\\nHot Points index = {}\\nCons index = {}\\nFaces index = {}\\nSurfacesIndex = {}".format(
		            guitk.BCToolBoxIndexOf(toolBox, favorites),
		            guitk.BCToolBoxIndexOf(toolBox, hotPoints),
		            guitk.BCToolBoxIndexOf(toolBox, cons),
		            guitk.BCToolBoxIndexOf(toolBox, faces),
		            guitk.BCToolBoxIndexOf(toolBox, surfaces),
		        )
		    )
		    guitk.BCShow(window)
		
		
		def frameWithMoveButtonsCreate(toolBox, btnsStrList, prefix):
		    frame = guitk.BCFrameCreate(toolBox)
		    fLayout = guitk.BCFlowLayoutCreate(frame)
		    for btnText in btnsStrList:
		        toolBtn = guitk.BCToolButtonCreate(toolBox, "", btnText, printMe, toolBox)
		        popupMenu = guitk.BCPopupMenuCreate(toolBtn)
		        guitk.BCButtonSetPopup(toolBtn, popupMenu)
		        guitk.BCPopupMenuInsertItem(
		            popupMenu,
		            "Move to favorites",
		            moveButtonToFavorites,
		            (fLayout, toolBox, toolBtn, prefix),
		        )
		        guitk.BCFlowLayoutInsert(fLayout, toolBtn)
		    return frame
		
		
		def printMe(b, toolBox):
		    print(
		        "'{}' Clicked! Current Index = {}".format(
		            guitk.BCButtonText(b), guitk.BCToolBoxCurrentIndex(toolBox)
		        )
		    )
		    return 0
		
		
		def moveButtonToFavorites(popupMenu, id, data):
		    fLayout, toolBox, toolBtn, prefix = data
		    favorites = guitk.BCToolBoxItem(toolBox, 0)
		    guitk.BCFlowLayoutRemove(fLayout, toolBtn)
		    position = guitk.BCGetUserDataKey(favorites, "nItems")
		    favoritesFLayout = guitk.BCLayout(favorites)
		    guitk.BCFlowLayoutInsert(favoritesFLayout, toolBtn)
		    guitk.BCSetUserDataKey(favorites, "nItems", position + 1)
		    guitk.BCToolBoxSetItemLabel(toolBox, favorites, "Favorites " + str(position + 1))
		    guitk.BCToolBoxSetCurrentItem(toolBox, favorites)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, id, False)
		    guitk.BCButtonSetText(toolBtn, prefix + guitk.BCButtonText(toolBtn))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxItem(tb: object, index: int) -> object:

	"""

	Returns the item of BCToolBox tb at index.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	index : int
		the index of the item that this function will return.

	Returns
	-------
	object
		the item at index index.

	See Also
	--------
	BCToolBoxIndexOf

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Move Button ToolBox Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    favorites = frameWithMoveButtonsCreate(toolBox, [], "")
		    guitk.BCSetUserDataKey(favorites, "nItems", 0)
		    hotPoints = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Insert", "Project", "Parametrical", "Delete"], "Points: "
		    )
		    cons = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Paste", "Release", "Fill Hole"], "Cons: "
		    )
		    faces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Cut", "Delete", "Undelete"], "Faces: "
		    )
		    surfaces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Coons", "Fit", "Extend"], "Surfaces: "
		    )
		    guitk.BCToolBoxAddItem(toolBox, favorites, "Favorites 0")
		    guitk.BCToolBoxAddItem(toolBox, hotPoints, "Hot Points")
		    guitk.BCToolBoxAddItem(toolBox, cons, "Cons")
		    guitk.BCToolBoxAddItem(toolBox, faces, "Faces")
		    guitk.BCToolBoxAddItem(toolBox, surfaces, "Surfaces")
		    print(
		        "Favorites index = {}\\nHot Points index = {}\\nCons index = {}\\nFaces index = {}\\nSurfacesIndex = {}".format(
		            guitk.BCToolBoxIndexOf(toolBox, favorites),
		            guitk.BCToolBoxIndexOf(toolBox, hotPoints),
		            guitk.BCToolBoxIndexOf(toolBox, cons),
		            guitk.BCToolBoxIndexOf(toolBox, faces),
		            guitk.BCToolBoxIndexOf(toolBox, surfaces),
		        )
		    )
		    guitk.BCShow(window)
		
		
		def frameWithMoveButtonsCreate(toolBox, btnsStrList, prefix):
		    frame = guitk.BCFrameCreate(toolBox)
		    fLayout = guitk.BCFlowLayoutCreate(frame)
		    for btnText in btnsStrList:
		        toolBtn = guitk.BCToolButtonCreate(toolBox, "", btnText, printMe, toolBox)
		        popupMenu = guitk.BCPopupMenuCreate(toolBtn)
		        guitk.BCButtonSetPopup(toolBtn, popupMenu)
		        guitk.BCPopupMenuInsertItem(
		            popupMenu,
		            "Move to favorites",
		            moveButtonToFavorites,
		            (fLayout, toolBox, toolBtn, prefix),
		        )
		        guitk.BCFlowLayoutInsert(fLayout, toolBtn)
		    return frame
		
		
		def printMe(b, toolBox):
		    print(
		        "'{}' Clicked! Current Index = {}".format(
		            guitk.BCButtonText(b), guitk.BCToolBoxCurrentIndex(toolBox)
		        )
		    )
		    return 0
		
		
		def moveButtonToFavorites(popupMenu, id, data):
		    fLayout, toolBox, toolBtn, prefix = data
		    favorites = guitk.BCToolBoxItem(toolBox, 0)
		    guitk.BCFlowLayoutRemove(fLayout, toolBtn)
		    position = guitk.BCGetUserDataKey(favorites, "nItems")
		    favoritesFLayout = guitk.BCLayout(favorites)
		    guitk.BCFlowLayoutInsert(favoritesFLayout, toolBtn)
		    guitk.BCSetUserDataKey(favorites, "nItems", position + 1)
		    guitk.BCToolBoxSetItemLabel(toolBox, favorites, "Favorites " + str(position + 1))
		    guitk.BCToolBoxSetCurrentItem(toolBox, favorites)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, id, False)
		    guitk.BCButtonSetText(toolBtn, prefix + guitk.BCButtonText(toolBtn))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxIndexOf(tb: object, w: object) -> int:

	"""

	Returns the index of item w of BCToolBox tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	w : object
		the item of which the index will be returned.

	Returns
	-------
	int
		the index of w.

	See Also
	--------
	BCToolBoxItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Move Button ToolBox Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    favorites = frameWithMoveButtonsCreate(toolBox, [], "")
		    guitk.BCSetUserDataKey(favorites, "nItems", 0)
		    hotPoints = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Insert", "Project", "Parametrical", "Delete"], "Points: "
		    )
		    cons = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Paste", "Release", "Fill Hole"], "Cons: "
		    )
		    faces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Cut", "Delete", "Undelete"], "Faces: "
		    )
		    surfaces = frameWithMoveButtonsCreate(
		        toolBox, ["Info", "Coons", "Fit", "Extend"], "Surfaces: "
		    )
		    guitk.BCToolBoxAddItem(toolBox, favorites, "Favorites 0")
		    guitk.BCToolBoxAddItem(toolBox, hotPoints, "Hot Points")
		    guitk.BCToolBoxAddItem(toolBox, cons, "Cons")
		    guitk.BCToolBoxAddItem(toolBox, faces, "Faces")
		    guitk.BCToolBoxAddItem(toolBox, surfaces, "Surfaces")
		    print(
		        "Favorites index = {}\\nHot Points index = {}\\nCons index = {}\\nFaces index = {}\\nSurfacesIndex = {}".format(
		            guitk.BCToolBoxIndexOf(toolBox, favorites),
		            guitk.BCToolBoxIndexOf(toolBox, hotPoints),
		            guitk.BCToolBoxIndexOf(toolBox, cons),
		            guitk.BCToolBoxIndexOf(toolBox, faces),
		            guitk.BCToolBoxIndexOf(toolBox, surfaces),
		        )
		    )
		    guitk.BCShow(window)
		
		
		def frameWithMoveButtonsCreate(toolBox, btnsStrList, prefix):
		    frame = guitk.BCFrameCreate(toolBox)
		    fLayout = guitk.BCFlowLayoutCreate(frame)
		    for btnText in btnsStrList:
		        toolBtn = guitk.BCToolButtonCreate(toolBox, "", btnText, printMe, toolBox)
		        popupMenu = guitk.BCPopupMenuCreate(toolBtn)
		        guitk.BCButtonSetPopup(toolBtn, popupMenu)
		        guitk.BCPopupMenuInsertItem(
		            popupMenu,
		            "Move to favorites",
		            moveButtonToFavorites,
		            (fLayout, toolBox, toolBtn, prefix),
		        )
		        guitk.BCFlowLayoutInsert(fLayout, toolBtn)
		    return frame
		
		
		def printMe(b, toolBox):
		    print(
		        "'{}' Clicked! Current Index = {}".format(
		            guitk.BCButtonText(b), guitk.BCToolBoxCurrentIndex(toolBox)
		        )
		    )
		    return 0
		
		
		def moveButtonToFavorites(popupMenu, id, data):
		    fLayout, toolBox, toolBtn, prefix = data
		    favorites = guitk.BCToolBoxItem(toolBox, 0)
		    guitk.BCFlowLayoutRemove(fLayout, toolBtn)
		    position = guitk.BCGetUserDataKey(favorites, "nItems")
		    favoritesFLayout = guitk.BCLayout(favorites)
		    guitk.BCFlowLayoutInsert(favoritesFLayout, toolBtn)
		    guitk.BCSetUserDataKey(favorites, "nItems", position + 1)
		    guitk.BCToolBoxSetItemLabel(toolBox, favorites, "Favorites " + str(position + 1))
		    guitk.BCToolBoxSetCurrentItem(toolBox, favorites)
		    guitk.BCPopupMenuSetItemEnabled(popupMenu, id, False)
		    guitk.BCButtonSetText(toolBtn, prefix + guitk.BCButtonText(toolBtn))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxCount(tb: object) -> int:

	"""

	Returns the number of items in BCToolBox tb.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	Returns
	-------
	int
		the number of items.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ToolBox Insert/Remove Colored Frames Example", guitk.constants.BCOnExitDestroy
		    )
		    toolBox = guitk.BCToolBoxCreate(window)
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCPushButtonCreate(hBox, "Insert Here", insertHere, [toolBox, 0])
		    guitk.BCPushButtonCreate(hBox, "Remove Current", removeCurrent, toolBox)
		    guitk.BCShow(window)
		
		
		def insertHere(b, data):
		    toolBox = data[0]
		    frameId = data[1]
		    data[1] = data[1] + 1
		    frame = guitk.BCFrameCreate(toolBox)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCBoxLayoutInsert(
		        bLayout, guitk.BCLabelCreate(bLayout, "Frame {} contents".format(frameId)), -1
		    )
		    currentIndex = guitk.BCToolBoxCurrentIndex(toolBox)
		    guitk.BCToolBoxInsertItem(toolBox, frame, "Frame " + str(frameId), currentIndex)
		    print(
		        "Item inserted at index={}. Current ToolBoxCount={}".format(
		            currentIndex, guitk.BCToolBoxCount(toolBox)
		        )
		    )
		    return 0
		
		
		def removeCurrent(b, toolBox):
		    frameToRemove = guitk.BCToolBoxCurrentItem(toolBox)
		    if frameToRemove:
		        guitk.BCToolBoxRemoveItem(toolBox, frameToRemove)
		        guitk.BCDestroyLater(frameToRemove)
		        print(
		            "Current Item removed. Current ToolBoxCount={}".format(
		                guitk.BCToolBoxCount(toolBox)
		            )
		        )
		    else:
		        print("No Current Item to remove.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxSetCurrentIndex(tb: object, index: int) -> None:

	"""

	Sets the current item of BCToolBox tb to be the one with index index.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	index : int
		the index of the new current item.

	Returns
	-------
	None

	See Also
	--------
	BCToolBoxSetCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tool Box", guitk.constants.BCOnExitDestroy)
		
		    toolbox = guitk.BCToolBoxCreate(window)
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCPushButtonCreate(frame, "Button 1", None)
		    guitk.BCPushButtonCreate(frame, "Button 2", None)
		    guitk.BCPushButtonCreate(frame, "Button 3", None)
		    guitk.BCSpacerCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Buttons")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLineEditCreate(frame, "Line Edit")
		    guitk.BCSpinBoxCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Input")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCButtonGroupCreate(frame, "ButtonGroup", guitk.constants.BCVertical)
		    guitk.BCFrameCreate(frame)
		    guitk.BCFrameSetShadow(frame, guitk.constants.BCRaised)
		    guitk.BCFrameSetShape(frame, guitk.constants.BCPanel)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Containers")
		    guitk.BCToolBoxSetItemToolTip(toolbox, 2, "This is a container item")
		    guitk.BCToolBoxSetItemEnabled(toolbox, 2, False)
		
		    listView = guitk.BCListViewCreate(toolbox, 2, ["Column 1", "Column 2"], True)
		    for i in range(4):
		        item = guitk.BCListViewAddTopLevelItem(listView)
		        guitk.BCListViewItemSetText(item, 0, "Item " + str(i))
		        guitk.BCListVIewItemSetText(item, 1, "val" + str(i))
		        guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCToolBoxAddItem(toolbox, listView, "View")
		
		    guitk.BCToolBoxSetCurrentChangedFunction(toolbox, toolboxChanged, None)
		    guitk.BCToolBoxSetCurrentIndex(toolbox, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunct, None)
		    guitk.BCShow(window)
		
		
		def acceptFunct(window, data):
		    return 0
		
		
		def toolboxChanged(tb, index, data):
		    itemCount = guitk.BCToolBoxCount(tb)
		    print("Total Items are: " + str(itemCount))
		    print("ToolBox Current changed to item: " + str(guitk.BCToolBoxCurrentIndex(tb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolBoxSetCurrentChangedFunction(tb: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the current item of BCToolBox tb
	is changed.
	This function is not supported under VR mode.

	Parameters
	----------
	tb : object
		the BCToolBox.

	funct : Callable
		the function. See BC_TOOLBOX_CURRENT_CHANGED_FUNCTION for details.
		integer BC_TOOLBOX_CURRENT_CHANGED_FUNCTION(tb, index, data)
		The function to be called when the current item of BCToolBox tb is changed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * tb : object
		                    the BCToolBox.
		          * index : int
		                    the index of the item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		a pointer to any user data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCToolBoxCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tool Box", guitk.constants.BCOnExitDestroy)
		
		    toolbox = guitk.BCToolBoxCreate(window)
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCPushButtonCreate(frame, "Button 1", None)
		    guitk.BCPushButtonCreate(frame, "Button 2", None)
		    guitk.BCPushButtonCreate(frame, "Button 3", None)
		    guitk.BCSpacerCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Buttons")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLineEditCreate(frame, "Line Edit")
		    guitk.BCSpinBoxCreate(frame)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Input")
		
		    frame = guitk.BCFrameCreate(toolbox)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCButtonGroupCreate(frame, "ButtonGroup", guitk.constants.BCVertical)
		    guitk.BCFrameCreate(frame)
		    guitk.BCFrameSetShadow(frame, guitk.constants.BCRaised)
		    guitk.BCFrameSetShape(frame, guitk.constants.BCPanel)
		    guitk.BCToolBoxAddItem(toolbox, frame, "Containers")
		    guitk.BCToolBoxSetItemToolTip(toolbox, 2, "This is a container item")
		    guitk.BCToolBoxSetItemEnabled(toolbox, 2, False)
		
		    listView = guitk.BCListViewCreate(toolbox, 2, ["Column 1", "Column 2"], True)
		    for i in range(4):
		        item = guitk.BCListViewAddTopLevelItem(listView)
		        guitk.BCListViewItemSetText(item, 0, "Item " + str(i))
		        guitk.BCListVIewItemSetText(item, 1, "val" + str(i))
		        guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCToolBoxAddItem(toolbox, listView, "View")
		
		    guitk.BCToolBoxSetCurrentChangedFunction(toolbox, toolboxChanged, None)
		    guitk.BCToolBoxSetCurrentIndex(toolbox, 3)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunct, None)
		    guitk.BCShow(window)
		
		
		def acceptFunct(window, data):
		    return 0
		
		
		def toolboxChanged(tb, index, data):
		    itemCount = guitk.BCToolBoxCount(tb)
		    print("Total Items are: " + str(itemCount))
		    print("ToolBox Current changed to item: " + str(guitk.BCToolBoxCurrentIndex(tb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetExpandCreate(p: object) -> object:

	"""

	Creates a container able to rapid expand the managed widget.
	Operates by pressing Shift+MiddleMouse and move mouse pointer to the desired expanding direction. 
	One widget can be managed at the time.
	NOTE: Create the managed widget with parent the WidgetExpand.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created WidgetExpand.

	See Also
	--------
	BCWidgetExpandSetWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Widget Expand", guitk.constants.BCOnExitDestroy
		    )
		    widgetExpand = guitk.BCWidgetExpandCreate(window)
		    string = "<h1 align=center>Widget Expand Tool</h1>"
		    string += "<h2><i>Keep down Shift + mouse middle over the text and then move mouse cursor.</i></h2>"
		    for i in range(0, 500):
		        string += (
		            "This is an example on how you can use the Widget Expand functionality<br>"
		        )
		    te = guitk.BCTextEditCreate(widgetExpand, string)
		    guitk.BCWidgetExpandSetWidget(widgetExpand, te)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetExpandSetWidget(wex: object, managedWidget: object) -> None:

	"""

	Connect widgetExpand wex and managedWidget to be managed.
	Managed widget should be something with scroll bars (i.e. list, text edit etc).
	NOTE: Create the managed widget with parent the WidgetExpand.
	This function is not supported under VR mode.

	Parameters
	----------
	wex : object
		the WidgetExpand.

	managedWidget : object
		the managed widget.

	Returns
	-------
	None

	See Also
	--------
	BCWidgetExpandGetWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Widget Expand", guitk.constants.BCOnExitDestroy
		    )
		    widgetExpand = guitk.BCWidgetExpandCreate(window)
		    string = "<h1 align=center>Widget Expand Tool</h1>"
		    string += "<h2><i>Keep down Shift + mouse middle over the text and then move mouse cursor.</i></h2>"
		    for i in range(0, 500):
		        string += (
		            "This is an example on how you can use the Widget Expand functionality<br>"
		        )
		    te = guitk.BCTextEditCreate(widgetExpand, string)
		    guitk.BCWidgetExpandSetWidget(widgetExpand, te)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetExpandClear(wex: object) -> None:

	"""

	Disconnect widgetExpand wex from its managed widget.
	The managed widget will NOT be deleted. Its your responsibility to give the managed widget a 
	reasonable geometry or to put it back into a layout.
	This function is not supported under VR mode.

	Parameters
	----------
	wex : object
		the WidgetExpand.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Widget Expand Switch", guitk.constants.BCOnExitDestroy
		    )
		    widgetExpand = guitk.BCWidgetExpandCreate(window)
		    # Create a list view and add it to widgetExpand
		    listView = guitk.BCListViewCreate(
		        widgetExpand, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCWidgetExpandSetWidget(widgetExpand, listView)
		    # Create a table also but hide it
		    table = guitk.BCTableCreate(widgetExpand, 4, 4)
		    for col in range(4):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		        for row in range(4):
		            guitk.BCTableSetText(
		                table, row, col, guitk.BCListViewGetText(listView, row, col)
		            )
		    guitk.BCHide(table)
		
		    btnSwitch = guitk.BCPushButtonCreate(window, "ListView", None, None)
		    guitk.BCButtonSetToggleButton(btnSwitch, True)
		    guitk.BCButtonSetToggledFunction(
		        btnSwitch, switchWidget, (widgetExpand, listView, table)
		    )
		    guitk.BCWindowSetInitSize(window, 200, 300)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def addPart(listView, id, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, id)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    return item
		
		
		def switchWidget(b, state, data):
		    widgetExpand, listView, table = data
		    curWidget = guitk.BCWidgetExpandGetWidget(widgetExpand)
		    guitk.BCWidgetExpandClear(widgetExpand)
		    guitk.BCHide(curWidget)
		    guitk.BCButtonSetText(b, "Table" if state else "ListView")
		    guitk.BCWidgetExpandSetWidget(widgetExpand, table if state else listView)
		    guitk.BCShow(table if state else listView)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackCreate(p: object) -> object:

	"""

	Creates a new BCWidgetStack with parent p.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created BCWidgetStack.

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    values = ["Red", "Green", "Blue"]
		    window = guitk.BCWindowCreate(
		        "Example Widget Stack", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    vLeft = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		    vRight = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		
		    checkBx = guitk.BCCheckBoxCreate(vLeft, "Manage WidgetStack")
		
		    combo = guitk.BCComboBoxCreate(vLeft, values)
		    guitk.BCSpacerCreate(vLeft)
		
		    stack = guitk.BCWidgetStackCreate(vRight)
		    guitk.BCCheckBoxAddManagedWidget(
		        checkBx,
		        stack,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCCheckBoxSetChecked(checkBx, True)
		
		    redFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(redFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(redFrame, "Stacked Widget A")
		    guitk.BCSetBackgroundColor(redFrame, 255, 0, 0)
		    guitk.BCWidgetStackAddWidget(stack, redFrame, 0)
		
		    greenFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(greenFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(greenFrame, "Stacked Widget B")
		    guitk.BCSetBackgroundColor(greenFrame, 0, 255, 0)
		    guitk.BCWidgetStackAddWidget(stack, greenFrame, 1)
		
		    blueFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(blueFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(blueFrame, "Stacked Widget C")
		    guitk.BCSetBackgroundColor(blueFrame, 0, 0, 255)
		    guitk.BCWidgetStackAddWidget(stack, blueFrame, 2)
		
		    guitk.BCComboBoxSetActivatedFunction(combo, widgetStackComboActivated, stack)
		
		    guitk.BCShow(window)
		
		
		def widgetStackComboActivated(combo, index, stack):
		    frame = guitk.BCWidgetStackWidget(stack, index)
		    guitk.BCWidgetStackRaiseWidget(stack, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackAddWidget(ws: object, w: object, id: int) -> None:

	"""

	Adds a widget to the BCWidgetStack.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack where w will be added.

	w : object
		the widget that will be added to the BCWidgetStack.

	id : int
		the id that will be assigned to w (-1 for auto indexing).

	Returns
	-------
	None

	See Also
	--------
	BCWidgetStackRemoveWidget

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    values = ["Red", "Green", "Blue"]
		    window = guitk.BCWindowCreate(
		        "Example Widget Stack", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    vLeft = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		    vRight = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		
		    checkBx = guitk.BCCheckBoxCreate(vLeft, "Manage WidgetStack")
		
		    combo = guitk.BCComboBoxCreate(vLeft, values)
		    guitk.BCSpacerCreate(vLeft)
		
		    stack = guitk.BCWidgetStackCreate(vRight)
		    guitk.BCCheckBoxAddManagedWidget(
		        checkBx,
		        stack,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCCheckBoxSetChecked(checkBx, True)
		
		    redFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(redFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(redFrame, "Stacked Widget A")
		    guitk.BCSetBackgroundColor(redFrame, 255, 0, 0)
		    guitk.BCWidgetStackAddWidget(stack, redFrame, 0)
		
		    greenFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(greenFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(greenFrame, "Stacked Widget B")
		    guitk.BCSetBackgroundColor(greenFrame, 0, 255, 0)
		    guitk.BCWidgetStackAddWidget(stack, greenFrame, 1)
		
		    blueFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(blueFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(blueFrame, "Stacked Widget C")
		    guitk.BCSetBackgroundColor(blueFrame, 0, 0, 255)
		    guitk.BCWidgetStackAddWidget(stack, blueFrame, 2)
		
		    guitk.BCComboBoxSetActivatedFunction(combo, widgetStackComboActivated, stack)
		
		    guitk.BCShow(window)
		
		
		def widgetStackComboActivated(combo, index, stack):
		    frame = guitk.BCWidgetStackWidget(stack, index)
		    guitk.BCWidgetStackRaiseWidget(stack, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackRemoveWidget(ws: object, w: object) -> None:

	"""

	Removes a widget from the BCWidgetStack.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack.

	w : object
		the widget that will be removed from the BCWidgetStack.

	Returns
	-------
	None

	See Also
	--------
	BCWidgetStackAddWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Widget Stack Raise Id Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    vBox = guitk.BCVBoxCreate(hBox)
		    widgetStack = guitk.BCWidgetStackCreate(hBox)
		    widgetStackMyAddFrame(widgetStack, 0, "logo_sdm.svg")
		    widgetStackMyAddFrame(widgetStack, 1, "logo_meta.svg")
		    widgetStackMyAddFrame(widgetStack, 2, "logo_spdrm.svg")
		    cmbProgram = guitk.BCComboBoxCreate(vBox, ["0: ANSA", "1: META", "2: SPDRM"])
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(cmbProgram, raiseFrame, widgetStack)
		    guitk.BCPushButtonCreate(
		        vBox, "Remove Current", removeCurrent, (widgetStack, cmbProgram)
		    )
		    guitk.BCShow(window)
		
		
		def widgetStackMyAddFrame(widgetStack, id, icon):
		    frame = guitk.BCFrameCreate(widgetStack)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    iconLabel = guitk.BCLabelCreate(bLayout, "")
		    guitk.BCLabelSetIconFileName(iconLabel, icon)
		    guitk.BCLabelSetAlignment(iconLabel, guitk.constants.BCAlignCenter)
		    guitk.BCBoxLayoutInsert(bLayout, iconLabel, -1)
		    guitk.BCWidgetStackAddWidget(widgetStack, frame, id)
		
		
		def raiseFrame(cmb, index, widgetStack):
		    id = int(guitk.BCComboBoxCurrentText(cmb).split(":")[0])
		    guitk.BCWidgetStackRaiseId(widgetStack, id)
		    print("WidgetStackCurrentId = {}".format(guitk.BCWidgetStackCurrentId(widgetStack)))
		    return 0
		
		
		def removeCurrent(btn, data):
		    widgetStack, cmb = data
		    if guitk.BCComboBoxCount(cmb) == 1:  # in case no more frames are available
		        guitk.BCComboBoxSetCurrentIndexChangedFunction(cmb, None, None)
		        guitk.BCSetEnabled(cmb, False)
		        guitk.BCSetEnabled(btn, False)
		    widgetToRemove = guitk.BCWidgetStackVisibleWidget(widgetStack)
		    guitk.BCComboBoxRemoveItem(cmb, guitk.BCComboBoxCurrentItem(cmb))
		    print(
		        "Widget id before removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCWidgetStackRemoveWidget(widgetStack, widgetToRemove)
		    print(
		        "Widget id after removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCDestroyLater(widgetToRemove)  # No reason to keep it alive.
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackWidget(ws: object, id: int) -> object:

	"""

	Returns the widget of id id.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack that contains the required widget.

	id : int
		the id of the required widget.

	Returns
	-------
	object
		the widget of id id or None if the BCWidgetStack does not manage a widget with id id.

	See Also
	--------
	BCWidgetStackId

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    values = ["Red", "Green", "Blue"]
		    window = guitk.BCWindowCreate(
		        "Example Widget Stack", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    vLeft = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		    vRight = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		
		    checkBx = guitk.BCCheckBoxCreate(vLeft, "Manage WidgetStack")
		
		    combo = guitk.BCComboBoxCreate(vLeft, values)
		    guitk.BCSpacerCreate(vLeft)
		
		    stack = guitk.BCWidgetStackCreate(vRight)
		    guitk.BCCheckBoxAddManagedWidget(
		        checkBx,
		        stack,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCCheckBoxSetChecked(checkBx, True)
		
		    redFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(redFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(redFrame, "Stacked Widget A")
		    guitk.BCSetBackgroundColor(redFrame, 255, 0, 0)
		    guitk.BCWidgetStackAddWidget(stack, redFrame, 0)
		
		    greenFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(greenFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(greenFrame, "Stacked Widget B")
		    guitk.BCSetBackgroundColor(greenFrame, 0, 255, 0)
		    guitk.BCWidgetStackAddWidget(stack, greenFrame, 1)
		
		    blueFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(blueFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(blueFrame, "Stacked Widget C")
		    guitk.BCSetBackgroundColor(blueFrame, 0, 0, 255)
		    guitk.BCWidgetStackAddWidget(stack, blueFrame, 2)
		
		    guitk.BCComboBoxSetActivatedFunction(combo, widgetStackComboActivated, stack)
		
		    guitk.BCShow(window)
		
		
		def widgetStackComboActivated(combo, index, stack):
		    frame = guitk.BCWidgetStackWidget(stack, index)
		    guitk.BCWidgetStackRaiseWidget(stack, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackId(ws: object, w: object) -> int:

	"""

	Returns the id of widget w within BCWidgetStack ws.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack that contains widget w.

	w : object
		the widget whose id is required.

	Returns
	-------
	int
		the id of the widget w or -1 if the BCWidgetStack does not manage widget w.

	See Also
	--------
	BCWidgetStackWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Widget Stack Raise Id Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    vBox = guitk.BCVBoxCreate(hBox)
		    widgetStack = guitk.BCWidgetStackCreate(hBox)
		    widgetStackMyAddFrame(widgetStack, 0, "logo_sdm.svg")
		    widgetStackMyAddFrame(widgetStack, 1, "logo_meta.svg")
		    widgetStackMyAddFrame(widgetStack, 2, "logo_spdrm.svg")
		    cmbProgram = guitk.BCComboBoxCreate(vBox, ["0: ANSA", "1: META", "2: SPDRM"])
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(cmbProgram, raiseFrame, widgetStack)
		    guitk.BCPushButtonCreate(
		        vBox, "Remove Current", removeCurrent, (widgetStack, cmbProgram)
		    )
		    guitk.BCShow(window)
		
		
		def widgetStackMyAddFrame(widgetStack, id, icon):
		    frame = guitk.BCFrameCreate(widgetStack)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    iconLabel = guitk.BCLabelCreate(bLayout, "")
		    guitk.BCLabelSetIconFileName(iconLabel, icon)
		    guitk.BCLabelSetAlignment(iconLabel, guitk.constants.BCAlignCenter)
		    guitk.BCBoxLayoutInsert(bLayout, iconLabel, -1)
		    guitk.BCWidgetStackAddWidget(widgetStack, frame, id)
		
		
		def raiseFrame(cmb, index, widgetStack):
		    id = int(guitk.BCComboBoxCurrentText(cmb).split(":")[0])
		    guitk.BCWidgetStackRaiseId(widgetStack, id)
		    print("WidgetStackCurrentId = {}".format(guitk.BCWidgetStackCurrentId(widgetStack)))
		    return 0
		
		
		def removeCurrent(btn, data):
		    widgetStack, cmb = data
		    if guitk.BCComboBoxCount(cmb) == 1:  # in case no more frames are available
		        guitk.BCComboBoxSetCurrentIndexChangedFunction(cmb, None, None)
		        guitk.BCSetEnabled(cmb, False)
		        guitk.BCSetEnabled(btn, False)
		    widgetToRemove = guitk.BCWidgetStackVisibleWidget(widgetStack)
		    guitk.BCComboBoxRemoveItem(cmb, guitk.BCComboBoxCurrentItem(cmb))
		    print(
		        "Widget id before removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCWidgetStackRemoveWidget(widgetStack, widgetToRemove)
		    print(
		        "Widget id after removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCDestroyLater(widgetToRemove)  # No reason to keep it alive.
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackVisibleWidget(ws: object) -> object:

	"""

	Returns the currently visible widget of BCWidgetStack ws.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack.

	Returns
	-------
	object
		the currently visible widget (the one at the top of the stack), or None if nothing is currently being shown.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Widget Stack Raise Id Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    vBox = guitk.BCVBoxCreate(hBox)
		    widgetStack = guitk.BCWidgetStackCreate(hBox)
		    widgetStackMyAddFrame(widgetStack, 0, "logo_sdm.svg")
		    widgetStackMyAddFrame(widgetStack, 1, "logo_meta.svg")
		    widgetStackMyAddFrame(widgetStack, 2, "logo_spdrm.svg")
		    cmbProgram = guitk.BCComboBoxCreate(vBox, ["0: ANSA", "1: META", "2: SPDRM"])
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(cmbProgram, raiseFrame, widgetStack)
		    guitk.BCPushButtonCreate(
		        vBox, "Remove Current", removeCurrent, (widgetStack, cmbProgram)
		    )
		    guitk.BCShow(window)
		
		
		def widgetStackMyAddFrame(widgetStack, id, icon):
		    frame = guitk.BCFrameCreate(widgetStack)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    iconLabel = guitk.BCLabelCreate(bLayout, "")
		    guitk.BCLabelSetIconFileName(iconLabel, icon)
		    guitk.BCLabelSetAlignment(iconLabel, guitk.constants.BCAlignCenter)
		    guitk.BCBoxLayoutInsert(bLayout, iconLabel, -1)
		    guitk.BCWidgetStackAddWidget(widgetStack, frame, id)
		
		
		def raiseFrame(cmb, index, widgetStack):
		    id = int(guitk.BCComboBoxCurrentText(cmb).split(":")[0])
		    guitk.BCWidgetStackRaiseId(widgetStack, id)
		    print("WidgetStackCurrentId = {}".format(guitk.BCWidgetStackCurrentId(widgetStack)))
		    return 0
		
		
		def removeCurrent(btn, data):
		    widgetStack, cmb = data
		    if guitk.BCComboBoxCount(cmb) == 1:  # in case no more frames are available
		        guitk.BCComboBoxSetCurrentIndexChangedFunction(cmb, None, None)
		        guitk.BCSetEnabled(cmb, False)
		        guitk.BCSetEnabled(btn, False)
		    widgetToRemove = guitk.BCWidgetStackVisibleWidget(widgetStack)
		    guitk.BCComboBoxRemoveItem(cmb, guitk.BCComboBoxCurrentItem(cmb))
		    print(
		        "Widget id before removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCWidgetStackRemoveWidget(widgetStack, widgetToRemove)
		    print(
		        "Widget id after removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCDestroyLater(widgetToRemove)  # No reason to keep it alive.
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackRaiseWidget(ws: object, w: object) -> None:

	"""

	Brings widget w to the top of BCWidgetStack ws.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack that contains widget w.

	w : object
		the widget that will be raised.

	Returns
	-------
	None

	See Also
	--------
	BCWidgetStackRaiseId

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    values = ["Red", "Green", "Blue"]
		    window = guitk.BCWindowCreate(
		        "Example Widget Stack", guitk.constants.BCOnExitDestroy
		    )
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    vLeft = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		    vRight = guitk.BCBoxLayoutCreate(hl, guitk.constants.BCVertical)
		
		    checkBx = guitk.BCCheckBoxCreate(vLeft, "Manage WidgetStack")
		
		    combo = guitk.BCComboBoxCreate(vLeft, values)
		    guitk.BCSpacerCreate(vLeft)
		
		    stack = guitk.BCWidgetStackCreate(vRight)
		    guitk.BCCheckBoxAddManagedWidget(
		        checkBx,
		        stack,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		    guitk.BCCheckBoxSetChecked(checkBx, True)
		
		    redFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(redFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(redFrame, "Stacked Widget A")
		    guitk.BCSetBackgroundColor(redFrame, 255, 0, 0)
		    guitk.BCWidgetStackAddWidget(stack, redFrame, 0)
		
		    greenFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(greenFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(greenFrame, "Stacked Widget B")
		    guitk.BCSetBackgroundColor(greenFrame, 0, 255, 0)
		    guitk.BCWidgetStackAddWidget(stack, greenFrame, 1)
		
		    blueFrame = guitk.BCFrameCreate(stack)
		    guitk.BCBoxLayoutCreate(blueFrame, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(blueFrame, "Stacked Widget C")
		    guitk.BCSetBackgroundColor(blueFrame, 0, 0, 255)
		    guitk.BCWidgetStackAddWidget(stack, blueFrame, 2)
		
		    guitk.BCComboBoxSetActivatedFunction(combo, widgetStackComboActivated, stack)
		
		    guitk.BCShow(window)
		
		
		def widgetStackComboActivated(combo, index, stack):
		    frame = guitk.BCWidgetStackWidget(stack, index)
		    guitk.BCWidgetStackRaiseWidget(stack, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackRaiseId(ws: object, id: int) -> None:

	"""

	Brings the widget with id to the top of BCWidgetStack ws.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack that will be checked.

	id : int
		the id of the widget that will be raised.

	Returns
	-------
	None

	See Also
	--------
	BCWidgetStackRaiseWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Widget Stack Raise Id Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    vBox = guitk.BCVBoxCreate(hBox)
		    widgetStack = guitk.BCWidgetStackCreate(hBox)
		    widgetStackMyAddFrame(widgetStack, 0, "logo_sdm.svg")
		    widgetStackMyAddFrame(widgetStack, 1, "logo_meta.svg")
		    widgetStackMyAddFrame(widgetStack, 2, "logo_spdrm.svg")
		    cmbProgram = guitk.BCComboBoxCreate(vBox, ["0: ANSA", "1: META", "2: SPDRM"])
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(cmbProgram, raiseFrame, widgetStack)
		    guitk.BCPushButtonCreate(
		        vBox, "Remove Current", removeCurrent, (widgetStack, cmbProgram)
		    )
		    guitk.BCShow(window)
		
		
		def widgetStackMyAddFrame(widgetStack, id, icon):
		    frame = guitk.BCFrameCreate(widgetStack)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    iconLabel = guitk.BCLabelCreate(bLayout, "")
		    guitk.BCLabelSetIconFileName(iconLabel, icon)
		    guitk.BCLabelSetAlignment(iconLabel, guitk.constants.BCAlignCenter)
		    guitk.BCBoxLayoutInsert(bLayout, iconLabel, -1)
		    guitk.BCWidgetStackAddWidget(widgetStack, frame, id)
		
		
		def raiseFrame(cmb, index, widgetStack):
		    id = int(guitk.BCComboBoxCurrentText(cmb).split(":")[0])
		    guitk.BCWidgetStackRaiseId(widgetStack, id)
		    print("WidgetStackCurrentId = {}".format(guitk.BCWidgetStackCurrentId(widgetStack)))
		    return 0
		
		
		def removeCurrent(btn, data):
		    widgetStack, cmb = data
		    if guitk.BCComboBoxCount(cmb) == 1:  # in case no more frames are available
		        guitk.BCComboBoxSetCurrentIndexChangedFunction(cmb, None, None)
		        guitk.BCSetEnabled(cmb, False)
		        guitk.BCSetEnabled(btn, False)
		    widgetToRemove = guitk.BCWidgetStackVisibleWidget(widgetStack)
		    guitk.BCComboBoxRemoveItem(cmb, guitk.BCComboBoxCurrentItem(cmb))
		    print(
		        "Widget id before removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCWidgetStackRemoveWidget(widgetStack, widgetToRemove)
		    print(
		        "Widget id after removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCDestroyLater(widgetToRemove)  # No reason to keep it alive.
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowCreate(name: str, a: int) -> object:

	"""

	Creates an empty window.
	The Window created contains by default a vertical BoxLayout (get with BCLayout()), 
	so everything placed on this Window is stacked from top to bottom.

	Parameters
	----------
	name : str
		the name of the new window. It primarily serves as the window's xml tag, under which gui data will be stored when window closes and loaded when window is shown. Take care that name is a unique string. You can use BCSetCaption to change the window's caption (title).

	a : int
		describes what will happen to the window when its filter returns 1 (i.e. on exit). See BCEnumExitAction for details.
		
		guitk.constants BCEnumExitAction
		This enum type defines what will happen to the window when its filter returns 1 (i.e. on
		exit). Exit action is used with BCWindowCreate for example.
		 - guitk.constants.BCOnExitHide
		hides the window.
		
		WARNING: var BCOnExitHide take no action when script ends.After script ends the window destroyed with var BCOnExitDestroy.
		var BCOnExitHide has action only if script not ends.
		
		WARNING: Take special care when you use this enumerator.
		You should destroy the window yourself in order to free the memory it holds.
		 - guitk.constants.BCOnExitDestroy
		destroys the window.

	Returns
	-------
	object
		The created widget.

	See Also
	--------
	BCSetCaption

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCWindow Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCDialogButtonBoxCreate(window)
		    # Warning: never set both accept and reject function to retun 0
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Window accepted (Enter). Window will remain open (return 0).")
		    return 0
		
		
		def rejectFunc(window, data):
		    print("Window canceled (Esc). Window will close (return 1).")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowIsDocked(wid: object) -> bool:

	"""

	Use this function to check if docking BCWindow wid is docked.
	This function is not supported under VR mode.

	Parameters
	----------
	wid : object
		the BCWindow to be checked.

	Returns
	-------
	bool
		True in case wid is docked; False otherwise.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Docked Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    notStr = "" if guitk.BCWindowIsDocked(window) else "not "
		    isDockedLabel = guitk.BCLabelCreate(hBox, "This window is\\n" + notStr + "docked")
		    guitk.BCLabelSetAlignment(isDockedLabel, guitk.constants.BCAlignCenter)
		    guitk.BCWindowSetOnPlaceChangedFunction(window, windowDockChanged, isDockedLabel)
		    guitk.BCShow(window)
		
		
		def windowDockChanged(window, position, isDockedLabel):
		    notStr = "" if position == guitk.constants.BCInDock else "not "
		    guitk.BCLabelSetText(isDockedLabel, "This window is\\n" + notStr + "docked")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetSaveSettings(w: object, save: bool) -> None:

	"""

	Sets whether BCWindow settings are saved when win is closed or not depending on the value of save.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	save : bool
		True to enable saving settings or False to disable.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCWindow Example", guitk.constants.BCOnExitDestroy)
		
		    # add some widgets
		    frame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(frame, "Value (Line edit for integers)")
		    guitk.BCLineEditCreateInt(frame, 0)
		    # the OK Cancel dialog
		    guitk.BCDialogButtonBoxCreate(window)
		
		    guitk.BCWindowSetInitSize(window, 400, 200)
		    guitk.BCWindowSetSaveSettings(window, False)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		
		    guitk.BCShow(window)
		
		
		def acceptFunc(win, data):
		    print("Window OK button clicked (Accept)")
		    return 1
		
		
		def rejectFunc(win, data):
		    print("Window cancel button clicked or Esc pressed (Reject)")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowAddSeparator(w: object) -> None:

	"""

	Adds a Separator on BCWindow w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	Returns
	-------
	None

	See Also
	--------
	BCWindowAddSpacer

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCCalculatorGetResult Example", guitk.constants.BCOnExitDestroy
		    )
		    calc = guitk.BCCalculatorCreate(window)
		    guitk.BCCalculatorSetExpression(calc, "2+2")
		
		    guitk.BCWindowAddSeparator(window)
		    guitk.BCSpacerCreate(window)
		    guitk.BCPushButtonCreate(window, "Print Result to console", getResult, calc)
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBoxFooter, "Result:")
		    lineEditResult = guitk.BCButtonLineEditCreate(hBoxFooter, "")
		    guitk.BCCalculatorConnectWithButtonLineEdit(calc, lineEditResult)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def getResult(btn, calc):
		    print("Result = " + guitk.BCCalculatorGetResult(calc))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowAddSpacer(w: object, l: object) -> None:

	"""

	Adds a Spacer on BCWindow w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	l : object
		a layout whose parent is the BCWindow w.

	Returns
	-------
	None

	See Also
	--------
	BCWindowAddSeparator

	"""

def BCWindowSetAcceptFunction(w: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the Accept Function of BCWindow w.
	The Accept Function of a BCWindow is the function called when Enter key is pressed on the window. Use this if you don' want OK Button visible in the widget but you need a function to be called on Enter. Also, if there is an OK Button in a dialog box in this BCWindow, when pressing OK Button this function will be called.
	IMPORTANT: Do not delete the BCWindow inside this function. If you return 1 and BCOnExitDestroy has been set, it will be deleted automatically after funct has run.

	Parameters
	----------
	w : object
		the BCWindow.

	funct : Callable
		the function that will be called on accept (enter key pressed). See BC_WINDOW_ACCEPT_FUNCTION for details.
		integer BC_WINDOW_ACCEPT_FUNCTION(w, data)
		The function to be called when Enter key is pressed on the BCWindow.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * w : object
		                    the BCWindow.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 for normally closing your window or 0 if you want your window to remain open on Return Key.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	None

	See Also
	--------
	BCWindowSetRejectFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCWindow Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCDialogButtonBoxCreate(window)
		    # Warning: never set both accept and reject function to retun 0
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Window accepted (Enter). Window will remain open (return 0).")
		    return 0
		
		
		def rejectFunc(window, data):
		    print("Window canceled (Esc). Window will close (return 1).")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetRejectFunction(w: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the Reject Function of widget w.
	The Reject Function of a widget is the function called when Escape key is pressed on the BCWindow. Use this if you don't want Cancel Button visible in the BCWindow but you need a function to be called on Escape. Also if there is a cancel button in a dialog box in this window when pressing cancel button this function will be called.
	IMPORTANT:  Do not delete the BCWindow inside this function. If you return 1 and BCOnExitDestroy has been set, it will be deleted automatically after funct has run.

	Parameters
	----------
	w : object
		the BCWindow.

	funct : Callable
		the function that will be called on reject (escape pressed). See BC_WINDOW_REJECT_FUNCTION for details.
		integer BC_WINDOW_REJECT_FUNCTION(w, data)
		The function to be called when Escape key is pressed on the BCWindow.
		This function operates when you press ESC (or QUITALL) and before your window is destroyed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * w : object
		                    the widget.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Return 1 for normally closing your window or 0 if you want your window to remain open on ESC. Before you return 0, be sure that the latter window behavior is necessary.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	None

	See Also
	--------
	BCWindowSetAcceptFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCWindow Example", guitk.constants.BCOnExitDestroy)
		    guitk.BCDialogButtonBoxCreate(window)
		    # Warning: never set both accept and reject function to retun 0
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def acceptFunc(window, data):
		    print("Window accepted (Enter). Window will remain open (return 0).")
		    return 0
		
		
		def rejectFunc(window, data):
		    print("Window canceled (Esc). Window will close (return 1).")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetSize(w: object, width: int, height: int) -> None:

	"""

	Sets the width and height of BCWindow w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	width : int
		the new width for BCWindow w.

	height : int
		the new height for BCWindow w.
		NOTE: If hide a children of BCWindow then before call BCWindowSetSize , you must call BCWindowUpdateGeometry

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    win = guitk.BCWindowCreate(
		        "BCWindow Geometry Example", guitk.constants.BCOnExitDestroy
		    )
		
		    guitk.BCPushButtonCreate(win, "Move window", moveWindowFunc, win)
		    guitk.BCPushButtonCreate(win, "Resize window", resizeWindowFunc, win)
		
		    guitk.BCWindowSetInitGeometry(win, 100, 100, 200, 200)
		    guitk.BCWindowSetSaveSettings(win, False)
		    guitk.BCShow(win)
		
		
		def moveWindowFunc(b, win):
		    guitk.BCWindowSetPosition(win, 300, 300)
		    return 0
		
		
		def resizeWindowFunc(b, win):
		    guitk.BCWindowSetSize(win, 400, 400)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowUpdateGeometry(w: object) -> None:

	"""

	Notifies the layout system that the BCWindow w has changed and may need to change geometry.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	Returns
	-------
	None

	"""

def BCWindowSetMousePressFunction(w: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when a mouse button is pressed on BCWindow widget w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow widget.

	funct : Callable
		the function that will be called when a mouse button is pressed on the BCWindow widget. 
		See BC_WINDOW_MOUSE_PRESS_FUNCTION for details.
		integer BC_WINDOW_MOUSE_PRESS_FUNCTION(w, mb, data)
		The function to be called when a mouse button is pressed on the BCWindow w.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * w : object
		                    the BCWindow.
		          * mb : int
		                    the mouse-button pressed. See BCEnumButtonState for details.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data that may be required in funct.

	Returns
	-------
	None

	"""

def BCWindowAccept(w: object) -> None:

	"""

	Calls the BCWindow's accept function.
	If no custom accept function has been set, a default one will be called.
	Normally this function is called when we press the 'OK' button to close the BCWindow.

	Parameters
	----------
	w : object
		the BCWindow whose accept function will be called.

	Returns
	-------
	None

	See Also
	--------
	BCWindowReject

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Accept/Reject Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelCreate(window, "WindowAcceptFunction returns 1 (Closes the window)")
		    guitk.BCLabelCreate(
		        window, "WindowRejectFunction returns 0 (Keeps the window open)"
		    )
		    lineEdit = guitk.BCLineEditCreate(window, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineEdit,
		        "Submitting a lineEdit, i.e. pressing Enter while it has focus, triggers WindowAccept",
		    )
		    btn = guitk.BCPushButtonCreate(window, "OK", okClicked, lineEdit)
		    guitk.BCAddToolTip(
		        btn, "Accepts the window if lineEdit has text; otherwise rejects it"
		    )
		    # Warning: never set both accept and reject function to retun 0
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def okClicked(btn, lineEdit):
		    window = guitk.BCGetTopWidget(btn)
		    if window:
		        guitk.BCWindowAccept(window) if guitk.BCLineEditHasText(
		            lineEdit
		        ) else guitk.BCWindowReject(window)
		    return 0
		
		
		def acceptFunc(window, data):
		    print("Window accepted (Enter). Window will close (return 1).")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Window rejected (Esc). Window will remain open (return 0).")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowReject(w: object) -> None:

	"""

	Calls the BCWindow's reject function.
	If no custom reject function has been set, a default one will be called.
	Normally this function is called when we press the 'Cancel' button to close the BCWindow.

	Parameters
	----------
	w : object
		the BCWindow whose reject function will be called.

	Returns
	-------
	None

	See Also
	--------
	BCWindowAccept

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Accept/Reject Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelCreate(window, "WindowAcceptFunction returns 1 (Closes the window)")
		    guitk.BCLabelCreate(
		        window, "WindowRejectFunction returns 0 (Keeps the window open)"
		    )
		    lineEdit = guitk.BCLineEditCreate(window, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineEdit,
		        "Submitting a lineEdit, i.e. pressing Enter while it has focus, triggers WindowAccept",
		    )
		    btn = guitk.BCPushButtonCreate(window, "OK", okClicked, lineEdit)
		    guitk.BCAddToolTip(
		        btn, "Accepts the window if lineEdit has text; otherwise rejects it"
		    )
		    # Warning: never set both accept and reject function to retun 0
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		    guitk.BCShow(window)
		
		
		def okClicked(btn, lineEdit):
		    window = guitk.BCGetTopWidget(btn)
		    if window:
		        guitk.BCWindowAccept(window) if guitk.BCLineEditHasText(
		            lineEdit
		        ) else guitk.BCWindowReject(window)
		    return 0
		
		
		def acceptFunc(window, data):
		    print("Window accepted (Enter). Window will close (return 1).")
		    return 1
		
		
		def rejectFunc(window, data):
		    print("Window rejected (Esc). Window will remain open (return 0).")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetCheckFunction(w: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the checkFunction of BCWindow w.
	The checkFunction can be used to check the data entered by the user on a BCWindow. If a checkFunction returns None, the data are considered correct, and the BCWindow is accepted (i.e. the accept function is called). If it returns a string, this means that some wrong data have been entered and thus the window remains active and showing, while a text message is displayed containing the returned string.
	NOTE: The checkFunction is called on BCWindow accept, BCComboBox activated, BCRadioButton toggled and BCCheckBox state changes.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow whose the checkFunction will be set.

	funct : Callable
		the checkFunction. See BC_WINDOW_CHECK_FUNCTION for details.
		string BC_WINDOW_CHECK_FUNCTION(w, data)
		The function to be called when check of data entered is needed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * w : object
		                    the BCWindow.
		          * data : Any
		                    anything that may be required in function.
		
		Return: If you return a text, a warning dialog window with this text as a short message will appear. If you return an empty string nothing happens.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Callbacks Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCSpacerCreate(hBox)
		    labelOnClose = guitk.BCLabelCreate(hBox, "onCloseFunction")
		    guitk.BCLabelSetAlignment(
		        labelOnClose, guitk.constants.BCAlignTop | guitk.constants.BCAlignRight
		    )
		    labelArrow = guitk.BCLabelCreate(hBox, "")
		    guitk.BCLabelSetIconFileName(labelArrow, "arrow_up_small.svg")
		    guitk.BCLabelSetAlignment(
		        labelArrow, guitk.constants.BCAlignTop | guitk.constants.BCAlignRight
		    )
		    hBoxReject = guitk.BCHBoxCreate(window)
		    lineEditCaption = guitk.BCLineEditCreate(hBoxReject, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineEditCaption, "Insert a Window Caption to reject eg. 'Properties'"
		    )
		    guitk.BCPushButtonCreate(hBoxReject, "Reject window", rejectWindow, lineEditCaption)
		    chkBoxCanBeAccepted = guitk.BCCheckBoxCreate(window, "Acceptable")
		    guitk.BCDialogButtonBoxCreate(window)
		    guitk.BCWindowSetCheckFunction(window, windowCheck, chkBoxCanBeAccepted)
		    guitk.BCWindowSetAcceptFunction(window, windowAccept, None)
		    guitk.BCWindowSetRejectFunction(window, windowReject, None)
		    guitk.BCWindowSetOnCloseFunction(window, windowClose, None)
		    guitk.BCShow(window)
		
		
		def rejectWindow(btn, lineEditCaption):
		    captionText = guitk.BCLineEditGetText(lineEditCaption)
		    print("Window '" + captionText + "' rejected")
		    guitk.BCWindowCaptionReject(captionText)
		    return 0
		
		
		def windowCheck(window, chkBox):
		    print("Window Check activated!")
		    return (
		        ""
		        if guitk.BCCheckBoxIsChecked(chkBox)
		        else "Check Acceptable CheckBox in order to accept this window"
		    )
		
		
		# Warning: Do NOT set both accept and reject function to return 0
		def windowAccept(window, data):
		    print("Window Accepted!")
		    return 1
		
		
		# Warning: Do NOT set both accept and reject function to return 0
		def windowReject(window, data):
		    print("Window Rejected!")
		    return 1
		
		
		def windowClose(window, data):
		    print("Window closed using the X button!")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetOnCloseFunction(win: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the [x] close button of the typical BCWindow is pressed.
	
	WARNING: funct will be called ONLY when the [x] button is pressed and NOT if the window is destroyed by any other way!
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow.

	funct : Callable
		the function that will be called. See BC_WINDOW_ON_CLOSE_FUNCTION for details
		integer BC_WINDOW_ON_CLOSE_FUNCTION(w, data)
		The function to be called when the [x] button of BCWindow w is pressed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * w : object
		                    the BCWindow.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		a pointer to any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCWindowSetRejectFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Callbacks Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCSpacerCreate(hBox)
		    labelOnClose = guitk.BCLabelCreate(hBox, "onCloseFunction")
		    guitk.BCLabelSetAlignment(
		        labelOnClose, guitk.constants.BCAlignTop | guitk.constants.BCAlignRight
		    )
		    labelArrow = guitk.BCLabelCreate(hBox, "")
		    guitk.BCLabelSetIconFileName(labelArrow, "arrow_up_small.svg")
		    guitk.BCLabelSetAlignment(
		        labelArrow, guitk.constants.BCAlignTop | guitk.constants.BCAlignRight
		    )
		    hBoxReject = guitk.BCHBoxCreate(window)
		    lineEditCaption = guitk.BCLineEditCreate(hBoxReject, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineEditCaption, "Insert a Window Caption to reject eg. 'Properties'"
		    )
		    guitk.BCPushButtonCreate(hBoxReject, "Reject window", rejectWindow, lineEditCaption)
		    chkBoxCanBeAccepted = guitk.BCCheckBoxCreate(window, "Acceptable")
		    guitk.BCDialogButtonBoxCreate(window)
		    guitk.BCWindowSetCheckFunction(window, windowCheck, chkBoxCanBeAccepted)
		    guitk.BCWindowSetAcceptFunction(window, windowAccept, None)
		    guitk.BCWindowSetRejectFunction(window, windowReject, None)
		    guitk.BCWindowSetOnCloseFunction(window, windowClose, None)
		    guitk.BCShow(window)
		
		
		def rejectWindow(btn, lineEditCaption):
		    captionText = guitk.BCLineEditGetText(lineEditCaption)
		    print("Window '" + captionText + "' rejected")
		    guitk.BCWindowCaptionReject(captionText)
		    return 0
		
		
		def windowCheck(window, chkBox):
		    print("Window Check activated!")
		    return (
		        ""
		        if guitk.BCCheckBoxIsChecked(chkBox)
		        else "Check Acceptable CheckBox in order to accept this window"
		    )
		
		
		# Warning: Do NOT set both accept and reject function to return 0
		def windowAccept(window, data):
		    print("Window Accepted!")
		    return 1
		
		
		# Warning: Do NOT set both accept and reject function to return 0
		def windowReject(window, data):
		    print("Window Rejected!")
		    return 1
		
		
		def windowClose(window, data):
		    print("Window closed using the X button!")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSaveControlSettings(win: object) -> None:

	"""

	On demand save the settings for children of window win to xml file, if children widgets support this functionality.
	BCSetSaveSettings() must first be called with the desired children using unique names.
	On demand save for individual widget is not supported. If you want to auto save settings for individual widget
	use BCSetSaveSettings(). If window win does not accommodate widgets which save their settings, nothing happens.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow.

	Returns
	-------
	None

	See Also
	--------
	BCWindowReadControlSettings

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Control Settings Example", guitk.constants.BCOnExitDestroy
		    )
		    for i in range(10):
		        toolBtn = guitk.BCToolButtonCreate(
		            window, "logo_sdm.svg", "Button " + str(i), None, None
		        )
		        guitk.BCSetSaveSettings(toolBtn, "ControlSettingsExample_button" + str(i))
		        guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCPushButtonCreate(window, "Adjust Window Size", adjustWindowSize, window)
		    guitk.BCPushButtonCreate(
		        window, "Save Current Settings", saveControlSettings, window
		    )
		    guitk.BCPushButtonCreate(window, "Load Settings", readControlSettings, window)
		    guitk.BCWindowShowTitleBarButtons(
		        window, guitk.constants.BCMaximizeButton | guitk.constants.BCCloseButton
		    )
		    guitk.BCShow(window)
		
		
		def adjustWindowSize(btn, window):
		    guitk.BCWindowAdjustSize(window)
		    return 0
		
		
		def saveControlSettings(btn, window):
		    guitk.BCWindowSaveControlSettings(window)
		    return 0
		
		
		def readControlSettings(btn, window):
		    guitk.BCWindowReadControlSettings(window)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowReadControlSettings(win: object) -> None:

	"""

	On demand read the settings for all children from xml file, if children widgets support this functionality.
	On demand read for individual widget is not supported. If you want to auto save settings for individual widget
	use BCSetSaveSettings(). If window win does not accommodate widgets which save their settings, nothing happens.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow.

	Returns
	-------
	None

	See Also
	--------
	BCWindowSaveControlSettings

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Control Settings Example", guitk.constants.BCOnExitDestroy
		    )
		    for i in range(10):
		        toolBtn = guitk.BCToolButtonCreate(
		            window, "logo_sdm.svg", "Button " + str(i), None, None
		        )
		        guitk.BCSetSaveSettings(toolBtn, "ControlSettingsExample_button" + str(i))
		        guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCPushButtonCreate(window, "Adjust Window Size", adjustWindowSize, window)
		    guitk.BCPushButtonCreate(
		        window, "Save Current Settings", saveControlSettings, window
		    )
		    guitk.BCPushButtonCreate(window, "Load Settings", readControlSettings, window)
		    guitk.BCWindowShowTitleBarButtons(
		        window, guitk.constants.BCMaximizeButton | guitk.constants.BCCloseButton
		    )
		    guitk.BCShow(window)
		
		
		def adjustWindowSize(btn, window):
		    guitk.BCWindowAdjustSize(window)
		    return 0
		
		
		def saveControlSettings(btn, window):
		    guitk.BCWindowSaveControlSettings(window)
		    return 0
		
		
		def readControlSettings(btn, window):
		    guitk.BCWindowReadControlSettings(window)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetOnPlaceChangedFunction(win: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets a callback function funct which will be called every time window win is docked or undocked.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow.

	funct : Callable
		the callback function. See BC_WINDOW_ON_PLACE_CHANGED_FUNCTION for details.
		integer BC_WINDOW_ON_PLACE_CHANGED_FUNCTION(w, p, data)
		The function to be called when the BCWindow w is docked or undocked.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * w : object
		                    the BCWindow.
		          * p : int
		                    the new place of the BCWindow. Can be either BCInDock or BCOutsideDock.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Docked Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    notStr = "" if guitk.BCWindowIsDocked(window) else "not "
		    isDockedLabel = guitk.BCLabelCreate(hBox, "This window is\\n" + notStr + "docked")
		    guitk.BCLabelSetAlignment(isDockedLabel, guitk.constants.BCAlignCenter)
		    guitk.BCWindowSetOnPlaceChangedFunction(window, windowDockChanged, isDockedLabel)
		    guitk.BCShow(window)
		
		
		def windowDockChanged(window, position, isDockedLabel):
		    notStr = "" if position == guitk.constants.BCInDock else "not "
		    guitk.BCLabelSetText(isDockedLabel, "This window is\\n" + notStr + "docked")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetPosition(win: object, x: int, y: int) -> None:

	"""

	Sets the position of BCWindow win.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow.

	x : int
		the x coordinate where wid will be displayed.

	y : int
		the y coordinate where wid will be displayed.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    win = guitk.BCWindowCreate(
		        "BCWindow Geometry Example", guitk.constants.BCOnExitDestroy
		    )
		
		    guitk.BCPushButtonCreate(win, "Move window", moveWindowFunc, win)
		    guitk.BCPushButtonCreate(win, "Resize window", resizeWindowFunc, win)
		
		    guitk.BCWindowSetInitGeometry(win, 100, 100, 200, 200)
		    guitk.BCWindowSetSaveSettings(win, False)
		    guitk.BCShow(win)
		
		
		def moveWindowFunc(b, win):
		    guitk.BCWindowSetPosition(win, 300, 300)
		    return 0
		
		
		def resizeWindowFunc(b, win):
		    guitk.BCWindowSetSize(win, 400, 400)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowShowTitleBarButtons(w: object, buttons: int) -> None:

	"""

	Sets which titlebar buttons will be shown (close, minimize, maximize).
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow

	buttons : int
		BCEnumTitleBarButton values. Multiple values can be ored together. See BCEnumTitleBarButton for details.
		
		guitk.constants BCEnumTitleBarButton
		This enum type is used to describe which buttons (close, minimize or maximize) will be active on a toolbar.
		 - guitk.constants.BCNothing
		No buttons will be active on the toolbar
		 - guitk.constants.BCCloseButton
		Close button will be active on the toolbar
		 - guitk.constants.BCMaximizeButton
		Maximize button will be active on the toolbar
		 - guitk.constants.BCMinimizeButton
		Minimize button will be active on the toolbar

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Control Settings Example", guitk.constants.BCOnExitDestroy
		    )
		    for i in range(10):
		        toolBtn = guitk.BCToolButtonCreate(
		            window, "logo_sdm.svg", "Button " + str(i), None, None
		        )
		        guitk.BCSetSaveSettings(toolBtn, "ControlSettingsExample_button" + str(i))
		        guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCPushButtonCreate(window, "Adjust Window Size", adjustWindowSize, window)
		    guitk.BCPushButtonCreate(
		        window, "Save Current Settings", saveControlSettings, window
		    )
		    guitk.BCPushButtonCreate(window, "Load Settings", readControlSettings, window)
		    guitk.BCWindowShowTitleBarButtons(
		        window, guitk.constants.BCMaximizeButton | guitk.constants.BCCloseButton
		    )
		    guitk.BCShow(window)
		
		
		def adjustWindowSize(btn, window):
		    guitk.BCWindowAdjustSize(window)
		    return 0
		
		
		def saveControlSettings(btn, window):
		    guitk.BCWindowSaveControlSettings(window)
		    return 0
		
		
		def readControlSettings(btn, window):
		    guitk.BCWindowReadControlSettings(window)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowIsMinimizedToTitleBar(win: object) -> bool:

	"""

	Returns True if BCWindow win is minimized to title bar, otherwise False.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow that will be tested whether it is minimized to title bar or not.

	Returns
	-------
	bool
		True if win is minimized to title bar or False if it is not.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Not Minimized-To-TitleBar Example", guitk.constants.BCOnExitDestroy
		    )
		    label = guitk.BCLabelCreate(
		        window, "Try minimizing me by middle-clicking my TitleBar"
		    )
		    timer = guitk.BCTimerCreate(window)
		    guitk.BCTimerSetTimeoutFunction(timer, checkMinimized, window)
		    guitk.BCTimerStart(timer, 500, False)
		    guitk.BCShow(window)
		
		
		def checkMinimized(timer, window):
		    if guitk.BCWindowIsMinimizedToTitleBar(window):
		        guitk.BCSetCaption(window, "Minimized-To-TitleBar Example")
		    else:
		        guitk.BCSetCaption(window, "Not Minimized-To-TitleBar Example")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowAdjustSize(win: object) -> None:

	"""

	Adjusts the width and height of BCWindow win so that it takes up the minimum space while
	showing all of its contents.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow whose size will be adjusted.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Control Settings Example", guitk.constants.BCOnExitDestroy
		    )
		    for i in range(10):
		        toolBtn = guitk.BCToolButtonCreate(
		            window, "logo_sdm.svg", "Button " + str(i), None, None
		        )
		        guitk.BCSetSaveSettings(toolBtn, "ControlSettingsExample_button" + str(i))
		        guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCPushButtonCreate(window, "Adjust Window Size", adjustWindowSize, window)
		    guitk.BCPushButtonCreate(
		        window, "Save Current Settings", saveControlSettings, window
		    )
		    guitk.BCPushButtonCreate(window, "Load Settings", readControlSettings, window)
		    guitk.BCWindowShowTitleBarButtons(
		        window, guitk.constants.BCMaximizeButton | guitk.constants.BCCloseButton
		    )
		    guitk.BCShow(window)
		
		
		def adjustWindowSize(btn, window):
		    guitk.BCWindowAdjustSize(window)
		    return 0
		
		
		def saveControlSettings(btn, window):
		    guitk.BCWindowSaveControlSettings(window)
		    return 0
		
		
		def readControlSettings(btn, window):
		    guitk.BCWindowReadControlSettings(window)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetInitSize(win: object, initWidth: int, initHeight: int) -> None:

	"""

	Set the init width and init height of BCWindow win, if there are not any declaration for wins size in xml.
	Should be called before BCShow of win. Window win takes this init size only at the first show.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow whose size will be adjusted.

	initWidth : int
		the init width for win.

	initHeight : int
		the init height for win.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("BCWindow Example", guitk.constants.BCOnExitDestroy)
		
		    # add some widgets
		    frame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(frame, "Value (Line edit for integers)")
		    guitk.BCLineEditCreateInt(frame, 0)
		    # the OK Cancel dialog
		    guitk.BCDialogButtonBoxCreate(window)
		
		    guitk.BCWindowSetInitSize(window, 400, 200)
		    guitk.BCWindowSetSaveSettings(window, False)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
		    guitk.BCWindowSetRejectFunction(window, rejectFunc, None)
		
		    guitk.BCShow(window)
		
		
		def acceptFunc(win, data):
		    print("Window OK button clicked (Accept)")
		    return 1
		
		
		def rejectFunc(win, data):
		    print("Window cancel button clicked or Esc pressed (Reject)")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetInitGeometry(win: object, initX: int, initY: int, initWidth: int, initHeight: int) -> None:

	"""

	Set the init x, y, width and height of BCWindow win, if there are not any declaration for wins geometry in xml.
	Should be called before BCShow of win. Window win takes this init size only at the first show.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow whose size will be adjusted.

	initX : int
		the init x position for win.

	initY : int
		the init y position for win.

	initWidth : int
		the init width for win.

	initHeight : int
		the init height for win.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    win = guitk.BCWindowCreate(
		        "BCWindow Geometry Example", guitk.constants.BCOnExitDestroy
		    )
		
		    guitk.BCPushButtonCreate(win, "Move window", moveWindowFunc, win)
		    guitk.BCPushButtonCreate(win, "Resize window", resizeWindowFunc, win)
		
		    guitk.BCWindowSetInitGeometry(win, 100, 100, 200, 200)
		    guitk.BCWindowSetSaveSettings(win, False)
		    guitk.BCShow(win)
		
		
		def moveWindowFunc(b, win):
		    guitk.BCWindowSetPosition(win, 300, 300)
		    return 0
		
		
		def resizeWindowFunc(b, win):
		    guitk.BCWindowSetSize(win, 400, 400)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardCreate(name: str, a: int) -> object:

	"""

	Creates an empty wizard dialog with name name, which is used for window title as well.
	All BCWindow functions can be used for Wizard as well, for example BCWindowSetAcceptFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	name : str
		the name of the new widget (also its caption).

	a : int
		describes what will happen to the window when its filter returns 1 (i.e. on exit). See BCEnumExitAction for details.
		
		guitk.constants BCEnumExitAction
		This enum type defines what will happen to the window when its filter returns 1 (i.e. on
		exit). Exit action is used with BCWindowCreate for example.
		 - guitk.constants.BCOnExitHide
		hides the window.
		
		WARNING: var BCOnExitHide take no action when script ends.After script ends the window destroyed with var BCOnExitDestroy.
		var BCOnExitHide has action only if script not ends.
		
		WARNING: Take special care when you use this enumerator.
		You should destroy the window yourself in order to free the memory it holds.
		 - guitk.constants.BCOnExitDestroy
		destroys the window.

	Returns
	-------
	object
		The created wizard.

	See Also
	--------
	BCWizardAddPage

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard 2D Shapes Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(
		        wizard, wizardCreateFirstPage(wizard), "Introduction", "Create 2D Shapes", ""
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateSecondPage(wizard),
		        "Type",
		        "Select the type of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateThirdPage(wizard),
		        "Color",
		        "Select the color of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateForthPage(wizard),
		        "Confirmation",
		        "Shape is about to be created",
		        "",
		    )
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizardCurrentPageChanged, None)
		    guitk.BCShow(wizard)
		
		
		def wizardCreateFirstPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        p, "Design simple geometric two-dimensional shapes<br>in 4 simple steps."
		    )
		    guitk.BCSpacerCreate(p)
		    guitk.BCLabelCreate(p, "Please <b>click Next</b> to continue.")
		    return p
		
		
		def wizardCreateSecondPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    group = guitk.BCButtonGroupCreate(p, "Types", guitk.constants.BCVertical)
		    guitk.BCButtonGroupSetBorderMode(group, guitk.constants.BCNoBorderNoMargin)
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Circle", None, None), 0
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Pentagon", None, None), 1
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Square", None, None), 2
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Triangle", None, None), 3
		    )
		    guitk.BCButtonGroupSetButton(group, 0)
		    guitk.BCSpacerCreate(p)
		    guitk.BCSetUserDataKey(wizard, "TYPE_BUTTON_GROUP", group)
		    return p
		
		
		def wizardCreateThirdPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(p, "Please select a color that fills the shape.")
		    lview = guitk.BCListViewCreate(p, 2, ["Color", "Hex code"], 1)
		    lViewAddColor(lview, "Red", "#FF0000")
		    lViewAddColor(lview, "Green", "#00FF00")
		    lViewAddColor(lview, "Blue", "#0000FF")
		    lViewAddColor(lview, "Black", "#000000")
		    lViewAddColor(lview, "White", "#FFFFFF")
		    lViewAddColor(lview, "Orange", "#FFA500")
		    guitk.BCSetUserDataKey(wizard, "COLOR_LIST_VIEW", lview)
		    guitk.BCListViewSetSelectionChangedFunction(
		        lview, ColorsListViewSelectionChanged, wizard
		    )
		    guitk.BCListViewSetDoubleClickedFunction(lview, ColorsListViewDoubleClicked, wizard)
		    return p
		
		
		def lViewAddColor(lview, name, hexCode):
		    item = guitk.BCListViewAddTopLevelItem(lview)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, hexCode)
		    return item
		
		
		def ColorsListViewSelectionChanged(lview, wizard):
		    selected = guitk.BCListViewGetSelectedItem(lview)
		    # make color selection mandatory
		    if selected:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		    else:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    # make color selection mandatory
		    if selected:
		        if guitk.BCListViewItemGetText(selected, 0) == "Black":
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "Colors for perimeter and body shape are the same.",
		                guitk.constants.BCWidgetStateWarning,
		            )
		        else:
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "The perimeter will be drawn using black color.",
		                guitk.constants.BCWidgetStateInformation,
		            )
		    else:
		        guitk.BCWizardClearPageInfo(wizard, 2)
		    return 0
		
		
		def ColorsListViewDoubleClicked(lview, item, col, wizard):
		    if item:
		        guitk.BCWizardGoToNextPage(wizard)
		    return 0
		
		
		def wizardCreateForthPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    grid = guitk.BCGridLayoutCreate(p, 6, 3)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid, guitk.BCLabelCreate(p, "You selected to create a "), 0, 0, 0, 2, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Type:"), 1, 0, 0)
		    type = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, type, 1, 1, 0)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(p, "Perimeter color:"), 2, 0, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "<b>Black</b>"), 2, 1, 0)
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Body color:"), 3, 0, 0)
		    color = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, color, 3, 1, 0)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid,
		        guitk.BCLabelCreate(p, "Please <b>click Finish</b> to create the shape."),
		        5,
		        5,
		        0,
		        2,
		        0,
		    )
		    guitk.BCGridLayoutSetRowStretch(grid, 4, 1)
		    guitk.BCGridLayoutSetColStretch(grid, 2, 1)
		    guitk.BCSetUserDataKey(wizard, "TYPE_LABEL", type)
		    guitk.BCSetUserDataKey(wizard, "COLOR_LABEL", color)
		    return p
		
		
		def wizardCurrentPageChanged(wizard, oldIndex, newIndex, data):
		    if newIndex == 2:
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        if guitk.BCListViewGetSelectedItem(lview):
		            guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		        else:
		            guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    elif newIndex == 3:
		        group = guitk.BCGetUserDataKey(wizard, "TYPE_BUTTON_GROUP")
		        type = guitk.BCGetUserDataKey(wizard, "TYPE_LABEL")
		        typestr = (
		            "<b>" + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(group)) + "</b>"
		        )
		        guitk.BCLabelSetText(type, typestr)
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        color = guitk.BCGetUserDataKey(wizard, "COLOR_LABEL")
		        colorstr = (
		            "<b>"
		            + guitk.BCListViewItemGetText(guitk.BCListViewGetSelectedItem(lview), 0)
		            + "</b>"
		        )
		        guitk.BCLabelSetText(color, colorstr)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardAddPage(wiz: object, w: object, sidebarText: str, titleText: str, infoText: str) -> object:

	"""

	Adds widget w at wizard wiz as a new page with sidebar sidebarText, titleText and infoText text.
	
	Empty sidebar text or empty title is not allowed.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	w : object
		the widget to be added as a page.

	sidebarText : str
		the text to be shown at the left sidebar list.

	titleText : str, optional
		the text to be shown bold on the top of the page (main instruction to explain user's objective with the page).

	infoText : str, optional
		the text to be used as additional help to the user (displayed below contents at the bottom and is prefixed with an info icon).

	Returns
	-------
	object
		the newly inserted page widget.

	See Also
	--------
	BCWizardRemovePage

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard 2D Shapes Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(
		        wizard, wizardCreateFirstPage(wizard), "Introduction", "Create 2D Shapes", ""
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateSecondPage(wizard),
		        "Type",
		        "Select the type of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateThirdPage(wizard),
		        "Color",
		        "Select the color of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateForthPage(wizard),
		        "Confirmation",
		        "Shape is about to be created",
		        "",
		    )
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizardCurrentPageChanged, None)
		    guitk.BCShow(wizard)
		
		
		def wizardCreateFirstPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        p, "Design simple geometric two-dimensional shapes<br>in 4 simple steps."
		    )
		    guitk.BCSpacerCreate(p)
		    guitk.BCLabelCreate(p, "Please <b>click Next</b> to continue.")
		    return p
		
		
		def wizardCreateSecondPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    group = guitk.BCButtonGroupCreate(p, "Types", guitk.constants.BCVertical)
		    guitk.BCButtonGroupSetBorderMode(group, guitk.constants.BCNoBorderNoMargin)
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Circle", None, None), 0
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Pentagon", None, None), 1
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Square", None, None), 2
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Triangle", None, None), 3
		    )
		    guitk.BCButtonGroupSetButton(group, 0)
		    guitk.BCSpacerCreate(p)
		    guitk.BCSetUserDataKey(wizard, "TYPE_BUTTON_GROUP", group)
		    return p
		
		
		def wizardCreateThirdPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(p, "Please select a color that fills the shape.")
		    lview = guitk.BCListViewCreate(p, 2, ["Color", "Hex code"], 1)
		    lViewAddColor(lview, "Red", "#FF0000")
		    lViewAddColor(lview, "Green", "#00FF00")
		    lViewAddColor(lview, "Blue", "#0000FF")
		    lViewAddColor(lview, "Black", "#000000")
		    lViewAddColor(lview, "White", "#FFFFFF")
		    lViewAddColor(lview, "Orange", "#FFA500")
		    guitk.BCSetUserDataKey(wizard, "COLOR_LIST_VIEW", lview)
		    guitk.BCListViewSetSelectionChangedFunction(
		        lview, ColorsListViewSelectionChanged, wizard
		    )
		    guitk.BCListViewSetDoubleClickedFunction(lview, ColorsListViewDoubleClicked, wizard)
		    return p
		
		
		def lViewAddColor(lview, name, hexCode):
		    item = guitk.BCListViewAddTopLevelItem(lview)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, hexCode)
		    return item
		
		
		def ColorsListViewSelectionChanged(lview, wizard):
		    selected = guitk.BCListViewGetSelectedItem(lview)
		    # make color selection mandatory
		    if selected:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		    else:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    # make color selection mandatory
		    if selected:
		        if guitk.BCListViewItemGetText(selected, 0) == "Black":
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "Colors for perimeter and body shape are the same.",
		                guitk.constants.BCWidgetStateWarning,
		            )
		        else:
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "The perimeter will be drawn using black color.",
		                guitk.constants.BCWidgetStateInformation,
		            )
		    else:
		        guitk.BCWizardClearPageInfo(wizard, 2)
		    return 0
		
		
		def ColorsListViewDoubleClicked(lview, item, col, wizard):
		    if item:
		        guitk.BCWizardGoToNextPage(wizard)
		    return 0
		
		
		def wizardCreateForthPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    grid = guitk.BCGridLayoutCreate(p, 6, 3)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid, guitk.BCLabelCreate(p, "You selected to create a "), 0, 0, 0, 2, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Type:"), 1, 0, 0)
		    type = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, type, 1, 1, 0)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(p, "Perimeter color:"), 2, 0, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "<b>Black</b>"), 2, 1, 0)
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Body color:"), 3, 0, 0)
		    color = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, color, 3, 1, 0)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid,
		        guitk.BCLabelCreate(p, "Please <b>click Finish</b> to create the shape."),
		        5,
		        5,
		        0,
		        2,
		        0,
		    )
		    guitk.BCGridLayoutSetRowStretch(grid, 4, 1)
		    guitk.BCGridLayoutSetColStretch(grid, 2, 1)
		    guitk.BCSetUserDataKey(wizard, "TYPE_LABEL", type)
		    guitk.BCSetUserDataKey(wizard, "COLOR_LABEL", color)
		    return p
		
		
		def wizardCurrentPageChanged(wizard, oldIndex, newIndex, data):
		    if newIndex == 2:
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        if guitk.BCListViewGetSelectedItem(lview):
		            guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		        else:
		            guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    elif newIndex == 3:
		        group = guitk.BCGetUserDataKey(wizard, "TYPE_BUTTON_GROUP")
		        type = guitk.BCGetUserDataKey(wizard, "TYPE_LABEL")
		        typestr = (
		            "<b>" + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(group)) + "</b>"
		        )
		        guitk.BCLabelSetText(type, typestr)
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        color = guitk.BCGetUserDataKey(wizard, "COLOR_LABEL")
		        colorstr = (
		            "<b>"
		            + guitk.BCListViewItemGetText(guitk.BCListViewGetSelectedItem(lview), 0)
		            + "</b>"
		        )
		        guitk.BCLabelSetText(color, colorstr)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardPageAt(wiz: object, index: int) -> object:

	"""

	Returns the widget that used as a page at index or 0 if index is out of range.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the page index. The valid range is from 0 to BCWizardPageCount()-1.

	Returns
	-------
	object
		the page widget at index.

	See Also
	--------
	BCWizardAddPage

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardAddUserButton(wiz: object, b: object) -> None:

	"""

	Add an extra button at the bottom left area of wizard (in the same line with Back Next buttons).
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	b : object
		can be a PushButton or a ToolButton.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardSetCurrentPageChangedFunction(wiz: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function to be called each time a page has changed.
	Wizard pages change by the user, by clicking Back or Next buttons. Previous pages can be accessed through the page title list.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	funct : Callable
		the function that will be called when a page has changed.
		See BC_WIZARD_CURRENT_PAGE_CHANGED_FUNCTION for details.
		integer BC_WIZARD_CURRENT_PAGE_CHANGED_FUNCTION(wiz, oldIndex, newIndex, data)
		The function to be called when wizard wiz page has changed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * wiz : object
		                    the wizard.
		          * oldIndex : int
		                    the index of previous page.
		          * newIndex : int
		                    the index of new page.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard 2D Shapes Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(
		        wizard, wizardCreateFirstPage(wizard), "Introduction", "Create 2D Shapes", ""
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateSecondPage(wizard),
		        "Type",
		        "Select the type of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateThirdPage(wizard),
		        "Color",
		        "Select the color of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateForthPage(wizard),
		        "Confirmation",
		        "Shape is about to be created",
		        "",
		    )
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizardCurrentPageChanged, None)
		    guitk.BCShow(wizard)
		
		
		def wizardCreateFirstPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        p, "Design simple geometric two-dimensional shapes<br>in 4 simple steps."
		    )
		    guitk.BCSpacerCreate(p)
		    guitk.BCLabelCreate(p, "Please <b>click Next</b> to continue.")
		    return p
		
		
		def wizardCreateSecondPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    group = guitk.BCButtonGroupCreate(p, "Types", guitk.constants.BCVertical)
		    guitk.BCButtonGroupSetBorderMode(group, guitk.constants.BCNoBorderNoMargin)
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Circle", None, None), 0
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Pentagon", None, None), 1
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Square", None, None), 2
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Triangle", None, None), 3
		    )
		    guitk.BCButtonGroupSetButton(group, 0)
		    guitk.BCSpacerCreate(p)
		    guitk.BCSetUserDataKey(wizard, "TYPE_BUTTON_GROUP", group)
		    return p
		
		
		def wizardCreateThirdPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(p, "Please select a color that fills the shape.")
		    lview = guitk.BCListViewCreate(p, 2, ["Color", "Hex code"], 1)
		    lViewAddColor(lview, "Red", "#FF0000")
		    lViewAddColor(lview, "Green", "#00FF00")
		    lViewAddColor(lview, "Blue", "#0000FF")
		    lViewAddColor(lview, "Black", "#000000")
		    lViewAddColor(lview, "White", "#FFFFFF")
		    lViewAddColor(lview, "Orange", "#FFA500")
		    guitk.BCSetUserDataKey(wizard, "COLOR_LIST_VIEW", lview)
		    guitk.BCListViewSetSelectionChangedFunction(
		        lview, ColorsListViewSelectionChanged, wizard
		    )
		    guitk.BCListViewSetDoubleClickedFunction(lview, ColorsListViewDoubleClicked, wizard)
		    return p
		
		
		def lViewAddColor(lview, name, hexCode):
		    item = guitk.BCListViewAddTopLevelItem(lview)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, hexCode)
		    return item
		
		
		def ColorsListViewSelectionChanged(lview, wizard):
		    selected = guitk.BCListViewGetSelectedItem(lview)
		    # make color selection mandatory
		    if selected:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		    else:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    # make color selection mandatory
		    if selected:
		        if guitk.BCListViewItemGetText(selected, 0) == "Black":
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "Colors for perimeter and body shape are the same.",
		                guitk.constants.BCWidgetStateWarning,
		            )
		        else:
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "The perimeter will be drawn using black color.",
		                guitk.constants.BCWidgetStateInformation,
		            )
		    else:
		        guitk.BCWizardClearPageInfo(wizard, 2)
		    return 0
		
		
		def ColorsListViewDoubleClicked(lview, item, col, wizard):
		    if item:
		        guitk.BCWizardGoToNextPage(wizard)
		    return 0
		
		
		def wizardCreateForthPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    grid = guitk.BCGridLayoutCreate(p, 6, 3)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid, guitk.BCLabelCreate(p, "You selected to create a "), 0, 0, 0, 2, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Type:"), 1, 0, 0)
		    type = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, type, 1, 1, 0)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(p, "Perimeter color:"), 2, 0, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "<b>Black</b>"), 2, 1, 0)
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Body color:"), 3, 0, 0)
		    color = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, color, 3, 1, 0)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid,
		        guitk.BCLabelCreate(p, "Please <b>click Finish</b> to create the shape."),
		        5,
		        5,
		        0,
		        2,
		        0,
		    )
		    guitk.BCGridLayoutSetRowStretch(grid, 4, 1)
		    guitk.BCGridLayoutSetColStretch(grid, 2, 1)
		    guitk.BCSetUserDataKey(wizard, "TYPE_LABEL", type)
		    guitk.BCSetUserDataKey(wizard, "COLOR_LABEL", color)
		    return p
		
		
		def wizardCurrentPageChanged(wizard, oldIndex, newIndex, data):
		    if newIndex == 2:
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        if guitk.BCListViewGetSelectedItem(lview):
		            guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		        else:
		            guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    elif newIndex == 3:
		        group = guitk.BCGetUserDataKey(wizard, "TYPE_BUTTON_GROUP")
		        type = guitk.BCGetUserDataKey(wizard, "TYPE_LABEL")
		        typestr = (
		            "<b>" + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(group)) + "</b>"
		        )
		        guitk.BCLabelSetText(type, typestr)
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        color = guitk.BCGetUserDataKey(wizard, "COLOR_LABEL")
		        colorstr = (
		            "<b>"
		            + guitk.BCListViewItemGetText(guitk.BCListViewGetSelectedItem(lview), 0)
		            + "</b>"
		        )
		        guitk.BCLabelSetText(color, colorstr)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardSetNextButtonEnabled(wiz: object, enabled: bool) -> None:

	"""

	Set whether Next button of wizard is enabled.
	By default Next button is enabled for all pages. If current page is the last, this function affects Finish button.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	enabled : bool
		set False to disable or True to enable.

	Returns
	-------
	None

	See Also
	--------
	BCWizardIsNextButtonEnabled

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard 2D Shapes Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(
		        wizard, wizardCreateFirstPage(wizard), "Introduction", "Create 2D Shapes", ""
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateSecondPage(wizard),
		        "Type",
		        "Select the type of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateThirdPage(wizard),
		        "Color",
		        "Select the color of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateForthPage(wizard),
		        "Confirmation",
		        "Shape is about to be created",
		        "",
		    )
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizardCurrentPageChanged, None)
		    guitk.BCShow(wizard)
		
		
		def wizardCreateFirstPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        p, "Design simple geometric two-dimensional shapes<br>in 4 simple steps."
		    )
		    guitk.BCSpacerCreate(p)
		    guitk.BCLabelCreate(p, "Please <b>click Next</b> to continue.")
		    return p
		
		
		def wizardCreateSecondPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    group = guitk.BCButtonGroupCreate(p, "Types", guitk.constants.BCVertical)
		    guitk.BCButtonGroupSetBorderMode(group, guitk.constants.BCNoBorderNoMargin)
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Circle", None, None), 0
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Pentagon", None, None), 1
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Square", None, None), 2
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Triangle", None, None), 3
		    )
		    guitk.BCButtonGroupSetButton(group, 0)
		    guitk.BCSpacerCreate(p)
		    guitk.BCSetUserDataKey(wizard, "TYPE_BUTTON_GROUP", group)
		    return p
		
		
		def wizardCreateThirdPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(p, "Please select a color that fills the shape.")
		    lview = guitk.BCListViewCreate(p, 2, ["Color", "Hex code"], 1)
		    lViewAddColor(lview, "Red", "#FF0000")
		    lViewAddColor(lview, "Green", "#00FF00")
		    lViewAddColor(lview, "Blue", "#0000FF")
		    lViewAddColor(lview, "Black", "#000000")
		    lViewAddColor(lview, "White", "#FFFFFF")
		    lViewAddColor(lview, "Orange", "#FFA500")
		    guitk.BCSetUserDataKey(wizard, "COLOR_LIST_VIEW", lview)
		    guitk.BCListViewSetSelectionChangedFunction(
		        lview, ColorsListViewSelectionChanged, wizard
		    )
		    guitk.BCListViewSetDoubleClickedFunction(lview, ColorsListViewDoubleClicked, wizard)
		    return p
		
		
		def lViewAddColor(lview, name, hexCode):
		    item = guitk.BCListViewAddTopLevelItem(lview)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, hexCode)
		    return item
		
		
		def ColorsListViewSelectionChanged(lview, wizard):
		    selected = guitk.BCListViewGetSelectedItem(lview)
		    # make color selection mandatory
		    if selected:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		    else:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    # make color selection mandatory
		    if selected:
		        if guitk.BCListViewItemGetText(selected, 0) == "Black":
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "Colors for perimeter and body shape are the same.",
		                guitk.constants.BCWidgetStateWarning,
		            )
		        else:
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "The perimeter will be drawn using black color.",
		                guitk.constants.BCWidgetStateInformation,
		            )
		    else:
		        guitk.BCWizardClearPageInfo(wizard, 2)
		    return 0
		
		
		def ColorsListViewDoubleClicked(lview, item, col, wizard):
		    if item:
		        guitk.BCWizardGoToNextPage(wizard)
		    return 0
		
		
		def wizardCreateForthPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    grid = guitk.BCGridLayoutCreate(p, 6, 3)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid, guitk.BCLabelCreate(p, "You selected to create a "), 0, 0, 0, 2, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Type:"), 1, 0, 0)
		    type = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, type, 1, 1, 0)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(p, "Perimeter color:"), 2, 0, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "<b>Black</b>"), 2, 1, 0)
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Body color:"), 3, 0, 0)
		    color = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, color, 3, 1, 0)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid,
		        guitk.BCLabelCreate(p, "Please <b>click Finish</b> to create the shape."),
		        5,
		        5,
		        0,
		        2,
		        0,
		    )
		    guitk.BCGridLayoutSetRowStretch(grid, 4, 1)
		    guitk.BCGridLayoutSetColStretch(grid, 2, 1)
		    guitk.BCSetUserDataKey(wizard, "TYPE_LABEL", type)
		    guitk.BCSetUserDataKey(wizard, "COLOR_LABEL", color)
		    return p
		
		
		def wizardCurrentPageChanged(wizard, oldIndex, newIndex, data):
		    if newIndex == 2:
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        if guitk.BCListViewGetSelectedItem(lview):
		            guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		        else:
		            guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    elif newIndex == 3:
		        group = guitk.BCGetUserDataKey(wizard, "TYPE_BUTTON_GROUP")
		        type = guitk.BCGetUserDataKey(wizard, "TYPE_LABEL")
		        typestr = (
		            "<b>" + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(group)) + "</b>"
		        )
		        guitk.BCLabelSetText(type, typestr)
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        color = guitk.BCGetUserDataKey(wizard, "COLOR_LABEL")
		        colorstr = (
		            "<b>"
		            + guitk.BCListViewItemGetText(guitk.BCListViewGetSelectedItem(lview), 0)
		            + "</b>"
		        )
		        guitk.BCLabelSetText(color, colorstr)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardIsNextButtonEnabled(wiz: object) -> int:

	"""

	Returns 1 if Next button of wizard is enabled (default), otherwise returns 0.
	If current page is the last, this function checks Finish button.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	Returns
	-------
	int

	See Also
	--------
	BCWizardSetNextButtonEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardCurrentIndex(wiz: object) -> int:

	"""

	Function is obsolete. Use BCWizardCurrentPage() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	Returns
	-------
	int
		the index of current page.

	"""

def BCWizardPageCount(wiz: object) -> int:

	"""

	Returns the number of pages in the wizard wiz.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	Returns
	-------
	int
		the number of pages.

	See Also
	--------
	BCWizardCurrentPage

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCApplicationClipboardSetText(text: str) -> None:

	"""

	Sets the text to application's Clipboard.
	This function is not supported under VR mode.

	Parameters
	----------
	text : str
		text to be set to application's Clipboard.

	Returns
	-------
	None

	See Also
	--------
	BCApplicationClipboardGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Set/Get Clipboard Example", guitk.constants.BCOnExitDestroy
		    )
		    # View the current clipboard value
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCBoxLayoutSetStretchFactor(
		        guitk.BCLayout(window), hBox, 1
		    )  # Let clipboard label have some space
		    label = guitk.BCLabelCreate(hBox, "Current Clipboard:")
		    guitk.BCLabelSetAlignment(
		        label, guitk.constants.BCAlignRight | guitk.constants.BCAlignVCenter
		    )
		    guitk.BCApplicationClipboardSetText("clipboard text")
		    labelClipboard = guitk.BCLabelCreate(hBox, guitk.BCApplicationClipboardGetText())
		    # A TextEdit to test upon
		    testTextEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(testTextEdit, "Test copy/paste here")
		    # A timer to continuously update text in labelClipboard
		    timer = guitk.BCTimerCreate(window)
		    guitk.BCTimerStart(timer, 100, False)  # 10 Hz
		    guitk.BCTimerSetTimeoutFunction(timer, timerTimeout, labelClipboard)
		    guitk.BCShow(window)
		
		
		def timerTimeout(timer, label):
		    guitk.BCLabelSetText(label, guitk.BCApplicationClipboardGetText())
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCApplicationClipboardGetText() -> str:

	"""

	Returns the application's Clipboard text or an empty string if there is no text
	This function is not supported under VR mode.

	Returns
	-------
	str
		the text of application's Clipboard.

	See Also
	--------
	BCApplicationClipboardSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Set/Get Clipboard Example", guitk.constants.BCOnExitDestroy
		    )
		    # View the current clipboard value
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCBoxLayoutSetStretchFactor(
		        guitk.BCLayout(window), hBox, 1
		    )  # Let clipboard label have some space
		    label = guitk.BCLabelCreate(hBox, "Current Clipboard:")
		    guitk.BCLabelSetAlignment(
		        label, guitk.constants.BCAlignRight | guitk.constants.BCAlignVCenter
		    )
		    guitk.BCApplicationClipboardSetText("clipboard text")
		    labelClipboard = guitk.BCLabelCreate(hBox, guitk.BCApplicationClipboardGetText())
		    # A TextEdit to test upon
		    testTextEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(testTextEdit, "Test copy/paste here")
		    # A timer to continuously update text in labelClipboard
		    timer = guitk.BCTimerCreate(window)
		    guitk.BCTimerStart(timer, 100, False)  # 10 Hz
		    guitk.BCTimerSetTimeoutFunction(timer, timerTimeout, labelClipboard)
		    guitk.BCShow(window)
		
		
		def timerTimeout(timer, label):
		    guitk.BCLabelSetText(label, guitk.BCApplicationClipboardGetText())
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewInfoBoxCreate(p: object, view: object) -> object:

	"""

	Function is obsolete. Use BCItemViewStatusBarCreate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	view : object
		the ListView for which the created ItemViewInfoBox will display info.

	Returns
	-------
	object
		the created ItemViewInfoBox.

	"""

def BCItemViewInfoBoxUpdate(infoBox: object) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarUpdate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	infoBox : object
		the ItemViewStatusBar

	Returns
	-------
	None

	"""

def BCItemViewInfoBoxBlockAutoUpdates(infoBox: object, index: int, block: bool) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarBlockAutoUpdates() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	infoBox : object
		the ItemViewStatusBar

	index : int
		set 0 to manually update left most field, 1 for the middle one and 2 for the field on the right.

	block : bool
		set True for manual updates or False for auto updates.

	Returns
	-------
	None

	"""

def BCItemViewInfoBoxSetText(infoBox: object, index: int, text: str) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarSetText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	infoBox : object
		the ItemViewStatusBar

	index : int
		set 0 for the left most field, 1 for the middle one and 2 for the field on the right.

	text : str
		the message to be displayed.

	Returns
	-------
	None

	"""

def BCItemViewInfoBoxSetTotalCounterMode(infoBox: object, mode: int) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarSetTotalCounterMode() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	infoBox : object
		the ItemViewStatusBar.

	mode : int
		set 1 to count all items of tree ListViews or 0 for top-level items only.

	Returns
	-------
	None

	"""

def BCListViewSetColumnResizeEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Enables or disables the resize property by the user of column col for the ListView lv.
	When header is hidden (and resize is enabled), columns can be resized with dragging inside viewport (between item cells).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	enable : bool
		True if the column should be allowed to be resized (the default), otherwise False.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetColumnResizeMode

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Simple Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 0, [], False)
		    guitk.BCListViewAddColumn(listView, "ID - Auto Width", -1)
		    guitk.BCListViewAddColumn(listView, "Part name - Fixed Width", 400)
		    guitk.BCListViewAddColumn(listView, "Version - Resize Disabled", -1)
		    guitk.BCListViewSetColumnResizeEnabled(listView, 2, False)
		    guitk.BCListViewAddColumn(listView, "Manufactured - Resized", 50)
		    guitk.BCListViewSetColumnWidth(listView, 3, 500)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    btnPrintStats = guitk.BCPushButtonCreate(
		        window, "Print Column Stats", printStats, listView
		    )
		    guitk.BCListViewSetColumnMovedFunction(listView, columnMoved, None)
		    guitk.BCListViewSetColumnResizedFunction(listView, columnResized, None)
		    guitk.BCWindowSetAcceptFunction(window, printStats, listView)
		    guitk.BCShow(window)
		
		
		def printStats(_, listView):
		    for col in range(guitk.BCListViewColumns(listView)):
		        print(
		            "Column {}: width={}, position={}".format(
		                col,
		                guitk.BCListViewColumnWidth(listView, col),
		                guitk.BCListViewColumnPosition(listView, col),
		            )
		        )
		    return 0
		
		
		def columnMoved(listView, col, fromPos, toPos, data):
		    print("Column {} moved position from: {} to: {}".format(col, fromPos, toPos))
		    return 0
		
		
		def columnResized(listView, col, oldSize, newSize, data):
		    print("Column {} resized from: {} to: {}".format(col, oldSize, newSize))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetToolTip(lv: object, col: int, tip: str) -> None:

	"""

	Set tooltip tip for the header section for column col of ListView lv.
	If you want to remove a tooltip just set an empty text.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	tip : str
		the tooltip.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Value"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", "2", "91.57")
		    addPart(listView, "1002", "Decklid", "1", "15.12")
		    createHeaderSideButtons(infoBox, listView, 2)
		    addPart(listView, "1003", "Pillar", "3", "62.03")
		    createHeaderSideButtons(infoBox, listView, 3)
		    guitk.BCListViewSetColumnDataType(listView, 2, guitk.constants.BCInt)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCDouble)
		    guitk.BCListViewSetRenameItemPrecision(listView, 3)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, quantity, value):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetText(item, 3, value)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def createHeaderSideButtons(infoBox, listView, col):
		    dict = {"listView": listView, "col": col, "infoBox": infoBox}
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "gear.svg", "", lambda btn, data: calculateFunct(btn, **data), dict
		    )
		    guitk.BCListViewHeaderSetColumnSideButton(listView, col, toolBtn)
		    guitk.BCListViewHeaderSetToolTip(listView, col, "Calculate Sum")
		
		
		def calculateFunct(btn, listView=0, col=0, infoBox=0):
		    isInt = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCInt
		    isDouble = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCDouble
		    rows = guitk.BCListViewTopLevelItemCount(listView)
		    total = 0
		    if isInt:
		        for row in range(rows):
		            total += guitk.BCListViewGetInt(listView, row, col)
		    elif isDouble:
		        for row in range(rows):
		            total += guitk.BCListViewGetDouble(listView, row, col)
		    text = (
		        "Sum of column '"
		        + guitk.BCListViewHeaderGetText(listView, col)
		        + "' is "
		        + str(total)
		    )
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetViewportText(lv: object, text: str) -> None:

	"""

	Displays a text at viewport instead of painting items.
	Message is displayed centered and wrapped (breaks lines at appropriate points to fit whole text), but you can provide break line (\n) as well inside your message.
	Items will not be deleted. To clear the message use the function with empty text. 
	NOTE: All events on items continue to operate normally (click, select, etc)
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	text : str
		the text to be displayed centered.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Size"], 0)
		    guitk.BCListViewSetViewportText(listView, "NO ITEMS INSERTED")
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetUniformRowHeights(lv: object, uniform: bool) -> None:

	"""

	This property defines whether all items in the ListView have the same height (default true).
	If property is true, the height is obtained from the first item in the view and is updated when the text data changes on that item.
	If property is false, each row has its own height related on its text data (for example item with text "a\nb" will be higher than item with text "ab")
	WARNING: ListView with non uniform row heights degrades performance.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	uniform : bool
		if you set 0 each item height depends on its data, while 1 indicates that the uniform height is obtained from the first item in the view.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemSpacing

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    addPart(listView, "1004", "Welded \\nAssembly", "Small", "6")
		    addPart(listView, "1005", "Spoiler", "Large", "1")
		    guitk.BCListViewSetUniformRowHeights(listView, False)
		    guitk.BCListViewSetSaveColumnsEnabled(listView, True)
		    guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "lock_small.svg", "", lockColumnsFunct, listView
		    )
		    text = "Click on the button to unlock columns' movement."
		    guitk.BCAddToolTip(toolBtn, text)
		    guitk.BCListViewSetHeaderToolButton(listView, toolBtn)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def lockColumnsFunct(btn, listView):
		    if guitk.BCListViewHeaderIsMovingEnabled(listView):
		        guitk.BCListViewHeaderSetMovingEnabled(listView, False)
		        guitk.BCButtonSetIconFileName(btn, "lock_small.svg")
		    else:
		        guitk.BCListViewHeaderSetMovingEnabled(listView, True)
		        guitk.BCButtonSetIconFileName(btn, "unlock_small.svg")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetCellsBackgroundColor(t: object, startRow: int, endRow: int, startColumn: int, endColumn: int, r: int, g: int, b: int) -> None:

	"""

	Changes the background color of given cells of BCTable t.
	Starting and ending row/column must be a number between zero and row/column count respectively. Also, the starting row/column must be
	a number less or equal to the ending one.
	If you want to reset the color to the default one, use the function BCTableResetCellsBackgroundColor().
	NOTE: This function sets the background color of the existing cells. Any new cells created by adding new rows/columns
	will be ignored. In case you want to keep the new color, see functions BCTableSetRowsCellsBackgroundColor() and BCTableSetColumnsCellsBackgroundColor().
	WARNING: This function sets the background color of given cells currently on the table. This means that, if previously
	BCTableSetRowsCellsBackgroundColor() or BCTableSetColumnsCellsBackgroundColor() has been called for those cells, on the next
	row/column addition, the background color of those cells will be set again to the color set by the latter functions!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	r : int
		the red component of the color to be set

	g : int
		the green component of the color to be set

	b : int
		the blue component of the color to be set

	Returns
	-------
	None

	See Also
	--------
	BCTableResetCellsBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable selection example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		    guitk.BCTableSetSelectionMode(table, guitk.constants.BCTableNoSelection)
		
		    reset = guitk.BCPushButtonCreate(w, "Reset background color", resetColorFunc, table)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    guitk.BCTableSetCellsBackgroundColor(t, row, row, col, col, 0, 255, 0)
		    return 0
		
		
		def resetColorFunc(b, table):
		    num_rows = guitk.BCTableNumRows(table)
		    num_cols = guitk.BCTableNumCols(table)
		    guitk.BCTableResetCellsBackgroundColor(table, 0, num_rows - 1, 0, num_cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableResetCellsBackgroundColor(t: object, startRow: int, endRow: int, startColumn: int, endColumn: int) -> None:

	"""

	Resets the background color of given cells of BCTable t.
	If no color is set, this function does nothing.
	WARNING: This function resets the background color of given cells currently on the table. This means that, if previously
	BCTableSetRowsCellsBackgroundColor() or BCTableSetColumnsCellsBackgroundColor() has been called for those cells, on the next
	row/column addition, the background color of those cells will be set again to the color set by the latter functions!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	Returns
	-------
	None

	See Also
	--------
	BCTableSetCellsBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "BCTable selection example", guitk.constants.BCOnExitDestroy
		    )
		
		    table = guitk.BCTableCreate(w, 3, 3)
		    guitk.BCTableSetCurrentCellChangedFunction(table, cellChangedFunc, None)
		    guitk.BCTableSetSelectionMode(table, guitk.constants.BCTableNoSelection)
		
		    reset = guitk.BCPushButtonCreate(w, "Reset background color", resetColorFunc, table)
		
		    guitk.BCShow(w)
		
		
		def cellChangedFunc(t, row, col, data):
		    guitk.BCTableSetCellsBackgroundColor(t, row, row, col, col, 0, 255, 0)
		    return 0
		
		
		def resetColorFunc(b, table):
		    num_rows = guitk.BCTableNumRows(table)
		    num_cols = guitk.BCTableNumCols(table)
		    guitk.BCTableResetCellsBackgroundColor(table, 0, num_rows - 1, 0, num_cols - 1)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableSetRowsCellsBackgroundColor(t: object, startRow: int, endRow: int, r: int, g: int, b: int) -> None:

	"""

	Sets the background color of cells, like BCTableSetCellsBackgroundColor(), but for whole rows.
	This function, in opposition to BCTableSetCellsBackgroundColor(), keeps track of the rows, so, any new cells
	added by adding new columns which belong to the range from startRow to endRow will also be colored
	with the given color.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	r : int
		the red component of the color to be set

	g : int
		the green component of the color to be set

	b : int
		the blue component of the color to be set

	Returns
	-------
	None

	See Also
	--------
	BCTableResetRowsCellsBackgroundColor

	"""

def BCTableSetColumnsCellsBackgroundColor(t: object, startColumn: int, endColumn: int, r: int, g: int, b: int) -> None:

	"""

	Sets the background color of cells, like BCTableSetCellsBackgroundColor(), but for whole columns.
	This functions does exactly what BCTableSetRowsCellsBackgroundColor() does but applies for columns.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	r : int
		the red component of the color to be set

	g : int
		the green component of the color to be set

	b : int
		the blue component of the color to be set

	Returns
	-------
	None

	See Also
	--------
	BCTableResetColumnsCellsBackgroundColor

	"""

def BCTableResetRowsCellsBackgroundColor(t: object, startRow: int, endRow: int) -> None:

	"""

	Resets the background color of the cells of BCTable t found between rows from startRow to endRow.
	In opposition to BCTableResetCellsBackgroundColor(), this function resets the colors and forgets the color setting.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	Returns
	-------
	None

	See Also
	--------
	BCTableSetRowsCellsBackgroundColor

	"""

def BCTableResetColumnsCellsBackgroundColor(t: object, startColumn: int, endColumn: int) -> None:

	"""

	Resets the background color of the cells of BCTable t found between columns from startColumn to endColumn.
	This functions does exactly what BCTableResetRowsCellsBackgroundColor() does but applies for columns.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	Returns
	-------
	None

	See Also
	--------
	BCTableSetColumnsCellsBackgroundColor

	"""

def BCWindowSetInitDockedPosition(w: object, neighbourName: str, dockPosition: int) -> None:

	"""

	Docked a BCWindow.
	This function overrides the window's position in xml file.
	If neighbourName is empty or invalid nothing happens.
	
	NOTE: For Script use must called with BCTimerSingleShot just before BCShow of BCWindow w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	neighbourName : str
		the name of the dockarea("LeftDockArea" or "TopDockArea" or "RightDockArea" or "BottomDockArea") or the name of neighbour Window.

	dockPosition : int
		the positions where the BCWindow will be allowed to dock. See BCEnumDockType for details).
		
		guitk.constants BCEnumDockType
		This enum type defines the docking supported by a BCWindow. It can be used with BCWidgetDockCreate().
		 - guitk.constants.BCDockNone
		No docking.
		 - guitk.constants.BCDockLeft
		The widget is allowed to dock to the left hand side of the main window.
		 - guitk.constants.BCDockRight
		The widget is allowed to dock to the right hand side of the main window.
		 - guitk.constants.BCDockTop
		The widget is allowed to dock to the top of the main window.
		 - guitk.constants.BCDockBottom
		The widget is allowed to dock to the bottom of the main window.

	Returns
	-------
	None

	See Also
	--------
	BCTimerSingleShot

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Init Docked Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelCreate(window, "This window should start in docked position")
		    guitk.BCTimerSingleShot(0, dockToDatabaseRight, window)
		    guitk.BCTimerSingleShot(0, checkDocking, window)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def dockToDatabaseRight(window):
		    guitk.BCWindowSetInitDockedPosition(window, "Database", guitk.constants.BCDockRight)
		    return 0
		
		
		def checkDocking(window):
		    if not guitk.BCWindowIsDocked(window):
		        print(
		            "Try changing the second argument of BCWindowSetInitDockedPosition to a valid name of a docked window"
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetInitTabbedPosition(w: object, neighbourName: str, tabPosition: int) -> None:

	"""

	Defines where the window w will be positioned (tabbed).
	This function overrides the window's position in xml file.
	If neighbourName is empty or invalid nothing happens.
	
	NOTE: For Script use must called with BCTimerSingleShot just before BCShow of BCWindow w.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	neighbourName : str
		the name of the neighbour Window.

	tabPosition : int
		the position where the BCWindow will be tabbed. Only BCLeftSide or BCRightSide are valid. See BCEnumHorizontalPosition for details).
		
		guitk.constants BCEnumHorizontalPosition
		This generic enum type defines a horizontal position.
		 - guitk.constants.BCLeftSide
		The left position.
		 - guitk.constants.BCRightSide
		The right position.
		 - guitk.constants.BCHorizontalCenter
		The middle position.

	Returns
	-------
	None

	See Also
	--------
	BCTimerSingleShot

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Init Tabbed Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelCreate(window, "This window should start in tabbed position")
		    guitk.BCTimerSingleShot(0, tabToDatabaseRight, window)
		    guitk.BCTimerSingleShot(0, checkDocking, window)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def tabToDatabaseRight(window):
		    guitk.BCWindowSetInitTabbedPosition(window, "Database", guitk.constants.BCRightSide)
		    return 0
		
		
		def checkDocking(window):
		    if not guitk.BCWindowIsDocked(window):
		        print(
		            "Try changing the second argument of BCWindowSetInitTabbedPosition to a valid name of a docked window"
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemColumnSetForegroundColor(item: object, col: int, mode: int, r: int, g: int, b: int) -> None:

	"""

	Sets a custom foreground color to a ListViewItem for column col.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose foreground color will be changed.

	col : int
		the column index.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	r : int
		the value of RED of the RGB foreground color.

	g : int
		the value of GREEN of the RGB foreground color.

	b : int
		the value of BLUE of the RGB foreground color.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemColumnResetForegroundColor

	"""

def BCListViewItemColumnResetForegroundColor(item: object, col: int, mode: int) -> None:

	"""

	Resets the foreground color of a ListViewItem for column col to the default one.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose foreground color will be reset. The new color will be in accordance with the colors of the parent ListView.

	col : int
		the column index.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemColumnSetForegroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemColumnSetBackgroundColor(item: object, col: int, mode: int, r: int, g: int, b: int) -> None:

	"""

	Sets a custom background color to a ListViewItem for column col.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose background color will be changed.

	col : int
		the column index.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	r : int
		the value of RED of the RGB background color.

	g : int
		the value of GREEN of the RGB background color.

	b : int
		the value of BLUE of the RGB background color.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemColumnResetBackgroundColor

	"""

def BCListViewItemColumnResetBackgroundColor(item: object, col: int, mode: int) -> None:

	"""

	Resets the background color of a ListViewItem for column col to the default one.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose background color will be reset. The new color will be in accordance with the colors of the parent ListView.

	col : int
		the column index.

	mode : int
		BCNormalMode and BCSelectedMode is only supported. See BCEnumMode for details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemColumnSetBackgroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetTextEllipsisPosition(lv: object, col: int, pos: int) -> None:

	"""

	Set where ellipsis (...) should be added for text that is too long to fit into an item for column col (default right).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	pos : int
		the position of '...' in the text. See BCEnumHorizontalPosition for details.
		
		guitk.constants BCEnumHorizontalPosition
		This generic enum type defines a horizontal position.
		 - guitk.constants.BCLeftSide
		The left position.
		 - guitk.constants.BCRightSide
		The right position.
		 - guitk.constants.BCHorizontalCenter
		The middle position.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetItemIconFileName(cb: object, fileName: str, index: int) -> None:

	"""

	Sets the pixmap file fileName as icon into the item of BCComboBox cb found at index index.
	This function is not supported under VR mode.

	Parameters
	----------
	cb : object
		the BCComboBox

	fileName : str
		the filename of the icon.

	index : int
		the index of the item

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxInsertItemIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    currRow = 0
		    rows = 3
		    cols = 2
		
		    window = guitk.BCWindowCreate(
		        "Simple ComboBox Example", guitk.constants.BCOnExitDestroy
		    )
		    grid = guitk.BCGridLayoutCreate(window, rows, cols)
		
		    label = guitk.BCLabelCreate(grid, "Regular")
		    regularCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Colors CheckBox", -1)
		    guitk.BCComboBoxInsertItem(regularCombo, "Enable Sizes CheckBox", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, regularCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(regularCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Colors")
		    colorsCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Red", 0)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_red_small.svg", 0)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Green", 1)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_green_small.svg", 1)
		    guitk.BCComboBoxInsertItem(colorsCombo, "Blue", 2)
		    guitk.BCComboBoxSetItemIconFileName(colorsCombo, "rect_blue_small.svg", 2)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, colorsCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(colorsCombo, ComboActivated, None)
		    currRow += 1
		
		    label = guitk.BCLabelCreate(grid, "Sizes")
		    sizesCombo = guitk.BCComboBoxCreate(grid, None)
		    guitk.BCComboBoxInsertItem(sizesCombo, "16x16", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "32x32", -1)
		    guitk.BCComboBoxInsertItem(sizesCombo, "64x64", -1)
		    guitk.BCGridLayoutAddWidget(grid, label, currRow, 0, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(
		        grid, sizesCombo, currRow, 1, guitk.constants.BCAlignAuto
		    )
		    guitk.BCComboBoxSetActivatedFunction(sizesCombo, ComboActivated, None)
		    currRow += 1
		
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        colorsCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        0,
		    )
		    guitk.BCComboBoxAddManagedWidget(
		        regularCombo,
		        sizesCombo,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		        1,
		    )
		
		    guitk.BCShow(window)
		
		
		def ComboActivated(combo, index, data):
		    print("Index is :" + str(guitk.BCComboBoxCurrentItem(combo)))
		    text = guitk.BCComboBoxGetText(combo, index)
		    print("Text is: " + text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewTopLevelItemExists(lv: object, col: int, text: str) -> bool:

	"""

	Searches for top level item that matches string text into column col.
	The search is case sensitive.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	text : str
		the string.

	Returns
	-------
	bool
		True if text matches ; False otherwise.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Tree/Flat View Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], 1)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addShapeGroup(listView, "Hexagon", "6")
		    addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    childItems = []
		    childItems.append(addShape(quad, "Cyclic", "4"))
		    childItems.append(addShape(quad, "Parallelogram", "4"))
		    childItems.append(addShape(quad, "Tangential", "4"))
		    childItems.append(addShape(quad, "Trapezoid", "4"))
		    childItems.append(addShape(tria, "Acute", "3"))
		    childItems.append(addShape(tria, "Equilateral", "3"))
		    childItems.append(addShape(tria, "Isosceles", "3"))
		    childItems.append(addShape(tria, "Right", "3"))
		    childItems.append(addShape(tria, "Scalene", "3"))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetItemsExpanded(listView, True)
		
		    btnSwitchView = guitk.BCPushButtonCreate(window, "Tree View", None, None)
		    guitk.BCButtonSetToggleButton(btnSwitchView, True)
		    guitk.BCButtonSetToggledFunction(btnSwitchView, switchView, childItems)  # new way
		    guitk.BCShow(window)
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parentItem, name, sides):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    guitk.BCListViewItemSetUserData(item, parentItem)
		    return item
		
		
		def switchView(btn, stateFlat, childItems):
		    listView = guitk.BCListViewItemGetListView(childItems[0])
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    for childItem in childItems:
		        parentItem = guitk.BCListViewItemGetUserData(childItem)
		        guitk.BCListViewTakeItem(parentItem if stateFlat else listView, childItem)
		        guitk.BCListViewInsertItem(listView if stateFlat else parentItem, childItem)
		        txtChild = guitk.BCListViewItemGetText(childItem, 0)
		        print(
		            "BCTopLevelItemExists(listView, '{}') = {}".format(
		                txtChild, guitk.BCListViewTopLevelItemExists(listView, 0, txtChild)
		            )
		        )
		    print("New TopLevelCount = {}".format(guitk.BCListViewTopLevelItemCount(listView)))
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCListViewSetRootIsDecorated(listView, not stateFlat)
		    guitk.BCButtonSetText(btn, "Flat View" if stateFlat else "Tree View")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewIsSelected(lv: object, item: object) -> bool:

	"""

	Returns True if item is selected, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	item : object
		the ListViewItem that will be checked.

	Returns
	-------
	bool
		True if item is selected; False otherwise

	See Also
	--------
	BCListViewSetSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Selected Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    for i in range(1, guitk.BCListViewColumns(listView)):
		        guitk.BCListViewSetSelectableColumn(listView, i, False)
		    guitk.BCStatusBarMessage(
		        guitk.BCStatusBarCreate(window),
		        "Click item on ID column or press Space to select an item.",
		    )
		    if guitk.BCListViewGetSelectionMode(listView) != guitk.constants.BCMulti:
		        guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, printIsSelected, None)
		    guitk.BCListViewRestoreSortState(listView)
		    hBox1 = guitk.BCHBoxCreate(window)
		    btnReverse = guitk.BCPushButtonCreate(
		        hBox1, "Reverse Selection", reverseSelectionAll, listView
		    )
		    btnAll = guitk.BCPushButtonCreate(
		        hBox1,
		        "Select All",
		        lambda b, listView: guitk.BCListViewSelectAll(listView),
		        listView,
		    )
		    btnClear = guitk.BCPushButtonCreate(
		        hBox1,
		        "Clear Selection",
		        lambda b, listView: guitk.BCListViewClearSelection(listView),
		        listView,
		    )
		    guitk.BCShow(window)
		
		
		def printIsSelected(listView, item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " isSelected = "
		        + str(guitk.BCListViewIsSelected(listView, item))
		    )
		    return 0
		
		
		def reverseSelectionAll(b, listView):
		    guitk.BCListViewInvertSelection(listView)
		    print("New Selected Count = {}".format(guitk.BCListViewCountSelected(listView)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetEnterPressedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the 'Return' (Enter) key is pressed inside ListView.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_ENTER_PRESSED_FUNCTION for details.
		integer BC_LISTVIEW_ENTER_PRESSED_FUNCTION(lv, item, data)
		The function to be called when the Enter (or Return) keyboard button is pressed on a ListView or a BCIconView.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView or the BCIconView.
		          * item : object
		                    the current item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 0 to block the event otherwise return 1.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Checkable", guitk.constants.BCOnExitDestroy)
		    hBox = guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetEnterPressedFunction(listView, enterPressed, None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def enterPressed(listView, item, data):
		    if guitk.BCListViewItemIsCheckable(item):
		        isOn = guitk.BCListViewItemCheckableIsOn(item)
		        guitk.BCListViewItemCheckableSetOn(item, not isOn)
		    return 0
		
		
		def itemToggled(item, state, data):
		    strState = "off to on" if state else "on to off"
		    print(
		        "Checkable Item with ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + " toggled from "
		        + strState
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Set item Checkable
		    guitk.BCListViewItemSetCheckable(item, True)
		    guitk.BCListViewItemCheckableSetToggledFunction(item, itemToggled, None)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetCurrentItemChangedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets a function that will be called when the current item in ListView lv has changed.
	The current item indicates keyboard focus in list view. Only one item can be the current at a time. You can shift the current item (without to change selected) by pressing Ctrl and Up/Down arrows.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called when current item has changed. See BC_LISTVIEW_CURRENT_ITEM_CHANGED_FUNCTION for details.
		integer BC_LISTVIEW_CURRENT_ITEM_CHANGED_FUNCTION(lv, item, data)
		The function to be called when the current item in ListView lv has changed.
		The current item indicates keyboard focus in list view.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the new current ListViewItem.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    label = guitk.BCLabelCreate(window, "Currently Selected Items: 0")
		    guitk.BCListViewSetCurrentItemChangedFunction(listView, currentChanged, label)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def currentChanged(listView, item, label):
		    print("Current item changed")
		    text = "Current Item: " + guitk.BCListViewItemGetText(item, 1)
		    if guitk.BCListViewItemIsSelected(item):
		        text += " is selected."
		    else:
		        text += " is not selected."
		    guitk.BCLabelSetText(label, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetText(lv: object, col: int, text: str) -> None:

	"""

	Sets the text displayed on the header of lv at column col to be text.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	text : str
		the text that will be displayed.

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderGetText

	"""

def BCListViewHeaderGetText(lv: object, col: int) -> str:

	"""

	Returns the text of the header of ListView lv at column col.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	str
		the text of the header of lv at col.

	See Also
	--------
	BCListViewHeaderSetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Column Visibility Changed Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, True)
		    guitk.BCListViewSetColumnVisibilityChangedFunction(
		        listView, lvColumnVisibilityChanged, None
		    )
		    guitk.BCShow(window)
		
		
		def lvColumnVisibilityChanged(listView, col, visible, data):
		    headerText = guitk.BCListViewHeaderGetText(listView, col)
		    isHidden = guitk.BCListViewIsColumnHidden(listView, col)
		    print(
		        "ListView Column '{}', (id {}) IsHidden = {}".format(headerText, col, isHidden)
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetAboutToRenameFunction(item: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets a function that will be called when renaming of a column of ListViewItem item starts.
	Use view oriented BCListViewSetAboutToRenameItemFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	funct : Callable
		the function that will be called. See BC_LISTVIEWITEM_ABOUT_TO_RENAME_FUNCTION for details.
		integer BC_LISTVIEWITEM_ABOUT_TO_RENAME_FUNCTION(item, col, data)
		The function to be called when renaming of a column of item starts.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 to cancel the rename action, or 0 to proceed.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetAboutToRenameItemFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Rename Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    chkBox = guitk.BCCheckBoxCreate(window, "Set DirectOnClicked Rename")
		    guitk.BCCheckBoxSetToggledFunction(chkBox, setDirectRename, listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetButton(item, 2, startRenameName, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 2, "edit_small.svg")
		    guitk.BCListViewItemSetText(item, 3, version)
		    guitk.BCListViewItemSetText(item, 4, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 4, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetAboutToRenameFunction(item, itemAboutToRename, None)
		    guitk.BCListViewItemSetRenameCanceledFunction(item, itemRenameCanceled, None)
		    guitk.BCListViewItemSetRenamedFunction(item, itemRenamed, None)
		    return item
		
		
		def startRenameName(item, col, data):
		    guitk.BCListViewStartRename(guitk.BCListViewItemGetListView(item), item, 1)
		    return 0
		
		
		def itemAboutToRename(item, col, data):
		    print(
		        "Item ID={}, column={} about to be renamed.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenameCanceled(item, col, data):
		    print(
		        "Item ID={}, column={} rename canceled.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenamed(item, col, data):
		    print(
		        "Item ID={}, column={} renamed. New Name: '{}'".format(
		            guitk.BCListViewItemGetText(item, 0),
		            col,
		            guitk.BCListViewItemGetText(item, col),
		        )
		    )
		    guitk.BCListViewItemSetUserData(item, col)
		    return 0
		
		
		def setDirectRename(chkBox, state, listView):
		    guitk.BCListViewSetRenameItemMode(
		        listView,
		        guitk.constants.BCDirectOnClicked
		        if state
		        else guitk.constants.BCDelayedOnSelectedClicked,
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewStartRename(lv: object, item: object, col: int) -> None:

	"""

	Starts renaming ListViewItem item at column col.
	If rename is not allowed (item rename type at col is BCRenameType_None) editing will not start.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetRenameType

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Rename Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    chkBox = guitk.BCCheckBoxCreate(window, "Set DirectOnClicked Rename")
		    guitk.BCCheckBoxSetToggledFunction(chkBox, setDirectRename, listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetButton(item, 2, startRenameName, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 2, "edit_small.svg")
		    guitk.BCListViewItemSetText(item, 3, version)
		    guitk.BCListViewItemSetText(item, 4, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 4, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetAboutToRenameFunction(item, itemAboutToRename, None)
		    guitk.BCListViewItemSetRenameCanceledFunction(item, itemRenameCanceled, None)
		    guitk.BCListViewItemSetRenamedFunction(item, itemRenamed, None)
		    return item
		
		
		def startRenameName(item, col, data):
		    guitk.BCListViewStartRename(guitk.BCListViewItemGetListView(item), item, 1)
		    return 0
		
		
		def itemAboutToRename(item, col, data):
		    print(
		        "Item ID={}, column={} about to be renamed.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenameCanceled(item, col, data):
		    print(
		        "Item ID={}, column={} rename canceled.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenamed(item, col, data):
		    print(
		        "Item ID={}, column={} renamed. New Name: '{}'".format(
		            guitk.BCListViewItemGetText(item, 0),
		            col,
		            guitk.BCListViewItemGetText(item, col),
		        )
		    )
		    guitk.BCListViewItemSetUserData(item, col)
		    return 0
		
		
		def setDirectRename(chkBox, state, listView):
		    guitk.BCListViewSetRenameItemMode(
		        listView,
		        guitk.constants.BCDirectOnClicked
		        if state
		        else guitk.constants.BCDelayedOnSelectedClicked,
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(lv: object, enable: bool) -> None:

	"""

	Shows a button on the right of the horizontal header that pops up a menu that enabled the user to show/hide columns.
	If you have column with empty header text (for example icon only), customize the display menu text with BCListViewHeaderSetStringRepresentation().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	enable : bool
		set to True to enable the header button with menu that show/hide columns, or False to hide it.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetColumnVisibilityChangeMenu

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Hide Column", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    # hide column on first show
		    guitk.BCListViewHideColumn(listView, 3)
		    # the user is able to modify columns visibility from a header button menu
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    # the user cannot hide from menu the column ID
		    guitk.BCListViewHeaderMenuBlockColumnVisibilityChange(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(
		        item, 0, guitk.constants.BCRenameType_None
		    )  # default
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderMenuBlockColumnVisibilityChange(lv: object, col: int, block: bool) -> None:

	"""

	Sets whether column col can be show/hide through column menu.
	It is useful when you have, for example, a visible column and you want it to remain visible (the user cannot hide it through column menu).
	The column where its visibility cannot change, displayed as a disabled item in the column menu.
	The default ListView column menu enables all columns to be shown/hidden.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	block : bool
		set True for col to block visibility change or False (default) to enable the user to show/hide it.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetHeaderMenuColumnVisibilityChangeEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Hide Column", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    # hide column on first show
		    guitk.BCListViewHideColumn(listView, 3)
		    # the user is able to modify columns visibility from a header button menu
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    # the user cannot hide from menu the column ID
		    guitk.BCListViewHeaderMenuBlockColumnVisibilityChange(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(
		        item, 0, guitk.constants.BCRenameType_None
		    )  # default
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnVisibilityChangeMenu(lv: object, pm: object=None) -> None:

	"""

	Set a custom popup menu to replace the menu which allows the user to hide/show columns.
	The default popup menu enables show/hide ability for all columns of the ListView. If you wish to have some columns unable to be hidden use a custom menu. After you use this function it is your responsibility to show/hide the columns.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	pm : object, optional
		the custom menu to replace the default one.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetHeaderMenuColumnVisibilityChangeEnabled

	"""

def BCListViewAcceptRename(lv: object) -> None:

	"""

	Confirm the renaming procedure of the editing item inside list lv.
	If no item is at rename procedure, nothing happens.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	"""

def BCListViewSetItemsSortedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called right after items sorted at ListView.
	Items can be sorted if you mouse click on the header of each column (and sorting property is enabled). Sorting can be ascending or descending.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		is a function that will be called when the user mouse click on the column header.
		See BC_LISTVIEW_ITEMS_SORTED_FUNCTION for details.
		integer BC_LISTVIEW_ITEMS_SORTED_FUNCTION(lv, col, ascending, data)
		The function to be called right after items sorted into the list (for example mouse click at a column header).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * col : int
		                    the ListView column.
		          * ascending : int
		                    1 for ascending and 0 for descending order.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemCompareFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SortedFunction Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetItemsSortedFunction(listView, itemsSorted, None)
		    guitk.BCShow(window)
		
		
		def itemsSorted(listView, col, ascending, data):
		    firstText = guitk.BCListViewGetText(listView, 0, col)
		    lastText = guitk.BCListViewItemGetText(guitk.BCListViewLastItem(listView), col)
		    print(
		        "Items sorted {}ending at column {}.".format(
		            "asc" if ascending else "desc", col
		        )
		    )
		    print(
		        "\\tFirst Sorted Column Value: {}\\n\\tLast Sorted Column Value: {}".format(
		            firstText, lastText
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetFilterAboutToApplyFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Set the function to be called just before filter condition is applied.
	Return 1 in your callback funct to stop the default filtering procedure otherwise return 0.
	If you return 1 you are responsible for which items to be visible or not. If you decide to block the default procedure you may need BCListViewAboutToFilterItem().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function to be called when filter applied. See BC_LISTVIEW_FILTER_ABOUT_TO_APPLY_FUNCTION for details.
		integer BC_LISTVIEW_FILTER_ABOUT_TO_APPLY_FUNCTION(lv, data)
		The function to be called when filter is applied.
		Return 1 to block the default process otherwise return 0.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 to block the default process otherwise return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewAboutToFilterItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    if not guitk.BCListViewColumnDataType(listView, 3) == guitk.constants.BCInt:
		        guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetFilterAsYouTypeOn(listView, False)
		    guitk.BCListViewFilterSetFilterAsYouTypeEnabled(listView, False)
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Apply filter to  'Group B' [Default = 'Group A']"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, setGroupToApplyFilterFunct, listView)
		    guitk.BCListViewSetFilterAboutToApplyFunction(
		        listView, aboutToApplyFilterFunct, checkBox
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setGroupToApplyFilterFunct(checkBox, state, listView):
		    guitk.BCListViewFilterApply(listView)
		    return 0
		
		
		def aboutToApplyFilterFunct(listView, checkBox):
		    state = guitk.BCCheckBoxIsChecked(checkBox)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, iterateGroupFunct, [state, listView]
		    )
		    return 1
		
		
		def iterateGroupFunct(item, data):
		    parent = guitk.BCListViewItemGetParent(item)
		    if parent:
		        if (
		            not data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group A"
		            or data[0]
		            and guitk.BCListViewItemGetText(parent, 0) == "Group B"
		        ):
		            passes_filter = guitk.BCListViewAboutToFilterItem(data[1], item)
		            if passes_filter:
		                guitk.BCListViewSetSelected(data[1], item, True)
		        guitk.BCListViewSetItemsExpanded(data[1], True)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnResizeMode(lv: object, mode: int) -> None:

	"""

	Define how the ListView's columns will behave when the width of the ListView change.
	Set if none (default), all or only the last column of the ListView automatically resize when the ListView width change.
	Horizontal scrollbar will be never shown if you set BCAllColumns or BCLastColumn.
	WARNING: This function should be applied after all necessary columns have been added on the ListView (otherwise the behaviour is undefined).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	mode : int
		the column resize mode. See BCEnumColumnResizeMode for details.
		
		guitk.constants BCEnumColumnResizeMode
		This enum type describes how the columns of a list view adjust to resize events on the width of the list.
		 - guitk.constants.BCNoColumn
		The columns are not resized when listview width change.
		Horizontal scrollbar will be shown when items content is too large to fit.
		 - guitk.constants.BCAllColumns
		Columns automatically and equally resize to fill the available viewport width.
		Columns width cannot be changed by the user or programmatically.
		Horizontal scrollbar will be never shown.
		 - guitk.constants.BCLastColumn
		Last column automatically resize to fill the available viewport width.
		Horizontal scrollbar will be never shown.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetColumnResizeEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ResizeMode", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(window, "Resize Mode: BCNoColumn"),
		        guitk.constants.BCAlignBottom,
		    )
		    listViewNoColumn = createPartsListView(window)
		    guitk.BCListViewSetColumnResizeMode(listViewNoColumn, guitk.constants.BCNoColumn)
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(window, "Resize Mode: BCAllColumns"),
		        guitk.constants.BCAlignBottom,
		    )
		    listViewAllColumns = createPartsListView(window)
		    guitk.BCListViewSetColumnResizeMode(
		        listViewAllColumns, guitk.constants.BCAllColumns
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(window, "Resize Mode: BCLastColumn"),
		        guitk.constants.BCAlignBottom,
		    )
		    listViewLastColumn = createPartsListView(window)
		    guitk.BCListViewSetColumnResizeMode(
		        listViewLastColumn, guitk.constants.BCLastColumn
		    )
		    guitk.BCShow(window)
		
		
		def createPartsListView(parent):
		    listView = guitk.BCListViewCreate(
		        parent, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    return listView
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetVisible(lv: object, visible: bool) -> None:

	"""

	Sets whether the header will be visible (default) or not depending on the value of visible.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	visible : bool
		set 0 for the header to be hidden, or 1 otherwise.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewHeaderMenuSetCopyEnabled(listView, 0, False)
		    guitk.BCListViewHeaderMenuSetAboutToShowFunction(
		        listView, customizePopupMenuFunct, None
		    )
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Change Header's Text orientation to Vertical"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, changeOrientationFunct, listView)
		    cBoxVisible = guitk.BCCheckBoxCreate(window, "Hide Header")
		    guitk.BCCheckBoxSetToggledFunction(cBoxVisible, setVisibleFunct, listView)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def setVisibleFunct(cb, state, listView):
		    guitk.BCListViewHeaderSetVisible(listView, not state)
		    return 0
		
		
		def changeOrientationFunct(checkBox, state, listView):
		    cols = guitk.BCListViewColumns(listView)
		    for i in range(cols):
		        guitk.BCListViewHeaderSetTextVerticalOrientationEnabled(listView, i, state)
		    return 0
		
		
		def customizePopupMenuFunct(listView, popup, col, data):
		    guitk.BCPopupMenuInsertItem(popup, "Popup Menu Item", None, None)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetRenameItemMode(lv: object, mode: int) -> None:

	"""

	Define which user actions will initiate ListView's item editing.
	The modes are BCDelayedOnSelectedClicked (default) and BCDirectOnClicked.
	Mode BCDirectOnClicked can be used to rename non selectable items.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	mode : int
		the rename mode. See BCEnumListRenameItemMode for details.
		
		guitk.constants BCEnumListRenameItemMode
		This property holds which actions will initiate ListViewItem rename.
		 - guitk.constants.BCDelayedOnSelectedClicked
		Rename starts delayed, when clicking on an already selected item.
		 - guitk.constants.BCDirectOnClicked
		Rename starts direct, when clicking on an item (no need to be selected).

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetRenameType

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Rename Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCHBoxCreate(window)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    chkBox = guitk.BCCheckBoxCreate(window, "Set DirectOnClicked Rename")
		    guitk.BCCheckBoxSetToggledFunction(chkBox, setDirectRename, listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetButton(item, 2, startRenameName, None)
		    guitk.BCListViewItemButtonSetIconFileName(item, 2, "edit_small.svg")
		    guitk.BCListViewItemSetText(item, 3, version)
		    guitk.BCListViewItemSetText(item, 4, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 4, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetAboutToRenameFunction(item, itemAboutToRename, None)
		    guitk.BCListViewItemSetRenameCanceledFunction(item, itemRenameCanceled, None)
		    guitk.BCListViewItemSetRenamedFunction(item, itemRenamed, None)
		    return item
		
		
		def startRenameName(item, col, data):
		    guitk.BCListViewStartRename(guitk.BCListViewItemGetListView(item), item, 1)
		    return 0
		
		
		def itemAboutToRename(item, col, data):
		    print(
		        "Item ID={}, column={} about to be renamed.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenameCanceled(item, col, data):
		    print(
		        "Item ID={}, column={} rename canceled.".format(
		            guitk.BCListViewItemGetText(item, 0), col
		        )
		    )
		    return 0
		
		
		def itemRenamed(item, col, data):
		    print(
		        "Item ID={}, column={} renamed. New Name: '{}'".format(
		            guitk.BCListViewItemGetText(item, 0),
		            col,
		            guitk.BCListViewItemGetText(item, col),
		        )
		    )
		    guitk.BCListViewItemSetUserData(item, col)
		    return 0
		
		
		def setDirectRename(chkBox, state, listView):
		    guitk.BCListViewSetRenameItemMode(
		        listView,
		        guitk.constants.BCDirectOnClicked
		        if state
		        else guitk.constants.BCDelayedOnSelectedClicked,
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetProgressBar(item: object, col: int) -> None:

	"""

	Sets a progress bar to be displayed in the ListViewItem item cell specified by the given column col.
	
	You can also use generic item widget functions BCListViewItemWidgetSetVisible(), BCListViewItemWidgetSetEnabled() and BCListViewItemWidgetDestroy().
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemIsProgressBar

	Examples
	--------
	::

		from sdm import guitk
		from random import randint
		import math
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Progress", "Show Percentage"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addAverage(listView)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateVisible, addProgressBar, 3
		    )
		    showAverageFunct(listView)
		
		    guitk.BCShow(window)
		
		
		def addAverage(parent):
		    avg = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetProgressBar(avg, 3)
		    guitk.BCListViewItemSetVisible(avg, False)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addProgressBar(item, col):
		    progress = randint(0, 100)
		    guitk.BCListViewItemSetProgressBar(item, col)
		    guitk.BCListViewItemProgressBarSetProgress(item, col, progress)
		    if progress == 100:
		        guitk.BCListViewItemWidgetDestroy(item, col)
		        guitk.BCListViewItemSetText(item, col, "DONE")
		    else:
		        guitk.BCListViewItemSetCheckBox(item, col + 1, True, showPercentageFunct, None)
		    return 0
		
		
		def showPercentageFunct(item, col, state, data):
		    guitk.BCListViewItemProgressBarSetPercentageVisible(item, col - 1, state)
		    return 0
		
		
		def showAverageFunct(lv):
		    # Counts average row too, subtracting - 1
		    rows = guitk.BCListViewTopLevelItemCount(lv) - 1
		    sum = 0
		    for row in range(rows):
		        item = guitk.BCListViewGetTopLevelItem(lv, row)
		        currentProgress = guitk.BCListViewItemProgressBarProgress(item, 3)
		        # currentProgress equals -1, when there is no progressBar, which means progress is 100%
		        if currentProgress < 0:
		            sum += 100
		        else:
		            sum += currentProgress
		    # Rounding down (only if all items are completed, the whole progress will be 100%)
		    avg = int(math.floor(sum / rows))
		    guitk.BCListViewSetText(lv, rows, 2, "AVERAGE PROGRESS:")
		    item_avg = guitk.BCListViewGetTopLevelItem(lv, rows)
		    guitk.BCListViewItemProgressBarSetProgress(item_avg, 3, avg)
		    guitk.BCListViewItemSetBold(item_avg, True)
		    guitk.BCListViewItemSetVisible(item_avg, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemProgressBarSetProgress(item: object, col: int, progress: int) -> None:

	"""

	Sets progress bar current value at item at column col to be progress.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	progress : int
		the current value.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemProgressBarProgress

	Examples
	--------
	::

		from sdm import guitk
		from random import randint
		import math
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Progress", "Show Percentage"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addAverage(listView)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateVisible, addProgressBar, 3
		    )
		    showAverageFunct(listView)
		
		    guitk.BCShow(window)
		
		
		def addAverage(parent):
		    avg = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetProgressBar(avg, 3)
		    guitk.BCListViewItemSetVisible(avg, False)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addProgressBar(item, col):
		    progress = randint(0, 100)
		    guitk.BCListViewItemSetProgressBar(item, col)
		    guitk.BCListViewItemProgressBarSetProgress(item, col, progress)
		    if progress == 100:
		        guitk.BCListViewItemWidgetDestroy(item, col)
		        guitk.BCListViewItemSetText(item, col, "DONE")
		    else:
		        guitk.BCListViewItemSetCheckBox(item, col + 1, True, showPercentageFunct, None)
		    return 0
		
		
		def showPercentageFunct(item, col, state, data):
		    guitk.BCListViewItemProgressBarSetPercentageVisible(item, col - 1, state)
		    return 0
		
		
		def showAverageFunct(lv):
		    # Counts average row too, subtracting - 1
		    rows = guitk.BCListViewTopLevelItemCount(lv) - 1
		    sum = 0
		    for row in range(rows):
		        item = guitk.BCListViewGetTopLevelItem(lv, row)
		        currentProgress = guitk.BCListViewItemProgressBarProgress(item, 3)
		        # currentProgress equals -1, when there is no progressBar, which means progress is 100%
		        if currentProgress < 0:
		            sum += 100
		        else:
		            sum += currentProgress
		    # Rounding down (only if all items are completed, the whole progress will be 100%)
		    avg = int(math.floor(sum / rows))
		    guitk.BCListViewSetText(lv, rows, 2, "AVERAGE PROGRESS:")
		    item_avg = guitk.BCListViewGetTopLevelItem(lv, rows)
		    guitk.BCListViewItemProgressBarSetProgress(item_avg, 3, avg)
		    guitk.BCListViewItemSetBold(item_avg, True)
		    guitk.BCListViewItemSetVisible(item_avg, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemProgressBarProgress(item: object, col: int) -> int:

	"""

	Returns the current value of progress bar item at column col.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	int
		The current value.

	See Also
	--------
	BCListViewItemProgressBarSetProgress

	Examples
	--------
	::

		from sdm import guitk
		from random import randint
		import math
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Progress", "Show Percentage"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addAverage(listView)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateVisible, addProgressBar, 3
		    )
		    showAverageFunct(listView)
		
		    guitk.BCShow(window)
		
		
		def addAverage(parent):
		    avg = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetProgressBar(avg, 3)
		    guitk.BCListViewItemSetVisible(avg, False)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addProgressBar(item, col):
		    progress = randint(0, 100)
		    guitk.BCListViewItemSetProgressBar(item, col)
		    guitk.BCListViewItemProgressBarSetProgress(item, col, progress)
		    if progress == 100:
		        guitk.BCListViewItemWidgetDestroy(item, col)
		        guitk.BCListViewItemSetText(item, col, "DONE")
		    else:
		        guitk.BCListViewItemSetCheckBox(item, col + 1, True, showPercentageFunct, None)
		    return 0
		
		
		def showPercentageFunct(item, col, state, data):
		    guitk.BCListViewItemProgressBarSetPercentageVisible(item, col - 1, state)
		    return 0
		
		
		def showAverageFunct(lv):
		    # Counts average row too, subtracting - 1
		    rows = guitk.BCListViewTopLevelItemCount(lv) - 1
		    sum = 0
		    for row in range(rows):
		        item = guitk.BCListViewGetTopLevelItem(lv, row)
		        currentProgress = guitk.BCListViewItemProgressBarProgress(item, 3)
		        # currentProgress equals -1, when there is no progressBar, which means progress is 100%
		        if currentProgress < 0:
		            sum += 100
		        else:
		            sum += currentProgress
		    # Rounding down (only if all items are completed, the whole progress will be 100%)
		    avg = int(math.floor(sum / rows))
		    guitk.BCListViewSetText(lv, rows, 2, "AVERAGE PROGRESS:")
		    item_avg = guitk.BCListViewGetTopLevelItem(lv, rows)
		    guitk.BCListViewItemProgressBarSetProgress(item_avg, 3, avg)
		    guitk.BCListViewItemSetBold(item_avg, True)
		    guitk.BCListViewItemSetVisible(item_avg, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemProgressBarSetPercentageVisible(item: object, col: int, visible: int) -> None:

	"""

	Sets whether the current progress value (text) is displayed as a percentage (default visible).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	visible : int
		set 0 to hide the percentage (text) or 1 to show it (default).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		from random import randint
		import math
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Progress", "Show Percentage"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addAverage(listView)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateVisible, addProgressBar, 3
		    )
		    showAverageFunct(listView)
		
		    guitk.BCShow(window)
		
		
		def addAverage(parent):
		    avg = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetProgressBar(avg, 3)
		    guitk.BCListViewItemSetVisible(avg, False)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addProgressBar(item, col):
		    progress = randint(0, 100)
		    guitk.BCListViewItemSetProgressBar(item, col)
		    guitk.BCListViewItemProgressBarSetProgress(item, col, progress)
		    if progress == 100:
		        guitk.BCListViewItemWidgetDestroy(item, col)
		        guitk.BCListViewItemSetText(item, col, "DONE")
		    else:
		        guitk.BCListViewItemSetCheckBox(item, col + 1, True, showPercentageFunct, None)
		    return 0
		
		
		def showPercentageFunct(item, col, state, data):
		    guitk.BCListViewItemProgressBarSetPercentageVisible(item, col - 1, state)
		    return 0
		
		
		def showAverageFunct(lv):
		    # Counts average row too, subtracting - 1
		    rows = guitk.BCListViewTopLevelItemCount(lv) - 1
		    sum = 0
		    for row in range(rows):
		        item = guitk.BCListViewGetTopLevelItem(lv, row)
		        currentProgress = guitk.BCListViewItemProgressBarProgress(item, 3)
		        # currentProgress equals -1, when there is no progressBar, which means progress is 100%
		        if currentProgress < 0:
		            sum += 100
		        else:
		            sum += currentProgress
		    # Rounding down (only if all items are completed, the whole progress will be 100%)
		    avg = int(math.floor(sum / rows))
		    guitk.BCListViewSetText(lv, rows, 2, "AVERAGE PROGRESS:")
		    item_avg = guitk.BCListViewGetTopLevelItem(lv, rows)
		    guitk.BCListViewItemProgressBarSetProgress(item_avg, 3, avg)
		    guitk.BCListViewItemSetBold(item_avg, True)
		    guitk.BCListViewItemSetVisible(item_avg, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemIsProgressBar(item: object, col: int) -> bool:

	"""

	Returns True if the ListViewItem item cell displays a progress bar at given column col, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	col : int
		the column index.

	Returns
	-------
	bool
		True if the ListViewItem item at column col is a progress bar, or False otherwise.

	See Also
	--------
	BCListViewItemSetProgressBar

	Examples
	--------
	::

		from sdm import guitk
		from random import seed, randint
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Is Some Widget Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        8,
		        [
		            "ID",
		            "Part name",
		            "Version",
		            "Manufactured",
		            "Radio",
		            "ComboBox",
		            "Progress",
		            "Button",
		        ],
		        False,
		    )
		    btnGroup = guitk.BCListViewButtonGroupCreate(listView, 4)
		    seed()
		    addPart(listView, "1001", "Bumper", "3A", "South Korea", btnGroup)
		    addPart(listView, "1002", "Decklid", "4A", "Germany", btnGroup)
		    addPart(listView, "1003", "Pillar", "4A", "Turkey", btnGroup)
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea", btnGroup)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, printIsers, None)
		    guitk.BCShow(window)
		
		
		def printIsers(listView, item, data):
		    itemId = guitk.BCListViewItemGetText(item, 0)
		    for col in range(4, 8):
		        print(
		            "\\nItem ID={}, Column {} IsRadioButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsRadioButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsButton = {}".format(
		                itemId, col, guitk.BCListViewItemIsButton(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsComboBox = {}".format(
		                itemId, col, guitk.BCListViewItemIsComboBox(item, col)
		            )
		        )
		        print(
		            "Item ID={}, Column {} IsProgressBar = {}".format(
		                itemId, col, guitk.BCListViewItemIsProgressBar(item, col)
		            )
		        )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured, btnGroup):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    # Add widgets
		    guitk.BCListViewItemSetRadioButton(item, 4, False, None, None)
		    guitk.BCListViewButtonGroupInsertItem(btnGroup, item)
		    guitk.BCListViewItemSetComboBox(
		        item, 5, ["Triangles", "Ortho-Triangles", "Rectangles"], None, None
		    )
		    guitk.BCListViewItemSetProgressBar(item, 6)
		    guitk.BCListViewItemProgressBarSetProgress(item, 6, randint(0, 100))
		    guitk.BCListViewItemSetButton(item, 7, None, None)
		    guitk.BCListViewItemButtonSetText(item, 7, "Button")
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckBoxSetCheckedNoCallBack(item: object, col: int, check: int) -> None:

	"""

	This is a convenience function. Sets the value of the checkBox at ListViewItem item at column col without the callback function of item to run (if any).
	Use BCBlockCallBackFunctions() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	check : int
		the new value.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	"""

def BCMDIMainWindowShowMaximized(mdiWindow: object=None) -> None:

	"""

	Show the BCMDIMainWindow maximized.
	This function is not supported under VR mode.

	Parameters
	----------
	mdiWindow : object, optional
		Currently unused. It is recommended to not pass anything.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Main Window Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCPushButtonCreate(w, "Restore", restore, None)
		    guitk.BCPushButtonCreate(w, "Maximize", maximize, None)
		    guitk.BCPushButtonCreate(w, "Minimize", minimize, None)
		    guitk.BCShow(w)
		
		
		def restore(btn, data):
		    guitk.BCMDIMainWindowShowRestored()
		    return 0
		
		
		def maximize(btn, data):
		    guitk.BCMDIMainWindowShowMaximized()
		    return 0
		
		
		def minimize(btn, data):
		    guitk.BCMDIMainWindowShowMinimized()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMDIMainWindowShowMinimized(mdiWindow: object=None) -> None:

	"""

	Show the BCMDIMainWindow minimized.
	This function is not supported under VR mode.

	Parameters
	----------
	mdiWindow : object, optional
		Currently unused. It is recommended to not pass anything.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Main Window Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCPushButtonCreate(w, "Restore", restore, None)
		    guitk.BCPushButtonCreate(w, "Maximize", maximize, None)
		    guitk.BCPushButtonCreate(w, "Minimize", minimize, None)
		    guitk.BCShow(w)
		
		
		def restore(btn, data):
		    guitk.BCMDIMainWindowShowRestored()
		    return 0
		
		
		def maximize(btn, data):
		    guitk.BCMDIMainWindowShowMaximized()
		    return 0
		
		
		def minimize(btn, data):
		    guitk.BCMDIMainWindowShowMinimized()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMDIMainWindowShowRestored(mdiWindow: object=None) -> None:

	"""

	Show the BCMDIMainWindow normal.
	This function is not supported under VR mode.

	Parameters
	----------
	mdiWindow : object, optional
		Currently unused. It is recommended to not pass anything.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Main Window Functions Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCPushButtonCreate(w, "Restore", restore, None)
		    guitk.BCPushButtonCreate(w, "Maximize", maximize, None)
		    guitk.BCPushButtonCreate(w, "Minimize", minimize, None)
		    guitk.BCShow(w)
		
		
		def restore(btn, data):
		    guitk.BCMDIMainWindowShowRestored()
		    return 0
		
		
		def maximize(btn, data):
		    guitk.BCMDIMainWindowShowMaximized()
		    return 0
		
		
		def minimize(btn, data):
		    guitk.BCMDIMainWindowShowMinimized()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWidgetStackCurrentId(ws: object) -> int:

	"""

	Returns id of the currently visible widget of BCWidgetStack ws.
	This function is not supported under VR mode.

	Parameters
	----------
	ws : object
		the BCWidgetStack.

	Returns
	-------
	int
		the id of the currently visible widget (the one at the top of the stack).

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Widget Stack Raise Id Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    vBox = guitk.BCVBoxCreate(hBox)
		    widgetStack = guitk.BCWidgetStackCreate(hBox)
		    widgetStackMyAddFrame(widgetStack, 0, "logo_sdm.svg")
		    widgetStackMyAddFrame(widgetStack, 1, "logo_meta.svg")
		    widgetStackMyAddFrame(widgetStack, 2, "logo_spdrm.svg")
		    cmbProgram = guitk.BCComboBoxCreate(vBox, ["0: ANSA", "1: META", "2: SPDRM"])
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(cmbProgram, raiseFrame, widgetStack)
		    guitk.BCPushButtonCreate(
		        vBox, "Remove Current", removeCurrent, (widgetStack, cmbProgram)
		    )
		    guitk.BCShow(window)
		
		
		def widgetStackMyAddFrame(widgetStack, id, icon):
		    frame = guitk.BCFrameCreate(widgetStack)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    iconLabel = guitk.BCLabelCreate(bLayout, "")
		    guitk.BCLabelSetIconFileName(iconLabel, icon)
		    guitk.BCLabelSetAlignment(iconLabel, guitk.constants.BCAlignCenter)
		    guitk.BCBoxLayoutInsert(bLayout, iconLabel, -1)
		    guitk.BCWidgetStackAddWidget(widgetStack, frame, id)
		
		
		def raiseFrame(cmb, index, widgetStack):
		    id = int(guitk.BCComboBoxCurrentText(cmb).split(":")[0])
		    guitk.BCWidgetStackRaiseId(widgetStack, id)
		    print("WidgetStackCurrentId = {}".format(guitk.BCWidgetStackCurrentId(widgetStack)))
		    return 0
		
		
		def removeCurrent(btn, data):
		    widgetStack, cmb = data
		    if guitk.BCComboBoxCount(cmb) == 1:  # in case no more frames are available
		        guitk.BCComboBoxSetCurrentIndexChangedFunction(cmb, None, None)
		        guitk.BCSetEnabled(cmb, False)
		        guitk.BCSetEnabled(btn, False)
		    widgetToRemove = guitk.BCWidgetStackVisibleWidget(widgetStack)
		    guitk.BCComboBoxRemoveItem(cmb, guitk.BCComboBoxCurrentItem(cmb))
		    print(
		        "Widget id before removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCWidgetStackRemoveWidget(widgetStack, widgetToRemove)
		    print(
		        "Widget id after removal = {}".format(
		            guitk.BCWidgetStackId(widgetStack, widgetToRemove)
		        )
		    )
		    guitk.BCDestroyLater(widgetToRemove)  # No reason to keep it alive.
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetAlternativeText(lv: object, col: int, text: str) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderSetStringRepresentation() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	text : str
		the text to be displayed at respective header menu item that indicates column col.

	Returns
	-------
	None

	"""

def BCWizardRemovePage(wiz: object, index: int) -> int:

	"""

	Removes the widget at page index index from wizard (the removed page-widget will NOT deleted).
	NOTE: After this call, it is the caller's responsibility to put the removed widget back into a layout or to delete it.
	NOTE: Page indexing will change (the valid range is from 0 to BCWizardPageCount()-1).
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the index of the page that will be removed. The valid range is from 0 to BCWizardPageCount()-1.

	Returns
	-------
	int
		1 if page removed succesfully, otherwise 0.

	See Also
	--------
	BCWizardAddPage

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardInsertPage(wiz: object, index: int, w: object, sidebarText: str, titleText: str, infoText: str) -> object:

	"""

	Inserts the widget with sidebar text t at the given page index index (position) into wizard.
	Designed for special cases. For almost all cases BCWizardAddPage() is needed.
	
	Empty sidebar text or empty title is not allowed.
	If index if negative, equal or higher than the total number of pages the page is NOT inserted.
	NOTE: Page indexing will change (the valid range is from 0 to BCWizardPageCount()-1).
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the index (position) to be inserted. The valid range is from 0 to BCWizardPageCount()-1.

	w : object
		the widget to be added as a page.

	sidebarText : str
		the text to be shown at the left sidebar (usually compact size).

	titleText : str, optional
		the text to be shown bold on the top of the page (main instruction to explain user's objective with the page).

	infoText : str, optional
		the text to be used as additional help to the user (displayed below contents at the bottom and is prefixed with an info icon).

	Returns
	-------
	object
		the inserted page.

	See Also
	--------
	BCWizardAddPage

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnDataTypes(lv: object, dataTypes: list) -> None:

	"""

	Define the data type for each column of your ListView (default BCString).
	These data are used by the filter to define the filtering method. If you have for example a column with checkBoxes you have to set this column to BCBool.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	dataTypes : list
		a list of data types. See BCEnumDataType for details.
		
		guitk.constants BCEnumDataType
		This enum type is used to describe the data type or the widget type of a ListViewItem
		 - guitk.constants.BCInt
		Defines the variant-column as integer.
		 - guitk.constants.BCFloat
		Defines the variant-column as float.
		 - guitk.constants.BCDouble
		Defines the variant-column as double.
		 - guitk.constants.BCString
		Defines the variant-column as string.
		 - guitk.constants.BCStringList
		Defines the variant-column as a list of strings (e.g. possible values of a variant red/green/blue).
		 - guitk.constants.BCBool
		Defines the variant-column as a boolen (e.g. for BCCheckBoxes that only take values 0 or 1).
		 - guitk.constants.BCInvalid
		Defines the variant with an invalid type.
		 - guitk.constants.BCDate
		Defines that the variant-column displays date.

	Returns
	-------
	None

	See Also
	--------
	BCListViewColumnDataType

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "State"], 0
		    )
		    addParts(listView)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetComboBox(listView, 3)
		    guitk.BCListViewSetPredefinedContentsIconFileNames(
		        listView,
		        3,
		        ["done_small.svg", "error_small.svg", "info_small.svg", "warning_small.svg"],
		    )
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addParts(listView):
		    item = addPart(listView, "1001", "Bumper", "Large")
		    guitk.BCListViewItemSetIconFileName(item, 3, "done_small.svg")
		    item = addPart(listView, "1002", "Decklid", "Large")
		    guitk.BCListViewItemSetIconFileName(item, 3, "info_small.svg")
		    item = addPart(listView, "1003", "Pillar", "Medium")
		    guitk.BCListViewItemSetIconFileName(item, 3, "warning_small.svg")
		    item = addPart(listView, "1004", "Welded Assembly", "Small")
		    guitk.BCListViewItemSetIconFileName(item, 3, "error_small.svg")
		    item = addPart(listView, "1005", "Spoiler", "Large")
		    guitk.BCListViewItemSetIconFileName(item, 3, "done_small.svg")
		    list = [
		        guitk.constants.BCInt,
		        guitk.constants.BCString,
		        guitk.constants.BCString,
		        guitk.constants.BCInvalid,
		    ]
		    guitk.BCListViewSetColumnDataTypes(listView, list)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewInfoBoxSetView(infoBox: object, view: object) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarSetView() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	infoBox : object
		the ItemViewStatusBar.

	view : object
		the ListView  for which the ItemViewStatusBar will display info.

	Returns
	-------
	None

	"""

def BCListViewHeaderMenuSetAboutToShowFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Customize the right mouse header menu of a ListView lv.
	You can add some menu items here with BCPopupMenuInsertItem().
	Standard menu provides some 'Copy items content' functionality that can be turn off with BCListViewHeaderMenuSetCopyEnabled().
	Standard ListView actions (copy and rename) are provided right after your actions (with a separator).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called when right mouse button pressed on a header section. See BC_LISTVIEW_HEADER_MENU_ABOUTTOSHOW_FUNCTION for details.
		integer BC_LISTVIEW_HEADER_MENU_ABOUTTOSHOW_FUNCTION(lv, pm, col, data)
		The function to be called when mouse right button pressed to the header of ListView lv.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * pm : object
		                    the provided pull down menu.
		          * col : int
		                    the ListView column. .
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCPopupMenuInsertItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewHeaderMenuSetCopyEnabled(listView, 0, False)
		    guitk.BCListViewHeaderMenuSetAboutToShowFunction(
		        listView, customizePopupMenuFunct, None
		    )
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Change Header's Text orientation to Vertical"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, changeOrientationFunct, listView)
		    cBoxVisible = guitk.BCCheckBoxCreate(window, "Hide Header")
		    guitk.BCCheckBoxSetToggledFunction(cBoxVisible, setVisibleFunct, listView)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def setVisibleFunct(cb, state, listView):
		    guitk.BCListViewHeaderSetVisible(listView, not state)
		    return 0
		
		
		def changeOrientationFunct(checkBox, state, listView):
		    cols = guitk.BCListViewColumns(listView)
		    for i in range(cols):
		        guitk.BCListViewHeaderSetTextVerticalOrientationEnabled(listView, i, state)
		    return 0
		
		
		def customizePopupMenuFunct(listView, popup, col, data):
		    guitk.BCPopupMenuInsertItem(popup, "Popup Menu Item", None, None)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetTextChangedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when the text changes in the ListView header for column col.
	Text at a header section can change programmatically with BCListViewHeaderSetText()
	or through the header right mouse menu editor that is activated with BCListViewHeaderMenuSetAboutToShowFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called after text has changed. See BC_LISTVIEW_HEADER_TEXT_CHANGED_FUNCTION for details.
		integer BC_LISTVIEW_HEADER_TEXT_CHANGED_FUNCTION(lv, col, oldText, newText, data)
		The function to be called after ListView header section text has changed.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * col : int
		                    the ListView column.
		          * oldText : str
		                    the old text at ListView header section.
		          * newText : str
		                    the new text at ListView header section.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderSetText

	"""

def BCListViewHeaderMenuSetRenameColumnEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	enable : bool
		If enable is set to True, then the first item after the custom ones, of the returned Menu will be an item having text "Rename", with which it is possible to rename the section of the header clicked.

	Returns
	-------
	None

	"""

def BCListViewHeaderMenuSetCopyEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Set whether header menu provides 'Copy items content' options.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	enable : bool
		If disable is set to True, then the 'Copy column' and 'Copy selected in column' items, of the returned Menu will not be shown. Otherwise these items will be shown (the default).

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderMenuSetAboutToShowFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewHeaderMenuSetCopyEnabled(listView, 0, False)
		    guitk.BCListViewHeaderMenuSetAboutToShowFunction(
		        listView, customizePopupMenuFunct, None
		    )
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Change Header's Text orientation to Vertical"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, changeOrientationFunct, listView)
		    cBoxVisible = guitk.BCCheckBoxCreate(window, "Hide Header")
		    guitk.BCCheckBoxSetToggledFunction(cBoxVisible, setVisibleFunct, listView)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def setVisibleFunct(cb, state, listView):
		    guitk.BCListViewHeaderSetVisible(listView, not state)
		    return 0
		
		
		def changeOrientationFunct(checkBox, state, listView):
		    cols = guitk.BCListViewColumns(listView)
		    for i in range(cols):
		        guitk.BCListViewHeaderSetTextVerticalOrientationEnabled(listView, i, state)
		    return 0
		
		
		def customizePopupMenuFunct(listView, popup, col, data):
		    guitk.BCPopupMenuInsertItem(popup, "Popup Menu Item", None, None)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetColumnSideButton(lv: object, col: int, b: object=None) -> None:

	"""

	Set a custom tool button aligned at the right of the text at header section for column col.
	
	The list view gets ownership of the tool button. 
	If you want to clear the button use this function with b None.
	If you orient header column text vertically (BCListViewHeaderSetTextVerticalOrientationEnabled) the button is positioned above vertically oriented text.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	col : int
		the column index.

	b : object, optional
		the custom tool button.

	Returns
	-------
	None

	See Also
	--------
	BCToolButtonCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Value"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", "2", "91.57")
		    addPart(listView, "1002", "Decklid", "1", "15.12")
		    createHeaderSideButtons(infoBox, listView, 2)
		    addPart(listView, "1003", "Pillar", "3", "62.03")
		    createHeaderSideButtons(infoBox, listView, 3)
		    guitk.BCListViewSetColumnDataType(listView, 2, guitk.constants.BCInt)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCDouble)
		    guitk.BCListViewSetRenameItemPrecision(listView, 3)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, quantity, value):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetText(item, 3, value)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def createHeaderSideButtons(infoBox, listView, col):
		    dict = {"listView": listView, "col": col, "infoBox": infoBox}
		    toolBtn = guitk.BCToolButtonCreate(
		        listView, "gear.svg", "", lambda btn, data: calculateFunct(btn, **data), dict
		    )
		    guitk.BCListViewHeaderSetColumnSideButton(listView, col, toolBtn)
		    guitk.BCListViewHeaderSetToolTip(listView, col, "Calculate Sum")
		
		
		def calculateFunct(btn, listView=0, col=0, infoBox=0):
		    isInt = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCInt
		    isDouble = guitk.BCListViewColumnDataType(listView, col) == guitk.constants.BCDouble
		    rows = guitk.BCListViewTopLevelItemCount(listView)
		    total = 0
		    if isInt:
		        for row in range(rows):
		            total += guitk.BCListViewGetInt(listView, row, col)
		    elif isDouble:
		        for row in range(rows):
		            total += guitk.BCListViewGetDouble(listView, row, col)
		    text = (
		        "Sum of column '"
		        + guitk.BCListViewHeaderGetText(listView, col)
		        + "' is "
		        + str(total)
		    )
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathLineEditText(lip: object) -> str:

	"""

	Convenient function that returns the current text of BCLineEditPath lip.
	Alternatively, in order to get the current text, you should do the following steps:

	- Get the BCComboBox from lip using BCLineEditPathGetCombo()
	- Get the BCLineEdit from BCComboBox using BCComboBoxGetLineEdit()
	- Get the text from BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath

	Returns
	-------
	str
		the current text

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File Example")
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    btnClearHistory = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Clear History", clearHistoryFunction, lineEditPath
		    )
		    btnRemoveOld = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Remove Oldest Entry", removeOEntryFunction, lineEditPath
		    )
		    btnRemoveNew = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Remove Newest Entry", removeNEntryFunction, lineEditPath
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearHistoryFunction(btn, lineEditPath):
		    guitk.BCLineEditPathClearHistory(lineEditPath)
		    print(
		        "Current text got from LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def removeOEntryFunction(btn, lineEditPath):
		    # Negative value to remove the oldest entry
		    isRemoved = guitk.BCLineEditPathRemoveEntry(lineEditPath, -1)
		    if isRemoved:
		        print("Removal succeded.")
		    else:
		        print("Removal failed.")
		    print(
		        "Current text shown in LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def removeNEntryFunction(btn, lineEditPath):
		    # Newest entry, index = 0
		    isRemoved = guitk.BCLineEditPathRemoveEntry(lineEditPath, 0)
		    if isRemoved:
		        print("Removal succeded.")
		    else:
		        print("Removal failed.")
		    print(
		        "Current text got from LineEdit: "
		        + guitk.BCLineEditPathLineEditText(lineEditPath)
		    )
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetColorLine(lv: object, col: int, r: int, g: int, b: int) -> None:

	"""

	Draw a color line at header section for column with index col.
	The color line is drawn at section bottom below text.
	To clear the line just set an invalid color (for example -1, -1, -1).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Header Formatting Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", ""], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewHeaderSetIconFileName(listView, 4, "logo_sdm.svg")
		    guitk.BCListViewHeaderSetColorLine(listView, 0, 255, 0, 0)
		    guitk.BCListViewHeaderSetStringRepresentation(listView, 4, "Alternative")
		    guitk.BCListViewHeaderSetForegroundColor(listView, 2, 255, 0, 0)
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    print(
		        "Notice that in the visibility header menu 'Alternative' text is displayed for column with Icon"
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewColumnSetUserData(lv: object, col: int, data: Any) -> None:

	"""

	Assigns user data data to ListView column index col.
	These data can be retrieved anytime using BCListViewColumnGetUserData().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	data : Any
		the user's data.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetUserData

	"""

def BCListViewColumnGetUserData(lv: object, col: int) -> object:

	"""

	Retrieves user data from ListView column with index col.
	These data have been set by calling BCListViewColumnSetUserData().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	object
		the user's data.

	See Also
	--------
	BCListViewItemSetUserData

	"""

def BCLineEditSetState(le: object, state: int, force: bool) -> None:

	"""

	Sets the state of BCLineEdit le to state.
	This state corresponds to setting a certain pair of foreground and background color for the BCLineEdit. This is useful when
	you want to draw the user's attention to that BCLineEdit. So, depending on state, BCLineEdit background and/or foreground color
	will be set accordingly.
	If the colors to be set are similar to the existing ones (either because of application settings or widget one),
	the colors will not be changed, unless force is set to 1. In this case, no matter what the existing color is,
	the colors set will be the default ones for that state.

	Parameters
	----------
	le : object
		the BCLineEdit.

	state : int
		the state to be set. See BCEnumWidgetState for
		details.
		
		guitk.constants BCEnumWidgetState
		This enumeration indicates the state (i.e. the color or icon used) for a widget
		 - guitk.constants.BCWidgetStateNone
		No state. Indicates the standard widget display.
		 - guitk.constants.BCWidgetStateInformation
		Indicates an info nothing out of the ordinary.
		 - guitk.constants.BCWidgetStateWarning
		Indicates a state that can be dealt with.
		 - guitk.constants.BCWidgetStateError
		Indicates a critical problem.
		 - guitk.constants.BCWidgetStateReadOnly
		Indicates that the widget cannot be edited.

	force : bool
		set this to 1 in order to force using the default color for state state; 0 otherwise (i.e. check versus pre-existing color).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "LineEdit Mode/State Example", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "Right-click inside LineEdit to change Mode or State."
		    )
		    popup = guitk.BCPopupMenuCreate(window)
		    guitk.BCLineEditSetAddItemsToPopupMenu(lineEdit, createPopup, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def echoModeFunction(popupMenu, id, lineEdit):
		    if id == 0:
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCNormalEchoMode)
		    elif id == 1:
		        # The text is still there, cursor moved at lineEditft. Moving back to normal mode will make it appear again.
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCNoEchoMode)
		    elif id == 2:
		        guitk.BCLineEditSetEchoMode(lineEdit, guitk.constants.BCPasswordMode)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		def echoStateFunction(popupMenu, id, lineEdit):
		    guitk.BCLineEditSetReadOnly(lineEdit, False)
		    # All states forced to change colors
		    if id == 0:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateNone, 1)
		    elif id == 1:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateInformation, 1)
		    elif id == 2:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateWarning, 1)
		    elif id == 3:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateError, 1)
		    elif id == 4:
		        guitk.BCLineEditSetState(lineEdit, guitk.constants.BCWidgetStateReadOnly, 1)
		        # Set BCLineEdit to read-only mode, too.
		        guitk.BCLineEditSetReadOnly(lineEdit, True)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		def createPopup(lineEdit, popup, data):
		    guitk.BCPopupMenuInsertSeparator(popup)
		    submenuMode = guitk.BCPopupMenuCreate(popup)
		    popupItemNormal = guitk.BCPopupMenuInsertItem(
		        submenuMode, "Normal Mode", echoModeFunction, lineEdit
		    )
		    popupItemNoEcho = guitk.BCPopupMenuInsertItem(
		        submenuMode, "No Echo Mode", echoModeFunction, lineEdit
		    )
		    popupItemPass = guitk.BCPopupMenuInsertItem(
		        submenuMode, "Password Mode", echoModeFunction, lineEdit
		    )
		    submenuState = guitk.BCPopupMenuCreate(popup)
		    popupItemNone = guitk.BCPopupMenuInsertItem(
		        submenuState, "None", echoStateFunction, lineEdit
		    )
		    popupItemInformation = guitk.BCPopupMenuInsertItem(
		        submenuState, "Information", echoStateFunction, lineEdit
		    )
		    popupItemWarning = guitk.BCPopupMenuInsertItem(
		        submenuState, "Warning", echoStateFunction, lineEdit
		    )
		    popupItemError = guitk.BCPopupMenuInsertItem(
		        submenuState, "Error", echoStateFunction, lineEdit
		    )
		    popupItemReadOnly = guitk.BCPopupMenuInsertItem(
		        submenuState, "Read Only", echoStateFunction, lineEdit
		    )
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Mode", submenuMode)
		    guitk.BCPopupMenuInsertPopupMenu(popup, "State", submenuState)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardSetPageId(wiz: object, index: int, id: int) -> None:

	"""

	Set a unique integer number (identifier) for WizardPage with index.
	Ids are useful when you insert/remove pages dynamically since they do not change automatically like index does.
	NOTE: The valid index range is from 0 to BCWizardPageCount()-1.
	Id is unique for each wizard page. If you do not set the page id, this is equal with index.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the page index. The valid range is from 0 to BCWizardPageCount()-1.

	id : int
		any unique integer number.

	Returns
	-------
	None

	See Also
	--------
	BCWizardPageId

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardPageId(wiz: object, index: int) -> int:

	"""

	Returns the unique integer number (identifier) for WizardPage with index.
	NOTE: The valid index range is from 0 to BCWizardPageCount()-1.
	Id is unique for each wizard page. If you do not set the page id, this is equal with index.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the page index. The valid range is from 0 to BCWizardPageCount()-1.

	Returns
	-------
	int
		the index of current page.

	See Also
	--------
	BCWizardSetPageId

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardPageIdToIndex(wiz: object, id: int) -> int:

	"""

	Returns the index for WizardPage with identifier id.
	If id does not exist function returns -1.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	id : int
		any unique integer number.

	Returns
	-------
	int
		the index of id or -1 if id does not exist.

	See Also
	--------
	BCWizardSetPageId

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetForegroundColor(lv: object, col: int, r: int, g: int, b: int) -> None:

	"""

	Sets a foreground (text) color at header section for column with index col.
	To reset the foreground to standard, just set an invalid color (for example -1, -1, -1).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Header Formatting Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", ""], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewHeaderSetIconFileName(listView, 4, "logo_sdm.svg")
		    guitk.BCListViewHeaderSetColorLine(listView, 0, 255, 0, 0)
		    guitk.BCListViewHeaderSetStringRepresentation(listView, 4, "Alternative")
		    guitk.BCListViewHeaderSetForegroundColor(listView, 2, 255, 0, 0)
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    print(
		        "Notice that in the visibility header menu 'Alternative' text is displayed for column with Icon"
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemWidgetSetVisible(item: object, col: int, visible: bool) -> None:

	"""

	Sets whether the cell widget at column col will be visible or not depending on the value of visible.
	Supported item widgets are
	- Button (BCListViewItemSetButton()),
	- Checkbox (BCListViewItemSetCheckBox()),
	- ComboBox (BCListViewItemSetComboBox()),
	- ProgressBar (BCListViewItemSetProgressBar()),
	- RadioButton (BCListViewItemSetRadioButton())
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	visible : bool
		set this parameter to 1 for the widget to be visible, or 0 otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemWidgetIsVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemWidgetIsVisible(item: object, col: int) -> bool:

	"""

	Returns whether the cell widget of item item at column col is visible or not.
	Supported item widgets are
	- Button (BCListViewItemSetButton()),
	- Checkbox (BCListViewItemSetCheckBox()),
	- ComboBox (BCListViewItemSetComboBox()),
	- ProgressBar (BCListViewItemSetProgressBar()),
	- RadioButton (BCListViewItemSetRadioButton())
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		True if the cell widget is visible, or False otherwise.

	See Also
	--------
	BCListViewItemWidgetSetVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemWidgetSetEnabled(item: object, col: int, enable: bool) -> None:

	"""

	Sets whether the cell widget at column col will be enabled or not depending on the value of enable.
	A disabled item widget does not interact with user events. By default, all item widgets are enabled.
	Supported item widgets are
	- Button (BCListViewItemSetButton()),
	- Checkbox (BCListViewItemSetCheckBox()),
	- ComboBox (BCListViewItemSetComboBox()),
	- ProgressBar (BCListViewItemSetProgressBar()),
	- RadioButton (BCListViewItemSetRadioButton())
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	enable : bool
		set 0 for the widget to be disabled, or 1 to enable (default).

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemWidgetIsEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Confirm Selected Assignee"], 0
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    addPart(listView, "1004", "Roof rack")
		    addPart(listView, "1005", "Spoiler")
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    comboBoxCol = 2
		    checkBoxCol = 3
		    guitk.BCListViewItemSetComboBox(
		        item, comboBoxCol, "", comboBoxActivatedFunct, checkBoxCol
		    )
		    guitk.BCListViewItemComboBoxInsertStrList(item, comboBoxCol, users)
		    guitk.BCListViewItemComboBoxInsertItem(item, comboBoxCol, "Select Assignee", 0)
		    guitk.BCListViewItemSetCheckBox(
		        item, checkBoxCol, False, assigneeConfirmedFunct, comboBoxCol
		    )
		    guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, checkBoxCol):
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, col)
		    if curText == "Select Assignee":
		        # Disable CheckBox if no assignee is selected
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    else:
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, True)
		        curIndex = guitk.BCListViewItemComboBoxIndexOf(item, col, curText)
		        print(
		            "Selected assignee no."
		            + str(curIndex)
		            + ": "
		            + curText
		            + ". Select CheckBox to confirm."
		        )
		    return 0
		
		
		def assigneeConfirmedFunct(item, col, state, comboBoxCol):
		    guitk.BCListViewItemWidgetSetEnabled(item, comboBoxCol, not state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemWidgetIsEnabled(item: object, col: int) -> bool:

	"""

	Returns whether the cell widget of item item at column col is enabled or not.
	Supported item widgets are
	- Button (BCListViewItemSetButton()),
	- Checkbox (BCListViewItemSetCheckBox()),
	- ComboBox (BCListViewItemSetComboBox()),
	- ProgressBar (BCListViewItemSetProgressBar()),
	- RadioButton (BCListViewItemSetRadioButton())
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		True if the cell widget is enabled, or False otherwise.

	See Also
	--------
	BCListViewItemWidgetSetEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Item RadioButton", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Checked"], 0)
		    listViewBtnGroup = guitk.BCListViewButtonGroupCreate(listView, 2)
		    guitk.BCListViewSetCurrentItemChangedFunction(
		        listView, currentItemChangedFunct, listViewBtnGroup
		    )
		    guitk.BCListViewButtonGroupSetMousePressedFunction(
		        listViewBtnGroup, mousePressedFunct, listView
		    )
		    addPart(listView, listViewBtnGroup, "1001", "Bumper")
		    addPart(listView, listViewBtnGroup, "1002", "Decklid")
		    addPart(listView, listViewBtnGroup, "1003", "Pillar")
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Remove last RadioButton from ButtonGroup"
		    )
		    guitk.BCCheckBoxSetToggledFunction(
		        checkBox, checkBoxEnableChangedState, [listViewBtnGroup, listView]
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, group, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetRadioButton(item, 2, True, None, None)
		    guitk.BCListViewButtonGroupInsertItem(group, item)
		    return item
		
		
		def currentItemChangedFunct(listView, item, listViewBtnGroup):
		    guitk.BCListViewButtonGroupSetChecked(listViewBtnGroup, item)
		    return 0
		
		
		def mousePressedFunct(listViewBtnGroup, item, col, listView):
		    guitk.BCListViewSetCurrentItem(listView, item)
		    return 0
		
		
		def checkBoxEnableChangedState(checkBox, state, data):
		    item = guitk.BCListViewGetTopLevelItem(data[1], 2)
		    curItem = guitk.BCListViewGetCurrentItem(data[1])
		    if state:
		        if item == curItem:
		            guitk.BCListViewButtonGroupSetChecked(
		                data[0], guitk.BCListViewItemGetPreviousSibling(item)
		            )
		        guitk.BCListViewButtonGroupRemoveItem(data[0], item)
		    else:
		        guitk.BCListViewButtonGroupInsertItem(data[0], item)
		    guitk.BCListViewItemWidgetSetVisible(item, 2, not state)
		
		    text = "Current state of Pillar's RadioButton: "
		    if guitk.BCListViewItemWidgetIsEnabled(item, 2):
		        text += "Enabled "
		    else:
		        text += "Disabled "
		    if guitk.BCListViewItemWidgetIsVisible(item, 2):
		        text += "and Visible."
		    else:
		        text += "and Invisible."
		    print(text)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetColumnSeparatorEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Set whether a vertical line (separator) is drawn at the right of column col.
	Separator is drawn at the viewport, aligned right of column col. Function can be used to visually group columns.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	enable : bool
		True to show the separator,  False otherwise (default).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetScrollViewEnabled(w: object, enableScrollView: bool) -> None:

	"""

	Enable scrollbars in the BCWindow.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the BCWindow.

	enableScrollView : bool
		set True to enable scrollview or False to disable scrollview.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window ScrollView Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelCreate(window, "This is a Window with ScrollView")
		    for i in range(20):
		        btn = guitk.BCPushButtonCreate(window, "Button " + str(i), None, None)
		    guitk.BCWindowSetScrollViewEnabled(window, True)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCWindowSetInitSize(window, 400, 200)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCGridLayoutAddMultiCellWidget(grid: object, w: object, fromRow: int, toRow: int, fromCol: int, toCol: int, alignment: int) -> None:

	"""

	Adds the widget w to BCGridLayout grid, spanning multiple rows/columns.
	The cell will span from (fromRow, fromCol ) to (toRow, toCol ). Alignment is specified by alignment. Use BCAlignAuto as default, which fills the entire cell.

	Parameters
	----------
	grid : object
		the BCGridLayout

	w : object
		the widget that will be added.

	fromRow : int
		the start row number.

	toRow : int
		the end row number.

	fromCol : int
		the start column.

	toCol : int
		the end column.

	alignment : int
		the alignment. For valid values see BCEnumAlignment.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	See Also
	--------
	BCGridLayoutAddWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("BCGridLayout Example", guitk.constants.BCOnExitDestroy)
		
		    glayout = guitk.BCGridLayoutCreate(w)
		
		    label1 = guitk.BCLabelCreate(glayout, "Row 1")
		    label2 = guitk.BCLabelCreate(glayout, "Row 2")
		    label3 = guitk.BCLabelCreate(glayout, "Row 3")
		
		    ledit1 = guitk.BCLineEditCreate(glayout, "")
		    ledit2 = guitk.BCLineEditCreate(glayout, "")
		    ledit3 = guitk.BCLineEditCreate(glayout, "")
		
		    button1 = guitk.BCPushButtonCreate(glayout, "Button 1", None, None)
		    button2 = guitk.BCPushButtonCreate(glayout, "Button 2", None, None)
		    button3 = guitk.BCPushButtonCreate(glayout, "Button 3", None, None)
		    button4 = guitk.BCPushButtonCreate(glayout, "Button 4", None, None)
		
		    guitk.BCGridLayoutAddWidget(glayout, label1, 0, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label2, 1, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, label3, 2, 0, guitk.constants.BCAlignLeft)
		    guitk.BCGridLayoutAddWidget(glayout, ledit1, 0, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit2, 1, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, ledit3, 2, 1, guitk.constants.BCAlignAuto)
		    guitk.BCGridLayoutAddWidget(glayout, button1, 0, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button2, 1, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddWidget(glayout, button3, 2, 2, guitk.constants.BCAlignRight)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        glayout, button4, 3, 4, 0, 2, guitk.constants.BCAlignAuto
		    )
		
		    guitk.BCSpacerCreate(w)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Margin :   ")
		    margin = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(margin, 1)
		    guitk.BCSpinBoxSetMaxValue(margin, 50)
		    guitk.BCSpinBoxSetValue(margin, 4)  # default margin
		    guitk.BCSpinBoxSetValueChangedFunction(margin, setMargin, glayout)
		    guitk.BCSpacerCreate(l)
		
		    l = guitk.BCBoxLayoutCreate(w, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(l, "Spacing : ")
		    spacing = guitk.BCSpinBoxCreate(l)
		    guitk.BCSpinBoxSetMinValue(spacing, 1)
		    guitk.BCSpinBoxSetMaxValue(spacing, 50)
		    guitk.BCSpinBoxSetValue(spacing, 4)  # default spacing
		    guitk.BCSpinBoxSetValueChangedFunction(spacing, setSpacing, glayout)
		    guitk.BCSpacerCreate(l)
		
		    guitk.BCWindowSetAcceptFunction(w, acceptFunc, None)
		    guitk.BCShow(w)
		
		
		def setMargin(spin, value, glayout):
		    guitk.BCGridLayoutSetMargin(glayout, value)
		    return 0
		
		
		def setSpacing(spin, value, glayout):
		    guitk.BCGridLayoutSetSpacing(glayout, value)
		    return 0
		
		
		def acceptFunc(w, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetInactive(item: object, inactive: bool) -> None:

	"""

	Sets whether a ListViewItem is inactive or active (default).
	Inactive item is only drawn as disabled but can handle all user events.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	inactive : bool
		1 to display inactive; 0 otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemInactive

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Inactive and Disabled Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Item Description"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    itemInactive = addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewItemSetInactive(itemInactive, True)
		    guitk.BCListViewItemSetText(itemInactive, 4, "Inactive item")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    itemDisabled = addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewItemSetEnabled(itemDisabled, False)
		    guitk.BCListViewItemSetText(itemDisabled, 4, "Disabled item")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, None)
		    guitk.BCListViewSetItemDeselectedFunction(listView, itemDeselected, None)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, printInactiveEnabled, None
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printInactiveEnabled(item, data):
		    print(
		        "Item ID={}: isInactive = {}, isEnabled = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemInactive(item),
		            guitk.BCListViewItemIsEnabled(item),
		        )
		    )
		    return 0
		
		
		def itemSelected(listView, item, data):
		    print(
		        "--------------\\nItem ID={} Selected!".format(
		            guitk.BCListViewItemGetText(item, 0)
		        )
		    )
		    return 0
		
		
		def itemDeselected(listView, item, data):
		    print("Item ID={} Deselected!".format(guitk.BCListViewItemGetText(item, 0)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetText(item, 4, "Regular Item")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemInactive(item: object) -> bool:

	"""

	Returns 1 if ListViewItem item is inactive or 0 otherwise.
	The default ListViewItem is active.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		1 if item is inactive, 0 otherwise.

	See Also
	--------
	BCListViewItemSetInactive

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Inactive and Disabled Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Version", "Manufactured", "Item Description"],
		        False,
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    itemInactive = addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewItemSetInactive(itemInactive, True)
		    guitk.BCListViewItemSetText(itemInactive, 4, "Inactive item")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    itemDisabled = addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewItemSetEnabled(itemDisabled, False)
		    guitk.BCListViewItemSetText(itemDisabled, 4, "Disabled item")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewSetItemSelectedFunction(listView, itemSelected, None)
		    guitk.BCListViewSetItemDeselectedFunction(listView, itemDeselected, None)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, printInactiveEnabled, None
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def printInactiveEnabled(item, data):
		    print(
		        "Item ID={}: isInactive = {}, isEnabled = {}".format(
		            guitk.BCListViewItemGetText(item, 0),
		            guitk.BCListViewItemInactive(item),
		            guitk.BCListViewItemIsEnabled(item),
		        )
		    )
		    return 0
		
		
		def itemSelected(listView, item, data):
		    print(
		        "--------------\\nItem ID={} Selected!".format(
		            guitk.BCListViewItemGetText(item, 0)
		        )
		    )
		    return 0
		
		
		def itemDeselected(listView, item, data):
		    print("Item ID={} Deselected!".format(guitk.BCListViewItemGetText(item, 0)))
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetText(item, 4, "Regular Item")
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxIndexOf(item: object, col: int, text: str) -> int:

	"""

	Returns the index of the first occurence of /a text inside ListViewItemComboBox, otherwise -1.
	The search is case insensitive.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	text : str
		the string to search.

	Returns
	-------
	int
		the index of the first item with string /a text; -1 otherwise.

	See Also
	--------
	BCListViewItemComboBoxInsertStrList

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Confirm Selected Assignee"], 0
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    addPart(listView, "1004", "Roof rack")
		    addPart(listView, "1005", "Spoiler")
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    comboBoxCol = 2
		    checkBoxCol = 3
		    guitk.BCListViewItemSetComboBox(
		        item, comboBoxCol, "", comboBoxActivatedFunct, checkBoxCol
		    )
		    guitk.BCListViewItemComboBoxInsertStrList(item, comboBoxCol, users)
		    guitk.BCListViewItemComboBoxInsertItem(item, comboBoxCol, "Select Assignee", 0)
		    guitk.BCListViewItemSetCheckBox(
		        item, checkBoxCol, False, assigneeConfirmedFunct, comboBoxCol
		    )
		    guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, checkBoxCol):
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, col)
		    if curText == "Select Assignee":
		        # Disable CheckBox if no assignee is selected
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    else:
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, True)
		        curIndex = guitk.BCListViewItemComboBoxIndexOf(item, col, curText)
		        print(
		            "Selected assignee no."
		            + str(curIndex)
		            + ": "
		            + curText
		            + ". Select CheckBox to confirm."
		        )
		    return 0
		
		
		def assigneeConfirmedFunct(item, col, state, comboBoxCol):
		    guitk.BCListViewItemWidgetSetEnabled(item, comboBoxCol, not state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterSetStretchFactor(sp: object, index: int, stretch: int) -> None:

	"""

	Sets the size policy of the widget at position index to have a stretch factor of stretch.
	Initializes the relative size of the widget at position index with regard to their sibling widgets.
	Setting stretch 0 will initialize the widget at position index to occupy minimum fixed size.
	NOTE: The stretch factor cannot change dynamically, except from 0 to positive and vice-versa (with weird results). To change the widget sizes dynamically use BCSplitterSetWidgetSizes.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	index : int
		the index of the item for which the stretch factor will be set.

	stretch : int
		the new stretch factor.

	Returns
	-------
	None

	See Also
	--------
	BCSplitterSetWidgetStretchFactor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter ResizeMode Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    splitterFrameCreate(splitter, "Frame A - stretch 0\\n(Keep Size)")
		    guitk.BCSplitterSetStretchFactor(splitter, 0, 0)
		    splitterFrameCreate(splitter, "Frame B - stretch 1")
		    guitk.BCSplitterSetStretchFactor(splitter, 1, 1)
		    frameC = splitterFrameCreate(splitter, "Frame C - stretch 2")
		    guitk.BCSplitterSetWidgetStretchFactor(splitter, frameC, 2)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def splitterFrameCreate(splitter, text):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(bLayout, text), guitk.constants.BCAlignCenter
		    )
		    hBox = guitk.BCHBoxCreate(bLayout)
		    guitk.BCPushButtonCreate(hBox, "Move First", moveToFirst, (splitter, frame))
		    guitk.BCPushButtonCreate(hBox, "Move Last", moveToLast, (splitter, frame))
		    return frame
		
		
		def moveToFirst(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToFirst(splitter, frame)
		    return 0
		
		
		def moveToLast(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToLast(splitter, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetTextChangedFunction(te: object, funct: Callable, data: Any=None) -> None:

	"""

	Set a function that will be called when the text of the BCTextEdit te changes. The te may also be a read-only BCTextEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	funct : Callable
		the callback function that is called when the cursor changes position.
		See BC_TEXTEDIT_TEXT_CHANGED_FUNCTION for details.
		integer BC_TEXTEDIT_TEXT_CHANGED_FUNCTION(te, data)
		The function to be called when the text changes.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * te : object
		                    the BCTextEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in function funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit with Stats Example", guitk.constants.BCOnExitDestroy
		    )
		    bLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    textEdit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        textEdit, "Text and TextEdit Stats.\\nTry typing and check the values below."
		    )
		    boldButton = myToolButtonCreate(bLayout, "font_bold.svg", boldFormat, textEdit)
		    italicButton = myToolButtonCreate(
		        bLayout, "font_italic.svg", italicFormat, textEdit
		    )
		    underlineButton = myToolButtonCreate(
		        bLayout, "font_underline.svg", underlineFormat, textEdit
		    )
		    monospacefontCheckBox = guitk.BCCheckBoxCreate(bLayout, "Monospace")
		    guitk.BCCheckBoxSetToggledFunction(
		        monospacefontCheckBox, monospaceFontFunction, textEdit
		    )
		    statsLabel = guitk.BCLabelCreate(window, "")
		    generateStatsLabel(textEdit, statsLabel)
		    guitk.BCTextEditSetTextChangedFunction(textEdit, generateStatsLabel, statsLabel)
		    guitk.BCWindowSetAcceptFunction(window, lambda w, data: 0, None)
		    guitk.BCShow(window)
		
		
		def generateStatsLabel(textEdit, label):
		    text = guitk.BCTextEditGetText(textEdit)
		    labelText = (
		        "\\nBCFontHeight = "
		        + str(guitk.BCFontHeight(textEdit))
		        + "\\nBCFontMaxWidth = "
		        + str(guitk.BCFontMaxWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCStringWidth = "
		        + str(guitk.BCStringWidth(textEdit, text, len(text)))
		        + "\\nBCTextEditGetVisibleWidth = "
		        + str(guitk.BCTextEditGetVisibleWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetVisibleHeight = "
		        + str(guitk.BCTextEditGetVisibleHeight(textEdit))
		        + "\\nBCTextEditGetContentsWidth = "
		        + str(guitk.BCTextEditGetContentsWidth(textEdit))
		    )
		    labelText += (
		        "\\nBCTextEditGetContentsHeight = "
		        + str(guitk.BCTextEditGetContentsHeight(textEdit))
		        + "\\nBCTextEditMonospaceFont = "
		        + str(guitk.BCTextEditMonospaceFont(textEdit))
		    )
		    guitk.BCLabelSetText(label, labelText)
		    return 0
		
		
		def myToolButtonCreate(p, iconName, function, textEdit):
		    toolBtn = guitk.BCToolButtonCreate(p, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(toolBtn, True)
		    guitk.BCButtonSetToggledFunction(toolBtn, function, textEdit)
		    return toolBtn
		
		
		def boldFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetBold(textEdit, state)
		    return 0
		
		
		def italicFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetItalic(textEdit, state)
		    return 0
		
		
		def underlineFormat(toolBtn, state, textEdit):
		    guitk.BCTextEditSetUnderline(textEdit, state)
		    return 0
		
		
		def monospaceFontFunction(chkBox, state, textEdit):
		    guitk.BCTextEditSetMonospaceFont(textEdit, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetParagraphForegroundColor(te: object, paragraph: int, r: int, g: int, b: int) -> None:

	"""

	Sets the RGB values for the foreground color of paragraph paragraph to be r, g and b.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the index of the paragraph to be affected.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	See Also
	--------
	BCTextEditClearParagraphForegroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraph Colors", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    colorBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph Color", guitk.constants.BCHorizontal
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Background", setParaBackground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Foreground", setParaForeground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Background", resetParaBackground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Foreground", resetParaForeground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(255, 255, 255)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphBackgroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def setParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(0, 0, 0)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphForegroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def resetParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphBackgroundColor(textEdit, paragraph)
		    return 0
		
		
		def resetParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphForegroundColor(textEdit, paragraph)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditClearParagraphForegroundColor(te: object, paragraph: int) -> None:

	"""

	Sets the foreground color of paragraph paragraph to the default.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	paragraph : int
		the index of the paragraph to be affected.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditSetParagraphForegroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit Paragraph Colors", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(window, open(__file__).read())
		    colorBtnGroup = guitk.BCButtonGroupCreate(
		        window, "Paragraph Color", guitk.constants.BCHorizontal
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Background", setParaBackground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Set Foreground", setParaForeground, textEdit
		        ),
		        "color_palette_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Background", resetParaBackground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCButtonSetIconFileName(
		        guitk.BCPushButtonCreate(
		            colorBtnGroup, "Reset Foreground", resetParaForeground, textEdit
		        ),
		        "clear_small.svg",
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(255, 255, 255)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphBackgroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def setParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    color = guitk.BCGetColor(0, 0, 0)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditSetParagraphForegroundColor(textEdit, paragraph, *color)
		    return 0
		
		
		def resetParaBackground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphBackgroundColor(textEdit, paragraph)
		    return 0
		
		
		def resetParaForeground(b, textEdit):
		    currentSelection = guitk.BCTextEditGetSelection(textEdit)
		    for paragraph in range(currentSelection[0], currentSelection[-2] + 1):
		        guitk.BCTextEditClearParagraphForegroundColor(textEdit, paragraph)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetClearOptionVisible(te: object, visible: bool) -> None:

	"""

	Control the availability of the 'Clear' option on BCTextEdit's right mouse click menu.
	If visible is set to True, the 'Clear' option will appear after the 'Select all' option. It will be disabled if the BCTextEdit te has no text.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	visible : bool
		set this parameter to True to make the 'Clear' option visible on right mouse click menu, or False otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCTextEditClearOptionVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 1", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    chkBoxReadOnly = guitk.BCCheckBoxCreate(hBoxFooter, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReadOnly, setReadOnly, textEdit)
		    chkBoxBlockUpdates = guitk.BCCheckBoxCreate(hBoxFooter, "Block Updates")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxBlockUpdates, blockUpdates, textEdit)
		    chkBoxClear = guitk.BCCheckBoxCreate(hBoxFooter, "Clear Option")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxClear, setClearOption, textEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setReadOnly(cb, state, textEdit):
		    guitk.BCTextEditSetReadOnly(textEdit, state)
		    print("ReadOnly set to: " + str(guitk.BCTextEditIsReadOnly(textEdit)))
		    return 0
		
		
		def blockUpdates(cb, state, textEdit):
		    guitk.BCTextEditBlockUpdates(textEdit, state)
		    print("BlockUpdates set to: " + str(guitk.BCTextEditAreUpdatesBlocked(textEdit)))
		    return 0
		
		
		def setClearOption(cb, state, textEdit):
		    guitk.BCTextEditSetClearOptionVisible(textEdit, state)
		    print(
		        "Context Menu Clear Option is Visible = "
		        + str(guitk.BCTextEditClearOptionVisible(textEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditClearOptionVisible(te: object) -> bool:

	"""

	Informs whether the 'Clear' option will be visible on a BCTextEdit right mouse click menu.
	This function will return True even if the option is currently disabled.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit

	Returns
	-------
	bool
		True if the 'Clear' option is visible on te's right mouse click menu, or False otherwise.

	See Also
	--------
	BCTextEditSetClearOptionVisible

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "TextEdit functions example 1", guitk.constants.BCOnExitDestroy
		    )
		    textEdit = guitk.BCTextEditCreate(
		        window, "Lorem ipsum dolor sit amet, consectetur adipisicing elit\\n\\n\\n" * 20
		    )
		    guitk.BCTextEditSetCursorPositionChangedFunction(
		        textEdit, cursorPositionChanged, None
		    )
		
		    hBoxFooter = guitk.BCHBoxCreate(window)
		    chkBoxReadOnly = guitk.BCCheckBoxCreate(hBoxFooter, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReadOnly, setReadOnly, textEdit)
		    chkBoxBlockUpdates = guitk.BCCheckBoxCreate(hBoxFooter, "Block Updates")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxBlockUpdates, blockUpdates, textEdit)
		    chkBoxClear = guitk.BCCheckBoxCreate(hBoxFooter, "Clear Option")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxClear, setClearOption, textEdit)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cursorPositionChanged(textEdit, para, pos, data):
		    print(
		        "Selection info (startPara, startPos, endPara, endPos) = '{}'".format(
		            guitk.BCTextEditGetSelection(textEdit)
		        )
		    )
		    return 0
		
		
		def setReadOnly(cb, state, textEdit):
		    guitk.BCTextEditSetReadOnly(textEdit, state)
		    print("ReadOnly set to: " + str(guitk.BCTextEditIsReadOnly(textEdit)))
		    return 0
		
		
		def blockUpdates(cb, state, textEdit):
		    guitk.BCTextEditBlockUpdates(textEdit, state)
		    print("BlockUpdates set to: " + str(guitk.BCTextEditAreUpdatesBlocked(textEdit)))
		    return 0
		
		
		def setClearOption(cb, state, textEdit):
		    guitk.BCTextEditSetClearOptionVisible(textEdit, state)
		    print(
		        "Context Menu Clear Option is Visible = "
		        + str(guitk.BCTextEditClearOptionVisible(textEdit))
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuClose(pm: object) -> bool:

	"""

	Closes this BCMenu. Returns true if the BCMenu pm was closed; otherwise returns false.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	Returns
	-------
	bool
		true if the BCMenu pm was closed; otherwise returns false.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Items Activated Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    lineEdit = guitk.BCLineEditCreate(popupMenu, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Press Enter twice")
		    guitk.BCAddToolTip(
		        lineEdit,
		        "Widgets inside PopupMenu are activated by pressing Enter while they have focus",
		    )
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, editingFinished, None)
		    guitk.BCPopupMenuInsertWidget(popupMenu, lineEdit)
		    guitk.BCPopupMenuSetItemCheckable(
		        popupMenu,
		        guitk.BCPopupMenuInsertItem(popupMenu, "Toggle Item", None, None),
		        True,
		    )
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popupMenu, False)
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Item" + str(i), None, None)
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, printItem, lineEdit)
		    guitk.BCShow(window)
		
		
		def editingFinished(lineEdit, data):
		    print("LineEditEditingFinished Activated.")
		    return 0
		
		
		def printItem(popupMenu, id, widget):
		    if id == guitk.BCPopupMenuItemId(popupMenu, "Toggle Item"):
		        guitk.BCPopupMenuSetItemChecked(
		            popupMenu, id, not guitk.BCPopupMenuIsItemChecked(popupMenu, id)
		        )
		        print("Toggle Item Activated.")
		    elif id == guitk.BCPopupMenuWidgetItemId(popupMenu, widget):
		        print("Widget Activated.")
		    else:
		        print(guitk.BCPopupMenuText(popupMenu, id) + " Activated.")
		        guitk.BCPopupMenuClose(popupMenu)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxInsertSeparator(box: object, index: int) -> None:

	"""

	Insert a separator at position index.
	Separator will be appended if index is negative or greater than the number of items in the combo box.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	index : int
		the index at which separator will be inserted (-1 to append).

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxIsSeparator

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxIsSeparator(box: object, index: int) -> bool:

	"""

	Returns whether combo box item at position index is a separator or not.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	index : int
		the index.

	Returns
	-------
	bool
		1 if item at position index is separator or 0 otherwise.

	See Also
	--------
	BCComboBoxInsertSeparator

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Item Insertions Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(
		        window, ["Initial 0", "Initial 1", "Initial 2", "Initial 3", "Initial 4"]
		    )
		
		    stringList = ["Insertion 0", "Insertion 1", "Insertion 2", "Insertion 3"]
		    guitk.BCComboBoxInsertStrList(cmb, stringList, len(stringList), 0)
		    print(
		        "Contains 'Insertion 1'="
		        + str(guitk.BCComboBoxContainsLabel(cmb, "Insertion 1"))
		    )
		
		    insertion3Index = guitk.BCComboBoxLabelIndex(cmb, "Insertion 3")
		    guitk.BCComboBoxInsertSeparator(cmb, insertion3Index + 1)
		    print("ComboBox index 5 IsSeparator= " + str(guitk.BCComboBoxIsSeparator(cmb, 4)))
		
		    guitk.BCComboBoxInsertItemIconFileName(cmb, "logo_ansa", "ansa", 0)
		    print("ComboBox Count=" + str(guitk.BCComboBoxCount(cmb)))
		    print("ComboBox Max Count=" + str(guitk.BCComboBoxMaxCount(cmb)))
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLabelSetLinkActivatedFunction(lb: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when a link is clicked inside lb.
	This function is not supported under VR mode.

	Parameters
	----------
	lb : object
		the BCLabel.

	funct : Callable
		the function that will be called when enter is pressed. See BC_LABEL_LINK_ACTIVATED_FUNCTION for details.
		integer BC_LABEL_LINK_ACTIVATED_FUNCTION(lb, link, data)
		The function to be called when the link link is clicked inside BCLabel lb.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lb : object
		                    the BCLabel.
		          * link : str
		                    the link that has been activated.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by funct.

	Returns
	-------
	None

	See Also
	--------
	

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Example Label", guitk.constants.BCOnExitDestroy)
		    grid = guitk.BCGridLayoutCreate(w, 5, 2)
		
		    tmp = guitk.BCLabelCreate(grid, "Regular")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 0, 0, guitk.constants.BCAlignAuto)
		    regular = guitk.BCLabelCreate(grid, "Distance from geometry")
		    guitk.BCGridLayoutAddWidget(grid, regular, 0, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Ticker")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 1, 0, guitk.constants.BCAlignAuto)
		    ticker = guitk.BCLabelTickerCreate(
		        w,
		        "The reported <b>deviation</b> is calculated as the ratio of the smallest value over the largest",
		    )
		    guitk.BCGridLayoutAddWidget(grid, ticker, 1, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Pixmap")
		    guitk.BCGridLayoutAddWidget(grid, tmp, 2, 0, guitk.constants.BCAlignAuto)
		    pix = guitk.BCLabelCreate(w, "")
		    guitk.BCLabelSetIconFileName(pix, "logo_sdm.svg")
		    guitk.BCGridLayoutAddWidget(grid, pix, 2, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, "Style Pixmap")
		    guitk.BCLabelSetStylePixmap(tmp, guitk.constants.BCMessageBoxInformation)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 3, 0, guitk.constants.BCAlignAuto)
		    stylePixmap = guitk.BCLabelCreate(w, "Use this example to give info with Labels")
		    guitk.BCGridLayoutAddWidget(grid, stylePixmap, 3, 1, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="Print Message">Print Message</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 0, guitk.constants.BCAlignAuto)
		
		    tmp = guitk.BCLabelCreate(grid, '<a href="OpenAWindow">Open Window</a>')
		    guitk.BCLabelSetLinkActivatedFunction(tmp, openLinkFun, 0)
		    guitk.BCGridLayoutAddWidget(grid, tmp, 5, 1, guitk.constants.BCAlignAuto)
		
		    guitk.BCShow(w)
		
		
		def openLinkFun(lb, link, data):
		    if link == "Print Message":
		        print("Message was printed!")
		    elif link == "OpenAWindow":
		        w = guitk.BCWindowCreate("Comments", guitk.constants.BCOnExitDestroy)
		        guitk.BCLabelCreate(w, "Opened from simple link")
		        guitk.BCDialogButtonBoxCreate(w)
		        guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemCheckableSetDrawAsRadioButton(item: object, drawAsRadioButton: bool) -> None:

	"""

	Sets the checkable ListViewItem to display radio button instead of check box indicator, depending on the value of radio.
	If item is not checkable nothing happens. You are responsible to operate the mutual exclusive property in the group of items.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	drawAsRadioButton : bool
		1 sets item to be displayed as radio button, 0 otherwise (default)

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetCheckable

	"""

def BCListViewSetItemSpacing(lv: object, pixels: int) -> None:

	"""

	Defines the item density in pixels (default 2).
	Spacing between items is calculated with respect to font size and style parameters but this function provides some extra space. 
	Use even integers to ensure same pixels above and below item contents. Negative pixels number is not allowed.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	pixels : int
		the extra empty space between items in pixels (default 2).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Delete Selected Assignee"], 0
		    )
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", infoBox)
		    addPart(listView, "1002", "Decklid", infoBox)
		    addPart(listView, "1003", "Pillar", infoBox)
		    addPart(listView, "1004", "Roof rack", infoBox)
		    addPart(listView, "1005", "Spoiler", infoBox)
		    guitk.BCListViewSetItemSpacing(listView, 6)
		    guitk.BCListViewSetColumnSeparatorEnabled(listView, 2, True)
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, infoBox):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    guitk.BCListViewItemSetComboBox(item, 2, users, comboBoxActivatedFunct, infoBox)
		    guitk.BCListViewItemComboBoxInsertItem(item, 2, "Select Assignee", 0)
		    guitk.BCListViewItemSetButton(item, 3, deleteAssigneeFunct, infoBox)
		    guitk.BCListViewItemButtonSetText(item, 3, "Delete")
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, infoBox):
		    curText = guitk.BCListViewItemComboBoxText(item, col, index)
		    text = "Total ComboBox values of selected item(ID=" + guitk.BCListViewItemGetText(
		        item, 0
		    )
		    text += "): " + str(guitk.BCListViewItemComboBoxCount(item, col))
		    text += " | Current value: " + curText
		    guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		    return 0
		
		
		def deleteAssigneeFunct(item, col, infoBox):
		    curIndex = guitk.BCListViewItemComboBoxCurrentItem(item, 2)
		    curText = guitk.BCListViewItemComboBoxText(item, 2, curIndex)
		    text = (
		        "Deleted User: "
		        + curText
		        + ", from item(ID="
		        + guitk.BCListViewItemGetText(item, 0)
		        + ")"
		    )
		    if not curIndex == 0:
		        guitk.BCListViewItemComboBoxRemoveItem(item, 2, curIndex)
		        guitk.BCItemViewStatusBarSetText(infoBox, 0, text)
		        guitk.BCListViewItemComboBoxSetCurrentText(item, 2, "Select Assignee")
		    else:
		        guitk.BCItemViewStatusBarSetText(
		            infoBox, 0, "This value can't be deleted. Please select another value."
		        )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetExpandMode(item: object, mode: int) -> None:

	"""

	Sets when the tree branch control ([+] and [-] in some styles) for item is visible and expand/collapse action is enabled.
	The standard item displays expand/collapse controls and enables action when contains at least one child (BCDontShowIndicatorWhenChildless).
	You can force show controls even when contains no children or force hide controls when children.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	mode : int
		See BCEnumItemExpandMode for more details.
		
		guitk.constants BCEnumItemExpandMode
		This mode decides how the ListViewItem tree branch expand/collapse indicator is shown.
		 - guitk.constants.BCShowIndicator
		The controls for expanding and collapsing will be shown for this item even if there are no children.
		 - guitk.constants.BCDontShowIndicator
		The controls for expanding and collapsing will never be shown even if there are children. If the node is forced open the user will not be able to expand or collapse the item.
		 - guitk.constants.BCDontShowIndicatorWhenChildless
		The controls for expanding and collapsing will be shown if the item contains children.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemExpandMode

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemExpandMode(item: object) -> int:

	"""

	Returns the item children expand mode (default BCDontShowIndicatorWhenChildless).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	int

	See Also
	--------
	BCListViewItemSetExpandMode

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSaveSortStateAndDisableSorting(lv: object) -> None:

	"""

	Saves the current sort state (column and order) of ListView lv and then disables sorting.
	When adding items or modifying their data (text, icons etc) in a ListView where sorting applied, the performance is low.
	It is recommended that you disable sorting first, then make mass data modifications and restore sorting again.
	NOTE: do not forget to BCListViewRestoreSortState() when mass modification finished.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	See Also
	--------
	BCListViewRestoreSortState

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Simple", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    # Start adding parts. Notice that we disable sorting while adding for performance reasons
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewRestoreSortState(lv: object) -> None:

	"""

	Restores the last saved sort state (column and order) of the ListView lv.
	If last saved sort state is not found, function does nothing.
	When adding items or modifying their data (text, icons etc) in a ListView where sorting applied, the performance is low.
	It is recommended that you disable sorting first, then make mass data modifications and restore sorting again.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSaveSortStateAndDisableSorting

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Simple", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    # Start adding parts. Notice that we disable sorting while adding for performance reasons
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMenuBarCreate(p: object) -> object:

	"""

	Creates a BCMenuBar in parent p.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.
		NOTE: BCMenuBars are meant to be created with BCWindow parents.

	Returns
	-------
	object
		the created BCMenuBar

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def openFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Open function called")
		
		
		def saveFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Save function called")
		
		
		def quitFun(pm, id, w):
		    print("Bye...")
		    guitk.BCWindowReject(w)
		
		
		def copyFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Copy function called")
		
		
		def cutFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Cut function called")
		
		
		def pasteFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Paste function called")
		
		
		def main():
		    w = guitk.BCWindowCreate("Window with MenuBar", guitk.constants.BCOnExitDestroy)
		    mb = guitk.BCMenuBarCreate(w)
		    te = guitk.BCTextEditCreate(w, "")
		    guitk.BCTextEditSetReadOnly(te, True)
		
		    file_menu = guitk.BCPopupMenuCreate(mb)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        file_menu, "Open", "file_open_small.svg", openFun, te
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        file_menu, "Save", "file_save_small.svg", saveFun, te
		    )
		    guitk.BCPopupMenuInsertSeparator(file_menu)
		    guitk.BCPopupMenuInsertItemWithIcon(file_menu, "Quit", "quit.svg", quitFun, w)
		    guitk.BCMenuBarAddMenuItem(mb, "&File", file_menu)
		
		    edit_menu = guitk.BCPopupMenuCreate(mb)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        edit_menu, "Copy", "edit_copy_small.svg", copyFun, te
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        edit_menu, "Cut", "edit_cut_small.svg", cutFun, te
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        edit_menu, "Paste", "edit_paste_small.svg", pasteFun, te
		    )
		    guitk.BCMenuBarAddMenuItem(mb, "&Edit", edit_menu)
		
		    guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMenuBarAddMenuItem(mb: object, text: str, menu: object) -> int:

	"""

	Adds menu menu in BCMenuBar mb under text.
	This function is not supported under VR mode.

	Parameters
	----------
	mb : object
		the BCMenuBar where the BCMenu will be added.

	text : str
		the name of the item that will hold BCMenu menu.

	menu : object
		the BCMenu that will be added

	Returns
	-------
	int
		the id of the item that holds BCMenu menu.

	Examples
	--------
	::

		# PYTHON script
		from sdm import guitk
		
		
		def openFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Open function called")
		
		
		def saveFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Save function called")
		
		
		def quitFun(pm, id, w):
		    print("Bye...")
		    guitk.BCWindowReject(w)
		
		
		def copyFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Copy function called")
		
		
		def cutFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Cut function called")
		
		
		def pasteFun(pm, id, te):
		    guitk.BCTextEditAppendParagraph(te, "Paste function called")
		
		
		def main():
		    w = guitk.BCWindowCreate("Window with MenuBar", guitk.constants.BCOnExitDestroy)
		    mb = guitk.BCMenuBarCreate(w)
		    te = guitk.BCTextEditCreate(w, "")
		    guitk.BCTextEditSetReadOnly(te, True)
		
		    file_menu = guitk.BCPopupMenuCreate(mb)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        file_menu, "Open", "file_open_small.svg", openFun, te
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        file_menu, "Save", "file_save_small.svg", saveFun, te
		    )
		    guitk.BCPopupMenuInsertSeparator(file_menu)
		    guitk.BCPopupMenuInsertItemWithIcon(file_menu, "Quit", "quit.svg", quitFun, w)
		    guitk.BCMenuBarAddMenuItem(mb, "&File", file_menu)
		
		    edit_menu = guitk.BCPopupMenuCreate(mb)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        edit_menu, "Copy", "edit_copy_small.svg", copyFun, te
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        edit_menu, "Cut", "edit_cut_small.svg", cutFun, te
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        edit_menu, "Paste", "edit_paste_small.svg", pasteFun, te
		    )
		    guitk.BCMenuBarAddMenuItem(mb, "&Edit", edit_menu)
		
		    guitk.BCShow(w)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardSetPageInfo(wiz: object, index: int, text: str, state: int=guitk.constants.BCWidgetStateInformation) -> None:

	"""

	Sets the text and the icon state (for example warning, error etc) for page index.
	Page info consist of an icon and a text displayed below page contents.
	To clear the info use and empty text with BCWidgetStateNone, or use the convenience function BCWizardClearPageInfo().
	Valid icon states are 
	- BCWidgetStateNone no icon,
	- BCWidgetStateInformation an icon indicating that the message is nothing out of the ordinary (default) or maybe a small tip,
	- BCWidgetStateWarning an icon indicating that the message is a warning, but can be dealt with,
	- BCWidgetStateError an icon indicating that the message represents a critical problem
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the page index. The valid range is from 0 to BCWizardPageCount()-1.

	text : str, optional
		the text at the bottom of the page to be displayed.

	state : int, optional
		the icon next to text at the bottom of the page to be displayed as info. See BCEnumWidgetState for details.
		
		guitk.constants BCEnumWidgetState
		This enumeration indicates the state (i.e. the color or icon used) for a widget
		 - guitk.constants.BCWidgetStateNone
		No state. Indicates the standard widget display.
		 - guitk.constants.BCWidgetStateInformation
		Indicates an info nothing out of the ordinary.
		 - guitk.constants.BCWidgetStateWarning
		Indicates a state that can be dealt with.
		 - guitk.constants.BCWidgetStateError
		Indicates a critical problem.
		 - guitk.constants.BCWidgetStateReadOnly
		Indicates that the widget cannot be edited.

	Returns
	-------
	None

	See Also
	--------
	BCWizardClearPageInfo

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard 2D Shapes Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(
		        wizard, wizardCreateFirstPage(wizard), "Introduction", "Create 2D Shapes", ""
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateSecondPage(wizard),
		        "Type",
		        "Select the type of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateThirdPage(wizard),
		        "Color",
		        "Select the color of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateForthPage(wizard),
		        "Confirmation",
		        "Shape is about to be created",
		        "",
		    )
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizardCurrentPageChanged, None)
		    guitk.BCShow(wizard)
		
		
		def wizardCreateFirstPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        p, "Design simple geometric two-dimensional shapes<br>in 4 simple steps."
		    )
		    guitk.BCSpacerCreate(p)
		    guitk.BCLabelCreate(p, "Please <b>click Next</b> to continue.")
		    return p
		
		
		def wizardCreateSecondPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    group = guitk.BCButtonGroupCreate(p, "Types", guitk.constants.BCVertical)
		    guitk.BCButtonGroupSetBorderMode(group, guitk.constants.BCNoBorderNoMargin)
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Circle", None, None), 0
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Pentagon", None, None), 1
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Square", None, None), 2
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Triangle", None, None), 3
		    )
		    guitk.BCButtonGroupSetButton(group, 0)
		    guitk.BCSpacerCreate(p)
		    guitk.BCSetUserDataKey(wizard, "TYPE_BUTTON_GROUP", group)
		    return p
		
		
		def wizardCreateThirdPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(p, "Please select a color that fills the shape.")
		    lview = guitk.BCListViewCreate(p, 2, ["Color", "Hex code"], 1)
		    lViewAddColor(lview, "Red", "#FF0000")
		    lViewAddColor(lview, "Green", "#00FF00")
		    lViewAddColor(lview, "Blue", "#0000FF")
		    lViewAddColor(lview, "Black", "#000000")
		    lViewAddColor(lview, "White", "#FFFFFF")
		    lViewAddColor(lview, "Orange", "#FFA500")
		    guitk.BCSetUserDataKey(wizard, "COLOR_LIST_VIEW", lview)
		    guitk.BCListViewSetSelectionChangedFunction(
		        lview, ColorsListViewSelectionChanged, wizard
		    )
		    guitk.BCListViewSetDoubleClickedFunction(lview, ColorsListViewDoubleClicked, wizard)
		    return p
		
		
		def lViewAddColor(lview, name, hexCode):
		    item = guitk.BCListViewAddTopLevelItem(lview)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, hexCode)
		    return item
		
		
		def ColorsListViewSelectionChanged(lview, wizard):
		    selected = guitk.BCListViewGetSelectedItem(lview)
		    # make color selection mandatory
		    if selected:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		    else:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    # make color selection mandatory
		    if selected:
		        if guitk.BCListViewItemGetText(selected, 0) == "Black":
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "Colors for perimeter and body shape are the same.",
		                guitk.constants.BCWidgetStateWarning,
		            )
		        else:
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "The perimeter will be drawn using black color.",
		                guitk.constants.BCWidgetStateInformation,
		            )
		    else:
		        guitk.BCWizardClearPageInfo(wizard, 2)
		    return 0
		
		
		def ColorsListViewDoubleClicked(lview, item, col, wizard):
		    if item:
		        guitk.BCWizardGoToNextPage(wizard)
		    return 0
		
		
		def wizardCreateForthPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    grid = guitk.BCGridLayoutCreate(p, 6, 3)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid, guitk.BCLabelCreate(p, "You selected to create a "), 0, 0, 0, 2, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Type:"), 1, 0, 0)
		    type = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, type, 1, 1, 0)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(p, "Perimeter color:"), 2, 0, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "<b>Black</b>"), 2, 1, 0)
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Body color:"), 3, 0, 0)
		    color = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, color, 3, 1, 0)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid,
		        guitk.BCLabelCreate(p, "Please <b>click Finish</b> to create the shape."),
		        5,
		        5,
		        0,
		        2,
		        0,
		    )
		    guitk.BCGridLayoutSetRowStretch(grid, 4, 1)
		    guitk.BCGridLayoutSetColStretch(grid, 2, 1)
		    guitk.BCSetUserDataKey(wizard, "TYPE_LABEL", type)
		    guitk.BCSetUserDataKey(wizard, "COLOR_LABEL", color)
		    return p
		
		
		def wizardCurrentPageChanged(wizard, oldIndex, newIndex, data):
		    if newIndex == 2:
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        if guitk.BCListViewGetSelectedItem(lview):
		            guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		        else:
		            guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    elif newIndex == 3:
		        group = guitk.BCGetUserDataKey(wizard, "TYPE_BUTTON_GROUP")
		        type = guitk.BCGetUserDataKey(wizard, "TYPE_LABEL")
		        typestr = (
		            "<b>" + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(group)) + "</b>"
		        )
		        guitk.BCLabelSetText(type, typestr)
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        color = guitk.BCGetUserDataKey(wizard, "COLOR_LABEL")
		        colorstr = (
		            "<b>"
		            + guitk.BCListViewItemGetText(guitk.BCListViewGetSelectedItem(lview), 0)
		            + "</b>"
		        )
		        guitk.BCLabelSetText(color, colorstr)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardClearPageInfo(wiz: object, index: int) -> None:

	"""

	Hides the information text and icon for page index.
	Convenience function for BCWizardSetPageInfo().
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the page index. The valid range is from 0 to BCWizardPageCount()-1.

	Returns
	-------
	None

	See Also
	--------
	BCWizardSetPageInfo

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard 2D Shapes Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(
		        wizard, wizardCreateFirstPage(wizard), "Introduction", "Create 2D Shapes", ""
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateSecondPage(wizard),
		        "Type",
		        "Select the type of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateThirdPage(wizard),
		        "Color",
		        "Select the color of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateForthPage(wizard),
		        "Confirmation",
		        "Shape is about to be created",
		        "",
		    )
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizardCurrentPageChanged, None)
		    guitk.BCShow(wizard)
		
		
		def wizardCreateFirstPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        p, "Design simple geometric two-dimensional shapes<br>in 4 simple steps."
		    )
		    guitk.BCSpacerCreate(p)
		    guitk.BCLabelCreate(p, "Please <b>click Next</b> to continue.")
		    return p
		
		
		def wizardCreateSecondPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    group = guitk.BCButtonGroupCreate(p, "Types", guitk.constants.BCVertical)
		    guitk.BCButtonGroupSetBorderMode(group, guitk.constants.BCNoBorderNoMargin)
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Circle", None, None), 0
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Pentagon", None, None), 1
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Square", None, None), 2
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Triangle", None, None), 3
		    )
		    guitk.BCButtonGroupSetButton(group, 0)
		    guitk.BCSpacerCreate(p)
		    guitk.BCSetUserDataKey(wizard, "TYPE_BUTTON_GROUP", group)
		    return p
		
		
		def wizardCreateThirdPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(p, "Please select a color that fills the shape.")
		    lview = guitk.BCListViewCreate(p, 2, ["Color", "Hex code"], 1)
		    lViewAddColor(lview, "Red", "#FF0000")
		    lViewAddColor(lview, "Green", "#00FF00")
		    lViewAddColor(lview, "Blue", "#0000FF")
		    lViewAddColor(lview, "Black", "#000000")
		    lViewAddColor(lview, "White", "#FFFFFF")
		    lViewAddColor(lview, "Orange", "#FFA500")
		    guitk.BCSetUserDataKey(wizard, "COLOR_LIST_VIEW", lview)
		    guitk.BCListViewSetSelectionChangedFunction(
		        lview, ColorsListViewSelectionChanged, wizard
		    )
		    guitk.BCListViewSetDoubleClickedFunction(lview, ColorsListViewDoubleClicked, wizard)
		    return p
		
		
		def lViewAddColor(lview, name, hexCode):
		    item = guitk.BCListViewAddTopLevelItem(lview)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, hexCode)
		    return item
		
		
		def ColorsListViewSelectionChanged(lview, wizard):
		    selected = guitk.BCListViewGetSelectedItem(lview)
		    # make color selection mandatory
		    if selected:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		    else:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    # make color selection mandatory
		    if selected:
		        if guitk.BCListViewItemGetText(selected, 0) == "Black":
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "Colors for perimeter and body shape are the same.",
		                guitk.constants.BCWidgetStateWarning,
		            )
		        else:
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "The perimeter will be drawn using black color.",
		                guitk.constants.BCWidgetStateInformation,
		            )
		    else:
		        guitk.BCWizardClearPageInfo(wizard, 2)
		    return 0
		
		
		def ColorsListViewDoubleClicked(lview, item, col, wizard):
		    if item:
		        guitk.BCWizardGoToNextPage(wizard)
		    return 0
		
		
		def wizardCreateForthPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    grid = guitk.BCGridLayoutCreate(p, 6, 3)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid, guitk.BCLabelCreate(p, "You selected to create a "), 0, 0, 0, 2, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Type:"), 1, 0, 0)
		    type = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, type, 1, 1, 0)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(p, "Perimeter color:"), 2, 0, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "<b>Black</b>"), 2, 1, 0)
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Body color:"), 3, 0, 0)
		    color = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, color, 3, 1, 0)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid,
		        guitk.BCLabelCreate(p, "Please <b>click Finish</b> to create the shape."),
		        5,
		        5,
		        0,
		        2,
		        0,
		    )
		    guitk.BCGridLayoutSetRowStretch(grid, 4, 1)
		    guitk.BCGridLayoutSetColStretch(grid, 2, 1)
		    guitk.BCSetUserDataKey(wizard, "TYPE_LABEL", type)
		    guitk.BCSetUserDataKey(wizard, "COLOR_LABEL", color)
		    return p
		
		
		def wizardCurrentPageChanged(wizard, oldIndex, newIndex, data):
		    if newIndex == 2:
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        if guitk.BCListViewGetSelectedItem(lview):
		            guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		        else:
		            guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    elif newIndex == 3:
		        group = guitk.BCGetUserDataKey(wizard, "TYPE_BUTTON_GROUP")
		        type = guitk.BCGetUserDataKey(wizard, "TYPE_LABEL")
		        typestr = (
		            "<b>" + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(group)) + "</b>"
		        )
		        guitk.BCLabelSetText(type, typestr)
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        color = guitk.BCGetUserDataKey(wizard, "COLOR_LABEL")
		        colorstr = (
		            "<b>"
		            + guitk.BCListViewItemGetText(guitk.BCListViewGetSelectedItem(lview), 0)
		            + "</b>"
		        )
		        guitk.BCLabelSetText(color, colorstr)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetItemsExpanded(lv: object, expand: bool) -> None:

	"""

	Expands or collapses all ListViewItems, depending on the value of expand.
	Optimizes performance and eliminates flicker compared with expanding items one by one.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	expand : bool
		set 1 to expand or 0 to collapse items.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetExpanded

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Tree", guitk.constants.BCOnExitDestroy
		    )
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], False)
		    # create group A
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 1, "Group A31")
		    addPart(groupA, "Bumper", "A31_1001", "8")
		    addPart(groupA, "Decklid", "A31_1002", "12")
		    # create group B
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 1, "Group B12")
		    addPart(groupB, "Roof rack", "B12_1004", "6")
		    addPart(groupB, "Spoiler", "B12_1005", "2")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(treeView, 0, True)
		    # item expand/collapse controllers display only at first column ('Part name' in this case)
		    guitk.BCListViewSetRootIsDecorated(treeView, True)
		    guitk.BCListViewSetItemsExpanded(treeView, True)
		    guitk.BCListViewMoveColumn(treeView, 1, 0)
		    guitk.BCShow(window)
		
		
		def addPart(parentItem, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetInfo(item: object, col: int, text: str) -> None:

	"""

	Function is obsolete. Use BCListViewItemSetPlaceholderText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	col : int
		the column index.

	text : str
		the message to be displayed.

	Returns
	-------
	None

	"""

def BCResetForegroundColor(w: object) -> None:

	"""

	Resets the foreground color of widget w to the values defined by the current style.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose foreground color will be reset.

	Returns
	-------
	None

	See Also
	--------
	BCSetForegroundColor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate(
		        "Common properties example", guitk.constants.BCOnExitDestroy
		    )
		
		    button1 = guitk.BCPushButtonCreate(w, "Disable", disableFunc, None)
		    guitk.BCAddToolTip(button1, "Disable the button widget")
		    button2 = guitk.BCPushButtonCreate(w, "Hide", hideFunc, None)
		    guitk.BCAddToolTip(button2, "Hide the button widget")
		    button3 = guitk.BCPushButtonCreate(w, "Hide later", hideLaterFunc, None)
		    guitk.BCAddToolTip(
		        button3, "Hide the button widget 1 second after the button press"
		    )
		    button4 = guitk.BCPushButtonCreate(w, "Foreground", foregroundFunc, None)
		    guitk.BCAddToolTip(button4, "Change the foreground color of the button widget")
		    button5 = guitk.BCPushButtonCreate(
		        w, "Reset Foreground", resetForegroundFunc, button4
		    )
		    guitk.BCAddToolTip(button5, "Change the foreground color of the button widget")
		    button6 = guitk.BCPushButtonCreate(w, "Background", backgroundFunc, None)
		    guitk.BCAddToolTip(button6, "Change the background color of the button widget")
		
		    guitk.BCShow(w)
		
		
		def disableFunc(b, data):
		    guitk.BCSetEnabled(b, False)
		    return 0
		
		
		def hideFunc(b, data):
		    guitk.BCSetVisible(b, False)
		    return 0
		
		
		def hideLaterFunc(b, data):
		    guitk.BCHideLater(b, 1000)
		    return 0
		
		
		def foregroundFunc(b, data):
		    guitk.BCSetForegroundColor(b, 255, 0, 0)
		    return 0
		
		
		def resetForegroundFunc(b, w):
		    guitk.BCResetForegroundColor(w)
		    return 0
		
		
		def backgroundFunc(b, data):
		    guitk.BCSetBackgroundColor(b, 255, 0, 0)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHeaderSetTextVerticalOrientationEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Set whether list header at column col draws text in vertical orientation (default horizontal).
	
	Text is drawn vertically from bottom to top (rotated by -90). Icon is positioned below text without to be rotated. 
	Vertical header has a maximum height 3 times bigger than the regular horizontal orienation header.
	If text does not fit the maximum height, it is drawn truncated (...) and a tooltip for whole text is 
	provided (if no user tooltip).
	Header text vertical orientation turns ListViews really compact when header text is long and items content is short, 
	for example checkboxes, icons only or short text
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	col : int
		the column index.

	enable : bool
		set 1 to draw text vertical or 0 otherwise (default).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large", "2")
		    addPart(listView, "1002", "Decklid", "Large", "1")
		    addPart(listView, "1003", "Pillar", "Medium", "3")
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    guitk.BCListViewHeaderMenuSetCopyEnabled(listView, 0, False)
		    guitk.BCListViewHeaderMenuSetAboutToShowFunction(
		        listView, customizePopupMenuFunct, None
		    )
		    checkBox = guitk.BCCheckBoxCreate(
		        window, "Change Header's Text orientation to Vertical"
		    )
		    guitk.BCCheckBoxSetToggledFunction(checkBox, changeOrientationFunct, listView)
		    cBoxVisible = guitk.BCCheckBoxCreate(window, "Hide Header")
		    guitk.BCCheckBoxSetToggledFunction(cBoxVisible, setVisibleFunct, listView)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    return item
		
		
		def setVisibleFunct(cb, state, listView):
		    guitk.BCListViewHeaderSetVisible(listView, not state)
		    return 0
		
		
		def changeOrientationFunct(checkBox, state, listView):
		    cols = guitk.BCListViewColumns(listView)
		    for i in range(cols):
		        guitk.BCListViewHeaderSetTextVerticalOrientationEnabled(listView, i, state)
		    return 0
		
		
		def customizePopupMenuFunct(listView, popup, col, data):
		    guitk.BCPopupMenuInsertItem(popup, "Popup Menu Item", None, None)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMessageCreate(p: object, a: int=guitk.constants.BCOnExitHide) -> object:

	"""

	Function is obsolete. Use BCAnimationMessageCreate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	a : int, optional
		describes what will happen to the widget when closed (cleared with [x]). See BCEnumExitAction for details.
		
		guitk.constants BCEnumExitAction
		This enum type defines what will happen to the window when its filter returns 1 (i.e. on
		exit). Exit action is used with BCWindowCreate for example.
		 - guitk.constants.BCOnExitHide
		hides the window.
		
		WARNING: var BCOnExitHide take no action when script ends.After script ends the window destroyed with var BCOnExitDestroy.
		var BCOnExitHide has action only if script not ends.
		
		WARNING: Take special care when you use this enumerator.
		You should destroy the window yourself in order to free the memory it holds.
		 - guitk.constants.BCOnExitDestroy
		destroys the window.

	Returns
	-------
	object
		The created message container.

	"""

def BCPopupMessageShowText(popupMsg: object, text: str) -> None:

	"""

	Function is obsolete. Use BCAnimationMessageShowText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	popupMsg : object
		the animation message.

	text : str
		the short piece of text to be displayed.

	Returns
	-------
	None

	"""

def BCPopupMessageShowTextTimeout(popupMsg: object, text: str, ms: int) -> None:

	"""

	Function is obsolete. Use BCAnimationMessageShowTextTimeout() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	popupMsg : object
		the animation message.

	text : str
		the short piece of text to be displayed.

	ms : int
		the number of milliseconds after which the message will be cleared.

	Returns
	-------
	None

	"""

def BCPopupMessageClear(popupMsg: object) -> None:

	"""

	Function is obsolete. Use BCAnimationMessageClear() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	popupMsg : object
		the animation message.

	Returns
	-------
	None

	"""

def BCPopupMessageSetWidget(popupMsg: object, w: object=None) -> None:

	"""

	Function is obsolete. Use BCAnimationMessageSetWidget() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	popupMsg : object
		the animation message.

	w : object, optional
		the widget.

	Returns
	-------
	None

	"""

def BCPopupMessageSetAlignment(popupMsg: object, align: int) -> None:

	"""

	Function is obsolete. Use BCAnimationMessageSetAlignment() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	popupMsg : object
		the animation message.

	align : int
		BCAlignLeft or BCAlignRight is only enabled.

	Returns
	-------
	None

	"""

def BCPopupMessageSetClosable(popupMsg: object, closable: bool) -> None:

	"""

	Function is obsolete. Use BCAnimationMessageSetClosable() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	popupMsg : object
		the animation message.

	closable : bool
		set 0 to hide the button or 1 to show it (default).

	Returns
	-------
	None

	"""

def BCWidgetExpandGetWidget(wex: object) -> object:

	"""

	Get the widget managed by wex.
	This function is not supported under VR mode.

	Parameters
	----------
	wex : object
		the WidgetExpand.

	Returns
	-------
	object
		the widget managed by wex.

	See Also
	--------
	BCWidgetExpandSetWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Widget Expand Switch", guitk.constants.BCOnExitDestroy
		    )
		    widgetExpand = guitk.BCWidgetExpandCreate(window)
		    # Create a list view and add it to widgetExpand
		    listView = guitk.BCListViewCreate(
		        widgetExpand, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCWidgetExpandSetWidget(widgetExpand, listView)
		    # Create a table also but hide it
		    table = guitk.BCTableCreate(widgetExpand, 4, 4)
		    for col in range(4):
		        guitk.BCTableSetColumnAcceptsText(table, col, True)
		        for row in range(4):
		            guitk.BCTableSetText(
		                table, row, col, guitk.BCListViewGetText(listView, row, col)
		            )
		    guitk.BCHide(table)
		
		    btnSwitch = guitk.BCPushButtonCreate(window, "ListView", None, None)
		    guitk.BCButtonSetToggleButton(btnSwitch, True)
		    guitk.BCButtonSetToggledFunction(
		        btnSwitch, switchWidget, (widgetExpand, listView, table)
		    )
		    guitk.BCWindowSetInitSize(window, 200, 300)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def addPart(listView, id, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, id)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    return item
		
		
		def switchWidget(b, state, data):
		    widgetExpand, listView, table = data
		    curWidget = guitk.BCWidgetExpandGetWidget(widgetExpand)
		    guitk.BCWidgetExpandClear(widgetExpand)
		    guitk.BCHide(curWidget)
		    guitk.BCButtonSetText(b, "Table" if state else "ListView")
		    guitk.BCWidgetExpandSetWidget(widgetExpand, table if state else listView)
		    guitk.BCShow(table if state else listView)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewHasSelected(lv: object) -> bool:

	"""

	Returns False if ListView lv has no item selected, or True otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	bool
		False if ListView has no item selected; True otherwise.

	See Also
	--------
	BCListViewCountSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SetColumn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Name", "Quantity", "Price"], False
		    )
		    guitk.BCSetUserDataKey(listView, "lastID", 0)
		    for i in range(20):
		        addEmptyItem(listView)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    hBox = guitk.BCHBoxCreate(window)
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "New selected item's text.")
		    btn = guitk.BCPushButtonCreate(hBox, "Set Column", None, None)
		    menu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCPopupMenuInsertItem(menu, "Name", None, None)  # id 0 -> col 1
		    guitk.BCPopupMenuInsertItem(menu, "Quantity", None, None)  # id 1 -> col 2
		    guitk.BCPopupMenuInsertItem(menu, "Price", None, None)  # id 2 -> col 3
		    guitk.BCButtonSetPopup(btn, menu)
		    multipleChkBox = guitk.BCCheckBoxCreate(
		        window, "ListView Multiple Rename For column 'Name'"
		    )
		    guitk.BCCheckBoxSetChecked(
		        multipleChkBox, guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		    )
		    guitk.BCCheckBoxSetToggledFunction(multipleChkBox, toggleMulRename, listView)
		    guitk.BCPopupMenuSetActivatedFunction(menu, pmActivated, (lineEdit, listView))
		    guitk.BCShow(window)
		
		
		def addEmptyItem(listView):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    itemId = guitk.BCGetUserDataKey(listView, "lastID") + 1
		    guitk.BCSetUserDataKey(listView, "lastID", itemId)
		    guitk.BCListViewItemSetText(item, 0, str(itemId))
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def pmActivated(menu, id, data):
		    lineEdit, listView = data
		    if guitk.BCListViewHasSelected(listView) and guitk.BCLineEditHasText(lineEdit):
		        col = id + 1
		        if col == 1:
		            name = guitk.BCLineEditGetText(lineEdit)
		            guitk.BCListViewSelectedSetColumnText(listView, col, name)
		        elif col == 2:
		            quantity = guitk.BCLineEditGetInt(lineEdit)
		            if quantity == guitk.constants.blank:
		                quantity = 0
		            guitk.BCListViewSelectedSetColumnInt(listView, col, quantity)
		        elif col == 3:
		            price = guitk.BCLineEditGetDouble(lineEdit)
		            if price == guitk.constants.blank:
		                price = 0
		            guitk.BCListViewSelectedSetColumnDouble(listView, col, price)
		        guitk.BCListViewAdjustColumn(listView, col)
		    else:
		        print("Select item/s and insert value to the LineEdit first")
		    return 0
		
		
		def toggleMulRename(chkBox, state, listView):
		    guitk.BCListViewSetMultipleItemsRenameEnabled(listView, 1, state)
		    print(
		        "MultipleItemsRename for column=1 set to {}".format(
		            guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetCurrentItemExecuteActivatedCallBack(box: object, index: int) -> None:

	"""

	Sets the current item of the BCComboBox to be the item with index index plus calls the activated function, if any.
	NOTE: This function is meant to be used by non-editable BCComboBoxes.

	Parameters
	----------
	box : object
		the BCComboBox.

	index : int
		the index of the item to which current will be set.

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Activated Example", guitk.constants.BCOnExitDestroy
		    )
		
		    cmb1 = guitk.BCComboBoxCreate(window, ["Option 1", "Option 2", "Option 3"])
		    guitk.BCComboBoxSetEditable(cmb1, True)
		    guitk.BCComboBoxSetActivatedTextFunction(cmb1, cmbActivatedText, None)
		    guitk.BCComboBoxSetCurrentItem(cmb1, 1)
		
		    cmb2 = guitk.BCComboBoxCreate(window, ["Item 1", "Item 2", "Item 3"])
		    guitk.BCComboBoxSetActivatedFunction(cmb2, cmb2Activated, None)
		    guitk.BCComboBoxSetCurrentItemExecuteActivatedCallBack(cmb2, 2)
		
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def cmbActivatedText(combo, text, data):
		    print("cmb1: ActivatedText triggered: CurrentText=" + text)
		    return 0
		
		
		def cmb2Activated(combo, index, data):
		    print(
		        "cmb2: Activated triggered: CurrentText=" + guitk.BCComboBoxCurrentText(combo)
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxSetCurrentItemExecuteActivatedCallBack(item: object, col: int, index: int) -> None:

	"""

	Sets the current item of the comboBox found at column col of ListViewItem item to be the item with index index plus executes the activated function (if any).
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column where comboBox is found.

	index : int
		the index of the item to which current will be set.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxSetCurrentItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Item Widgets", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Completed"], 0
		    )
		    item1 = addPart(listView, "1001", "Bumper")
		    guitk.BCListViewItemCheckBoxSetChecked(item1, 3, True)
		    item2 = addPart(listView, "1002", "Decklid")
		    # This will not trigger the ComboBox callback
		    guitk.BCListViewItemComboBoxSetCurrentItem(item2, 2, 1)
		    item3 = addPart(listView, "1003", "Pillar")
		    item4 = addPart(listView, "1004", "Roof rack")
		    guitk.BCListViewItemCheckBoxSetChecked(item4, 3, True)
		    # This will trigger the ComboBox callback:
		    guitk.BCListViewItemComboBoxSetCurrentItemExecuteActivatedCallBack(item4, 2, 2)
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name):
		    users = ["Alexander", "David", "George", "Sarah"]
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(item, 2, users, AssigneeChanged, None)
		    guitk.BCListViewItemSetCheckBox(item, 3, False, CompletedChanged, None)
		    return item
		
		
		def AssigneeChanged(item, col, index, data):
		    print("Assignee Changed!")
		    # UpdateDataOnAssigneeChanged()
		    return 0
		
		
		def CompletedChanged(item, col, state, data):
		    print("Completed Changed!")
		    # UpdateDataOnCompletedChanged()
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCRepaint(w: object) -> None:

	"""

	Repaints the widget immediately.
	In all cases widgets get paint correct when you set a value to them. 
	This function is useful in the case you un-block widget updates with BCSetUpdatesEnabled().
	Is also useful when you want to force a widget paint (for example a Label text change) inside a loop.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget to be repainted.

	Returns
	-------
	None

	See Also
	--------
	BCSetUpdatesEnabled

	"""

def BCBlockCallBackFunctions(w: object, block: bool) -> None:

	"""

	Stops executing all user call back functions of widget w.
	NOTE: BCListViewItemSetAboutToDestroyFunction() cannot be blocked.
	The supported widgets are:
	ButtonGroup
	CheckBox
	ComboBox
	DateEdit
	DoubleSpinBox
	IconView
	LineEdit
	ListView (also applied at ListViewItem, ListViewItemWidget and ListViewFilter)
	PushButton
	SpinBox
	TextEdit
	ToolButton

	Parameters
	----------
	w : object
		the widget to block its user call backs functions.

	block : bool
		True to block all call back functions of Widget or False to un-block (default).

	Returns
	-------
	None

	See Also
	--------
	BCCallBackFunctionsBlocked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Destroy Selected", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    menu = guitk.BCPopupMenuCreate(listView)
		    guitk.BCPopupMenuInsertItem(menu, "Delete", DeleteSelectedItems, listView)
		    guitk.BCPopupMenuInsertSeparator(menu)
		    guitk.BCPopupMenuInsertItem(menu, "Update", None, None)
		    guitk.BCListViewSetMousePressedFunction(listView, ListViewMousePressed, menu)
		    guitk.BCShow(window)
		
		
		def DeleteSelectedItems(menu, id, listView):
		    # standard deletion with a single function as below
		    # guitk.BCListViewSelectedRemove(listView)
		    # or custom deletion with iteration
		    items = list()
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateSelected, GatherSelectedItems, items
		    )
		    # silent mode (for example the selection change call back, if any, will not be triggerred)
		    guitk.BCBlockCallBackFunctions(listView, 1)
		    for item in items:
		        guitk.BCListViewItemDestroy(item)
		    guitk.BCBlockCallBackFunctions(listView, 0)
		
		
		def GatherSelectedItems(item, items):
		    items.append(item)
		    return 0
		
		
		def ListViewMousePressed(listView, button, item, col, menu):
		    # do not popup on mouse button left or middle buttons
		    if button is not guitk.constants.BCRightButton:
		        return 0
		    # do not popup when press on empty viewport space
		    if not item:
		        return 0
		    guitk.BCPopupMenuPopup(menu)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCCallBackFunctionsBlocked(w: object) -> bool:

	"""

	Returns True if callback functions of Widget w are blocked, False otherwise (default).
	The supported widgets are:
	ButtonGroup
	CheckBox
	ComboBox
	DateEdit
	DoubleSpinBox
	IconView
	LineEdit
	ListView (also applied at ListViewItem, ListViewItemWidget and ListViewFilter)
	PushButton
	SpinBox
	TextEdit
	ToolButton
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose functions checked whether are blocked.

	Returns
	-------
	bool
		True if call back functions are blocked, False otherwise.

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter Widget Sizes Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Set Sizes", guitk.constants.BCHorizontal
		    )
		    guitk.BCLabelCreate(
		        window,
		        "Try using either the arrows or the mouse wheel to change the SpinBoxes.",
		    )
		    myFrameCreate(splitter, "Frame A")
		    myFrameCreate(splitter, "Frame B")
		    myFrameCreate(splitter, "Frame C")
		    guitk.BCButtonGroupSetExclusive(btnGroup, False)
		    spinBoxes = [None] * 3
		    for i in range(len(spinBoxes)):
		        spinBoxes[i] = sizeSpinBoxCreate(btnGroup)
		        guitk.BCSpinBoxSetValueChangedFunction(
		            spinBoxes[i], setNewSizes, (splitter, spinBoxes, i)
		        )
		    guitk.BCSplitterSetSplitterMovedFunction(splitter, updateSpinBoxes, spinBoxes)
		    guitk.BCTimerSingleShot(0, lambda data: updateSpinBoxes(splitter, spinBoxes), None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def myFrameCreate(splitter, labelText):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    label = guitk.BCLabelCreate(bLayout, labelText)
		    guitk.BCLabelSetAlignment(label, guitk.constants.BCAlignCenter)
		
		
		def sizeSpinBoxCreate(btnGroup):
		    spinBox = guitk.BCSpinBoxCreate(btnGroup)
		    guitk.BCSpinBoxSetMinValue(spinBox, 85)
		    guitk.BCSpinBoxSetMaxValue(spinBox, 10000)
		    guitk.BCSpinBoxSetLineStep(spinBox, 10)
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBox, True)
		    return spinBox
		
		
		def setNewSizes(sb, val, data):
		    splitter, spinBoxes, i = data
		    sizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    sizes[i] = val
		    guitk.BCSplitterSetWidgetSizes(splitter, sizes)
		    guitk.BCTimerSingleShot(
		        500, lambda data: updateSpinBoxes(splitter, spinBoxes), None
		    )
		    return 0
		
		
		def updateSpinBoxes(splitter, spinBoxes):
		    newSizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    for i, size in enumerate(newSizes):
		        # Check in case you want to block Callback functions on a higher level in your code.
		        alreadyBlocked = guitk.BCCallBackFunctionsBlocked(spinBoxes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], True)
		        guitk.BCSpinBoxSetValue(spinBoxes[i], newSizes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetTextChangeFunction(lip: object, funct: Callable, data: Any=None) -> None:

	"""

	Convenient function that sets function funct to be called when the current text of BCLineEditPath lip is changed.
	Alternatively, in order to set a text-changed function, you should do the following steps:

	- Get the BCComboBox from lip using BCLineEditPathGetCombo()
	- Get the BCLineEdit from BCComboBox using BCComboBoxGetLineEdit()
	- Set the callback function using BCLineEdit's function BCLineEditSetTextChangeFunction()
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath

	funct : Callable
		the function to be called. See BC_LINEEDIT_TEXT_CHANGED_FUNCTION for details.
		integer BC_LINEEDIT_TEXT_CHANGED_FUNCTION(le, text, data)
		The function to be called when the text changes in the BCLineEdit.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * text : str
		                    the current text in the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File, Filter Example")
		    guitk.BCLineEditPathSetTextChangeFunction(
		        lineEditPath, pathSetTextChangeFunction, None
		    )
		
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayoutBtns, "Default file type filters are set.")
		    data = [lineEditPath, label]
		    btnClearFilter = guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "",
		        "Clear file type filters [Default]",
		        clearFilterFunction,
		        data,
		    )
		    btnSetFilter = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Add some file type filters", setFilterFunction, data
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFilterFunction(tb, data):
		    guitk.BCLineEditPathClearFilter(data[0])
		    guitk.BCLabelSetText(data[1], "No file type filters [Default].")
		    return 0
		
		
		def setFilterFunction(tb, data):
		    guitk.BCLineEditPathSetFilter(
		        data[0],
		        "Script files (*.bs *.c);;Python files (*.py);;CPP (*.cpp);;All files (*)",
		    )
		    guitk.BCLabelSetText(data[1], "Custom file type filters added.")
		    return 0
		
		
		def pathSetTextChangeFunction(le, text, data):
		    print("LineEdit text changed to: " + str(text))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathSetFilter(lip: object, filter: str) -> None:

	"""

	Set the filters on the popup FileDialog
	  *
	  *
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath
		  *

	filter : str
		the file filters that will be used in file dialog.
		  * WARNING: Use only the following format: "label1 (*.extension1 *.extension2 ...);;label2 (*.extension1 *.extension2 ...);;...".
		  * e.g. "Script files (*.bs *.c);;Python files (*.py);;All files (*)
		  *

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathAddFilter

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File, Filter Example")
		    guitk.BCLineEditPathSetTextChangeFunction(
		        lineEditPath, pathSetTextChangeFunction, None
		    )
		
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayoutBtns, "Default file type filters are set.")
		    data = [lineEditPath, label]
		    btnClearFilter = guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "",
		        "Clear file type filters [Default]",
		        clearFilterFunction,
		        data,
		    )
		    btnSetFilter = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Add some file type filters", setFilterFunction, data
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFilterFunction(tb, data):
		    guitk.BCLineEditPathClearFilter(data[0])
		    guitk.BCLabelSetText(data[1], "No file type filters [Default].")
		    return 0
		
		
		def setFilterFunction(tb, data):
		    guitk.BCLineEditPathSetFilter(
		        data[0],
		        "Script files (*.bs *.c);;Python files (*.py);;CPP (*.cpp);;All files (*)",
		    )
		    guitk.BCLabelSetText(data[1], "Custom file type filters added.")
		    return 0
		
		
		def pathSetTextChangeFunction(le, text, data):
		    print("LineEdit text changed to: " + str(text))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditPathClearFilter(lip: object) -> None:

	"""

	Clears the filter (if any) of the filedialog of BCLineEditPath lip
	The filter of the filedialog reverts back to its default, this is "All files (*)"
	This function is not supported under VR mode.

	Parameters
	----------
	lip : object
		the BCLineEditPath

	Returns
	-------
	None

	See Also
	--------
	BCLineEditPathAddFilter

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example LineEditPath", guitk.constants.BCOnExitDestroy
		    )
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(boxLayout, "LineEdit Path")
		    lineEditPath = guitk.BCLineEditPathCreate(
		        boxLayout,
		        guitk.constants.BCHistoryAnything,
		        "",
		        guitk.constants.BCHistoryOpen,
		        "LineEditPath_Example",
		    )
		    guitk.BCLineEditPathSetSelectionMode(lineEditPath, guitk.constants.BCMulti)
		    guitk.BCLineEditPathSetFileDialogTitle(lineEditPath, "Select File, Filter Example")
		    guitk.BCLineEditPathSetTextChangeFunction(
		        lineEditPath, pathSetTextChangeFunction, None
		    )
		
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayoutBtns, "Default file type filters are set.")
		    data = [lineEditPath, label]
		    btnClearFilter = guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "",
		        "Clear file type filters [Default]",
		        clearFilterFunction,
		        data,
		    )
		    btnSetFilter = guitk.BCToolButtonCreate(
		        boxLayoutBtns, "", "Add some file type filters", setFilterFunction, data
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFilterFunction(tb, data):
		    guitk.BCLineEditPathClearFilter(data[0])
		    guitk.BCLabelSetText(data[1], "No file type filters [Default].")
		    return 0
		
		
		def setFilterFunction(tb, data):
		    guitk.BCLineEditPathSetFilter(
		        data[0],
		        "Script files (*.bs *.c);;Python files (*.py);;CPP (*.cpp);;All files (*)",
		    )
		    guitk.BCLabelSetText(data[1], "Custom file type filters added.")
		    return 0
		
		
		def pathSetTextChangeFunction(le, text, data):
		    print("LineEdit text changed to: " + str(text))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDateEditCreate(p: object) -> object:

	"""

	Creates a BCDateEdit. This is a field which accepts only dates.
	On the right side of the widget there is an arrow which pops up a calendar for selecting the date.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created BCDateEdit.

	See Also
	--------
	

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example DateEdit", guitk.constants.BCOnExitDestroy)
		    datelayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(datelayout, "DateEdit")
		    dateedit = guitk.BCDateEditCreate(datelayout)
		    guitk.BCDateEditSetDateYMD(dateedit, 2020, 1, 1)
		
		    btnLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCPushButtonCreate(btnLayout, "Year", getYearFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Month", getMonthFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Day", getDayFunction, dateedit)
		    guitk.BCSpacerCreate(datelayout)
		    guitk.BCSpacerCreate(btnLayout)
		    guitk.BCSpacerCreate(window)
		    guitk.BCShow(window)
		
		
		def getYearFunction(b, dateedit):
		    print("Year: " + str(guitk.BCDateEditGetYear(dateedit)))
		    return 0
		
		
		def getMonthFunction(b, dateedit):
		    print("Month: " + str(guitk.BCDateEditGetMonth(dateedit)))
		    return 0
		
		
		def getDayFunction(b, dateedit):
		    print("Day: " + str(guitk.BCDateEditGetDay(dateedit)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDateEditGetDay(dtEdit: object) -> int:

	"""

	Returns the content's day of BCDateEdit dtEdit
	This function is not supported under VR mode.

	Parameters
	----------
	dtEdit : object
		the BCDateEdit.

	Returns
	-------
	int
		the content's day of BCDateEdit dtEdit

	See Also
	--------
	BCDateEditGetMonth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example DateEdit", guitk.constants.BCOnExitDestroy)
		    datelayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(datelayout, "DateEdit")
		    dateedit = guitk.BCDateEditCreate(datelayout)
		    guitk.BCDateEditSetDateYMD(dateedit, 2020, 1, 1)
		
		    btnLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCPushButtonCreate(btnLayout, "Year", getYearFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Month", getMonthFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Day", getDayFunction, dateedit)
		    guitk.BCSpacerCreate(datelayout)
		    guitk.BCSpacerCreate(btnLayout)
		    guitk.BCSpacerCreate(window)
		    guitk.BCShow(window)
		
		
		def getYearFunction(b, dateedit):
		    print("Year: " + str(guitk.BCDateEditGetYear(dateedit)))
		    return 0
		
		
		def getMonthFunction(b, dateedit):
		    print("Month: " + str(guitk.BCDateEditGetMonth(dateedit)))
		    return 0
		
		
		def getDayFunction(b, dateedit):
		    print("Day: " + str(guitk.BCDateEditGetDay(dateedit)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDateEditGetMonth(dtEdit: object) -> int:

	"""

	Returns the content's month of BCDateEdit dtEdit
	This function is not supported under VR mode.

	Parameters
	----------
	dtEdit : object
		the BCDateEdit.

	Returns
	-------
	int
		the content's month of BCDateEdit dtEdit

	See Also
	--------
	BCDateEditGetDay

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example DateEdit", guitk.constants.BCOnExitDestroy)
		    datelayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(datelayout, "DateEdit")
		    dateedit = guitk.BCDateEditCreate(datelayout)
		    guitk.BCDateEditSetDateYMD(dateedit, 2020, 1, 1)
		
		    btnLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCPushButtonCreate(btnLayout, "Year", getYearFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Month", getMonthFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Day", getDayFunction, dateedit)
		    guitk.BCSpacerCreate(datelayout)
		    guitk.BCSpacerCreate(btnLayout)
		    guitk.BCSpacerCreate(window)
		    guitk.BCShow(window)
		
		
		def getYearFunction(b, dateedit):
		    print("Year: " + str(guitk.BCDateEditGetYear(dateedit)))
		    return 0
		
		
		def getMonthFunction(b, dateedit):
		    print("Month: " + str(guitk.BCDateEditGetMonth(dateedit)))
		    return 0
		
		
		def getDayFunction(b, dateedit):
		    print("Day: " + str(guitk.BCDateEditGetDay(dateedit)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDateEditGetYear(dtEdit: object) -> int:

	"""

	Returns the content's year of BCDateEdit dtEdit
	This function is not supported under VR mode.

	Parameters
	----------
	dtEdit : object
		the BCDateEdit.

	Returns
	-------
	int
		the content's year of BCDateEdit dtEdit

	See Also
	--------
	BCDateEditGetDay

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example DateEdit", guitk.constants.BCOnExitDestroy)
		    datelayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(datelayout, "DateEdit")
		    dateedit = guitk.BCDateEditCreate(datelayout)
		    guitk.BCDateEditSetDateYMD(dateedit, 2020, 1, 1)
		
		    btnLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCPushButtonCreate(btnLayout, "Year", getYearFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Month", getMonthFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Day", getDayFunction, dateedit)
		    guitk.BCSpacerCreate(datelayout)
		    guitk.BCSpacerCreate(btnLayout)
		    guitk.BCSpacerCreate(window)
		    guitk.BCShow(window)
		
		
		def getYearFunction(b, dateedit):
		    print("Year: " + str(guitk.BCDateEditGetYear(dateedit)))
		    return 0
		
		
		def getMonthFunction(b, dateedit):
		    print("Month: " + str(guitk.BCDateEditGetMonth(dateedit)))
		    return 0
		
		
		def getDayFunction(b, dateedit):
		    print("Day: " + str(guitk.BCDateEditGetDay(dateedit)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDateEditSetDateYMD(dtEdit: object, year: int, month: int, day: int) -> None:

	"""

	Sets the day, month and year to the content of BCDateEdit dtEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	dtEdit : object
		the BCDateEdit.

	year : int
		the day of the date

	month : int
		the day of the date

	day : int
		the day of the date

	Returns
	-------
	None

	See Also
	--------
	BCDateEditGetYear

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example DateEdit", guitk.constants.BCOnExitDestroy)
		    datelayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(datelayout, "DateEdit")
		    dateedit = guitk.BCDateEditCreate(datelayout)
		    guitk.BCDateEditSetDateYMD(dateedit, 2020, 1, 1)
		
		    btnLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCPushButtonCreate(btnLayout, "Year", getYearFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Month", getMonthFunction, dateedit)
		    guitk.BCPushButtonCreate(btnLayout, "Day", getDayFunction, dateedit)
		    guitk.BCSpacerCreate(datelayout)
		    guitk.BCSpacerCreate(btnLayout)
		    guitk.BCSpacerCreate(window)
		    guitk.BCShow(window)
		
		
		def getYearFunction(b, dateedit):
		    print("Year: " + str(guitk.BCDateEditGetYear(dateedit)))
		    return 0
		
		
		def getMonthFunction(b, dateedit):
		    print("Month: " + str(guitk.BCDateEditGetMonth(dateedit)))
		    return 0
		
		
		def getDayFunction(b, dateedit):
		    print("Day: " + str(guitk.BCDateEditGetDay(dateedit)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardGoToNextPage(wiz: object) -> None:

	"""

	Goes to the next wizard wiz page.
	Convenience function for BCWizardSetCurrentPage(wiz, CurrentPage + 1)
	Avoid using programmatical ways to fall through pages when not necessary; 
	let the user decide if and when will continue to next page.
	Wizard will go to next page, even if next button is disabled.
	Continuous sequential calls will not forward wizard to subsequent pages since 
	when (changing page) animation is in progress, the function does nothing.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	Returns
	-------
	None

	See Also
	--------
	BCWizardSetCurrentPage

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard 2D Shapes Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(
		        wizard, wizardCreateFirstPage(wizard), "Introduction", "Create 2D Shapes", ""
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateSecondPage(wizard),
		        "Type",
		        "Select the type of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateThirdPage(wizard),
		        "Color",
		        "Select the color of the shape",
		        "",
		    )
		    guitk.BCWizardAddPage(
		        wizard,
		        wizardCreateForthPage(wizard),
		        "Confirmation",
		        "Shape is about to be created",
		        "",
		    )
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizardCurrentPageChanged, None)
		    guitk.BCShow(wizard)
		
		
		def wizardCreateFirstPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(
		        p, "Design simple geometric two-dimensional shapes<br>in 4 simple steps."
		    )
		    guitk.BCSpacerCreate(p)
		    guitk.BCLabelCreate(p, "Please <b>click Next</b> to continue.")
		    return p
		
		
		def wizardCreateSecondPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    group = guitk.BCButtonGroupCreate(p, "Types", guitk.constants.BCVertical)
		    guitk.BCButtonGroupSetBorderMode(group, guitk.constants.BCNoBorderNoMargin)
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Circle", None, None), 0
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Pentagon", None, None), 1
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Square", None, None), 2
		    )
		    guitk.BCButtonGroupInsert(
		        group, guitk.BCRadioButtonCreate(group, "Triangle", None, None), 3
		    )
		    guitk.BCButtonGroupSetButton(group, 0)
		    guitk.BCSpacerCreate(p)
		    guitk.BCSetUserDataKey(wizard, "TYPE_BUTTON_GROUP", group)
		    return p
		
		
		def wizardCreateThirdPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    guitk.BCBoxLayoutCreate(p, guitk.constants.BCVertical)
		    guitk.BCLabelCreate(p, "Please select a color that fills the shape.")
		    lview = guitk.BCListViewCreate(p, 2, ["Color", "Hex code"], 1)
		    lViewAddColor(lview, "Red", "#FF0000")
		    lViewAddColor(lview, "Green", "#00FF00")
		    lViewAddColor(lview, "Blue", "#0000FF")
		    lViewAddColor(lview, "Black", "#000000")
		    lViewAddColor(lview, "White", "#FFFFFF")
		    lViewAddColor(lview, "Orange", "#FFA500")
		    guitk.BCSetUserDataKey(wizard, "COLOR_LIST_VIEW", lview)
		    guitk.BCListViewSetSelectionChangedFunction(
		        lview, ColorsListViewSelectionChanged, wizard
		    )
		    guitk.BCListViewSetDoubleClickedFunction(lview, ColorsListViewDoubleClicked, wizard)
		    return p
		
		
		def lViewAddColor(lview, name, hexCode):
		    item = guitk.BCListViewAddTopLevelItem(lview)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, hexCode)
		    return item
		
		
		def ColorsListViewSelectionChanged(lview, wizard):
		    selected = guitk.BCListViewGetSelectedItem(lview)
		    # make color selection mandatory
		    if selected:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		    else:
		        guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    # make color selection mandatory
		    if selected:
		        if guitk.BCListViewItemGetText(selected, 0) == "Black":
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "Colors for perimeter and body shape are the same.",
		                guitk.constants.BCWidgetStateWarning,
		            )
		        else:
		            guitk.BCWizardSetPageInfo(
		                wizard,
		                2,
		                "The perimeter will be drawn using black color.",
		                guitk.constants.BCWidgetStateInformation,
		            )
		    else:
		        guitk.BCWizardClearPageInfo(wizard, 2)
		    return 0
		
		
		def ColorsListViewDoubleClicked(lview, item, col, wizard):
		    if item:
		        guitk.BCWizardGoToNextPage(wizard)
		    return 0
		
		
		def wizardCreateForthPage(wizard):
		    p = guitk.BCFrameCreate(wizard)
		    grid = guitk.BCGridLayoutCreate(p, 6, 3)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid, guitk.BCLabelCreate(p, "You selected to create a "), 0, 0, 0, 2, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Type:"), 1, 0, 0)
		    type = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, type, 1, 1, 0)
		    guitk.BCGridLayoutAddWidget(
		        grid, guitk.BCLabelCreate(p, "Perimeter color:"), 2, 0, 0
		    )
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "<b>Black</b>"), 2, 1, 0)
		    guitk.BCGridLayoutAddWidget(grid, guitk.BCLabelCreate(p, "Body color:"), 3, 0, 0)
		    color = guitk.BCLabelCreate(p, "")
		    guitk.BCGridLayoutAddWidget(grid, color, 3, 1, 0)
		    guitk.BCGridLayoutAddMultiCellWidget(
		        grid,
		        guitk.BCLabelCreate(p, "Please <b>click Finish</b> to create the shape."),
		        5,
		        5,
		        0,
		        2,
		        0,
		    )
		    guitk.BCGridLayoutSetRowStretch(grid, 4, 1)
		    guitk.BCGridLayoutSetColStretch(grid, 2, 1)
		    guitk.BCSetUserDataKey(wizard, "TYPE_LABEL", type)
		    guitk.BCSetUserDataKey(wizard, "COLOR_LABEL", color)
		    return p
		
		
		def wizardCurrentPageChanged(wizard, oldIndex, newIndex, data):
		    if newIndex == 2:
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        if guitk.BCListViewGetSelectedItem(lview):
		            guitk.BCWizardSetNextButtonEnabled(wizard, 1)
		        else:
		            guitk.BCWizardSetNextButtonEnabled(wizard, 0)
		    elif newIndex == 3:
		        group = guitk.BCGetUserDataKey(wizard, "TYPE_BUTTON_GROUP")
		        type = guitk.BCGetUserDataKey(wizard, "TYPE_LABEL")
		        typestr = (
		            "<b>" + guitk.BCRadioButtonText(guitk.BCButtonGroupSelected(group)) + "</b>"
		        )
		        guitk.BCLabelSetText(type, typestr)
		        lview = guitk.BCGetUserDataKey(wizard, "COLOR_LIST_VIEW")
		        color = guitk.BCGetUserDataKey(wizard, "COLOR_LABEL")
		        colorstr = (
		            "<b>"
		            + guitk.BCListViewItemGetText(guitk.BCListViewGetSelectedItem(lview), 0)
		            + "</b>"
		        )
		        guitk.BCLabelSetText(color, colorstr)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCApplicationIsGuiMode() -> bool:

	"""

	Informs whether the current Application has started in GUI mode or not.
	This function is not supported under VR mode.

	Returns
	-------
	bool
		True if application has started in GUI mode, False otherwise.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    # Check if application started on GUI mode
		    is_gui = guitk.BCApplicationIsGuiMode()
		    if is_gui:
		        print("Current Application started in GUI mode.")
		    else:
		        print("Current Application started in No-GUI mode.")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetSideButton(item: object, col: int, funct: Callable, data: Any=None) -> None:

	"""

	Sets a tiny push button to be displayed aligned at the right of the cell at item for column col together with other content (text, icon).
	The standard side button displays "..." as text but you can set icon with BCListViewItemSideButtonSetIconFileName().
	
	WARNING: Side button and cell widgets (combo box, push button, check box, progress bar) in the same cell is not supported.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	funct : Callable
		a callback function that will be called every time the button clicked.
		See BC_LISTVIEWITEM_BUTTON_CLICKED_FUNCTION for details.
		integer BC_LISTVIEWITEM_BUTTON_CLICKED_FUNCTION(item, col, data)
		The function to be called everytime the button will be clicked.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column at which the button is found.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemHasSideButton

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example Item Side Button", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "File name"], 0
		    )
		    addPart(listView, "1001", "Bumper", "67", "")
		    addPart(listView, "1002", "Decklid", "4", "")
		    addPart(listView, "1003", "Pillar", "254", "C:/home/pillar.txt")
		    addPart(listView, "1004", "Roof rack", "14", "")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, quantity, fileName):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, fileName)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetSideButton(item, 3, ItemSideButtonClicked, None)
		    return item
		
		
		def ItemSideButtonClicked(item, col, data):
		    f = utils.SelectOpenFile(0, "Part files (*.txt)")
		    if len(f):
		        guitk.BCListViewItemSetText(item, 3, f[0])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSideButtonSetIconFileName(item: object, col: int, fileName: str) -> None:

	"""

	Sets an icon with file name fileName to the side button of item at col.
	Side button cannot display both icon and text.
	Images larger than item height will be scaled down.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the button.

	col : int
		the column index.

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSideButtonSetToolTip

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSideButtonSetToolTip(item: object, col: int, tip: str) -> None:

	"""

	Sets the tooltip (balloon help) for side button item item at column col to the text specified by tip.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the side button.

	col : int
		the column index.

	tip : str
		the text to be displayed at balloon help.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSideButtonSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemHasSideButton(item: object, col: int) -> bool:

	"""

	Returns True if the ListViewItem item cell contains a side button aligned right at given column col, or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	col : int
		the column index.

	Returns
	-------
	bool
		True if the ListViewItem item at column col contains a side button, or False otherwise.

	See Also
	--------
	BCListViewItemSetSideButton

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSideButtonSetVisible(item: object, col: int, visible: bool) -> None:

	"""

	Sets whether the side button at column col will be visible or not depending on the value of visible.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	visible : bool
		set this parameter to 1 for the widget to be visible, or 0 otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSideButtonIsVisible

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSideButtonIsVisible(item: object, col: int) -> bool:

	"""

	Returns whether the side button of item item at column col is visible or not.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		True if the side button is visible, or False otherwise.

	See Also
	--------
	BCListViewItemSideButtonSetVisible

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSideButtonSetEnabled(item: object, col: int, enable: bool) -> None:

	"""

	Sets whether the side button at column col will be enabled or not depending on the value of enable.
	A disabled item widget does not interact with user events. By default, all side buttons are enabled.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	enable : bool
		set 0 for the side button to be disabled, or 1 to enable (default).

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSideButtonIsEnabled

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSideButtonIsEnabled(item: object, col: int) -> bool:

	"""

	Returns whether the side button of item item at column col is enabled or not.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		True if the side button is enabled, or False otherwise.

	See Also
	--------
	BCListViewItemWidgetSetEnabled

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetAboutToRenameItemFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets a function that will be called when renaming of a column of ListViewItem item is about to start.
	You have access to rename editor here (type BCLineEdit).
	If you want to block renaming items use BCListViewItemSetRenameType(item, col, BCRenameType_None) after constructed them.
	If you want to validate the rename data use BCListViewSetAboutToCommitRenameEditorDataFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_ABOUT_TO_RENAME_ITEM_FUNCTION for details.
		integer BC_LISTVIEW_ABOUT_TO_RENAME_ITEM_FUNCTION(lv, item, col, editor, data)
		The function to be called when renaming of an item cell starts.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * editor : object
		                    the LineEdit used as an editor.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 to cancel the rename action, or 0 to proceed.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetQuestionMarkFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Rename Item", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    messenger = guitk.BCAnimationMessageCreate(listView, guitk.constants.BCOnExitHide)
		    guitk.BCListViewSetAboutToRenameItemFunction(
		        listView, DynamicDiscardRenameItem, messenger
		    )
		    guitk.BCListViewSetAboutToCommitRenameEditorDataFunction(
		        listView, DiscardNegativeNumbers, messenger
		    )
		    guitk.BCListViewSetRenameItemFinishedFunction(
		        listView, ShowMessageOnQuantityUpdated, messenger
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def DynamicDiscardRenameItem(listView, item, col, editor, messenger):
		    if (
		        guitk.BCListViewItemGetText(item, 0) == "1003"
		    ):  # scenario: check you data whether item is locked
		        guitk.BCAnimationMessageShowTextTimeout(
		            messenger, "Pillar is locked from another user.", 3000
		        )
		        return 1
		    return 0
		
		
		def DiscardNegativeNumbers(listView, item, col, editor, reason, messenger):
		    # discard empty or negative for numeric columns
		    renameType = guitk.BCListViewItemRenameType(item, col)
		    if renameType in (
		        guitk.constants.BCRenameType_Int,
		        guitk.constants.BCRenameType_Double,
		    ):
		        if not len(guitk.BCLineEditGetText(editor)):
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Empty value discarded.", 3000
		            )
		            return 1  # discard empty
		        value = -1
		        value = (
		            guitk.BCLineEditGetInt(editor)
		            if renameType == guitk.constants.BCRenameType_Int
		            else guitk.BCLineEditGetDouble(editor)
		        )
		        if value < 0:
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Negative value discarded.", 3000
		            )
		            return 1  # discard
		    return 0  # accept
		
		
		def ShowMessageOnQuantityUpdated(listView, item, col, dataCommitted, text, messenger):
		    if col == 2 and dataCommitted:
		        guitk.BCAnimationMessageShowTextTimeout(messenger, "Quantity updated.", 3000)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowSetTextAlignment(messageWindow: object, alignment: int) -> None:

	"""

	Sets the alignment of the text message (default BCAlignCenter).
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	alignment : int
		specifies the alignment of the text message.
		See BCEnumAlignment for details.
		
		guitk.constants BCEnumAlignment
		This enum type is used to describe alignment. It contains horizontal and vertical flags. Alignment is used with BCGridLayoutAddMultiCellWidget for example.
		NOTE: You can use at most one horizontal and one vertical flag at a time.
		 - guitk.constants.BCAlignAuto
		aligns according to the language. Left for most, right for Arabic and Hebrew.
		 - guitk.constants.BCAlignLeft
		aligns with the left edge.
		 - guitk.constants.BCAlignRight
		aligns with the right edge.
		 - guitk.constants.BCAlignHCenter
		centers horizontally in the available space.
		 - guitk.constants.BCAlignJustify
		justifies the text in the available space.
		 - guitk.constants.BCAlignTop
		aligns with the top.
		 - guitk.constants.BCAlignBottom
		aligns with the bottom.
		 - guitk.constants.BCAlignVCenter
		centers vertically in the available space.
		 - guitk.constants.BCAlignCenter
		centers in both dimensions (vertically and horizontally).
		 - guitk.constants.BCAlignHorizontal_Mask
		horizontal mask.
		 - guitk.constants.BCAlignVertical_Mask
		vertical mask.
		 - guitk.constants.BCAlignVJustify
		Justifies the text vertically in the available space.

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    messageWindow = guitk.BCMessageWindowCreate(
		        guitk.constants.BCMessageBoxWarning,
		        "Some <b>errors</b> have been detected.<br>Do you want to proceed?",
		        True,
		    )
		    guitk.BCMessageWindowSetAcceptButtonText(messageWindow, "Yes")
		    guitk.BCMessageWindowSetRejectButtonText(messageWindow, "No")
		    guitk.BCMessageWindowSetTextAlignment(
		        messageWindow, guitk.constants.BCAlignTop | guitk.constants.BCAlignHCenter
		    )
		    answer = guitk.BCMessageWindowExecute(messageWindow)
		    if answer == guitk.constants.BCRetKey:
		        print("Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Quitall")
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetF2Function(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called when F2 key is pressed in the BCLineEdit.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function that will be called. See BC_LINEEDIT_F2_FUNCTION for details.
		integer BC_LINEEDIT_F2_FUNCTION(le, data)
		The function to be called when F2 key is pressed in BCLineEdit le.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly
		but with the use of a timer (BCTimerSingleShot). If you are not sure how to do it, please contact GUI Dept for more details.
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditSetEditingFinishedFunction(le: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called when editing of BCLineEdit le is finished.
	Editing of a BCLineEdit is finished by pressing the Return or Enter key or when le loses focus. If the text
	is unchanged though, funct will not be called!
	NOTE: If BCLineEditSetEnterPressedFunction is set for le and enter is pressed, the enter-pressed-function callback will be called first.
	NOTE: Function funct can be called even if BCLineEdit le is in read only mode.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	funct : Callable
		the function to be called. See BC_LINEEDIT_EDITING_FINISHED_FUNCTION for details.
		integer BC_LINEEDIT_EDITING_FINISHED_FUNCTION(le, data)
		The function to be called when the editing on BCLineEdit le is finished.
		Editing is finished by pressing the Return or Enter key or when le loses focus. If the text is unchanged though, this function will not be called.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * le : object
		                    the BCLineEdit.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetEnterPressedFunction

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "Press Enter Key, Question Mark (?) Key or F1 key"
		    )
		    guitk.BCLineEditSetQuestionMarkFunction(lineEdit, questionMarkEntered, None)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, enterPressed, None)
		    guitk.BCLineEditSetF1Function(lineEdit, f1pressedFunct, None)
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, editingFinishedFunction, None)
		    guitk.BCLineEditSetFixedNumCharWidth(lineEdit, 50)
		    guitk.BCLineEditSetMinimumWidth(lineEdit, guitk.constants.BCSizeSmall)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def editingFinishedFunction(lineEdit, data):
		    print("Enter pressed. editingFinishedFunction() called after.")
		    guitk.BCLineEditSetText(lineEdit, "Editing Finished.")
		    return 0
		
		
		def enterPressed(lineEdit, data):
		    print("Enter pressed. enterPressed() called first.")
		    guitk.BCLineEditSetText(lineEdit, "Enter Pressed.")
		    return 0
		
		
		def questionMarkEntered(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "Question Mark Entered.")
		    return 0
		
		
		def f1pressedFunct(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "F1 pressed.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCDrawerGridSetStableWidget(drawer: object, w: object) -> None:

	"""

	Set the stable widget (cannot hidden with buttons) w inside DrawerGrid drawer.
	The widget will be nested inside the grid.
	Stable widget cannot be shown/hidden with buttons, i.e. is always visible.
	This function is not supported under VR mode.

	Parameters
	----------
	drawer : object
		the DrawerGrid.

	w : object
		the widget to be inserted.
		NOTE: Recall that each drawer grid is designed to accommodate one and only one stable widget.

	Returns
	-------
	None

	See Also
	--------
	BCDrawerGridInsertWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Drawer Grid Example", guitk.constants.BCOnExitDestroy
		    )
		    drawerGrid = guitk.BCDrawerGridCreate(window)
		    textEdit = guitk.BCTextEditCreate(drawerGrid, "")
		    hBoxTop = guitk.BCHBoxCreate(drawerGrid)
		    for i in range(4):
		        chkBox = guitk.BCCheckBoxCreate(hBoxTop, "CheckBox {}".format(i))
		        guitk.BCCheckBoxSetToggledFunction(chkBox, chkBoxToggled, None)
		    hBoxFoot = guitk.BCHBoxCreate(drawerGrid)
		    for i in range(3):
		        btn = guitk.BCPushButtonCreate(
		            hBoxFoot, "Button {}".format(i), btnClicked, None
		        )
		    # The order in which we insert widgets in the DrawerGrid handles their position.
		    # Current limits: max 1 non-stable widget per side (top-bottom)
		    btnShowFormat = guitk.BCDrawerGridInsertWidget(
		        drawerGrid, hBoxTop, False, "CheckBoxes"
		    )
		    guitk.BCDrawerGridSetStableWidget(drawerGrid, textEdit)
		    btnShowInfo = guitk.BCDrawerGridInsertWidget(drawerGrid, hBoxFoot, False, "Buttons")
		    guitk.BCShow(window)
		
		
		def chkBoxToggled(chkBox, state, data):
		    print(guitk.BCCheckBoxText(chkBox) + " toggled to state: " + str(state))
		    return 0
		
		
		def btnClicked(btn, data):
		    print(guitk.BCButtonText(btn) + " clicked.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetMaxVisibleItems(box: object, maxItems: int) -> None:

	"""

	Sets the maximum on screen size of the BCComboBox in number of items (default is 10).
	NOTE: If maxItems is exceeded, a vertical scrollbar is displayed.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	maxItems : int
		the on screen number of items.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option " + str(i) for i in range(15)])
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "Max Visible:")
		    lineEditMaxVisible = guitk.BCLineEditCreateInt(hBox0, 10)
		    guitk.BCLineEditSetEnterPressedFunction(lineEditMaxVisible, changeMaxVisible, cmb)
		    chkBoxWheel = guitk.BCCheckBoxCreate(window, "Wheel Enabled")
		    guitk.BCCheckBoxSetChecked(chkBoxWheel, True)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxWheel, toggleWheel, cmb)
		    hBox1 = guitk.BCHBoxCreate(window)
		
		    btnRemoveCurrent = guitk.BCPushButtonCreate(
		        hBox1, "Remove Current Item", removeCurrent, cmb
		    )
		    btnClear = guitk.BCPushButtonCreate(hBox1, "Clear combo box", btnClearClicked, cmb)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def removeCurrent(btn, cmb):
		    index = guitk.BCComboBoxCurrentItem(cmb)
		    if index >= 0:
		        guitk.BCComboBoxRemoveItem(cmb, index)
		    return 0
		
		
		def btnClearClicked(btn, cmb):
		    guitk.BCComboBoxClear(cmb)
		    return 0
		
		
		def changeMaxVisible(lineEdit, data):
		    text = guitk.BCLineEditGetText(lineEdit)
		    if guitk.BCLineEditValidate(lineEdit):
		        guitk.BCComboBoxSetMaxVisibleItems(data, int(text))
		    return 0
		
		
		def toggleWheel(chkBox, state, cmb):
		    guitk.BCComboBoxSetMouseWheelEnabled(cmb, state)
		    print("WheelEnabled = " + str(guitk.BCComboBoxMouseWheelEnabled(cmb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetAboutToCommitRenameEditorDataFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called just before list rename editor's data committed to item.
	You can check and validate the rename data (string or number) inserted from user.
	At this point the user decided to modify the ListViewItem text (for example pressed Enter key), but value was not applied yet.
	Editor rename data can be discarded or accepted according to return value of call back.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_ABOUT_TO_COMMIT_RENAME_EDITOR_DATA_FUNCTION for details.
		integer BC_LISTVIEW_ABOUT_TO_COMMIT_RENAME_EDITOR_DATA_FUNCTION(lv, item, col, editor, reason, data)
		The function to be called just before list rename editor data committed to ListViewItem.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * editor : object
		                    the LineEdit used as an editor.
		          * reason : int
		                    the user response that triggered commit data (KeyEnter, KeyTab, MouseButtonPress etc).
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 to discard editor's data from committing, or 0 to accept the data.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Rename Item", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    messenger = guitk.BCAnimationMessageCreate(listView, guitk.constants.BCOnExitHide)
		    guitk.BCListViewSetAboutToRenameItemFunction(
		        listView, DynamicDiscardRenameItem, messenger
		    )
		    guitk.BCListViewSetAboutToCommitRenameEditorDataFunction(
		        listView, DiscardNegativeNumbers, messenger
		    )
		    guitk.BCListViewSetRenameItemFinishedFunction(
		        listView, ShowMessageOnQuantityUpdated, messenger
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def DynamicDiscardRenameItem(listView, item, col, editor, messenger):
		    if (
		        guitk.BCListViewItemGetText(item, 0) == "1003"
		    ):  # scenario: check you data whether item is locked
		        guitk.BCAnimationMessageShowTextTimeout(
		            messenger, "Pillar is locked from another user.", 3000
		        )
		        return 1
		    return 0
		
		
		def DiscardNegativeNumbers(listView, item, col, editor, reason, messenger):
		    # discard empty or negative for numeric columns
		    renameType = guitk.BCListViewItemRenameType(item, col)
		    if renameType in (
		        guitk.constants.BCRenameType_Int,
		        guitk.constants.BCRenameType_Double,
		    ):
		        if not len(guitk.BCLineEditGetText(editor)):
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Empty value discarded.", 3000
		            )
		            return 1  # discard empty
		        value = -1
		        value = (
		            guitk.BCLineEditGetInt(editor)
		            if renameType == guitk.constants.BCRenameType_Int
		            else guitk.BCLineEditGetDouble(editor)
		        )
		        if value < 0:
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Negative value discarded.", 3000
		            )
		            return 1  # discard
		    return 0  # accept
		
		
		def ShowMessageOnQuantityUpdated(listView, item, col, dataCommitted, text, messenger):
		    if col == 2 and dataCommitted:
		        guitk.BCAnimationMessageShowTextTimeout(messenger, "Quantity updated.", 3000)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewIsMultipleItemsRenameEnabled(lv: object, col: int) -> int:

	"""

	Returns 1 if column col at ListView lv enables multiple items renaming; otherwise returns 0 (default).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	Returns
	-------
	int
		1 if column col enables multiple items renaming, otherwise 0.

	See Also
	--------
	BCListViewSetMultipleItemsRenameEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView SetColumn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Name", "Quantity", "Price"], False
		    )
		    guitk.BCSetUserDataKey(listView, "lastID", 0)
		    for i in range(20):
		        addEmptyItem(listView)
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    hBox = guitk.BCHBoxCreate(window)
		    lineEdit = guitk.BCLineEditCreate(hBox, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "New selected item's text.")
		    btn = guitk.BCPushButtonCreate(hBox, "Set Column", None, None)
		    menu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCPopupMenuInsertItem(menu, "Name", None, None)  # id 0 -> col 1
		    guitk.BCPopupMenuInsertItem(menu, "Quantity", None, None)  # id 1 -> col 2
		    guitk.BCPopupMenuInsertItem(menu, "Price", None, None)  # id 2 -> col 3
		    guitk.BCButtonSetPopup(btn, menu)
		    multipleChkBox = guitk.BCCheckBoxCreate(
		        window, "ListView Multiple Rename For column 'Name'"
		    )
		    guitk.BCCheckBoxSetChecked(
		        multipleChkBox, guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		    )
		    guitk.BCCheckBoxSetToggledFunction(multipleChkBox, toggleMulRename, listView)
		    guitk.BCPopupMenuSetActivatedFunction(menu, pmActivated, (lineEdit, listView))
		    guitk.BCShow(window)
		
		
		def addEmptyItem(listView):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    itemId = guitk.BCGetUserDataKey(listView, "lastID") + 1
		    guitk.BCSetUserDataKey(listView, "lastID", itemId)
		    guitk.BCListViewItemSetText(item, 0, str(itemId))
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		def pmActivated(menu, id, data):
		    lineEdit, listView = data
		    if guitk.BCListViewHasSelected(listView) and guitk.BCLineEditHasText(lineEdit):
		        col = id + 1
		        if col == 1:
		            name = guitk.BCLineEditGetText(lineEdit)
		            guitk.BCListViewSelectedSetColumnText(listView, col, name)
		        elif col == 2:
		            quantity = guitk.BCLineEditGetInt(lineEdit)
		            if quantity == guitk.constants.blank:
		                quantity = 0
		            guitk.BCListViewSelectedSetColumnInt(listView, col, quantity)
		        elif col == 3:
		            price = guitk.BCLineEditGetDouble(lineEdit)
		            if price == guitk.constants.blank:
		                price = 0
		            guitk.BCListViewSelectedSetColumnDouble(listView, col, price)
		        guitk.BCListViewAdjustColumn(listView, col)
		    else:
		        print("Select item/s and insert value to the LineEdit first")
		    return 0
		
		
		def toggleMulRename(chkBox, state, listView):
		    guitk.BCListViewSetMultipleItemsRenameEnabled(listView, 1, state)
		    print(
		        "MultipleItemsRename for column=1 set to {}".format(
		            guitk.BCListViewIsMultipleItemsRenameEnabled(listView, 1)
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetRenameItemFinishedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called after ListViewItem rename finished (data accepted or discarded).
	The editor is not active at this point since item is not in editing state anymore.
	If you want to validate the rename data use BCListViewSetAboutToCommitRenameEditorDataFunction().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_RENAME_ITEM_FINISHED_FUNCTION for details.
		integer BC_LISTVIEW_RENAME_ITEM_FINISHED_FUNCTION(lv, item, col, dataCommitted, text, data)
		The function to be called after ListViewItem rename finished.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * dataCommitted : int
		                    whether editor data applied to item cell: 1 when the data committed (Accept on enter), 0 otherwise (Cancel on escape).
		          * text : str
		                    the new text that just committed to the item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemGetText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Rename Item", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Quantity", "Price"], 0
		    )
		    messenger = guitk.BCAnimationMessageCreate(listView, guitk.constants.BCOnExitHide)
		    guitk.BCListViewSetAboutToRenameItemFunction(
		        listView, DynamicDiscardRenameItem, messenger
		    )
		    guitk.BCListViewSetAboutToCommitRenameEditorDataFunction(
		        listView, DiscardNegativeNumbers, messenger
		    )
		    guitk.BCListViewSetRenameItemFinishedFunction(
		        listView, ShowMessageOnQuantityUpdated, messenger
		    )
		    addPart(listView, "1001", "Bumper", "67", "23.5")
		    addPart(listView, "1002", "Decklid", "4", "0.9")
		    addPart(listView, "1003", "Pillar", "254", "12.2")
		    addPart(listView, "1004", "Roof rack", "14", "6.75")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def DynamicDiscardRenameItem(listView, item, col, editor, messenger):
		    if (
		        guitk.BCListViewItemGetText(item, 0) == "1003"
		    ):  # scenario: check you data whether item is locked
		        guitk.BCAnimationMessageShowTextTimeout(
		            messenger, "Pillar is locked from another user.", 3000
		        )
		        return 1
		    return 0
		
		
		def DiscardNegativeNumbers(listView, item, col, editor, reason, messenger):
		    # discard empty or negative for numeric columns
		    renameType = guitk.BCListViewItemRenameType(item, col)
		    if renameType in (
		        guitk.constants.BCRenameType_Int,
		        guitk.constants.BCRenameType_Double,
		    ):
		        if not len(guitk.BCLineEditGetText(editor)):
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Empty value discarded.", 3000
		            )
		            return 1  # discard empty
		        value = -1
		        value = (
		            guitk.BCLineEditGetInt(editor)
		            if renameType == guitk.constants.BCRenameType_Int
		            else guitk.BCLineEditGetDouble(editor)
		        )
		        if value < 0:
		            guitk.BCAnimationMessageShowTextTimeout(
		                messenger, "Negative value discarded.", 3000
		            )
		            return 1  # discard
		    return 0  # accept
		
		
		def ShowMessageOnQuantityUpdated(listView, item, col, dataCommitted, text, messenger):
		    if col == 2 and dataCommitted:
		        guitk.BCAnimationMessageShowTextTimeout(messenger, "Quantity updated.", 3000)
		    return 0
		
		
		def addPart(listView, pid, name, quantity, price):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetText(item, 3, price)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Double)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetExpandItemsButtonEnabled(lv: object, enable: bool) -> None:

	"""

	Shows a button at the right of the header that when clicked expand or collapse the items of (tree) list view lv.
	Makes sense for tree views.
	NOTE: If you execute BCListViewSetItemsExpanded(), button state is adjusted.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	enable : bool
		set 1 to enable the button or 0 to disable (default).

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemsExpanded

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListViewItemSetExpanded Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 2, ["Shape", "Sides"], False)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    hexa = addShapeGroup(listView, "Hexagon", "6")
		    penta = addShapeGroup(listView, "Pentagon", "5")
		    quad = addShapeGroup(listView, "Quadrilateral", "4")
		    tria = addShapeGroup(listView, "Triangle", "3")
		    addShape(quad, "Cyclic", "4")
		    addShape(quad, "Parallelogram", "4")
		    addShape(quad, "Tangential", "4")
		    addShape(quad, "Trapezoid", "4")
		    addShape(tria, "Acute", "3")
		    addShape(tria, "Equilateral", "3")
		    addShape(tria, "Isosceles", "3")
		    addShape(tria, "Right", "3")
		    addShape(tria, "Scalene", "3")
		    guitk.BCListViewSetSortingColumn(listView, 1, False)
		    guitk.BCListViewItemSetExpanded(quad, True)
		
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateFirstLevel, printExpandedStatus, None
		    )
		    guitk.BCListViewSetExpandItemsButtonEnabled(listView, True)
		    guitk.BCShow(window)
		
		
		def printExpandedStatus(item, data):
		    print(
		        guitk.BCListViewItemGetText(item, 0)
		        + " is Expanded = "
		        + str(guitk.BCListViewItemIsExpanded(item))
		    )
		    return 0
		
		
		def addShapeGroup(listView, name, sides):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		def addShape(parent, name, sides):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, sides)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableIsCellSelected(t: object, row: int, col: int) -> bool:

	"""

	Returns 1 if cell at column col and row row is selected, otherwise returns 0.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	row : int
		the row.

	col : int
		the column.

	Returns
	-------
	bool
		True if the requested cell is selected, False otherwise.

	See Also
	--------
	BCTableIsRowSelected

	"""

def BCSliderSetValueChangedOnMouseOrKeyRelease(sl: object, enable: int) -> None:

	"""

	Sets whether BCSlider's sb value changed callback will be called only on mouse or key (Right, Left, Up, Down Arrow, Page Up, Page Down) release or not.
	This function is not supported under VR mode.

	Parameters
	----------
	sl : object
		the BCSlider.

	enable : int
		set this parameter to 1 so that value changed callback will be called only on mouse or key release, or 0 otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCSliderSetValueChangedFunction

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Slider Boundaries Extras Example", guitk.constants.BCOnExitDestroy
		    )
		
		    slider = guitk.BCSliderCreate(window, 0, 20, 1, 1, guitk.constants.BCHorizontal)
		    guitk.BCSliderEnableBoundaries(slider, True)
		    guitk.BCSliderSetMinValue(slider, 0)
		    guitk.BCSliderSetMaxValue(slider, 20)
		    guitk.BCSliderSetValue(slider, 10)
		    guitk.BCSliderSetStartBoundValue(slider, 4)
		    guitk.BCSliderSetEndBoundValue(slider, 16)
		
		    bLayoutFooter = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    chkBoxOnRelease = guitk.BCCheckBoxCreate(
		        bLayoutFooter, "Trigger Callback only on Release"
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxOnRelease, 0)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxOnRelease, 1)
		    chkBoxExceed = guitk.BCCheckBoxCreate(bLayoutFooter, "Exceed Bounds")
		    guitk.BCBoxLayoutInsert(bLayoutFooter, chkBoxExceed, -1)
		    guitk.BCBoxLayoutSetStretchFactor(bLayoutFooter, chkBoxExceed, 1)
		    btnGoToMin = guitk.BCPushButtonCreate(
		        bLayoutFooter, "Go to Min", setSliderToMin, slider
		    )
		    guitk.BCBoxLayoutInsert(bLayoutFooter, btnGoToMin, -1)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxOnRelease, setOnRelease, slider)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxExceed, setExceedBounds, slider)
		    guitk.BCSliderSetValueChangedFunction(slider, sliderValueChanged, None)
		    guitk.BCShow(window)
		
		
		def setSliderToMin(btn, slider):
		    exceedsBounds = guitk.BCSliderExceedBounds(slider)
		    guitk.BCSliderSetValueNoCallback(
		        slider,
		        guitk.BCSliderMinValue(slider)
		        if exceedsBounds
		        else guitk.BCSliderStartBoundValue(slider),
		    )
		    return 0
		
		
		def setOnRelease(chkBox, state, slider):
		    guitk.BCSliderSetValueChangedOnMouseOrKeyRelease(slider, state)
		    return 0
		
		
		def setExceedBounds(chkBox, state, slider):
		    guitk.BCSliderSetExceedBounds(slider, state)
		    return 0
		
		
		def sliderValueChanged(slider, value, data):
		    print(
		        "Slider Change Callback triggered.\\nValue = {}, StartBound = {}, EndBound = {}".format(
		            value,
		            guitk.BCSliderStartBoundValue(slider),
		            guitk.BCSliderEndBoundValue(slider),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowSetModal(win: object, modal: bool) -> None:

	"""

	Sets whether win will be shown as modal or modeless to modal
	While in modal state, a window grabs all input. No other window can be used until win is closed.
	NOTE: BCWindowSetModal function must be called before the BCShow function.
	NOTE: If from BCWindow win created an other BCWindow win2 then function BCWindowSetModal must be called and for win2 and so on.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow.

	modal : bool
		the new value for modal state

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Modal Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(window, "<h1>Urgent</h1>"), guitk.constants.BCAlignCenter
		    )
		    guitk.BCSeparatorCreate(window)
		    guitk.BCLabelCreate(
		        window,
		        "Just an example, not really urgent. You cannot use the Main Window while I am open.",
		    )
		    guitk.BCWindowSetModal(window, True)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterGetWidgetSizes(sp: object) -> object:

	"""

	Returns an IntArray of the size parameters of all the widgets in splitter sp.
	If the splitter's orientation is horizontal, the array is a list of widget widths.
	If the orientation is vertical, the array is a list of widget heights.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter whose children's sizes you want to get.

	Returns
	-------
	object
		an IntArray of the size parameters of all the widgets in splitter sp.

	See Also
	--------
	BCSplitterSetWidgetSizes

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter Widget Sizes Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Set Sizes", guitk.constants.BCHorizontal
		    )
		    guitk.BCLabelCreate(
		        window,
		        "Try using either the arrows or the mouse wheel to change the SpinBoxes.",
		    )
		    myFrameCreate(splitter, "Frame A")
		    myFrameCreate(splitter, "Frame B")
		    myFrameCreate(splitter, "Frame C")
		    guitk.BCButtonGroupSetExclusive(btnGroup, False)
		    spinBoxes = [None] * 3
		    for i in range(len(spinBoxes)):
		        spinBoxes[i] = sizeSpinBoxCreate(btnGroup)
		        guitk.BCSpinBoxSetValueChangedFunction(
		            spinBoxes[i], setNewSizes, (splitter, spinBoxes, i)
		        )
		    guitk.BCSplitterSetSplitterMovedFunction(splitter, updateSpinBoxes, spinBoxes)
		    guitk.BCTimerSingleShot(0, lambda data: updateSpinBoxes(splitter, spinBoxes), None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def myFrameCreate(splitter, labelText):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    label = guitk.BCLabelCreate(bLayout, labelText)
		    guitk.BCLabelSetAlignment(label, guitk.constants.BCAlignCenter)
		
		
		def sizeSpinBoxCreate(btnGroup):
		    spinBox = guitk.BCSpinBoxCreate(btnGroup)
		    guitk.BCSpinBoxSetMinValue(spinBox, 85)
		    guitk.BCSpinBoxSetMaxValue(spinBox, 10000)
		    guitk.BCSpinBoxSetLineStep(spinBox, 10)
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBox, True)
		    return spinBox
		
		
		def setNewSizes(sb, val, data):
		    splitter, spinBoxes, i = data
		    sizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    sizes[i] = val
		    guitk.BCSplitterSetWidgetSizes(splitter, sizes)
		    guitk.BCTimerSingleShot(
		        500, lambda data: updateSpinBoxes(splitter, spinBoxes), None
		    )
		    return 0
		
		
		def updateSpinBoxes(splitter, spinBoxes):
		    newSizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    for i, size in enumerate(newSizes):
		        # Check in case you want to block Callback functions on a higher level in your code.
		        alreadyBlocked = guitk.BCCallBackFunctionsBlocked(spinBoxes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], True)
		        guitk.BCSpinBoxSetValue(spinBoxes[i], newSizes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterSetWidgetSizes(sp: object, sizes: object) -> None:

	"""

	Sets the size parameters of splitter's widgets to the values given in the sizes array.
	If the BCSplitter is horizontal, the values set the widths of each widget going from left
	to right. If the BCSplitter is vertical, the values set the heights of each widget going
	from top to bottom. Extra values in the list are ignored. If the integer array contains
	too few values, the result is undefined but the program will still be well-behaved.
	Note that the values in list should be the height/width that the widgets should be resized to.
	Take care that the setting of the new values is done after the window which the BCSplitter
	belongs to, has been created.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter whose children's sizes you want to set.

	sizes : object
		the IntArray with the sizes you want to set for every BCSplitter's child.

	Returns
	-------
	None

	See Also
	--------
	BCSplitterGetWidgetSizes

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter Widget Sizes Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Set Sizes", guitk.constants.BCHorizontal
		    )
		    guitk.BCLabelCreate(
		        window,
		        "Try using either the arrows or the mouse wheel to change the SpinBoxes.",
		    )
		    myFrameCreate(splitter, "Frame A")
		    myFrameCreate(splitter, "Frame B")
		    myFrameCreate(splitter, "Frame C")
		    guitk.BCButtonGroupSetExclusive(btnGroup, False)
		    spinBoxes = [None] * 3
		    for i in range(len(spinBoxes)):
		        spinBoxes[i] = sizeSpinBoxCreate(btnGroup)
		        guitk.BCSpinBoxSetValueChangedFunction(
		            spinBoxes[i], setNewSizes, (splitter, spinBoxes, i)
		        )
		    guitk.BCSplitterSetSplitterMovedFunction(splitter, updateSpinBoxes, spinBoxes)
		    guitk.BCTimerSingleShot(0, lambda data: updateSpinBoxes(splitter, spinBoxes), None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def myFrameCreate(splitter, labelText):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    label = guitk.BCLabelCreate(bLayout, labelText)
		    guitk.BCLabelSetAlignment(label, guitk.constants.BCAlignCenter)
		
		
		def sizeSpinBoxCreate(btnGroup):
		    spinBox = guitk.BCSpinBoxCreate(btnGroup)
		    guitk.BCSpinBoxSetMinValue(spinBox, 85)
		    guitk.BCSpinBoxSetMaxValue(spinBox, 10000)
		    guitk.BCSpinBoxSetLineStep(spinBox, 10)
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBox, True)
		    return spinBox
		
		
		def setNewSizes(sb, val, data):
		    splitter, spinBoxes, i = data
		    sizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    sizes[i] = val
		    guitk.BCSplitterSetWidgetSizes(splitter, sizes)
		    guitk.BCTimerSingleShot(
		        500, lambda data: updateSpinBoxes(splitter, spinBoxes), None
		    )
		    return 0
		
		
		def updateSpinBoxes(splitter, spinBoxes):
		    newSizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    for i, size in enumerate(newSizes):
		        # Check in case you want to block Callback functions on a higher level in your code.
		        alreadyBlocked = guitk.BCCallBackFunctionsBlocked(spinBoxes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], True)
		        guitk.BCSpinBoxSetValue(spinBoxes[i], newSizes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterSetSplitterMovedFunction(sp: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called every time a splitter handle is moved.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	funct : Callable
		the function that will be called when a splitter handle is moved.
		See BC_SPLITTER_MOVED_FUNCTION for details.
		integer BC_SPLITTER_MOVED_FUNCTION(splitter, data)
		The function to be called when splitter areas have been resized (i.e. a handle of the splitter has been moved).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * splitter : object
		                    the BCSplitter.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter Widget Sizes Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    btnGroup = guitk.BCButtonGroupCreate(
		        window, "Set Sizes", guitk.constants.BCHorizontal
		    )
		    guitk.BCLabelCreate(
		        window,
		        "Try using either the arrows or the mouse wheel to change the SpinBoxes.",
		    )
		    myFrameCreate(splitter, "Frame A")
		    myFrameCreate(splitter, "Frame B")
		    myFrameCreate(splitter, "Frame C")
		    guitk.BCButtonGroupSetExclusive(btnGroup, False)
		    spinBoxes = [None] * 3
		    for i in range(len(spinBoxes)):
		        spinBoxes[i] = sizeSpinBoxCreate(btnGroup)
		        guitk.BCSpinBoxSetValueChangedFunction(
		            spinBoxes[i], setNewSizes, (splitter, spinBoxes, i)
		        )
		    guitk.BCSplitterSetSplitterMovedFunction(splitter, updateSpinBoxes, spinBoxes)
		    guitk.BCTimerSingleShot(0, lambda data: updateSpinBoxes(splitter, spinBoxes), None)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def myFrameCreate(splitter, labelText):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    label = guitk.BCLabelCreate(bLayout, labelText)
		    guitk.BCLabelSetAlignment(label, guitk.constants.BCAlignCenter)
		
		
		def sizeSpinBoxCreate(btnGroup):
		    spinBox = guitk.BCSpinBoxCreate(btnGroup)
		    guitk.BCSpinBoxSetMinValue(spinBox, 85)
		    guitk.BCSpinBoxSetMaxValue(spinBox, 10000)
		    guitk.BCSpinBoxSetLineStep(spinBox, 10)
		    guitk.BCSpinBoxSetValueChangedOnMouseRelease(spinBox, True)
		    return spinBox
		
		
		def setNewSizes(sb, val, data):
		    splitter, spinBoxes, i = data
		    sizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    sizes[i] = val
		    guitk.BCSplitterSetWidgetSizes(splitter, sizes)
		    guitk.BCTimerSingleShot(
		        500, lambda data: updateSpinBoxes(splitter, spinBoxes), None
		    )
		    return 0
		
		
		def updateSpinBoxes(splitter, spinBoxes):
		    newSizes = guitk.BCSplitterGetWidgetSizes(splitter)
		    for i, size in enumerate(newSizes):
		        # Check in case you want to block Callback functions on a higher level in your code.
		        alreadyBlocked = guitk.BCCallBackFunctionsBlocked(spinBoxes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], True)
		        guitk.BCSpinBoxSetValue(spinBoxes[i], newSizes[i])
		        if not alreadyBlocked:
		            guitk.BCBlockCallBackFunctions(spinBoxes[i], False)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetMouseWheelEnabled(cb: object, enable: bool) -> None:

	"""

	Enables or disables scrolling though combobox items with mouse wheel according to enable.
	By default, when a BCComboBox has the focus, the mouse wheel scrolls though its items, even if its popup is hidden.
	Calling this function with enable set to False, the mouse wheel is disabled. Disabling mouse wheel may come in handy
	in cases where you want to scroll only the container (like a scrollview) into which the combobox is placed but not
	the very same combobox.
	This function is not supported under VR mode.

	Parameters
	----------
	cb : object
		the BCComboBox

	enable : bool
		set this to False in order to disable mouse wheel; True otherwise. By default, mouse wheel is enabled

	Returns
	-------
	None

	See Also
	--------
	BCComboBoxMouseWheelEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option " + str(i) for i in range(15)])
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "Max Visible:")
		    lineEditMaxVisible = guitk.BCLineEditCreateInt(hBox0, 10)
		    guitk.BCLineEditSetEnterPressedFunction(lineEditMaxVisible, changeMaxVisible, cmb)
		    chkBoxWheel = guitk.BCCheckBoxCreate(window, "Wheel Enabled")
		    guitk.BCCheckBoxSetChecked(chkBoxWheel, True)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxWheel, toggleWheel, cmb)
		    hBox1 = guitk.BCHBoxCreate(window)
		
		    btnRemoveCurrent = guitk.BCPushButtonCreate(
		        hBox1, "Remove Current Item", removeCurrent, cmb
		    )
		    btnClear = guitk.BCPushButtonCreate(hBox1, "Clear combo box", btnClearClicked, cmb)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def removeCurrent(btn, cmb):
		    index = guitk.BCComboBoxCurrentItem(cmb)
		    if index >= 0:
		        guitk.BCComboBoxRemoveItem(cmb, index)
		    return 0
		
		
		def btnClearClicked(btn, cmb):
		    guitk.BCComboBoxClear(cmb)
		    return 0
		
		
		def changeMaxVisible(lineEdit, data):
		    text = guitk.BCLineEditGetText(lineEdit)
		    if guitk.BCLineEditValidate(lineEdit):
		        guitk.BCComboBoxSetMaxVisibleItems(data, int(text))
		    return 0
		
		
		def toggleWheel(chkBox, state, cmb):
		    guitk.BCComboBoxSetMouseWheelEnabled(cmb, state)
		    print("WheelEnabled = " + str(guitk.BCComboBoxMouseWheelEnabled(cmb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCScrollAreaCreate(p: object) -> object:

	"""

	Creates a BCScrollArea widget.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout of the created BCScrollArea.

	Returns
	-------
	object
		the created BCScrollArea.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCScrollArea Example", guitk.constants.BCOnExitDestroy
		    )
		    tab = guitk.BCTabWidgetCreate(window)
		    # No ScrollArea
		    guitk.BCTabWidgetAddTab(tab, gridLabelsFrameCreate(tab, 5, 5), "No BCScrollArea")
		    # With ScrollArea
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    # With ScrollArea, resizable
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCScrollAreaSetWidgetResizable(scrollArea, True)
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    guitk.BCShow(window)
		
		
		def gridLabelsFrameCreate(p, rows, cols):
		    frame = guitk.BCFrameCreate(p)
		    gLayout = guitk.BCGridLayoutCreate(frame, 1, 1)
		    for row in range(rows):
		        for col in range(cols):
		            guitk.BCGridLayoutAddWidget(
		                gLayout,
		                guitk.BCLabelCreate(gLayout, "CHILD ({}, {})".format(row + 1, col + 1)),
		                row,
		                col,
		                guitk.constants.BCAlignLeft,
		            )
		    return frame
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCScrollAreaSetWidget(sa: object, w: object) -> None:

	"""

	Sets widget w to BCScrollArea sa.
	The widget becomes a child of the BCScrollArea, and will be destroyed when the BCScrollArea is deleted or when a new widget is set.
	If the BCScrollArea is visible when the widget is added, you must show() it explicitly.
	Note that you must add the layout of widget before you call this function.
	if you add it later, the widget will not be visible - regardless of when you show() the scroll area. In this case, you can also not show() the widget later.
	This function is not supported under VR mode.

	Parameters
	----------
	sa : object
		the BCScrollArea.

	w : object
		the widget that will be set in the BCScrollArea.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCScrollArea Example", guitk.constants.BCOnExitDestroy
		    )
		    tab = guitk.BCTabWidgetCreate(window)
		    # No ScrollArea
		    guitk.BCTabWidgetAddTab(tab, gridLabelsFrameCreate(tab, 5, 5), "No BCScrollArea")
		    # With ScrollArea
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    # With ScrollArea, resizable
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCScrollAreaSetWidgetResizable(scrollArea, True)
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    guitk.BCShow(window)
		
		
		def gridLabelsFrameCreate(p, rows, cols):
		    frame = guitk.BCFrameCreate(p)
		    gLayout = guitk.BCGridLayoutCreate(frame, 1, 1)
		    for row in range(rows):
		        for col in range(cols):
		            guitk.BCGridLayoutAddWidget(
		                gLayout,
		                guitk.BCLabelCreate(gLayout, "CHILD ({}, {})".format(row + 1, col + 1)),
		                row,
		                col,
		                guitk.constants.BCAlignLeft,
		            )
		    return frame
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCScrollAreaSetWidgetResizable(sa: object, resizable: bool) -> None:

	"""

	Sets whether the BCScrollArea should resize its set widget.
	If this property is set to to False (the default), the BCScrollArea honors the size of its widget.
	
	If this property is set to to True, the BCScrollArea will automatically resize the widget in order to avoid scroll bars where they can be avoided,
	or to take advantage of extra space.
	This function is not supported under VR mode.

	Parameters
	----------
	sa : object
		the BCScrollArea.

	resizable : bool
		the boolean value of the property.

	Returns
	-------
	None

	See Also
	--------
	BCScrollAreaWidgetResizable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCScrollArea Example", guitk.constants.BCOnExitDestroy
		    )
		    tab = guitk.BCTabWidgetCreate(window)
		    # No ScrollArea
		    guitk.BCTabWidgetAddTab(tab, gridLabelsFrameCreate(tab, 5, 5), "No BCScrollArea")
		    # With ScrollArea
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    # With ScrollArea, resizable
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCScrollAreaSetWidgetResizable(scrollArea, True)
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    guitk.BCShow(window)
		
		
		def gridLabelsFrameCreate(p, rows, cols):
		    frame = guitk.BCFrameCreate(p)
		    gLayout = guitk.BCGridLayoutCreate(frame, 1, 1)
		    for row in range(rows):
		        for col in range(cols):
		            guitk.BCGridLayoutAddWidget(
		                gLayout,
		                guitk.BCLabelCreate(gLayout, "CHILD ({}, {})".format(row + 1, col + 1)),
		                row,
		                col,
		                guitk.constants.BCAlignLeft,
		            )
		    return frame
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCScrollAreaWidgetResizable(sa: object) -> bool:

	"""

	Returns the value of the resizable property of BCScrollArea sa.
	This function is not supported under VR mode.

	Parameters
	----------
	sa : object
		the BCScrollArea.

	Returns
	-------
	bool
		the boolean value of the property.

	See Also
	--------
	BCScrollAreaSetWidgetResizable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCScrollArea Example", guitk.constants.BCOnExitDestroy
		    )
		    tab = guitk.BCTabWidgetCreate(window)
		    # No ScrollArea
		    guitk.BCTabWidgetAddTab(tab, gridLabelsFrameCreate(tab, 5, 5), "No BCScrollArea")
		    # With ScrollArea
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    # With ScrollArea, resizable
		    scrollArea = guitk.BCScrollAreaCreate(tab)
		    guitk.BCScrollAreaSetWidget(scrollArea, gridLabelsFrameCreate(scrollArea, 20, 20))
		    guitk.BCScrollAreaSetWidgetResizable(scrollArea, True)
		    guitk.BCTabWidgetAddTab(
		        tab,
		        scrollArea,
		        "BCScrollArea, Resizable = {}".format(
		            guitk.BCScrollAreaWidgetResizable(scrollArea)
		        ),
		    )
		    guitk.BCShow(window)
		
		
		def gridLabelsFrameCreate(p, rows, cols):
		    frame = guitk.BCFrameCreate(p)
		    gLayout = guitk.BCGridLayoutCreate(frame, 1, 1)
		    for row in range(rows):
		        for col in range(cols):
		            guitk.BCGridLayoutAddWidget(
		                gLayout,
		                guitk.BCLabelCreate(gLayout, "CHILD ({}, {})".format(row + 1, col + 1)),
		                row,
		                col,
		                guitk.constants.BCAlignLeft,
		            )
		    return frame
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxMouseWheelEnabled(cb: object) -> bool:

	"""

	Returns True or False if mouse wheel is enabled or not for BCComboBox cb.
	This function is not supported under VR mode.

	Parameters
	----------
	cb : object
		the BCComboBox

	Returns
	-------
	bool
		True if mouse wheel is enabled; False otherwise

	See Also
	--------
	BCComboBoxSetMouseWheelEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ComboBox Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    cmb = guitk.BCComboBoxCreate(window, ["Option " + str(i) for i in range(15)])
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "Max Visible:")
		    lineEditMaxVisible = guitk.BCLineEditCreateInt(hBox0, 10)
		    guitk.BCLineEditSetEnterPressedFunction(lineEditMaxVisible, changeMaxVisible, cmb)
		    chkBoxWheel = guitk.BCCheckBoxCreate(window, "Wheel Enabled")
		    guitk.BCCheckBoxSetChecked(chkBoxWheel, True)
		    guitk.BCCheckBoxSetToggledFunction(chkBoxWheel, toggleWheel, cmb)
		    hBox1 = guitk.BCHBoxCreate(window)
		
		    btnRemoveCurrent = guitk.BCPushButtonCreate(
		        hBox1, "Remove Current Item", removeCurrent, cmb
		    )
		    btnClear = guitk.BCPushButtonCreate(hBox1, "Clear combo box", btnClearClicked, cmb)
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def removeCurrent(btn, cmb):
		    index = guitk.BCComboBoxCurrentItem(cmb)
		    if index >= 0:
		        guitk.BCComboBoxRemoveItem(cmb, index)
		    return 0
		
		
		def btnClearClicked(btn, cmb):
		    guitk.BCComboBoxClear(cmb)
		    return 0
		
		
		def changeMaxVisible(lineEdit, data):
		    text = guitk.BCLineEditGetText(lineEdit)
		    if guitk.BCLineEditValidate(lineEdit):
		        guitk.BCComboBoxSetMaxVisibleItems(data, int(text))
		    return 0
		
		
		def toggleWheel(chkBox, state, cmb):
		    guitk.BCComboBoxSetMouseWheelEnabled(cmb, state)
		    print("WheelEnabled = " + str(guitk.BCComboBoxMouseWheelEnabled(cmb)))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetFixedItemIconSize(lv: object, w: int, h: int) -> None:

	"""

	Sets the size of the items' icons to be width /a w and height /a h.
	Icons size can only scaled down from their actual (physical) icons size.
	All items have same size icons for readability and performance reasons.
	The icons size (when not fixed) depends on the largest icon set with BCListViewItemSetIconFileName().
	To clear the fixed icons size just use an invalid size, i.e. width or height to -1.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	w : int
		the icon size width in pixels

	h : int
		the icon size height in pixels

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		SMALL = 16
		LARGE = 24
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Set Fixed Icon Size Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Icon Size"), guitk.constants.BCAlignCenter
		    )
		    cmbIconSize = guitk.BCComboBoxCreate(hBox, ["Small", "Large"])
		    guitk.BCComboBoxSetSizePolicy(
		        cmbIconSize, guitk.constants.BCMaximum, guitk.constants.BCMaximum
		    )
		    guitk.BCSpacerCreate(hBox)
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(
		        cmbIconSize, changeIconSize, listView
		    )
		    guitk.BCComboBoxSetCurrentItem(cmbIconSize, 1)
		    guitk.BCShow(window)
		
		
		def changeIconSize(cmb, index, listView):
		    size = SMALL if index == 0 else LARGE
		    print("Setting icon size to {0}x{0}".format(size))
		    guitk.BCListViewSetFixedItemIconSize(listView, size, size)
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetIconFileName(item, 0, "logo_sdm.svg"),
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetPredefinedContentsIconFileNames(lv: object, col: int, fileNames: object) -> None:

	"""

	Set ListView filter to use specific (fixed) icon options for filter widgets that provide a menu (ComboBox and CheckableMenu).
	You can customize the options for the drop down menus of ComboBox and CheckableMenu.
	NOTE: The standard ListView filter ComboBox or CheckableMenu builds its drop down menu from the contents of ListViewItems.
	NOTE: If you need the option to search for empty (no icon) include an empty string in your predefined list.
	If your filter does not provide ComboBox or CheckableMenu for column col, nothing happens. Duplicates are removed.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	fileNames : object
		the icon file names.

	Returns
	-------
	None

	See Also
	--------
	BCListViewFilterSetComboBox

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "State"], 0
		    )
		    addParts(listView)
		    guitk.BCListViewSetFilterEnabled(listView, True)
		    guitk.BCListViewFilterSetComboBox(listView, 3)
		    guitk.BCListViewSetPredefinedContentsIconFileNames(
		        listView,
		        3,
		        ["done_small.svg", "error_small.svg", "info_small.svg", "warning_small.svg"],
		    )
		
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addParts(listView):
		    item = addPart(listView, "1001", "Bumper", "Large")
		    guitk.BCListViewItemSetIconFileName(item, 3, "done_small.svg")
		    item = addPart(listView, "1002", "Decklid", "Large")
		    guitk.BCListViewItemSetIconFileName(item, 3, "info_small.svg")
		    item = addPart(listView, "1003", "Pillar", "Medium")
		    guitk.BCListViewItemSetIconFileName(item, 3, "warning_small.svg")
		    item = addPart(listView, "1004", "Welded Assembly", "Small")
		    guitk.BCListViewItemSetIconFileName(item, 3, "error_small.svg")
		    item = addPart(listView, "1005", "Spoiler", "Large")
		    guitk.BCListViewItemSetIconFileName(item, 3, "done_small.svg")
		    list = [
		        guitk.constants.BCInt,
		        guitk.constants.BCString,
		        guitk.constants.BCString,
		        guitk.constants.BCInvalid,
		    ]
		    guitk.BCListViewSetColumnDataTypes(listView, list)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemWidgetDestroy(item: object, col: int) -> None:

	"""

	Deletes the cell widget that was set at item column col.
	Supported item widgets are
	- Button (BCListViewItemSetButton()),
	- Checkbox (BCListViewItemSetCheckBox()),
	- ComboBox (BCListViewItemSetComboBox()),
	- ProgressBar (BCListViewItemSetProgressBar()),
	- RadioButton (BCListViewItemSetRadioButton())
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemWidgetSetVisible

	Examples
	--------
	::

		from sdm import guitk
		from random import randint
		import math
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Size", "Progress", "Show Percentage"], 0
		    )
		    addPart(listView, "1001", "Bumper", "Large")
		    addPart(listView, "1002", "Decklid", "Large")
		    addPart(listView, "1003", "Pillar", "Medium")
		    addPart(listView, "1004", "Welded Assembly", "Small")
		    addAverage(listView)
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateVisible, addProgressBar, 3
		    )
		    showAverageFunct(listView)
		
		    guitk.BCShow(window)
		
		
		def addAverage(parent):
		    avg = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetProgressBar(avg, 3)
		    guitk.BCListViewItemSetVisible(avg, False)
		
		
		def addPart(parent, pid, name, size):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    return item
		
		
		def addProgressBar(item, col):
		    progress = randint(0, 100)
		    guitk.BCListViewItemSetProgressBar(item, col)
		    guitk.BCListViewItemProgressBarSetProgress(item, col, progress)
		    if progress == 100:
		        guitk.BCListViewItemWidgetDestroy(item, col)
		        guitk.BCListViewItemSetText(item, col, "DONE")
		    else:
		        guitk.BCListViewItemSetCheckBox(item, col + 1, True, showPercentageFunct, None)
		    return 0
		
		
		def showPercentageFunct(item, col, state, data):
		    guitk.BCListViewItemProgressBarSetPercentageVisible(item, col - 1, state)
		    return 0
		
		
		def showAverageFunct(lv):
		    # Counts average row too, subtracting - 1
		    rows = guitk.BCListViewTopLevelItemCount(lv) - 1
		    sum = 0
		    for row in range(rows):
		        item = guitk.BCListViewGetTopLevelItem(lv, row)
		        currentProgress = guitk.BCListViewItemProgressBarProgress(item, 3)
		        # currentProgress equals -1, when there is no progressBar, which means progress is 100%
		        if currentProgress < 0:
		            sum += 100
		        else:
		            sum += currentProgress
		    # Rounding down (only if all items are completed, the whole progress will be 100%)
		    avg = int(math.floor(sum / rows))
		    guitk.BCListViewSetText(lv, rows, 2, "AVERAGE PROGRESS:")
		    item_avg = guitk.BCListViewGetTopLevelItem(lv, rows)
		    guitk.BCListViewItemProgressBarSetProgress(item_avg, 3, avg)
		    guitk.BCListViewItemSetBold(item_avg, True)
		    guitk.BCListViewItemSetVisible(item_avg, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCFlash(w: object) -> None:

	"""

	Highlight widget w with animation.
	Use it when you want to draw user's attention to a specific window component.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	Returns
	-------
	None

	See Also
	--------
	BCFontMaxWidth

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "H/VBoxCreate Example", guitk.constants.BCOnExitDestroy
		    )
		
		    checkBoxReverse = guitk.BCCheckBoxCreate(window, "Reverse Main Layout")
		    guitk.BCCheckBoxSetToggledFunction(checkBoxReverse, reverseToggled, window)
		
		    vBox = guitk.BCVBoxCreate(window)
		    guitk.BCLabelCreate(vBox, "Vertical Label 1")
		    guitk.BCLabelCreate(vBox, "Vertical Label 2")
		    guitk.BCLabelCreate(vBox, "Vertical Label 3")
		
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox, "Horizontal Label 1")
		    guitk.BCLabelCreate(hBox, "Horizontal Label 2")
		
		    vBox2 = guitk.BCVBoxCreate(hBox)
		    guitk.BCLabelCreate(vBox2, "H-V label 1")
		    guitk.BCLabelCreate(vBox2, "H-V label 2")
		    btnFlash = guitk.BCPushButtonCreate(vBox2, "Flash Box", btnFlashClicked, vBox2)
		
		    guitk.BCShow(window)
		
		
		def reverseToggled(checkBOx, state, window):
		    layMain = guitk.BCLayout(window)
		    guitk.BCBoxLayoutSetDirection(
		        layMain,
		        guitk.constants.BCBottomToTop if state else guitk.constants.BCTopToBottom,
		    )
		    return 0
		
		
		def btnFlashClicked(btn, box):
		    guitk.BCFlash(box)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSetFocusColor(w: object, r: int, g: int, b: int) -> None:

	"""

	Sets the color (r, g and b values) to highlight widget \w while it has the focus (i.e. after making it current either by pressing Tab or by mouse click)
	NOTE: Some widgets by design don't get focus or the get focus only by Tab or only by mouse click.
	WARNING: Avoid using this function and respect the current style to achieve a coherent appearance of your GUI.
	WARNING: This function may become disabled or its result may be overridden in the future or by applications that use their own style or stylesheet.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget whose background color will be set while it has focus.

	r : int
		the value for red (0 - 255).

	g : int
		the value for green (0 - 255).

	b : int
		the value for blue (0 - 255).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Focus with SaveSettings Example", guitk.constants.BCOnExitDestroy
		    )
		
		    btn1 = guitk.BCPushButtonCreate(window, "Button 1", None, None)
		    btn2 = guitk.BCPushButtonCreate(window, "Button 2", None, None)
		    lineEdit = guitk.BCLineEditCreate(window, "")
		    cmbFocus = guitk.BCComboBoxCreate(
		        window,
		        ["BCNoFocus", "BCTabFocus", "BCClickFocus", "BCStrongFocus", "BCWheelFocus"],
		    )
		
		    chkBoxReverse = guitk.BCCheckBoxCreate(window, "Reverse Buttons' Focus Order")
		    guitk.BCCheckBoxSetToggledFunction(chkBoxReverse, cbReverseToggled, [btn1, btn2])
		
		    guitk.BCSetFocusColor(lineEdit, 200, 0, 0)
		
		    widgets = [btn1, btn2, lineEdit, cmbFocus, chkBoxReverse]
		    guitk.BCComboBoxSetCurrentIndexChangedFunction(
		        cmbFocus, cmbFocusCurrentIndexChanged, widgets
		    )
		    guitk.BCComboBoxSetCurrentItem(cmbFocus, 3)
		
		    guitk.BCShow(window)
		
		
		def cbReverseToggled(cb, state, btns):
		    btn1, btn2 = tuple(btns)
		    guitk.BCSetTabOrder(btn2, btn1) if state else guitk.BCSetTabOrder(btn1, btn2)
		    return 0
		
		
		def cmbFocusCurrentIndexChanged(cmb, index, widgets):
		    focusPolicy = eval("guitk.constants." + guitk.BCComboBoxCurrentText(cmb))
		    for widget in widgets:
		        guitk.BCSetFocusPolicy(widget, focusPolicy)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemRepaint(item: object) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	None

	"""

def BCListViewItemSetRenameEnabled(item: object, col: int, enable: int) -> None:

	"""

	Function is obsolete. Use BCListViewItemSetRenameType() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	enable : int
		set one of the possible values (for example, set to 0 to disable renaming).
		Possible values are :
		- 0 : no renaming (default).
		- 1 : double values are accepted.
		- 2 : integers are accepted.
		- 3 : anything goes.

	Returns
	-------
	None

	"""

def BCListViewItemColumnRenameType(item: object, col: int) -> int:

	"""

	Function is obsolete. Use BCListViewItemRenameType() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	Returns
	-------
	int
		the rename type of the column for in place edit :text, int, double, no renaming.
		Possible values are :
		- 0 : no renaming (default).
		- 1 : double values are accepted.
		- 2 : integers are accepted.
		- 3 : anything goes.

	"""

def BCListViewItemSetRadioButtonValueNoCallBack(item: object, col: int, check: int) -> None:

	"""

	Function is obsolete. Use BCBlockCallBackFunctions() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	check : int
		the new value.

	Returns
	-------
	None

	"""

def BCListViewItemSetCheckBoxValueNoCallBack(item: object, col: int, check: int) -> None:

	"""

	Function is obsolete. Use BCBlockCallBackFunctions() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	check : int
		the new value.

	Returns
	-------
	None

	"""

def BCListViewSetColumnAlwaysVisible(lv: object, col: int, visible: bool) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderMenuBlockColumnVisibilityChange() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	visible : bool
		set True for col to stay always visible or False to enable show/hide it.

	Returns
	-------
	None

	"""

def BCTextEditAppendMonoFont(te: object, txt: str) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	txt : str
		the text that the BCTextEdit will display.

	Returns
	-------
	None

	"""

def BCPopupMenuSetCheckable(pm: object, checkable: bool) -> None:

	"""

	Function is obsolete. Use BCPopupMenuSetItemCheckable() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the Menu.

	checkable : bool
		set 1 for checkable, 0 otherwise.

	Returns
	-------
	None

	"""

def BCTextEditSetTextFormat(te: object, bcf: int) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the TextEdit.

	bcf : int
		the format.

	Returns
	-------
	None

	"""

def BCButtonGroupSetFlat(bg: object, f: int) -> None:

	"""

	Function is obsolete. Use BCButtonGroupSetBorderMode() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	bg : object
		the BCButtonGroup.

	f : int
		set this parameter to 1 for no frame, 2 for flat mode, or 0 for full frame mode.

	Returns
	-------
	None

	"""

def BCListViewInsertToolButtonToHeader(lv: object, toolButton: object) -> None:

	"""

	Function is obsolete. Use BCListViewSetHeaderToolButton() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	toolButton : object
		the custom tool button to be incorporated.

	Returns
	-------
	None

	"""

def BCWizardSetPage(wiz: object, index: int, w: object) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the index of the page that will change.

	w : object
		the widget to be set as a page.

	Returns
	-------
	None

	"""

def BCListViewItemSetOpen(item: object, open: bool) -> None:

	"""

	Function is obsolete. Use BCListViewItemSetExpanded() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	open : bool
		set this parameter to True to expand item, or to False to collapse it.

	Returns
	-------
	None

	"""

def BCListViewItemIsOpen(item: object) -> bool:

	"""

	Function is obsolete. Use BCListViewItemIsExpanded() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that is checked.

	Returns
	-------
	bool
		True or False depending on the state of item.

	"""

def BCListViewItemGetCheckBoxValue(item: object, col: int) -> int:

	"""

	Function is obsolete. Use BCListViewItemCheckBoxIsChecked() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	Returns
	-------
	int
		1 if the checkBox at column col of ListViewItem item is checked, or 0 otherwise.

	"""

def BCListViewItemSetCheckBoxValue(item: object, col: int, check: int) -> None:

	"""

	Function is obsolete. Use BCListViewItemCheckBoxSetChecked() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	check : int
		the value to be set.

	Returns
	-------
	None

	"""

def BCListViewItemSetRadioButtonValue(item: object, col: int, check: int) -> None:

	"""

	Function is obsolete. Use BCListViewItemRadioButtonSetChecked() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	check : int
		1 to turn it on or 0 to turn it off.

	Returns
	-------
	None

	"""

def BCListViewItemGetRadioButtonValue(item: object, col: int) -> int:

	"""

	Function is obsolete. Use BCListViewItemRadioButtonIsChecked() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	Returns
	-------
	int
		1 if the radio button at column col of ListViewItem item is on, or 0 otherwise.

	"""

def BCListViewCount(lv: object) -> int:

	"""

	Function is obsolete. Use BCListViewTopLevelItemCount() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	int
		The number of top-level items in ListView lv.

	"""

def BCListViewItemCount(item: object) -> int:

	"""

	Function is obsolete. Use BCListViewItemChildCount() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem whose number of children will be counted.

	Returns
	-------
	int
		the number of immediate children of item.

	"""

def BCCheckListItemSetOn(item: object, on: bool) -> None:

	"""

	Function is obsolete. Use BCListViewItemCheckableSetOn() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	on : bool
		True sets item to checked, False sets it to unchecked.

	Returns
	-------
	None

	"""

def BCCheckListItemIsOn(item: object) -> bool:

	"""

	Function is obsolete. Use BCListViewItemCheckableIsOn() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	Returns
	-------
	bool
		True or False depending on the state of item.

	"""

def BCListViewAddCheckItem(lv: object, numCols: int, strl: object, rename: list) -> object:

	"""

	Function is obsolete. Use BCListViewItemSetCheckable() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	numCols : int
		the number of columns in lv.

	strl : object
		the strings that will be displayed in the new item.

	rename : list
		an array of integers denoting which column texts may be renamed. Possible
		values are:
		
			- 0 : no renaming (default).
			- 1 : double values are accepted.
			- 2 : integers are accepted.
			- 3 : anything goes.

	Returns
	-------
	object
		the created ListViewItem.

	"""

def BCListViewItemAddCheckItem(item: object, numCols: int, strl: object, rename: list) -> object:

	"""

	Function is obsolete. Use BCListViewItemSetCheckable() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the parent item where the new CheckListItem will be added.

	numCols : int
		the number of columns.

	strl : object
		the text that will be displayed for each column.

	rename : list
		an array on integers denoting which column texts may be renamed.
			- 0 : no renaming (default).
			- 1 : double values are accepted.
			- 2 : integers are accepted.
			- 3 : anything goes.

	Returns
	-------
	object
		The created ListViewItem.

	"""

def BCCheckListItemSetStateChangedFunction(item: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCListViewItemCheckableSetToggledFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the CheckListItem.

	funct : Callable
		the function that is called. See BC_LISTVIEWITEM_CHECKABLE_TOGGLED_FUNCTION for details.
		integer BC_LISTVIEWITEM_CHECKABLE_TOGGLED_FUNCTION(item, state, data)
		The function to be called when checkable ListViewItem item is checked or unchecked.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the checkable ListViewItem.
		          * state : int
		                    the toggle state information: 1 when the BCPushButton is on (i.e. toggled); 0 otherwise.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any user data required by function funct.

	Returns
	-------
	None

	"""

def BCListViewHeaderSetIcon(lv: object, col: int, filename: str) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderSetIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the header section of column where the icon will be set.

	filename : str
		the filename of the icon.

	Returns
	-------
	None

	"""

def BCListViewItemPixmap(item: object, col: int) -> bool:

	"""

	Function is obsolete. Use BCListViewItemHasIcon() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column of the ListViewItem.

	Returns
	-------
	bool
		False if there is no pixmap (default) at column col, True otherwise.

	"""

def BCListViewItemButtonSetPixmapFile(item: object, col: int, pixFile: str) -> None:

	"""

	Function is obsolete. Use BCListViewItemButtonSetIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the button.

	col : int
		the column where the button is set.

	pixFile : str
		the filename of the pixmap.

	Returns
	-------
	None

	"""

def BCListViewItemButtonPixmapFile(item: object, col: int) -> str:

	"""

	Function is obsolete. Use BCListViewItemButtonIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem that contains the button.

	col : int
		the column where the button is set.

	Returns
	-------
	str
		the filename of the pixmap.

	"""

def BCRadioButtonSetPixmapFile(rb: object, iconname: str) -> None:

	"""

	Function is obsolete. Use BCRadioButtonSetIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the BCRadioButton.

	iconname : str
		the absolute path of the iconfile.

	Returns
	-------
	None

	"""

def BCComboBoxInsertItemPixmapFile(box: object, filename: str, text: str, index: int) -> None:

	"""

	Function is obsolete. Use BCComboBoxInsertItemIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	filename : str
		the absolute path of a PNG file.

	text : str
		the text that will be inserted.

	index : int
		the index at which text will be inserted (-1 to append).

	Returns
	-------
	None

	"""

def BCListViewItemSetPixmapFile(item: object, col: int, pixFile: str) -> None:

	"""

	Function is obsolete. Use BCListViewItemSetIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column of the ListViewItem.

	pixFile : str
		the absolute path to the PNG file that we want to use.

	Returns
	-------
	None

	"""

def BCTabWidgetSetTabIconFile(tw: object, w: object, iconname: str) -> None:

	"""

	Function is obsolete. Use BCTabWidgetSetTabIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget.

	w : object
		the page widget contained by the tab, in which the icon will be shown.

	iconname : str
		the absolute path of a PNG file . If you pass an empty string here, the icon (if any) will not show any more.

	Returns
	-------
	None

	"""

def BCWindowSetTitleBarIcon(win: object, iconName: str) -> None:

	"""

	Function is obsolete. Use BCWindowSetTitleBarIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	win : object
		the BCWindow.

	iconName : str
		the absolute path of the icon file.

	Returns
	-------
	None

	"""

def BCLabelSetPixmapFile(lab: object, iconname: str) -> None:

	"""

	Function is obsolete. Use BCLabelSetIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lab : object
		the BCLabel.

	iconname : str
		the absolute path of the icon file.

	Returns
	-------
	None

	"""

def BCButtonSetPixmapFile() -> None:

	"""

	Function is obsolete. Use BCButtonSetIconFileName() instead.
	This function is not supported under VR mode.

	Returns
	-------
	None

	"""

def BCButtonGetPixmapFile(b: object) -> str:

	"""

	Function is obsolete. Use BCButtonSetIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the button.

	Returns
	-------
	str

	"""

def BCButtonSetIconFile(b: object, iconname: str) -> None:

	"""

	Function is obsolete. Use BCButtonSetIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the button.

	iconname : str
		the iconname of a PNG file that exists in the images directory or the absolute filename of a PNG file.

	Returns
	-------
	None

	"""

def BCButtonAddIconFile(b: object, iconname: str, mode: int, state: int) -> None:

	"""

	Function is obsolete. Use BCButtonAddIconFileName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the toggle button.

	iconname : str
		the iconname of a PNG file that exists in the images directory or the absolute filename of a PNG file, that will be displayed under mode and state.

	mode : int
		the mode for which a pixmap is intended to be used. See BCEnumMode property for more details.
		
		guitk.constants BCEnumMode
		This enum type describes a Button's pixmap or a ListViewItem's mode.
		 - guitk.constants.BCNormalMode
		The user does not interact with the Button or the ListViewItem, but their functionality is available.
		 - guitk.constants.BCDisabledMode
		The user cannot interact with the Button.
		 - guitk.constants.BCActiveMode
		Button: The user mouse cursor is over button or button is pressed (only for ToolButtons).
		 - guitk.constants.BCSelectedMode
		Button: Display the pixmap when the item represented by the icon is selected.
		ListViewItem: The item is selected.

	state : int
		the state for which a pixmap is intended to be used. See BCEnumIconState property for more details.
		
		guitk.constants BCEnumIconState
		This enum describes the state for which a pixmap is intended to be used.
		 - guitk.constants.BCOffState
		Display the pixmap when a toggle button is in an "off" state (unpressed)
		 - guitk.constants.BCOnState
		Display the pixmap when a toggle buttons is in an "on" state (pressed)

	Returns
	-------
	None

	"""

def BCListViewSetResizeEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Function is obsolete. Use BCListViewSetColumnResizeEnabled() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	enable : bool
		True if the column should be allowed to be resized (the default), otherwise False.

	Returns
	-------
	None

	"""

def BCListViewHeaderAddToolTip(lv: object, col: int, tip: str) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderSetToolTip() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the header section for column col.

	tip : str
		the tooltip.

	Returns
	-------
	None

	"""

def BCListViewDisplayMessageInViewport(lv: object, message: str) -> None:

	"""

	Function is obsolete. Use BCListViewSetViewportText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	message : str
		the message to be displayed centered vertically and horizontally.

	Returns
	-------
	None

	"""

def BCListViewInfoBoxCreate(p: object, lv: object) -> object:

	"""

	Function is obsolete. Use BCItemViewStatusBarCreate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	lv : object
		the ListView for which the created ListInfoBox will display info.

	Returns
	-------
	object
		the created ListInfoBox.

	"""

def BCListViewInfoBoxUpdate(lv: object) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarUpdate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView that ItemViewInfoBox manages.

	Returns
	-------
	None

	"""

def BCListViewInfoBoxSetManualUpdateEnabled(lv: object, fieldIndex: int, enable: bool) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarBlockAutoUpdates() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView that ItemViewInfoBox manages.

	fieldIndex : int
		set 0 to manually update left most field, 1 for the middle one and 2 for the field on the right.

	enable : bool
		set True for manual updates or False for auto updates.

	Returns
	-------
	None

	"""

def BCListViewInfoBoxSetMessage(lv: object, fieldIndex: int, message: str) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarSetText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView that ItemViewInfoBox manages.

	fieldIndex : int
		set 0 for the left most field, 1 for the middle one and 2 for the field on the right.

	message : str
		the message to be displayed.

	Returns
	-------
	None

	"""

def BCListViewInfoBoxSetHierarchy(info: object, hierarchy: bool) -> None:

	"""

	Function is obsolete. Use BCItemViewStatusBarSetTotalCounterMode() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	info : object
		the ItemViewInfoBox.

	hierarchy : bool
		set True to count all items of hierarchical ListViews or False for top-level items.

	Returns
	-------
	None

	"""

def BCListViewSetColumnMenuVisibilityChangeEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderMenuBlockColumnVisibilityChange() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	enable : bool
		set False for col to block visibility change or True (default) to enable show/hide it.

	Returns
	-------
	None

	"""

def BCListViewSetColumnMenuAlternativeName(lv: object, col: int, altName: str) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderSetStringRepresentation() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	altName : str
		the alternative name to be shown in column menu.

	Returns
	-------
	None

	"""

def BCListViewShowColumnMenuButton(lv: object, show: bool) -> None:

	"""

	Function is obsolete. Use BCListViewSetHeaderMenuColumnVisibilityChangeEnabled() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	show : bool
		set this parameter to True to show the column button, or False to hide it.

	Returns
	-------
	None

	"""

def BCListViewColumnMenuButtonIsShown(lv: object) -> bool:

	"""

	Function is obsolete. Use BCListViewSetHeaderMenuColumnVisibilityChangeEnabled() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	bool
		True if button is visible or False otherwise.

	"""

def BCListViewSetColumnMenu(lv: object, pm: object) -> None:

	"""

	Function is obsolete. Use BCListViewSetColumnVisibilityChangeMenu() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	pm : object
		the custom menu to replace the default one.

	Returns
	-------
	None

	"""

def BCListViewSetColumnMenuAddItemEnabled(lv: object, enable: bool, funct: Callable, data: Any=None) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	enable : bool
		set this parameter to True to enable adding columns to ListView t, or to False to disable it.

	funct : Callable
		is a function that will be called when the user presses the enter key in the LineEdit. See BC_LISTVIEW_ADD_COLUMN_MENU_FUNCTION for details.
		integer BC_LISTVIEW_ADD_COLUMN_MENU_FUNCTION(lv, newCol, name, data)
		The function to be called when the user presses the enter key in the BCLineEdit of the popup menu.
		This means when the user has finished entering a name for the new column. 
		This function can be used to check if the name entered is applicable to the listview or not. If it returns 1, the name is applicable and the column is added to the right side of the listview, otherwise the name is not applicable and the operation is cancelled.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * newCol : int
		                    the index of the new column.
		          * name : str
		                    the name for the new column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	"""

def BCListViewSetReturnPressedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCListViewSetEnterPressedFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_ENTER_PRESSED_FUNCTION for details.
		integer BC_LISTVIEW_ENTER_PRESSED_FUNCTION(lv, item, data)
		The function to be called when the Enter (or Return) keyboard button is pressed on a ListView or a BCIconView.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView or the BCIconView.
		          * item : object
		                    the current item.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 0 to block the event otherwise return 1.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	"""

def BCListViewHeaderSetLabel(lv: object, col: int, text: str) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderSetText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the header section for column.

	text : str
		the text that will be displayed.

	Returns
	-------
	None

	"""

def BCListViewHeaderGetLabel(lv: object, col: int) -> str:

	"""

	Function is obsolete. Use BCListViewHeaderGetText() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the header section for column of which the label is required.

	Returns
	-------
	str
		the label of the header of lv at col.

	"""

def BCListViewHeaderHide(lv: object) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderSetVisible() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	None

	"""

def BCListViewHeaderShow(lv: object) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderSetVisible() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView whose header we want to show.

	Returns
	-------
	None

	"""

def BCListViewSetCurrentChangedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCListViewSetCurrentItemChangedFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called when current item has changed.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	"""

def BCListViewItemOkRename(item: object, col: int) -> None:

	"""

	Function is obsolete. Use BCListViewAcceptRename() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	Returns
	-------
	None

	"""

def BCListViewItemStartRename(item: object, col: int) -> None:

	"""

	Function is obsolete. Use BCListViewStartRename() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column.

	Returns
	-------
	None

	"""

def BCListViewSetResizeMode(lv: object, mode: int) -> None:

	"""

	Function is obsolete. Use BCListViewSetColumnResizeMode() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	mode : int
		the column resize mode. See BCEnumColumnResizeMode for details.
		
		guitk.constants BCEnumColumnResizeMode
		This enum type describes how the columns of a list view adjust to resize events on the width of the list.
		 - guitk.constants.BCNoColumn
		The columns are not resized when listview width change.
		Horizontal scrollbar will be shown when items content is too large to fit.
		 - guitk.constants.BCAllColumns
		Columns automatically and equally resize to fill the available viewport width.
		Columns width cannot be changed by the user or programmatically.
		Horizontal scrollbar will be never shown.
		 - guitk.constants.BCLastColumn
		Last column automatically resize to fill the available viewport width.
		Horizontal scrollbar will be never shown.

	Returns
	-------
	None

	"""

def BCListViewItemExists(lv: object, col: int, text: str) -> bool:

	"""

	Function is obsolete. Use BCListViewTopLevelItemExists() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column.

	text : str
		the string that will be searched.

	Returns
	-------
	bool
		True if text is found within the ListView; False otherwise.

	"""

def BCListViewSetFilterAppliedFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCListViewSetFilterAboutToApplyFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function to be called when filter applied. See BC_LISTVIEW_FILTER_ABOUT_TO_APPLY_FUNCTION for details.
		integer BC_LISTVIEW_FILTER_ABOUT_TO_APPLY_FUNCTION(lv, data)
		The function to be called when filter is applied.
		Return 1 to block the default process otherwise return 0.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 to block the default process otherwise return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	"""

def BCListViewItemSetRenameStartedFunction(item: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCListViewItemSetAboutToRenameFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	funct : Callable
		the function that will be called. See BC_LISTVIEWITEM_ABOUT_TO_RENAME_FUNCTION for details.
		integer BC_LISTVIEWITEM_ABOUT_TO_RENAME_FUNCTION(item, col, data)
		The function to be called when renaming of a column of item starts.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * item : object
		                    the ListViewItem.
		          * col : int
		                    the ListViewItem column.
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 to cancel the rename action, or 0 to proceed.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	"""

def BCListViewSetSortingFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCListViewSetItemsSortedFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		is a function that will be called when the user mouse click on the column header. See BC_LISTVIEW_ITEMS_SORTED_FUNCTION for details.
		integer BC_LISTVIEW_ITEMS_SORTED_FUNCTION(lv, col, ascending, data)
		The function to be called right after items sorted into the list (for example mouse click at a column header).
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * col : int
		                    the ListView column.
		          * ascending : int
		                    1 for ascending and 0 for descending order.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	"""

def BCListViewHeaderPopupSetFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderMenuSetAboutToShowFunction() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called when right mouse button pressed. See BC_LISTVIEW_HEADER_MENU_ABOUTTOSHOW_FUNCTION for details.
		integer BC_LISTVIEW_HEADER_MENU_ABOUTTOSHOW_FUNCTION(lv, pm, col, data)
		The function to be called when mouse right button pressed to the header of ListView lv.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * pm : object
		                    the provided pull down menu.
		          * col : int
		                    the ListView column. .
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	None

	"""

def BCListViewHeaderPopupShowPopupUnderColumn(lv: object, show: bool) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderMenuPopupBelowHeader() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	show : bool
		set True for showing the header popup immediately under the column header, or False for showing it on mouse cursor's position.

	Returns
	-------
	None

	"""

def BCListViewHeaderPopupSetRenameEnabled(lv: object, col: int, enable: bool) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderMenuSetRenameColumnEnabled() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	enable : bool
		If enable is set to True, then the first item after the custom ones, of the returned Menu will be an item having text "Rename", with which it is possible to rename the section of the header clicked.

	Returns
	-------
	None

	"""

def BCListViewHeaderPopupSetCopyDisabled(lv: object, col: int, disable: bool) -> None:

	"""

	Function is obsolete. Use BCListViewHeaderMenuSetCopyEnabled() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the header section for column col.

	disable : bool
		If disable is set to True, then the 'Copy column' and 'Copy selected in column' items, of the returned Menu will not be shown. Otherwise these items will be shown (the default).

	Returns
	-------
	None

	"""

def BCRadioButtonSetPressFunction(rb: object, funct: Callable, data: Any=None) -> None:

	"""

	Function is obsolete. Use BCRadioButtonCreate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	rb : object
		the BCRadioButton.

	funct : Callable
		the function that will be called when the BCRadioButton is pressed. See BC_RADIOBUTTON_PRESS_FUNCTION for details.
		integer BC_RADIOBUTTON_PRESS_FUNCTION(rb, data)
		The function to be called when an existing BCRadioButton is pressed.
		 DEPRECATED: Do not use this callback.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * rb : object
		                    the BCRadioButton.
		          * data : Any
		                    anything that may be required by the function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		anything that may be required in funct.

	Returns
	-------
	None

	"""

def BCListViewHeaderMenuPopupBelowHeader(lv: object, below: bool) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	below : bool
		set True for showing the header popup immediately under the column header, or False for showing it on mouse cursor's position.

	Returns
	-------
	None

	"""

def BCMessageWindowAddExtraButton(messageWindow: object, text: str, returnedValue: int) -> None:

	"""

	Function is obsolete. Use BCMessageWindowSetExtraButton() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	text : str
		the text of button.

	returnedValue : int
		the value that will be returned from BCMessageWindowExecute() if extra button pressed.

	Returns
	-------
	None

	"""

def BCPlotModelItemName(plotItem: object) -> str:

	"""

	Function is obsolete. Use BCPlotModelCurveName() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	plotItem : object
		the Curve.

	Returns
	-------
	str
		the name of plotItem.

	"""

def BC3DBarChartPlotModelItemCreate(chart: object, name: str, x: list, y: list, z: list, pointsCount: int, r: int, g: int, b: int) -> object:

	"""

	Function is obsolete. Use BC3DBarChartPlotModelCurveCreate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	chart : object
		the BCPlot3DBar.

	name : str
		the name of plot item.

	x : list
		the array of x values.

	y : list
		the array of y values.

	z : list
		the array of z values.

	pointsCount : int
		the number of points.

	r : int
		the red value.

	g : int
		the green value.

	b : int
		the blue value.

	Returns
	-------
	object
		the created bar item.

	"""

def BCListViewItemComboBoxSetCurrentItemIntActivatedFunction(item: object, col: int, id: int) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column where comboBox is found.

	id : int
		the id of the item to which current will be set.

	Returns
	-------
	None

	"""

def BCWidgetExpandManagedWidget(wex: object) -> object:

	"""

	Function is obsolete. Use BCWidgetExpandGetWidget() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	wex : object
		the WidgetExpand.

	Returns
	-------
	object
		the widget controlled by wex.

	"""

def BCListViewItemComboBoxSetCurrentItemActivatedFunction(item: object, col: int, index: int) -> None:

	"""

	Function is obsolete. Use BCListViewItemComboBoxSetCurrentItemExecuteActivatedCallBack() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column where comboBox is found.

	index : int
		the index of the item to which current will be set.

	Returns
	-------
	None

	"""

def BCComboBoxSetCurrentItemActivatedFunction(box: object, index: int) -> None:

	"""

	Function is obsolete. Use BCComboBoxSetCurrentItemExecuteActivatedCallBack() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	index : int
		the index of the item to which current will be set.

	Returns
	-------
	None

	"""

def BCListViewBlockCallBackFunctions(lv: object, block: bool) -> None:

	"""

	Function is obsolete. Use BCBlockCallBackFunctions() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	block : bool
		True to block all call back functions of ListView, ListViewItem and ListViewFilter, or False to un-block (default).

	Returns
	-------
	None

	"""

def BCListViewCallBackFunctionsBlocked(lv: object) -> bool:

	"""

	Function is obsolete. Use BCCallBackFunctionsBlocked() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	bool
		True if call back functions are blocked, False otherwise.

	"""

def BCComboBoxBlockCallBackFunctions(cb: object, block: int) -> None:

	"""

	Function is obsolete. Use BCBlockCallBackFunctions() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	cb : object
		the BCComboBox.

	block : int
		set 1 to block all callback functions of BCComboBox; 0 otherwise.

	Returns
	-------
	None

	"""

def BCComboBoxCallBackFunctionsBlocked(cb: object) -> int:

	"""

	Function is obsolete. Use BCCallBackFunctionsBlocked() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	cb : object
		the BCComboBox.

	Returns
	-------
	int
		1 if call back functions are blocked; 0 otherwise.

	"""

def BCLineEditBlockCallBackFunctions(le: object, block: bool) -> None:

	"""

	Function is obsolete. Use BCBlockCallBackFunctions() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	block : bool
		set 1 to block all callback functions of BCLineEdit; 0 otherwise.

	Returns
	-------
	None

	"""

def BCLineEditCallBackFunctionsBlocked(le: object) -> bool:

	"""

	Function is obsolete. Use BCCallBackFunctionsBlocked() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	bool
		1 if call back functions are blocked; 0 otherwise.

	"""

def BCListViewSetDateFormat(lv: object, format: str, sep: str) -> None:

	"""

	Function is not supported. For more info, please contact Customer Service department.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	format : str
		supported date formats are 
		- d : day as number (1 to 31),
		- dd : day as number with leading zero (01 to 31),
		- ddd : the sort localized day name (Mon to Sun),
		- M : the month as number (1 to 12)
		- MM : the month as number with leading zero (01 to 12)
		- MMM : the sort localized month name (Jan to Dec),
		- yy : the year as two digit number (00-99),
		- yyyy : the year as four digit number,
		For example the 18th day of March 2014 can be displayed as 18-3-2010, 3-18-2010 or 18-Mar-2010 etc.

	sep : str
		the separator can also be specified in the format string (format).

	Returns
	-------
	None

	"""

def BCDrawerGridInsertStableWidget(dg: object, w: object) -> None:

	"""

	Function is obsolete. Use BCDrawerGridSetStableWidget() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	dg : object
		the BCDrawerGrid.

	w : object
		the widget to be inserted.

	Returns
	-------
	None

	"""

def BCComboBoxSetSizeLimit(box: object, limit: int) -> None:

	"""

	Function is obsolete. Use BCComboBoxSetMaxVisibleItems() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	box : object
		the BCComboBox.

	limit : int
		the limit of line number to be displayed.

	Returns
	-------
	None

	"""

def BCListViewFilterSetFixedOptionIconFileNames(lv: object, col: int, fileNames: object) -> None:

	"""

	Function is obsolete. Use BCListViewSetPredefinedContentsIconFileNames() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	fileNames : object
		the icon file names (absolute or relative) None terminated.

	Returns
	-------
	None

	"""

def BCWindowFlash(wid: object) -> None:

	"""

	Function is obsolete. Use BCFlash() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	wid : object
		the Window.

	Returns
	-------
	None

	"""

def BCFrameFlash(f: object) -> None:

	"""

	Function is obsolete. Use BCFlash() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	f : object
		the BCFrame.

	Returns
	-------
	None

	"""

def BCPopupMenuSetItemCurrent(pm: object, id: int) -> None:

	"""

	Makes current and highlights the item with id id.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	id : int
		the id of the item to become current. If id is invalid nothing will happen.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Popup Set Current Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Item 0", None, None)
		    item1 = guitk.BCPopupMenuInsertItem(popupMenu, "Item 1", None, None)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Item 2", None, None)
		    # Notice that when opening the popup, Item 1 is selected
		    guitk.BCPopupMenuSetItemCurrent(popupMenu, item1)
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCPopupMenuWidgetItemId(pm: object, w: object) -> int:

	"""

	Returns the id of the item to which widget w has been inserted, or -1 otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	pm : object
		the BCMenu.

	w : object
		the widget that will be checked.

	Returns
	-------
	int
		the id of item with widget w, or -1 otherwise.

	See Also
	--------
	BCPopupMenuItemId

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "PopupMenu Items Activated Example", guitk.constants.BCOnExitDestroy
		    )
		    btn = guitk.BCPushButtonCreate(window, "Push me", None, None)
		    popupMenu = guitk.BCPopupMenuCreate(btn)
		    guitk.BCButtonSetPopup(btn, popupMenu)
		    lineEdit = guitk.BCLineEditCreate(popupMenu, "")
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Press Enter twice")
		    guitk.BCAddToolTip(
		        lineEdit,
		        "Widgets inside PopupMenu are activated by pressing Enter while they have focus",
		    )
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, editingFinished, None)
		    guitk.BCPopupMenuInsertWidget(popupMenu, lineEdit)
		    guitk.BCPopupMenuSetItemCheckable(
		        popupMenu,
		        guitk.BCPopupMenuInsertItem(popupMenu, "Toggle Item", None, None),
		        True,
		    )
		    guitk.BCPopupMenuSetHideOnCheckEnabled(popupMenu, False)
		    for i in range(5):
		        guitk.BCPopupMenuInsertItem(popupMenu, "Item" + str(i), None, None)
		    guitk.BCPopupMenuSetActivatedFunction(popupMenu, printItem, lineEdit)
		    guitk.BCShow(window)
		
		
		def editingFinished(lineEdit, data):
		    print("LineEditEditingFinished Activated.")
		    return 0
		
		
		def printItem(popupMenu, id, widget):
		    if id == guitk.BCPopupMenuItemId(popupMenu, "Toggle Item"):
		        guitk.BCPopupMenuSetItemChecked(
		            popupMenu, id, not guitk.BCPopupMenuIsItemChecked(popupMenu, id)
		        )
		        print("Toggle Item Activated.")
		    elif id == guitk.BCPopupMenuWidgetItemId(popupMenu, widget):
		        print("Widget Activated.")
		    else:
		        print(guitk.BCPopupMenuText(popupMenu, id) + " Activated.")
		        guitk.BCPopupMenuClose(popupMenu)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCApplicationProcessNonUserInputEvents() -> None:

	"""

	Processes pending events for the calling thread (normally the main/GUI thread) or until there are no more events to process, whichever is shorter.
	You can call this function occasionally when your program is busy performing a long operation (e.g. copying a file).
	This function is useful when you are doing graphical changes while performing a heavy job and you want to visualize these changes immediately.
	E.g. when you want to update a BCProgressBar while performing a heavy calculation or importing a large file.
	WARNING: Your loop may become slower if you decide to process pending events several times. Call this function with caution, as few times as possible.
	NOTE: This function will not process any user input events, e.g. moving or resizing windows, writing in a BCTextEdit, mouse clicks on buttons etc
	This function is not supported under VR mode.

	Returns
	-------
	None

	Examples
	--------
	::

		import sdm
		from sdm import guitk
		
		
		def main():
		    global script_ended
		    script_ended = False
		
		    w = guitk.BCWindowCreate("w", guitk.constants.BCOnExitDestroy)
		    b = guitk.BCPushButtonCreate(w, "Process Job", None, 0)
		    pb = guitk.BCProgressBarCreate(w, 100)
		    guitk.BCButtonSetClickedFunction(b, process_heavy_job, pb)
		
		    guitk.BCShow(w)
		
		
		def process_heavy_job(b, pb):
		    iterations = 1000
		    div = iterations // 100
		
		    for i in range(iterations):
		        do_something(i)
		
		        if i % (div) == 0:
		            print(i // div)
		
		            guitk.BCProgressBarSetProgress(pb, i // div)
		            guitk.BCApplicationProcessNonUserInputEvents()
		
		
		def do_something(i):
		    iter2 = 100
		    for j in range(iter2):
		        print(j + i * 10000)
		    return
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewGetSelectedItem(lv: object) -> object:

	"""

	Returns the single selected item from ListView lv (only one item is selected), otherwise returns None.
	You will get None if more than one items are selected.
	NOTE: This function is much faster than running a loop to find the selected item.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	object
		the selected item.

	See Also
	--------
	BCListViewSetSelected

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "List View Set Date Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", "At Date"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		
		    hBox = guitk.BCHBoxCreate(window)
		    atDateEdit = guitk.BCDateEditCreate(hBox)
		    btnSetDate = guitk.BCPushButtonCreate(
		        hBox, "Set Selected Date", setDate, (listView, atDateEdit)
		    )
		    guitk.BCWindowSetAcceptFunction(window, lambda window, data: 0, None)
		    guitk.BCShow(window)
		
		
		def setDate(btn, data):
		    listView, dateEdit = data
		    item = guitk.BCListViewGetSelectedItem(listView)
		    if item:
		        guitk.BCListViewItemSetDate(
		            item,
		            4,
		            guitk.BCDateEditGetYear(dateEdit),
		            guitk.BCDateEditGetMonth(dateEdit),
		            guitk.BCDateEditGetDay(dateEdit),
		        )
		        guitk.BCListViewAdjustColumn(listView, 4)
		    else:
		        print("Please select an item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWindowCaptionReject(caption: str) -> bool:

	"""

	Calls the reject function of the BCWindow with caption.
	If no custom accept function has been set, a default one will be called.
	Normally this function is called when we press the 'Cancel' button to close the BCWindow.
	This function is not supported under VR mode.

	Parameters
	----------
	caption : str
		the caption (title) of the BCWindow whose reject function will be called.

	Returns
	-------
	bool

	See Also
	--------
	BCWindowReject

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Window Callbacks Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCHBoxCreate(window)
		    guitk.BCSpacerCreate(hBox)
		    labelOnClose = guitk.BCLabelCreate(hBox, "onCloseFunction")
		    guitk.BCLabelSetAlignment(
		        labelOnClose, guitk.constants.BCAlignTop | guitk.constants.BCAlignRight
		    )
		    labelArrow = guitk.BCLabelCreate(hBox, "")
		    guitk.BCLabelSetIconFileName(labelArrow, "arrow_up_small.svg")
		    guitk.BCLabelSetAlignment(
		        labelArrow, guitk.constants.BCAlignTop | guitk.constants.BCAlignRight
		    )
		    hBoxReject = guitk.BCHBoxCreate(window)
		    lineEditCaption = guitk.BCLineEditCreate(hBoxReject, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineEditCaption, "Insert a Window Caption to reject eg. 'Properties'"
		    )
		    guitk.BCPushButtonCreate(hBoxReject, "Reject window", rejectWindow, lineEditCaption)
		    chkBoxCanBeAccepted = guitk.BCCheckBoxCreate(window, "Acceptable")
		    guitk.BCDialogButtonBoxCreate(window)
		    guitk.BCWindowSetCheckFunction(window, windowCheck, chkBoxCanBeAccepted)
		    guitk.BCWindowSetAcceptFunction(window, windowAccept, None)
		    guitk.BCWindowSetRejectFunction(window, windowReject, None)
		    guitk.BCWindowSetOnCloseFunction(window, windowClose, None)
		    guitk.BCShow(window)
		
		
		def rejectWindow(btn, lineEditCaption):
		    captionText = guitk.BCLineEditGetText(lineEditCaption)
		    print("Window '" + captionText + "' rejected")
		    guitk.BCWindowCaptionReject(captionText)
		    return 0
		
		
		def windowCheck(window, chkBox):
		    print("Window Check activated!")
		    return (
		        ""
		        if guitk.BCCheckBoxIsChecked(chkBox)
		        else "Check Acceptable CheckBox in order to accept this window"
		    )
		
		
		# Warning: Do NOT set both accept and reject function to return 0
		def windowAccept(window, data):
		    print("Window Accepted!")
		    return 1
		
		
		# Warning: Do NOT set both accept and reject function to return 0
		def windowReject(window, data):
		    print("Window Rejected!")
		    return 1
		
		
		def windowClose(window, data):
		    print("Window closed using the X button!")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCMessageWindowSetExtraButton(messageWindow: object, text: str, returnedValue: int) -> None:

	"""

	Adds a custom user button between the accept and reject buttons with text text.
	WARNING: Do NOT use the numbers 4, 66 or 68 for your custom return value, since they are used internally for OK, Cancel and QuitAll.
	This function is not supported under VR mode.

	Parameters
	----------
	messageWindow : object
		the BCMessageWindow.

	text : str
		the text of button.

	returnedValue : int
		the value that will be returned from BCMessageWindowExecute() if extra button pressed.

	Returns
	-------
	None

	See Also
	--------
	BCMessageWindowExecute

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Message Window Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCPushButtonCreate(window, "Click Me!", buttonPressedFunct, window)
		    guitk.BCPushButtonCreate(window, "Don't Click Me!", buttonPressedFunct, window)
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		
		    guitk.BCShow(window)
		
		
		def buttonPressedFunct(b, window):
		    text = guitk.BCButtonText(b)
		    message = "You Pressed button: " + text
		    if text == "Don't Click Me!":
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxCritical, message, False
		        )
		    else:
		        msgWindow = guitk.BCMessageWindowCreate(
		            guitk.constants.BCMessageBoxInformation, message, False
		        )
		    guitk.BCMessageWindowSetExtraButton(msgWindow, "Accept All", 10)
		    guitk.BCMessageWindowSetAcceptButtonVisible(msgWindow, False)
		    guitk.BCMessageWindowSetRejectButtonVisible(msgWindow, False)
		    answer = guitk.BCMessageWindowExecute(msgWindow)
		    if answer == 10:
		        print("Message Window: Accept All")
		        guitk.BCWindowAccept(window)
		    elif answer == guitk.constants.BCRetKey:
		        print("Message Window: Accept")
		    elif answer == guitk.constants.BCEscKey:
		        print("Message Window: Reject")
		    elif answer == guitk.constants.BCQuitAll:
		        print("Message Window: Quit All")
		    return 0
		
		
		def acceptFunction(window, data):
		    print("Main Window: Accept")
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardSetFinishButtonText(wiz: object, text: str) -> None:

	"""

	Customize the text for the finish button (default text is Finish).
	Avoid text that may confuse the user and conflict with standard buttons text, for example avoid text Back, Previous, Next, Cancel etc.
	Finish button will be visible when user navigates to the last Wizard page
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	text : str
		the new text.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCToolButtonSetSideArrowEnabled(b: object, enabled: bool) -> None:

	"""

	Sets whether a separated side arrow button is used when ToolButton provides a popup menu (default enabled).
	When side arrow is enabled the tool button displays a special arrow at the right side to indicate that a menu is present.
	When side arrow is not enabled the menu popups instant while the button's own action (click function) is not triggered.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the BCToolButton.

	enabled : bool
		set True to show or False to hide the down arrow.

	Returns
	-------
	None

	See Also
	--------
	BCButtonSetPopup

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    w = guitk.BCWindowCreate("Buttons", guitk.constants.BCOnExitDestroy)
		
		    # Although all Buttons can display a PopupMenu...
		    lay_menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 1x1", "mdi_windows_layout_1x1.svg", itemFunction
		    )
		    guitk.BCPopupMenuInsertItemWithIcon(
		        lay_menu, "Layout 2x1", "mdi_windows_layout_2x1.svg", itemFunction
		    )
		
		    menu_pbut = guitk.BCPushButtonCreate(w, "Layouts", None)
		    guitk.BCButtonSetIconFileName(menu_pbut, "mdi_windows_layout_2x2.svg")
		    guitk.BCButtonSetPopup(menu_pbut, lay_menu)
		
		    menu = guitk.BCPopupMenuCreate(w)
		    guitk.BCPopupMenuInsertItem(menu, "Item 1", itemFunction)
		    guitk.BCPopupMenuInsertItem(menu, "Item 2", itemFunction)
		
		    menu_tbut = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCToolButtonSetSideArrowEnabled(menu_tbut, False)
		    guitk.BCButtonSetPopup(menu_tbut, menu)
		
		    # Only BCToolButtons can display a PopupMenu through a separate sub-button,
		    # thus keeping their clicking / toggling functionality
		    toggling_but = guitk.BCToolButtonCreate(w, "filter.svg", "", None)
		    guitk.BCButtonSetToggleButton(toggling_but, True)
		    guitk.BCButtonSetToggledFunction(toggling_but, toggledFunction)
		    guitk.BCButtonSetPopup(toggling_but, menu)
		
		    guitk.BCShow(w)
		
		
		def itemFunction(pm, id, data):
		    print("Item " + str(id) + " clicked")
		    return 0
		
		
		def toggledFunction(b, state, data):
		    s = "off"
		    if state:
		        s = "on"
		    print("The button is now " + s)
		    return 0
		
		
		main()


	"""

def BCToolButtonIsSideArrowEnabled(b: object) -> bool:

	"""

	Returns True if separated side arrow button indicates that the menu is present, or False otherwise.
	When side arrow is not enabled the menu popups instant while the button's own action (click function) is not triggered.
	This function is not supported under VR mode.

	Parameters
	----------
	b : object
		the BCToolButton.

	Returns
	-------
	bool

	See Also
	--------
	BCToolButtonSetSideArrowEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "SideArrow and PopupIndicator Example", guitk.constants.BCOnExitDestroy
		    )
		
		    popupMenu = guitk.BCPopupMenuCreate(window)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Item 1", None, None)
		    guitk.BCPopupMenuInsertItem(popupMenu, "Item 2", None, None)
		
		    hBox0 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox0, "Default")
		    toolButtonDefault = guitk.BCToolButtonCreate(
		        hBox0, "filter.svg", "ToolButton", None, None
		    )
		    print(
		        "ToolButtonSideArrow Default = "
		        + str(guitk.BCToolButtonIsSideArrowEnabled(toolButtonDefault))
		    )
		    guitk.BCButtonSetPopup(toolButtonDefault, popupMenu)
		
		    hBox1 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox1, "No Side Arrow")
		    toolButtonNoSideArrow = guitk.BCToolButtonCreate(
		        hBox1, "filter.svg", "ToolButton", None, None
		    )
		    guitk.BCToolButtonSetSideArrowEnabled(toolButtonNoSideArrow, False)
		    guitk.BCButtonSetPopup(toolButtonNoSideArrow, popupMenu)
		
		    hBox2 = guitk.BCHBoxCreate(window)
		    guitk.BCLabelCreate(hBox2, "No Popup Indicator")
		    toolButtonNoPopupIndicator = guitk.BCToolButtonCreate(
		        hBox2, "filter.svg", "ToolButton", None, None
		    )
		    # False Popup Indicator has no Effect with Side Arrow Enabled
		    guitk.BCToolButtonSetSideArrowEnabled(toolButtonNoPopupIndicator, False)
		    guitk.BCToolButtonSetPopupIndicator(toolButtonNoPopupIndicator, False)
		    guitk.BCButtonSetPopup(toolButtonNoPopupIndicator, popupMenu)
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxSetItemEnabled(item: object, col: int, index: int, enable: bool) -> None:

	"""

	Sets whether the combobox item with index /a index is enabled. Standard combo box items are enabled.
	Disabled combo box items do not respond to user actions.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	index : int
		the index of drop menu item.

	enable : bool
		set 0 disable the combo box item or 1 to enable.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxIsItemEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Confirm Selected Assignee"], 0
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    addPart(listView, "1004", "Roof rack")
		    addPart(listView, "1005", "Spoiler")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createComboBoxes, listView
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createComboBoxes(item, listView):
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    comboBoxCol = 2
		    checkBoxCol = 3
		    guitk.BCListViewItemSetComboBox(
		        item, comboBoxCol, users, comboBoxActivatedFunct, checkBoxCol
		    )
		    guitk.BCListViewItemComboBoxInsertItem(item, comboBoxCol, "Select Assignee", 0)
		    guitk.BCListViewItemSetCheckBox(
		        item, checkBoxCol, False, assigneeConfirmedFunct, [listView, comboBoxCol]
		    )
		    guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		
		
		def comboBoxActivatedFunct(item, col, index, checkBoxCol):
		    isAvailable = guitk.BCListViewItemComboBoxIsItemEnabled(item, col, index)
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, col)
		    if not isAvailable or curText == "Select Assignee":
		        # Disable CheckBox if an assignee has been already confirmed or if no assignee is selected
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    else:
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, True)
		    return 0
		
		
		def assigneeConfirmedFunct(item, col, state, data):
		    listView = data[0]
		    comboBoxCol = data[1]
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, comboBoxCol)
		    guitk.BCListViewItemWidgetSetEnabled(item, comboBoxCol, not state)
		    guitk.BCListViewForEachItem(
		        listView,
		        guitk.constants.BCIterateAll,
		        checkAvailability,
		        [comboBoxCol, curText, item],
		    )
		    return 0
		
		
		def checkAvailability(item, data):
		    comboBoxCol = data[0]
		    text = data[1]
		    curItem = data[2]
		    itemText = guitk.BCListViewItemComboBoxCurrentText(item, comboBoxCol)
		    if not item == curItem:
		        index = guitk.BCListViewItemComboBoxIndexOf(item, comboBoxCol, text)
		        if guitk.BCListViewItemComboBoxIsItemEnabled(item, comboBoxCol, index):
		            # Disable confirmed assignee from other ComboBoxes
		            guitk.BCListViewItemComboBoxSetItemEnabled(item, comboBoxCol, index, False)
		            if itemText == text:
		                # If a confirmed assignee was current at an other ComboBox, reset value
		                guitk.BCListViewItemComboBoxSetCurrentItem(item, comboBoxCol, 0)
		        else:
		            # Enable unconfirmed assignee
		            guitk.BCListViewItemComboBoxSetItemEnabled(item, comboBoxCol, index, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxIsItemEnabled(item: object, col: int, index: int) -> int:

	"""

	Returns 1 in case the combobox item with index /a index is enabled (default enabled).
	NOTE: If there is no comboBox at item at column col, this function returns 0.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	index : int
		the index of drop menu item.

	Returns
	-------
	int
		1 in case the comboBox item in ListViewItem item, found in column col with index is enabled, 0 otherwise.

	See Also
	--------
	BCListViewItemComboBoxSetItemEnabled

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Assignee", "Confirm Selected Assignee"], 0
		    )
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    addPart(listView, "1004", "Roof rack")
		    addPart(listView, "1005", "Spoiler")
		    guitk.BCListViewForEachItem(
		        listView, guitk.constants.BCIterateAll, createComboBoxes, listView
		    )
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def createComboBoxes(item, listView):
		    users = ["Alexander", "David", "Sarah", "Helena", "Jose"]
		    comboBoxCol = 2
		    checkBoxCol = 3
		    guitk.BCListViewItemSetComboBox(
		        item, comboBoxCol, users, comboBoxActivatedFunct, checkBoxCol
		    )
		    guitk.BCListViewItemComboBoxInsertItem(item, comboBoxCol, "Select Assignee", 0)
		    guitk.BCListViewItemSetCheckBox(
		        item, checkBoxCol, False, assigneeConfirmedFunct, [listView, comboBoxCol]
		    )
		    guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		
		
		def comboBoxActivatedFunct(item, col, index, checkBoxCol):
		    isAvailable = guitk.BCListViewItemComboBoxIsItemEnabled(item, col, index)
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, col)
		    if not isAvailable or curText == "Select Assignee":
		        # Disable CheckBox if an assignee has been already confirmed or if no assignee is selected
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, False)
		    else:
		        guitk.BCListViewItemWidgetSetEnabled(item, checkBoxCol, True)
		    return 0
		
		
		def assigneeConfirmedFunct(item, col, state, data):
		    listView = data[0]
		    comboBoxCol = data[1]
		    curText = guitk.BCListViewItemComboBoxCurrentText(item, comboBoxCol)
		    guitk.BCListViewItemWidgetSetEnabled(item, comboBoxCol, not state)
		    guitk.BCListViewForEachItem(
		        listView,
		        guitk.constants.BCIterateAll,
		        checkAvailability,
		        [comboBoxCol, curText, item],
		    )
		    return 0
		
		
		def checkAvailability(item, data):
		    comboBoxCol = data[0]
		    text = data[1]
		    curItem = data[2]
		    itemText = guitk.BCListViewItemComboBoxCurrentText(item, comboBoxCol)
		    if not item == curItem:
		        index = guitk.BCListViewItemComboBoxIndexOf(item, comboBoxCol, text)
		        if guitk.BCListViewItemComboBoxIsItemEnabled(item, comboBoxCol, index):
		            # Disable confirmed assignee from other ComboBoxes
		            guitk.BCListViewItemComboBoxSetItemEnabled(item, comboBoxCol, index, False)
		            if itemText == text:
		                # If a confirmed assignee was current at an other ComboBox, reset value
		                guitk.BCListViewItemComboBoxSetCurrentItem(item, comboBoxCol, 0)
		        else:
		            # Enable unconfirmed assignee
		            guitk.BCListViewItemComboBoxSetItemEnabled(item, comboBoxCol, index, True)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionCreate(p: object, name: str, funct: Callable, data: Any=None) -> object:

	"""

	Creates an BCAction object with parent p, a name name and a callback function fun with data data.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	name : str
		the object name of the action and the text that will be displayed in widgets added with BCActionAddWidget(), together with the shortcut combination set with BCActionSetShortcut().

	funct : Callable
		the function that will be called when the created BCAction is triggered. See
		BC_ACTION_CALLBACK_FUNCTION for details.
		integer BC_ACTION_CALLBACK_FUNCTION(action, data)
		The function to be called when a BCAction is triggered.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * action : object
		                    the BCAction.
		          * data : Any
		                    anything that may be required in function.
		
		Return: Reserved for future use. We recommend you always return 0.

	data : Any, optional
		any data required by funct.

	Returns
	-------
	object
		the created BCAction.

	See Also
	--------
	BCActionAddWidget

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionSetCheckable(action: object, checkable: bool) -> None:

	"""

	Makes BCAction action checkable or uncheckable.
	A checkable action supports on/off states. By default, a BCAction is not checkable.
	Note that the callback of a checkable BCAction will be triggered after the checked state is changed manually (e.g. by pressing a BCPushButton added to BCAction), but not by calling BCActionSetChecked().
	Also, BCActionTrigger() will change the checked state of a checkable BCAction.
	This function is not supported under VR mode.

	Parameters
	----------
	action : object
		the BCAction.

	checkable : bool
		set this parameter to True to give a checkable property to action or False to remove it.

	Returns
	-------
	None

	See Also
	--------
	BCActionIsCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionIsCheckable(action: object) -> bool:

	"""

	Returns True if the BCAction is checkable or False otherwise.
	This function is not supported under VR mode.

	Parameters
	----------
	action : object
		the BCAction.

	Returns
	-------
	bool
		True if the action is checkable or False otherwise.

	See Also
	--------
	BCActionSetCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionSetChecked(action: object, check: bool) -> None:

	"""

	Changes the checked (on/off) state of BCAction action, if it is checkable.
	It will also change the checked state of any widget added to action
	Note that the callback of action will not be triggered. Also, this function will do nothing if action is not checkable.
	This function is not supported under VR mode.

	Parameters
	----------
	action : object
		the BCAction.

	check : bool
		set this parameter to True to check (set on) action or False to uncheck it.

	Returns
	-------
	None

	See Also
	--------
	BCActionSetCheckable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionIsChecked(action: object) -> bool:

	"""

	Returns the current checked state of BCAction. If action is not checkable this function will always return  False .
	This function is not supported under VR mode.

	Parameters
	----------
	action : object
		the BCAction.

	Returns
	-------
	bool
		True if currently the action is checked or False otherwise.

	See Also
	--------
	BCActionSetChecked

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionTrigger(action: object) -> None:

	"""

	Executes the callback function of action, set with BCActionCreate().
	If action is checkable, its checked state will also change, along with the check state of any widget added to it.
	This function is not supported under VR mode.

	Parameters
	----------
	action : object
		the BCAction.

	Returns
	-------
	None

	See Also
	--------
	BCActionCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionSetShortcut(action: object, key: str) -> bool:

	"""

	Sets shortcut key to action.
	A shortcut key is a combination of keyboard buttons (e.g. Ctrl+O), which on press, they will trigger the BCAction.
	Note that shortcut keys set with this function will have a global (application-wide) scope.
	You cannot assign the same shortcut key to different actions. If you do so the shortcut key will first be removed by the previous action.
	In case the shortcut key was already used by an application non-script action, it will be assigned back to it when the script ends.
	This function is not supported under VR mode.

	Parameters
	----------
	action : object
		the BCAction.

	key : str
		the shortcut key. Valid shortcut keys are composed by:
		- one or more modifier keys: Ctrl, Alt, Shift, Meta (i.e. the Win key)
		- one and only one key: [0,9], [A,Z], [F1,F12], Space, Insert, Delete, Home, End, Page Up, Page Down, Left, Up, Right, Down (arrow keys)
		Syntax: &lt;Modifier&gt;[+&lt;Modifier&gt;+&lt;Modifier&gt;]+Key. Exception to this rule are the [F1,F12] keys, which can also be used without a modifier.
		Examples: "Ctrl+P", "Ctrl+Alt+Space", "F2"

	Returns
	-------
	bool
		True if shortcut key is valid and set successfully to action or False otherwise.

	See Also
	--------
	BCActionTrigger

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCActionAddWidget(action: object, widget: object) -> bool:

	"""

	Adds widget under the control of action.
	This means that:

	- The widget will call the action's callback. If a function was already set to the widget, it will be replaced.
	- The widget will adopt the checkable property of action and follow its checked state.
	- The action's tooltip will be set to the widget, displaying the name and any shortcut that was set.
	WARNING: The widget cannot have any functionality that BCAction cannot handle. For example, a BCPopupMenu added to the widget, will be removed after action takes control of it.
	This function is not supported under VR mode.

	Parameters
	----------
	action : object
		the BCAction.

	widget : object
		the widget to add to action's control. Supported widgets are:
		- BCPushButton
		- BCToolButton
		- BCCheckBox

	Returns
	-------
	bool
		True if widget was added successfully to action or False otherwise.

	See Also
	--------
	BCActionTrigger

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Action", guitk.constants.BCOnExitDestroy)
		    action = guitk.BCActionCreate(window, "Action", onAction, None)
		    shortcut = guitk.BCActionSetShortcut(action, "Ctrl+A")
		    if shortcut:
		        print("Shortcut was set successfully")
		    else:
		        print("Shortcut was not set successfully")
		
		    pBtn = guitk.BCPushButtonCreate(window, "Trigger Action", None, None)
		    # Widget under control of action
		    guitk.BCActionSetCheckable(action, True)
		    guitk.BCActionTrigger(action)
		    guitk.BCActionSetChecked(action, False)
		
		    if guitk.BCActionIsCheckable(action):
		        print("Action is Checkable")
		    widget = guitk.BCActionAddWidget(action, pBtn)
		    if widget:
		        print("Widget was added successfully to action")
		    else:
		        print("Widget was not added successfully to action")
		
		    guitk.BCShow(window)
		
		
		def onAction(action, data):
		    print("Action Happened")
		    state = "Off"
		    if guitk.BCActionIsChecked(action):
		        state = "On"
		    print("Current state of Action is: " + state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetItemCompareFunction(lv: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function that will be called during items get sorted inside the ListView.
	Use this function for custom sorting. This function will only run if sorting is enabled.
	NOTE: This function will run multiple times during sorting (avoid complex calculations in here). For example if you have four items A, B, C and D, the function will run 6 times.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	funct : Callable
		the function that will be called. See BC_LISTVIEW_ITEM_COMPARE_FUNCTION for details.
		integer BC_LISTVIEW_ITEM_COMPARE_FUNCTION(lv, item, other, col, ascOrder, data)
		The function that enables custom sorting in list view items.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * lv : object
		                    the ListView.
		          * item : object
		                    the ListViewItem currently compared.
		          * other : object
		                    the other ListViewItem currently compared with.
		          * col : int
		                    the ListViewItem column index where sorting takes place.
		          * ascOrder : int
		                    the sorting order (1 when ascending, 0 when descending).
		          * data : Any
		                    anything that may be required in function.
		
		Return: 1 if item is less than other, -1 if item is NOT less than other or 0 for default implementation.

	data : Any, optional
		any data required by function funct.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetItemsSortedFunction

	"""

def BCLineEditSetPlaceholderText(le: object, text: str) -> None:

	"""

	Set the message to display when le is empty and does not have keyboard focus.
	When the user sets focus inside line edit info dissapears. If you want to remove the info set an empty text.

	Parameters
	----------
	le : object
		the BCLineEdit.

	text : str
		the message.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditGetPlaceholderText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example LineEdit", guitk.constants.BCOnExitDestroy)
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    guitk.BCLabelCreate(hl, "LineEdit")
		    lineedit = guitk.BCLineEditCreate(hl, "")
		    guitk.BCLineEditSetPlaceholderText(
		        lineedit, "This is a LineEdit. Give an input or press F1"
		    )
		    guitk.BCLineEditSetEnterPressedFunction(lineedit, enterpressedFunction, None)
		
		    optionsHL = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    readonlyCB = guitk.BCCheckBoxCreate(optionsHL, "Read Only")
		    guitk.BCCheckBoxSetToggledFunction(readonlyCB, readonlyFunction, lineedit)
		    alignrightCB = guitk.BCCheckBoxCreate(optionsHL, "Align Right")
		    guitk.BCCheckBoxSetToggledFunction(alignrightCB, alignrightFunction, lineedit)
		    maximumlengthCB = guitk.BCCheckBoxCreate(optionsHL, "Maximum Length")
		    guitk.BCCheckBoxSetToggledFunction(maximumlengthCB, maximumwidthFunction, lineedit)
		    guitk.BCLineEditSetF1Function(lineedit, f1buttonPressed, None)
		    guitk.BCLineEditSetF2Function(lineedit, f2buttonPressed, None)
		    guitk.BCLineEditSetF3Function(lineedit, f3buttonPressed, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def readonlyFunction(cb, state, data):
		    guitk.BCLineEditSetReadOnly(data, state)
		    return 0
		
		
		def alignrightFunction(cb, state, data):
		    if state:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignRight)
		    else:
		        guitk.BCLineEditSetAlignment(data, guitk.constants.BCAlignLeft)
		    return 0
		
		
		def enterpressedFunction(le, data):
		    print("Current text is:" + guitk.BCLineEditGetText(le))
		    return 0
		
		
		def f1buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F1 Button was pressed. ")
		    return 0
		
		
		def f2buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F2 Button was pressed. ")
		    return 0
		
		
		def f3buttonPressed(le, data):
		    guitk.BCLineEditSetText(le, "F3 Button was pressed. ")
		    return 0
		
		
		def maximumwidthFunction(cb, state, data):
		    if state:
		        maxlength = 10
		    else:
		        maxlength = 40
		    guitk.BCLineEditSetMaxLength(data, maxlength)
		    print("Max Length is: " + str(maxlength))
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCLineEditGetPlaceholderText(le: object) -> str:

	"""

	Returns the info message (when is empty and does not have keyboard focus) that is displayed in le or None if no info set.

	Parameters
	----------
	le : object
		the BCLineEdit.

	Returns
	-------
	str
		the text displayed as info.

	See Also
	--------
	BCLineEditSetPlaceholderText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    boxLayoutBtns = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "This is the current text of LineEdit."
		    )
		    guitk.BCLineEditSetPlaceholderText(lineEdit, "Write something here.")
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_left_16.png",
		        "Move Cursor Left",
		        moveCursorLeftFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "align_right_16.png",
		        "Move Cursor Right",
		        moveCursorRightFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns,
		        "info_small.svg",
		        "Get info(Holder) as text",
		        getInfoFunction,
		        lineEdit,
		    )
		    guitk.BCToolButtonCreate(
		        boxLayoutBtns, "clean_small.svg", "Clean LineEdit", clearFunction, lineEdit
		    )
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def clearFunction(toolBtn, lineEdit):
		    if guitk.BCLineEditHasText(lineEdit):
		        print("Has text and will be cleared.")
		        guitk.BCLineEditClear(lineEdit)
		    return 0
		
		
		def getInfoFunction(toolBtn, lineEdit):
		    # Must set placeholder text first. Using guitk.BCLineEditSetPlaceholderText()
		    infoTxt = guitk.BCLineEditGetPlaceholderText(lineEdit)
		    if not infoTxt == None:
		        guitk.BCLineEditSetText(lineEdit, infoTxt)
		    else:
		        guitk.BCLineEditSetText(lineEdit, "No info set.")
		    return 0
		
		
		def moveCursorRightFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) + 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def moveCursorLeftFunction(toolBtn, lineEdit):
		    newPos = guitk.BCLineEditGetCursorPosition(lineEdit) - 1
		    guitk.BCLineEditSetCursorPosition(lineEdit, newPos)
		    return 0
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemSetPlaceholderText(item: object, col: int, text: str) -> None:

	"""

	Set the message to display when item cell text at col is empty.
	Message usually provide guidance for the contents type of an editable cell, like "Type here", "Integers are only allowed" etc.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	col : int
		the column index.

	text : str
		the message to be displayed.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemSetText

	Examples
	--------
	::

		from sdm import guitk
		from sdm import utils
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window,
		        5,
		        ["ID", "Part name", "Size", "Quantity", "Select Corresponding File"],
		        0,
		    )
		    group = addGroup(listView, "Group")
		    item = addPart(group, "1001", "Bumper", "Large", "2")
		    setSideButton(listView, item, 4, True)
		    item = addPart(group, "1002", "Decklid", "Large", "1")
		    setSideButton(listView, item, 4, False)
		    guitk.BCListViewSetSortingColumn(listView, 0, 1)
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, True)
		    if (
		        not guitk.BCListViewItemExpandMode(group)
		        == guitk.constants.BCDontShowIndicatorWhenChildless
		    ):
		        guitk.BCListViewItemSetExpandMode(
		            group, guitk.constants.BCDontShowIndicatorWhenChildless
		        )
		    guitk.BCListViewItemSetExpanded(group, True)
		    guitk.BCListViewItemSetSideButton(group, 4, parentSideButtonClicked, None)
		    guitk.BCListViewItemSideButtonSetIconFileName(group, 4, "alert_info.svg")
		    guitk.BCListViewItemSideButtonSetToolTip(
		        group, 4, "Click to enable childrens' buttons to load files"
		    )
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def setSideButton(listView, item, col, visible):
		    guitk.BCListViewItemSetPlaceholderText(item, col, "File path")
		    guitk.BCListViewItemSetSideButton(item, col, sideButtonClickedFunct, listView)
		    if visible:
		        guitk.BCListViewItemSideButtonSetEnabled(item, col, False)
		    else:
		        guitk.BCListViewItemSideButtonSetVisible(item, col, False)
		
		
		def parentSideButtonClicked(item, col, data):
		    child1 = guitk.BCListViewItemGetFirstChild(item)
		    child2 = guitk.BCListViewItemGetNextSibling(child1)
		    if guitk.BCListViewItemHasSideButton(item, col):
		        if not guitk.BCListViewItemSideButtonIsEnabled(child1, col):
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetEnabled(child1, col, False)
		
		        if not guitk.BCListViewItemSideButtonIsVisible(child2, col):
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, True)
		        else:
		            guitk.BCListViewItemSideButtonSetVisible(child2, col, False)
		    return 0
		
		
		def sideButtonClickedFunct(item, col, lv):
		    m = utils.SelectOpenFile(0, "Ansa files (*.ansa)", "Txt files (*.txt)")
		    if m:
		        guitk.BCListViewItemSetText(item, col, m[0])
		        guitk.BCListViewSetTextEllipsisPosition(lv, col, guitk.constants.BCLeftSide)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTextEditSetPlaceholderText(te: object, text: str) -> None:

	"""

	Set the message to display when te has no text inside and not keyboard focus.
	Message is displayed wrapped (breaks lines at appropriate points to fit whole text), but you can provide break line (\n) as well inside your message.
	When the user set focus inside text edit info dissapears. Use empty text to clear.
	Text is aligned centered horizontally and vertically in edit area.
	This function is not supported under VR mode.

	Parameters
	----------
	te : object
		the BCTextEdit.

	text : str
		the text to be displayed.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Text Edit", guitk.constants.BCOnExitDestroy)
		
		    hl = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    tedit = guitk.BCTextEditCreate(window, "")
		    guitk.BCTextEditSetPlaceholderText(
		        tedit,
		        "This is an example for BCTextEdit functions.\\nUse Ctrl+f in order to Search/Replace Text.",
		    )
		
		    boldButton = createToolButton(hl, tedit, "Bold", "font_bold.svg", True, boldFormat)
		    italicButton = createToolButton(
		        hl, tedit, "Italic", "font_italic.svg", True, italicFormat
		    )
		    underlineButton = createToolButton(
		        hl, tedit, "Underline", "font_underline.svg", True, underlineFormat
		    )
		    copySelectedButton = createToolButton(
		        hl, tedit, "Copy Selectred", "edit_copy.svg", False, copySelectedFunction
		    )
		    clearButton = createToolButton(
		        hl, tedit, "Clear", "clean.svg", False, clearFunction
		    )
		    wordwrapCheckBox = createCheckBox(hl, tedit, "Word Wrap", wordwrapFunction)
		    monospacefontCheckBox = createCheckBox(
		        hl, tedit, "Monospace Font", monospaceFontFunction
		    )
		    guitk.BCShow(window)
		
		
		def createToolButton(hl, tedit, text, iconName, toggled, function):
		    tempButton = guitk.BCToolButtonCreate(hl, iconName, "", None, None)
		    guitk.BCButtonSetToggleButton(tempButton, toggled)
		    if toggled:
		        guitk.BCButtonSetToggledFunction(tempButton, function, tedit)
		    else:
		        guitk.BCButtonSetClickedFunction(tempButton, function, tedit)
		    return tempButton
		
		
		def createCheckBox(hl, tedit, text, function):
		    tempCheckBox = guitk.BCCheckBoxCreate(hl, text)
		    guitk.BCCheckBoxSetToggledFunction(tempCheckBox, function, tedit)
		    return tempCheckBox
		
		
		def boldFormat(tb, state, data):
		    guitk.BCTextEditSetBold(data, state)
		    return 0
		
		
		def italicFormat(tb, state, data):
		    guitk.BCTextEditSetItalic(data, state)
		    return 0
		
		
		def underlineFormat(tb, state, data):
		    guitk.BCTextEditSetUnderline(data, state)
		    return 0
		
		
		def copySelectedFunction(tb, data):
		    print("Selected text is: " + str(guitk.BCTextEditGetSelectedText(data)))
		    return 0
		
		
		def clearFunction(tb, data):
		    guitk.BCTextEditClear(data)
		    return 0
		
		
		def wordwrapFunction(pb, state, data):
		    if state:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCWidgetWidth)
		    else:
		        guitk.BCTextEditSetWordWrap(data, guitk.constants.BCNoWrap)
		    return 0
		
		
		def monospaceFontFunction(pb, state, data):
		    guitk.BCTextEditSetMonospaceFont(data, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewAddTopLevelItem(lv: object) -> object:

	"""

	Appends a top level item to ListView lv.
	
	WARNING: If no sorting enabled in the list, the item is appended.
	WARNING: In order to avoid performance issues, it is recommended that sorting in list is disabled on mass adding items.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView

	Returns
	-------
	object
		The created ListViewItem

	See Also
	--------
	BCListViewItemAddChild

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Simple", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    # Start adding parts. Notice that we disable sorting while adding for performance reasons
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewRestoreSortState(listView)
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemAddChild(item: object) -> object:

	"""

	Appends a child item item to ListViewItem item.
	
	WARNING: If no sorting enabled in the list, the child item is appended.
	WARNING: In order to avoid performance issues, it is recommended that sorting in list is disabled on mass adding items.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem

	Returns
	-------
	object
		The created ListViewItem

	See Also
	--------
	BCListViewAddTopLevelItem

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Tree", guitk.constants.BCOnExitDestroy
		    )
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], False)
		    # create group A
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 1, "Group A31")
		    addPart(groupA, "Bumper", "A31_1001", "8")
		    addPart(groupA, "Decklid", "A31_1002", "12")
		    # create group B
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 1, "Group B12")
		    addPart(groupB, "Roof rack", "B12_1004", "6")
		    addPart(groupB, "Spoiler", "B12_1005", "2")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(treeView, 0, True)
		    # item expand/collapse controllers display only at first column ('Part name' in this case)
		    guitk.BCListViewSetRootIsDecorated(treeView, True)
		    guitk.BCListViewSetItemsExpanded(treeView, True)
		    guitk.BCListViewMoveColumn(treeView, 1, 0)
		    guitk.BCShow(window)
		
		
		def addPart(parentItem, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewGetTopLevelItem(lv: object, row: int) -> object:

	"""

	Returns the item at row row of ListView lv.
	NOTE: If sorting is enabled the items order change.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	row : int
		the row.

	Returns
	-------
	object
		the top level ListViewItem at the given row.

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Reset Colors Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		    # Set some colors
		    for i in range(guitk.BCListViewTopLevelItemCount(listView)):
		        item = guitk.BCListViewGetTopLevelItem(listView, i)
		        if i % 2:
		            guitk.BCListViewItemSetForegroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		        else:
		            guitk.BCListViewItemSetBackgroundColor(
		                item, guitk.constants.BCNormalMode, 0, 127, 0
		            )
		    hBox = guitk.BCHBoxCreate(window)
		    btnItemReset = guitk.BCPushButtonCreate(
		        hBox, "Reset Selected Item", resetItemColors, listView
		    )
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(hBox, "Reset Selected's Column: "),
		        guitk.constants.BCAlignVCenter + guitk.constants.BCAlignRight,
		    )
		    for i in range(guitk.BCListViewColumns(listView)):
		        guitk.BCToolButtonCreate(hBox, "", str(i), resetColumnColors, (listView, i))
		    guitk.BCShow(window)
		
		
		def resetItemColors(btn, listView):
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemResetBackgroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemResetForegroundColor(
		            selectedItem, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def resetColumnColors(btn, data):
		    listView, col = data
		    selectedItem = guitk.BCListViewGetSelectedItem(listView)
		    if selectedItem:
		        guitk.BCListViewItemColumnResetBackgroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		        guitk.BCListViewItemColumnResetForegroundColor(
		            selectedItem, col, guitk.constants.BCNormalMode
		        )
		    else:
		        print("Select an Item first.")
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCComboBoxSetMinimumContentsLength(cb: object, numChars: int) -> None:

	"""

	Sets the minimum number of characters that should fit into BCComboBox cb.
	If numChars is set to BCSizeAuto, the minimum width of the combobox is set to
	be equal to the largest containing string.
	NOTE: The minimum width in pixels depends on the current font used by the application.
	This function is not supported under VR mode.

	Parameters
	----------
	cb : object
		the BCComboBox

	numChars : int
		the number of characters that should fit into the combobox. The default
		value is BCSizeMedium. See See BCEnumSize for details.
		
		guitk.constants BCEnumSize
		This enum type is used to define the size (minimum/fixed/maximum) of a widget, depending on the function, measured in number of characters.
		 - guitk.constants.BCSizeAuto
		the widget's size depends on its contents.
		 - guitk.constants.BCSizeSmall
		sets the widget's size to small.
		 - guitk.constants.BCSizeMedium
		sets the widget's size to medium.
		 - guitk.constants.BCSizeLarge
		sets the widget's size to large.
		 - guitk.constants.BCSizeExtraLarge
		sets the widget's size to extra large.

	Returns
	-------
	None

	"""

def BCTableSetCellsForegroundColor(t: object, startRow: int, endRow: int, startColumn: int, endColumn: int, r: int, g: int, b: int) -> None:

	"""

	Changes the foreground color (i.e. the text) of given cells of BCTable t.
	Starting and ending row/column must be a number between zero and row/column count respectively. Also, the starting row/column must be
	a number less or equal to the ending one.
	If you want to reset the color to the default one, use the function BCTableResetCellsForegroundColor().
	NOTE: This function sets the foreground color of the existing cells. Any new cells created by adding new rows/columns
	will be ignored. In case you want to keep the new color, see functions BCTableSetRowsCellsForegroundColor() and BCTableSetColumnsCellsForegroundColor().
	WARNING: This function sets the foreground color of given cells currently on the table. This means that, if previously
	BCTableSetRowsCellsForegroundColor() or BCTableSetColumnsCellsForegroundColor() has been called for those cells, on the next
	row/column addition, the foreground color of those cells will be set again to the color set by the latter functions!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	r : int
		the red component of the color to be set

	g : int
		the green component of the color to be set

	b : int
		the blue component of the color to be set

	Returns
	-------
	None

	See Also
	--------
	BCTableResetCellsForegroundColor

	"""

def BCTableResetCellsForegroundColor(t: object, startRow: int, endRow: int, startColumn: int, endColumn: int) -> None:

	"""

	Resets the foreground color of given cells of BCTable t.
	If no color is set, this function does nothing.
	WARNING: This function resets the foreground color of given cells currently on the table. This means that, if previously
	BCTableSetRowsCellsForegroundColor() or BCTableSetColumnsCellsForegroundColor() has been called for those cells, on the next
	row/column addition, the foreground color of those cells will be set again to the color set by the latter functions!
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	Returns
	-------
	None

	See Also
	--------
	BCTableSetCellsForegroundColor

	"""

def BCTableSetRowsCellsForegroundColor(t: object, startRow: int, endRow: int, r: int, g: int, b: int) -> None:

	"""

	Sets the foreground color of cells, like BCTableSetCellsForegroundColor(), but for whole rows.
	This function, in opposition to BCTableSetCellsForegroundColor(), keeps track of the rows, so, any new cells
	added by adding new columns which belong to the range from startRow to endRow will also be colored
	with the given color.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	r : int
		the red component of the color to be set

	g : int
		the green component of the color to be set

	b : int
		the blue component of the color to be set

	Returns
	-------
	None

	See Also
	--------
	BCTableResetRowsCellsForegroundColor

	"""

def BCTableSetColumnsCellsForegroundColor(t: object, startColumn: int, endColumn: int, r: int, g: int, b: int) -> None:

	"""

	Sets the foreground color of cells, like BCTableSetCellsForegroundColor(), but for whole columns.
	This functions does exactly what BCTableSetRowsCellsForegroundColor() does but applies for columns.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	r : int
		the red component of the color to be set

	g : int
		the green component of the color to be set

	b : int
		the blue component of the color to be set

	Returns
	-------
	None

	See Also
	--------
	BCTableResetColumnsCellsForegroundColor

	"""

def BCTableResetRowsCellsForegroundColor(t: object, startRow: int, endRow: int) -> None:

	"""

	Resets the foreground color of the cells of BCTable t found between rows from startRow to endRow.
	In opposition to BCTableResetCellsForegroundColor(), this function resets the colors and forgets the color setting.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startRow : int
		the starting row

	endRow : int
		the ending row

	Returns
	-------
	None

	See Also
	--------
	BCTableSetRowsCellsForegroundColor

	"""

def BCTableResetColumnsCellsForegroundColor(t: object, startColumn: int, endColumn: int) -> None:

	"""

	Resets the foreground color of the cells of BCTable t found between columns from startColumn to endColumn.
	This functions does exactly what BCTableResetRowsCellsForegroundColor() does but applies for columns.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	startColumn : int
		the starting column

	endColumn : int
		the ending column

	Returns
	-------
	None

	See Also
	--------
	BCTableSetColumnsCellsForegroundColor

	"""

def BCListViewHeaderSetStringRepresentation(lv: object, col: int, text: str) -> None:

	"""

	Set the string representation for column with index col.
	String representation text is not displayed at header section.
	It is useful for columns with no text (for example icon only) at header.
	String representation is used when regular text is empty at 
	- header menu that show/hide columns
	- filter output query bottom bar
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	text : str
		the text to be used as string representation.

	Returns
	-------
	None

	See Also
	--------
	BCListViewHeaderSetIconFileName

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView Header Formatting Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", ""], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    guitk.BCListViewHeaderSetIconFileName(listView, 4, "logo_sdm.svg")
		    guitk.BCListViewHeaderSetColorLine(listView, 0, 255, 0, 0)
		    guitk.BCListViewHeaderSetStringRepresentation(listView, 4, "Alternative")
		    guitk.BCListViewHeaderSetForegroundColor(listView, 2, 255, 0, 0)
		    guitk.BCListViewSetHeaderMenuColumnVisibilityChangeEnabled(listView, 1)
		    print(
		        "Notice that in the visibility header menu 'Alternative' text is displayed for column with Icon"
		    )
		    guitk.BCShow(window)
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCButtonLineEditSetFixedPixelWidth(ble: object, pixels: int) -> None:

	"""

	Sets both the minimum and maximum width of the widget to pixels width without changing the heights.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	pixels : int
		the pixels ble will occupy.

	Returns
	-------
	None

	"""

def BCLineEditSetFixedNumCharWidth(le: object, numChars: int) -> None:

	"""

	Sets both the minimum and maximum width of the widget to numChars width without changing the heights.
	This function is not supported under VR mode.

	Parameters
	----------
	le : object
		the BCLineEdit.

	numChars : int
		the number of characters.

	Returns
	-------
	None

	See Also
	--------
	BCLineEditSetMinimumWidth

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("LineEdit Example", guitk.constants.BCOnExitDestroy)
		    boxLayout = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(boxLayout, "LineEdit")
		    lineEdit = guitk.BCLineEditCreate(
		        boxLayout, "Press Enter Key, Question Mark (?) Key or F1 key"
		    )
		    guitk.BCLineEditSetQuestionMarkFunction(lineEdit, questionMarkEntered, None)
		    guitk.BCLineEditSetEnterPressedFunction(lineEdit, enterPressed, None)
		    guitk.BCLineEditSetF1Function(lineEdit, f1pressedFunct, None)
		    guitk.BCLineEditSetEditingFinishedFunction(lineEdit, editingFinishedFunction, None)
		    guitk.BCLineEditSetFixedNumCharWidth(lineEdit, 50)
		    guitk.BCLineEditSetMinimumWidth(lineEdit, guitk.constants.BCSizeSmall)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def editingFinishedFunction(lineEdit, data):
		    print("Enter pressed. editingFinishedFunction() called after.")
		    guitk.BCLineEditSetText(lineEdit, "Editing Finished.")
		    return 0
		
		
		def enterPressed(lineEdit, data):
		    print("Enter pressed. enterPressed() called first.")
		    guitk.BCLineEditSetText(lineEdit, "Enter Pressed.")
		    return 0
		
		
		def questionMarkEntered(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "Question Mark Entered.")
		    return 0
		
		
		def f1pressedFunct(lineEdit, data):
		    guitk.BCLineEditSetText(lineEdit, "F1 pressed.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCSplitterSetWidgetStretchFactor(sp: object, w: object, stretch: int) -> None:

	"""

	Sets the size policy of the widget w to have a stretch factor of stretch.
	Initializes the relative size of the widget w with regard to their sibling widgets.
	Setting stretch to 0 will initialize the widget w to occupy minimum fixed size.
	NOTE: The stretch factor cannot change dynamically, except from 0 to positive and vice-versa (with weird results). To change the widget sizes dynamically use BCSplitterSetWidgetSizes.
	This function is not supported under VR mode.

	Parameters
	----------
	sp : object
		the BCSplitter.

	w : object
		the widget for which the stretch factor will be set.

	stretch : int
		the new stretch factor.

	Returns
	-------
	None

	See Also
	--------
	BCSplitterSetStretchFactor

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Splitter ResizeMode Example", guitk.constants.BCOnExitDestroy
		    )
		    splitter = guitk.BCSplitterCreate(window, guitk.constants.BCHorizontal)
		    splitterFrameCreate(splitter, "Frame A - stretch 0\\n(Keep Size)")
		    guitk.BCSplitterSetStretchFactor(splitter, 0, 0)
		    splitterFrameCreate(splitter, "Frame B - stretch 1")
		    guitk.BCSplitterSetStretchFactor(splitter, 1, 1)
		    frameC = splitterFrameCreate(splitter, "Frame C - stretch 2")
		    guitk.BCSplitterSetWidgetStretchFactor(splitter, frameC, 2)
		    guitk.BCWindowSetSaveSettings(window, False)
		    guitk.BCShow(window)
		
		
		def splitterFrameCreate(splitter, text):
		    frame = guitk.BCFrameCreate(splitter)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    guitk.BCLabelSetAlignment(
		        guitk.BCLabelCreate(bLayout, text), guitk.constants.BCAlignCenter
		    )
		    hBox = guitk.BCHBoxCreate(bLayout)
		    guitk.BCPushButtonCreate(hBox, "Move First", moveToFirst, (splitter, frame))
		    guitk.BCPushButtonCreate(hBox, "Move Last", moveToLast, (splitter, frame))
		    return frame
		
		
		def moveToFirst(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToFirst(splitter, frame)
		    return 0
		
		
		def moveToLast(btn, data):
		    splitter, frame = data
		    guitk.BCSplitterMoveToLast(splitter, frame)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableEnableRightPressMenu(t: object, options: int) -> None:

	"""

	Sets what will be displayed in the popupmenu that is shown on right press on BCTable t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	options : int
		this parameter specifies which options will be displayed.
		The enumerators can be OR'ed (added) together. The default value is BCNoMenu.
		See BCEnumTablePopupContents for details.
		
		guitk.constants BCEnumTablePopupContents
		This enum defines the options that will be displayed in the popupmenu shown on right click on BCTable.
		 - guitk.constants.BCNoMenu
		no popup menu will be displayed.
		 - guitk.constants.BCInsertRow
		options that allow row insertion will be displayed.
		 - guitk.constants.BCInsertColumn
		options that allow column insertion will be displayed.
		 - guitk.constants.BCDeleteRow
		option that allows row deletion will be displayed.
		 - guitk.constants.BCDeleteColumn
		option that allows column deletion will be displayed.
		 - guitk.constants.BCClipboardFunctions
		cut, copy and paste options will be displayed.
		 - guitk.constants.BCAll
		all above options will be displayed.

	Returns
	-------
	None

	See Also
	--------
	BCTableSetMousePressedFunction

	"""

def BCButtonLineEditSetFixedNumCharWidth(ble: object, numChars: int) -> None:

	"""

	Sets both the minimum and maximum width of the widget to numChars width without changing the heights.
	This function is not supported under VR mode.

	Parameters
	----------
	ble : object
		the BCButtonLineEdit.

	numChars : int
		the number of characters.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ButtonLineEdit Example", guitk.constants.BCOnExitDestroy
		    )
		    hBox = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
		    label = guitk.BCLabelCreate(hBox, "ButtonLineEdit:")
		    btnLe = guitk.BCButtonLineEditCreate(
		        hBox, "Right-click inside ButtonLineEdit to show popup menu."
		    )
		    guitk.BCButtonLineEditSetAddItemsToPopupMenu(btnLe, createPopup, None)
		
		    guitk.BCWindowSetAcceptFunction(window, acceptFunction, None)
		    guitk.BCShow(window)
		
		
		def acceptFunction(window, data):
		    return 0
		
		
		def createPopup(btnLe, popup, data):
		    guitk.BCPopupMenuInsertSeparator(popup)
		    submenu = guitk.BCPopupMenuCreate(popup)
		    popup_20 = guitk.BCPopupMenuInsertItem(submenu, "20", widthFunction, btnLe)
		    popup_40 = guitk.BCPopupMenuInsertItem(submenu, "40", widthFunction, btnLe)
		    popup_60 = guitk.BCPopupMenuInsertItem(submenu, "60", widthFunction, btnLe)
		    popup_80 = guitk.BCPopupMenuInsertItem(submenu, "80", widthFunction, btnLe)
		    popup_100 = guitk.BCPopupMenuInsertItem(submenu, "100", widthFunction, btnLe)
		    guitk.BCPopupMenuInsertPopupMenu(popup, "Set Width", submenu)
		    return 0
		
		
		def widthFunction(pm, id, btnLe):
		    if id == 0:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 20)
		    elif id == 1:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 40)
		    elif id == 2:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 60)
		    elif id == 3:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 80)
		    elif id == 4:
		        guitk.BCButtonLineEditSetFixedNumCharWidth(btnLe, 100)
		    else:
		        print("Nothing to be done.No changes made.")
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTabWidgetSetTabsClosableEnabled(tw: object, closable: bool, act: int, funct: Callable, data: Any) -> None:

	"""

	Sets the tabs of BCTabWidget tw to be closable according to closable.
	Setting closable to 1 makes the tabs to show a little button with 'X' icon. The tab will close or not according to
	act and the return value of funct.
	This function is not supported under VR mode.

	Parameters
	----------
	tw : object
		the BCTabWidget

	closable : bool
		set this to 1 in order to show the 'X' button; 0 otherwise. By default, the 'X' button is not visible

	act : int
		the action to be taken when the 'X' button is clicked and the user function returns 1 (e.g. you can hide or delete the tab)

	funct : Callable
		the user function that will be called. See BC_TABWIDGET_BUTTON_SET_FUNCTION for details
		integer BC_TABWIDGET_BUTTON_SET_FUNCTION(tw, tab, data)
		The function to be called when a pixmap with a callback function is needed to be created on a tab of a BCTabWidget.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * tw : object
		                    the BCTabWidget.
		          * tab : object
		                    the current tab (i.e. the created widget that made tab).
		          * data : Any
		                    anything that may be required in function.
		
		Return: Return 1 in case you want to run the action set; 0 otherwise.

	data : Any
		any user data that will be used by funct

	Returns
	-------
	None

	Examples
	--------
	::

		import os
		import sdm
		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("Example Tab Widget", guitk.constants.BCOnExitDestroy)
		    tabWidget = guitk.BCTabWidgetCreate(window)
		
		    # Create tab pages
		    redTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(redTab, 255, 0, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, redTab, "Red")
		
		    orangeTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(orangeTab, 255, 128, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, orangeTab, "Orange")
		
		    yellowTab = guitk.BCFrameCreate(tabWidget)
		    guitk.BCSetBackgroundColor(yellowTab, 255, 255, 0)
		    guitk.BCTabWidgetAddTab(tabWidget, yellowTab, "Yellow")
		
		    # tooltips
		    guitk.BCTabWidgetSetToolTip(tabWidget, 0, "Red frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 1, "Orange frame")
		    guitk.BCTabWidgetSetToolTip(tabWidget, 2, "Yellow frame")
		
		    le = guitk.BCLineEditCreate(window, "New title of the current tab")
		    guitk.BCLineEditSetEnterPressedFunction(le, ChangeCurrentTabLabel, tabWidget)
		
		    guitk.BCTabWidgetSetTabsClosableEnabled(
		        tabWidget, 1, guitk.constants.BCOnExitDestroy, TabWidgetButtonPressed, le
		    )
		
		    guitk.BCShow(window)
		
		
		def ChangeCurrentTabLabel(le, data):
		    text = guitk.BCLineEditGetText(le)
		    currentTab = guitk.BCTabWidgetGetCurrentTab(data)
		    guitk.BCTabWidgetSetTabLabel(data, currentTab, text)
		    return 1  # The accept function of the main window will not operate
		
		
		# if the last tab is deleted, disable the LineEdit
		def TabWidgetButtonPressed(tabWidget, tab, le):
		    count = guitk.BCTabWidgetCount(tabWidget)
		    if count < 2:
		        guitk.BCSetEnabled(le, False)
		    return 1
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCTableRemoveRows(t: object, rows: list, numOfRows: int) -> None:

	"""

	Removes the rows which are stored at array rows with size numOfRows from table t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	rows : list
		the array of the row indexes that will be removed.

	numOfRows : int
		the size of the array rows.

	Returns
	-------
	None

	See Also
	--------
	BCTableRemoveColumn

	"""

def BCTableRemoveColumns(t: object, cols: list, numOfColumns: int) -> None:

	"""

	Removes the columns which are stored at array cols with size numOfColumns from table t.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable.

	cols : list
		the array of the column indexes that will be removed.

	numOfColumns : int
		the size of the array cols.

	Returns
	-------
	None

	See Also
	--------
	BCTableRemoveColumn

	"""

def BCTableSetAboutToInsertRemoveRowsFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called right before rows are about to be inserted or removed.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	funct : Callable
		the function to call. See BC_TABLE_ABOUT_TO_INSERT_REMOVE_ROWS_FUNCTION for details.
		boolean BC_TABLE_ABOUT_TO_INSERT_REMOVE_ROWS_FUNCTION(t, indexes, count, inserted, data)
		The function to be called just before inserting or removing rows from BCTable t.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable
		          * indexes : list
		                    array of indexes of rows that are about to be inserted or removed. indexes is valid only for this callback function
		          * count : int
		                    the number of rows that will be inserted or removed
		          * inserted : bool
		                    1 if rows are about to be inserted; 0 otherwise
		          * data : Any
		                    anything that may be required in function
		
		Return: 1 if you want to cancel the row insertion/removal; 0 for normal insertion/removal

	data : Any, optional
		any data required by function funct

	Returns
	-------
	None

	See Also
	--------
	BCTableSetAboutToInsertRemoveColumnsFunction

	"""

def BCTableSetAboutToInsertRemoveColumnsFunction(t: object, funct: Callable, data: Any=None) -> None:

	"""

	Sets the function to be called right before columns are about to be inserted or removed.
	This function is not supported under VR mode.

	Parameters
	----------
	t : object
		the BCTable

	funct : Callable
		the function to call. See BC_TABLE_ABOUT_TO_INSERT_REMOVE_COLUMNS_FUNCTION for details.
		boolean BC_TABLE_ABOUT_TO_INSERT_REMOVE_COLUMNS_FUNCTION(t, indexes, count, inserted, data)
		The function to be called just before inserting or removing columns from BCTable t.
		WARNING: If you need to delete a GUI object (button, list view item etc) inside your call back function, do NOT delete it directly but with the use of a timer (BCTimerSingleShot).
		
		Arguments
		          * t : object
		                    the BCTable
		          * indexes : list
		                    array of indexes of colunms that are about to be inserted or removed. indexes is valid only for this callback function.
		          * count : int
		                    the number of colunms that will be inserted or removed
		          * inserted : bool
		                    1 if colunms are about to be inserted; 0 otherwise
		          * data : Any
		                    anything that may be required in function
		
		Return: 1 if you want to cancel the colunm insertion/removal; 0 for normal insertion/removal

	data : Any, optional
		any data required by function funct

	Returns
	-------
	None

	See Also
	--------
	BCTableSetAboutToInsertRemoveRowsFunction

	"""

def BCListViewSetDisplayDoubleDecimals(lv: object, col: int, digits: int) -> None:

	"""

	This property holds the displayed decimals at double numbers for ListViewItem column with index col.
	Item data are not affected but only the way are shown.
	When item is selected (or disabled) all its decimals are displayed.
	Exponential format is not affected (for example 1.5E-06).
	If you want to clear, use a negative digits value (for example -1).
	NOTE: At the moment this function cannot cooperate together with BCListViewItemSetBoldChars().
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	col : int
		the column index.

	digits : int
		the number of decimals displayed.

	Returns
	-------
	None

	See Also
	--------
	BCListViewSetRenameItemPrecision

	"""

def BCScrollViewCreate(p: object) -> object:

	"""

	Function is obsolete. Use BCScrollAreaCreate() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout of the created BCScrollView.

	Returns
	-------
	object
		the frame where all widgets are placed.

	"""

def BCScrollViewGetPointer(svfr: object) -> object:

	"""

	Function is obsolete. Use BCGetBScrollView() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	svfr : object
		the frame inside the BCScrollView, returned by the BCScrollViewCreate().

	Returns
	-------
	object
		the BCScrollView itself in order to be used elsewhere e.g. as a widget.

	"""

def BCScrollViewSyncScrollBars(w1: object, w2: object) -> None:

	"""

	Function is obsolete. Use BCScrollAreaSyncScrollBars() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	w1 : object
		the first widget to sync.

	w2 : object
		the second widget to sync.

	Returns
	-------
	None

	"""

def BCScrollViewSyncScrollBarVertical(w1: object, w2: object) -> None:

	"""

	Function is obsolete. Use BCScrollAreaSyncScrollBarVertical() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	w1 : object
		the first widget to sync.

	w2 : object
		the second widget to sync.

	Returns
	-------
	None

	"""

def BCScrollViewSyncScrollBarHorizontal(w1: object, w2: object) -> None:

	"""

	Function is obsolete. Use BCScrollAreaSyncScrollBarHorizontal() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	w1 : object
		the first widget to sync.

	w2 : object
		the second widget to sync.

	Returns
	-------
	None

	"""

def BCScrollViewSetVScrollBarValue(sv: object, value: int) -> None:

	"""

	Function is obsolete. Use BCScrollAreaSetVScrollBarValue() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	sv : object
		the BCScrollView.

	value : int
		the value in pixels.

	Returns
	-------
	None

	"""

def BCScrollViewGetVScrollBarValue(sv: object) -> int:

	"""

	Function is obsolete. Use BCScrollAreaGetVScrollBarValue() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	sv : object
		the BCScrollView.

	Returns
	-------
	int

	"""

def BCScrollViewSetHScrollBarValue(sv: object, value: int) -> None:

	"""

	Function is obsolete. Use BCScrollAreaSetHScrollBarValue() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	sv : object
		the BCScrollView.

	value : int
		the value in pixels.

	Returns
	-------
	None

	"""

def BCScrollViewGetHScrollBarValue(sv: object) -> int:

	"""

	Function is obsolete. Use BCScrollAreaGetHScrollBarValue() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	sv : object
		the BCScrollView.

	Returns
	-------
	int

	"""

def BCScrollViewSetWidget(sv: object, frame: object) -> None:

	"""

	Function is obsolete. Use BCScrollAreaSetWidget() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	sv : object
		the BCScrollView.

	frame : object
		the frame where all widgets are placed.

	Returns
	-------
	None

	"""

def BCScrollViewSetWidgetResizable(sv: object, resizable: bool) -> None:

	"""

	Function is obsolete. Use BCScrollAreaSetWidgetResizable() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	sv : object
		the BCScrollView.

	resizable : bool
		set to 1 so that the scroll area will automatically resize the widget
		in order to avoid scroll bars where they can be avoided, or to take advantage of extra space,
		or set to 0 so that the scroll area honors the size of its widget.

	Returns
	-------
	None

	"""

def BCListViewItemComboBoxSetIconFileName(item: object, col: int, index: int, fileName: str) -> None:

	"""

	Set the icon for the comboBox item with index.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	index : int
		the index of the comboBox item.

	fileName : str
		the filename of the icon.

	Returns
	-------
	None

	See Also
	--------
	BCIconIsValid

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView ComboBox Icons", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Name", "Color"], False)
		    infoBox = guitk.BCItemViewStatusBarCreate(window, listView)
		    addPart(listView, "1001", "Bumper", 0)
		    addPart(listView, "1002", "Decklid", 1)
		    addPart(listView, "1003", "Pillar", 2)
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name, colorIdx):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(item, 2, ["Red", "Green", "No Color"], None, None)
		    guitk.BCListViewItemComboBoxSetIconFileName(item, 2, 0, "led_red_small.svg")
		    guitk.BCListViewItemComboBoxSetIconFileName(item, 2, 1, "led_green_small.svg")
		    guitk.BCListViewItemComboBoxSetIconFileName(item, 2, 2, "empty_small.svg")
		    guitk.BCListViewItemComboBoxSetCurrentItem(item, 2, colorIdx)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardCurrentPage(wiz: object) -> int:

	"""

	Returns the index of the current page.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	Returns
	-------
	int
		the index of current page.

	See Also
	--------
	BCWizardSetCurrentPage

	Examples
	--------
	::

		from sdm import guitk
		
		SHAPE_PAGE = 100
		TRIA_PAGE = 101
		CONFIRM_PAGE = 102
		
		
		def main():
		    wizard = guitk.BCWizardCreate(
		        "Wizard Extras Example", guitk.constants.BCOnExitDestroy
		    )
		    guitk.BCWizardAddPage(wizard, shapePageCreate(wizard), "Shape", "Choose Shape", "")
		    guitk.BCWizardSetPageId(wizard, 0, SHAPE_PAGE)
		    guitk.BCWizardAddPage(
		        wizard, confirmPageCreate(wizard), "Confirm", "Confirm Shape", ""
		    )
		    guitk.BCWizardSetPageId(wizard, 1, CONFIRM_PAGE)
		    guitk.BCSetUserDataKey(wizard, "shape", "None")
		    guitk.BCSetUserDataKey(wizard, "triaType", "Innaplicable")
		    guitk.BCWizardAddUserButton(
		        wizard, guitk.BCPushButtonCreate(wizard, "Print Data", printData, wizard)
		    )
		    guitk.BCWizardSetFinishButtonText(wizard, "Confirm")
		    guitk.BCWizardSetNextButtonEnabled(wizard, False)
		    print("NextButtonEnabled = {}".format(guitk.BCWizardIsNextButtonEnabled(wizard)))
		    guitk.BCShow(wizard)
		
		
		def shapePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    shapeBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Shape", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, shapeBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(shapeBtnGroup, "None", None, None), True
		    )
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Circle", None, None)
		    guitk.BCRadioButtonCreate(shapeBtnGroup, "Triangle", None, None)
		    guitk.BCButtonGroupSetPressedFunction(shapeBtnGroup, shapeChosen, wizard)
		    return frame
		
		
		def confirmPageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    dataTable = guitk.BCTableCreate(bLayout, 2, 1)
		    guitk.BCBoxLayoutInsert(bLayout, dataTable, -1)
		    guitk.BCTableSetColumnAcceptsText(dataTable, 0, True)
		    guitk.BCTableSetRowLabels(dataTable, ["Shape", "Type"])
		    guitk.BCTableSetColumnLabels(dataTable, ["Value"])
		    guitk.BCWizardSetCurrentPageChangedFunction(wizard, wizPageChanged, dataTable)
		    return frame
		
		
		def wizPageChanged(wizard, oldI, newI, dataTable):
		    if guitk.BCWizardPageId(wizard, newI) == CONFIRM_PAGE:
		        guitk.BCTableSetText(dataTable, 0, 0, guitk.BCGetUserDataKey(wizard, "shape"))
		        guitk.BCTableSetText(
		            dataTable, 1, 0, guitk.BCGetUserDataKey(wizard, "triaType")
		        )
		    print(
		        "CurrentIndex={}. Total pages={}.".format(
		            guitk.BCWizardCurrentPage(wizard), guitk.BCWizardPageCount(wizard)
		        )
		    )
		    return 0
		
		
		def shapeChosen(btnGroup, id, wizard):
		    shape = guitk.BCRadioButtonText(guitk.BCButtonGroupFind(btnGroup, id))
		    if shape == "Triangle":
		        guitk.BCWizardInsertPage(
		            wizard, 1, trianglePageCreate(wizard), "Type", "Choose Triangle Type", ""
		        )
		        guitk.BCWizardSetPageId(wizard, 1, TRIA_PAGE)
		    else:  # If triangle page exists, remove it
		        trianglePageIndex = guitk.BCWizardPageIdToIndex(wizard, TRIA_PAGE)
		        if trianglePageIndex != -1:
		            trianglePage = guitk.BCWizardPageAt(wizard, trianglePageIndex)
		            guitk.BCWizardRemovePage(wizard, trianglePageIndex)
		            guitk.BCDestroyLater(trianglePage)
		            guitk.BCSetUserDataKey(wizard, "triaType", "Inapplicable")
		    guitk.BCSetUserDataKey(wizard, "shape", shape)
		    guitk.BCWizardSetNextButtonEnabled(wizard, shape != "None")
		    print(
		        "NextButtonEnabled changed to {}".format(
		            guitk.BCWizardIsNextButtonEnabled(wizard)
		        )
		    )
		    return 0
		
		
		# Triangle Page is created dynamically
		def trianglePageCreate(wizard):
		    frame = guitk.BCFrameCreate(wizard)
		    bLayout = guitk.BCBoxLayoutCreate(frame, guitk.constants.BCVertical)
		    triangleBtnGroup = guitk.BCButtonGroupCreate(
		        bLayout, "Triangle Type", guitk.constants.BCVertical
		    )
		    guitk.BCBoxLayoutInsert(bLayout, triangleBtnGroup, -1)
		    guitk.BCRadioButtonSetChecked(
		        guitk.BCRadioButtonCreate(triangleBtnGroup, "Equillateral", None, None), True
		    )
		    guitk.BCRadioButtonCreate(triangleBtnGroup, "Right", None, None)
		    guitk.BCSetUserDataKey(wizard, "triaType", "Equillateral")
		    guitk.BCButtonGroupSetPressedFunction(triangleBtnGroup, typeChosen, wizard)
		    return frame
		
		
		def typeChosen(btnGroup, index, wizard):
		    triaType = guitk.BCRadioButtonText(
		        guitk.BCButtonGroupFind(btnGroup, guitk.BCButtonGroupGetSelectedId(btnGroup))
		    )
		    guitk.BCSetUserDataKey(wizard, "triaType", triaType)
		    return 0
		
		
		def printData(btn, wizard):
		    print(
		        "shape = {}, triaType = {}".format(
		            guitk.BCGetUserDataKey(wizard, "shape"),
		            guitk.BCGetUserDataKey(wizard, "triaType"),
		        )
		    )
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCWizardSetCurrentPage(wiz: object, index: int) -> None:

	"""

	Goes to the specified wizard wiz page.
	Avoid using programmatical ways to fall through pages when not necessary; 
	let the user decide if and when will continue to next page.
	Wizard will go to specified page, even if next button is disabled.
	If (changing page) animation is in progress, nothing happens.
	This function is not supported under VR mode.

	Parameters
	----------
	wiz : object
		the wizard.

	index : int
		the page index. The valid range is from 0 to BCWizardPageCount()-1.

	Returns
	-------
	None

	See Also
	--------
	BCWizardCurrentPage

	"""

def BCButtonGroupHiddenCreate(p: object) -> object:

	"""

	Creates a container without visual representation to organize groups of button widgets (i.e. add radio buttons 
	explicitly anywhere in the main widget).
	A hidden BCButtonGroup is useful when you want to use the callback functions and 
	properties of the BCButtonGroup, but you don't want it to be visible.
	Create your own BCButtons with parent the widget or layout you want as if the 
	BCButtonGroup didn't exist. Then, add them into the created BCButtonGroup by calling 
	BCButtonGroupInsert().
	WARNING: Is only applicable to buttons.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	Returns
	-------
	object
		the created BCButtonGroup.

	See Also
	--------
	BCButtonGroupInsert

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Hidden ButtonGroup Example", guitk.constants.BCOnExitDestroy
		    )
		    hiddenGroup = guitk.BCButtonGroupHiddenCreate(window)
		    option1 = guitk.BCRadioButtonCreate(window, "Input 1", None, None)
		    guitk.BCButtonGroupInsert(hiddenGroup, option1, 0)
		    option2 = guitk.BCRadioButtonCreate(window, "Input 2", None, None)
		    guitk.BCButtonGroupInsert(hiddenGroup, option2, 1)
		    guitk.BCButtonGroupSetButton(
		        hiddenGroup, guitk.BCButtonGroupId(hiddenGroup, option2)
		    )
		
		    guitk.BCShow(window)
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewFilterSetAutoShowQueryBar(lv: object, autoShow: bool) -> None:

	"""

	Sets whether the standard filter query bottom bar is automatically shown when a filter is applied.
	If autoShow is true (default), the query bar be automatically shown, otherwise it will not.
	The query bar displays the current query with and extra enable/disable control.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView to set.

	autoShow : bool
		set False to permanent hide the output or True to automatically show the query when a filter is applied.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate("ListView Filter", guitk.constants.BCOnExitDestroy)
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Size", "Quantity"], 0
		    )
		    guitk.BCSetUserDataKey(window, "listView", listView)
		    # create group A
		    groupA = addGroup(listView, "Group A")
		    addPart(groupA, "1001", "Bumper", "Large", "2")
		    addPart(groupA, "1002", "Decklid", "Large", "1")
		    addPart(groupA, "1003", "Pillar", "Medium", "3")
		    # create group B
		    groupB = addGroup(listView, "Group B")
		    addPart(groupB, "1004", "Welded Assembly", "Small", "6")
		    addPart(groupB, "1005", "Spoiler", "Large", "1")
		    countA = guitk.BCListViewItemChildCount(groupA)
		    countB = guitk.BCListViewItemChildCount(groupB)
		    guitk.BCListViewItemSetText(groupA, 3, str(countA))
		    guitk.BCListViewItemSetText(groupB, 3, str(countB))
		    guitk.BCListViewSetColumnDataType(listView, 3, guitk.constants.BCInt)
		    guitk.BCListViewSetRootIsDecorated(listView, 1)
		    guitk.BCListViewSetSelectionMode(listView, guitk.constants.BCMulti)
		    # filter options
		    enableFilterCheckBox = guitk.BCCheckBoxCreate(window, "Enable filtering")
		    autoShowCheckBox = guitk.BCCheckBoxCreate(window, "Auto show query bar")
		    guitk.BCSetUserDataKey(window, "autoShowCheckBox", autoShowCheckBox)
		    guitk.BCCheckBoxSetChecked(autoShowCheckBox, True)
		    guitk.BCCheckBoxSetToggledFunction(
		        enableFilterCheckBox, enableFilteringFunct, window
		    )
		    guitk.BCCheckBoxSetToggledFunction(autoShowCheckBox, autoShowQueryBarFunct, window)
		    guitk.BCCheckBoxAddManagedWidget(
		        enableFilterCheckBox,
		        autoShowCheckBox,
		        guitk.constants.BCManagedEnable,
		        guitk.constants.BCManagedDisable,
		    )
		
		    guitk.BCShow(window)
		
		
		def addGroup(listView, name):
		    group = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(group, 0, name)
		    return group
		
		
		def addPart(parent, pid, name, size, quantity):
		    item = guitk.BCListViewItemAddChild(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, size)
		    guitk.BCListViewItemSetText(item, 3, quantity)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def enableFilteringFunct(checkBox, state, window):
		    listView = guitk.BCGetUserDataKey(window, "listView")
		    guitk.BCListViewSetFilterEnabled(listView, state)
		    autoShowCheckBox = guitk.BCGetUserDataKey(window, "autoShowCheckBox")
		    guitk.BCListViewFilterSetAutoShowQueryBar(
		        listView, guitk.BCCheckBoxIsChecked(autoShowCheckBox)
		    )
		    return 0
		
		
		def autoShowQueryBarFunct(checkBox, state, window):
		    listView = guitk.BCGetUserDataKey(window, "listView")
		    if guitk.BCListViewIsFilterEnabled(listView):
		        guitk.BCListViewFilterSetAutoShowQueryBar(listView, state)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetItemComboBoxFrameDrawn(lv: object, drawn: bool) -> None:

	"""

	Sets whether the item comboBox of the ListView draws itself with a frame when item is not selected (default on).
	When item turns selected the frame will be drawn.
	WARNING: Do not set any item cell contents (text, icon etc) to the same cell with ComboBox.
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	drawn : bool
		sets this parameter to 0 for the comboBoxes to be drawn minimal (frameless) when item is not selected.
		If False is set the comboBoxes will only be visible upon ListViewItem selection.

	Returns
	-------
	None

	See Also
	--------
	BCListViewIsItemComboBoxFrameDrawn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView ComboBox Frame Drawn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", "Mesh Shape"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    cbHideCmbFrame = guitk.BCCheckBoxCreate(
		        window, "Hide ComboBox frame when not selected"
		    )
		    guitk.BCCheckBoxSetToggledFunction(cbHideCmbFrame, setCmbFrameDrawn, listView)
		    guitk.BCShow(window)
		
		
		def setCmbFrameDrawn(cb, state, listView):
		    guitk.BCListViewSetItemComboBoxFrameDrawn(listView, not state)
		    print(
		        "ListViewComboBoxFrameDrawn = {}".format(
		            guitk.BCListViewIsItemComboBoxFrameDrawn(listView)
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetComboBox(
		        item, 4, ["Triangles", "Ortho-Triangles", "Rectangles"], None, None
		    )
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewIsItemComboBoxFrameDrawn(lv: object) -> bool:

	"""

	Returns whether the item comboBox of the ListView draws itself with a frame when item is not selected (default on).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	Returns
	-------
	bool
		True if the ComboBoxes are always visible, or False if only their current value is shown.

	See Also
	--------
	BCListViewSetItemComboBoxFrameDrawn

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ListView ComboBox Frame Drawn Example", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(
		        window, 5, ["ID", "Part name", "Version", "Manufactured", "Mesh Shape"], False
		    )
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    addPart(listView, "1003", "Pillar", "4A", "Turkey")
		    addPart(listView, "1004", "Roof rack", "3A", "South Korea")
		    guitk.BCListViewSetSortingColumn(listView, 0, True)
		
		    cbHideCmbFrame = guitk.BCCheckBoxCreate(
		        window, "Hide ComboBox frame when not selected"
		    )
		    guitk.BCCheckBoxSetToggledFunction(cbHideCmbFrame, setCmbFrameDrawn, listView)
		    guitk.BCShow(window)
		
		
		def setCmbFrameDrawn(cb, state, listView):
		    guitk.BCListViewSetItemComboBoxFrameDrawn(listView, not state)
		    print(
		        "ListViewComboBoxFrameDrawn = {}".format(
		            guitk.BCListViewIsItemComboBoxFrameDrawn(listView)
		        )
		    )
		    return 0
		
		
		def addPart(listView, pid, name, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetComboBox(
		        item, 4, ["Triangles", "Ortho-Triangles", "Rectangles"], None, None
		    )
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewSetRootIsDecorated(lv: object, decorated: bool) -> None:

	"""

	Sets whether the ListView will show controls for expanding/collapsing top level items (default false).
	Makes sense in tree views and is usually a (+) sign for collapsed items and a (-) sign for expanded items.
	Decoration can only be provided in items of the first added column (index 0).
	This function is not supported under VR mode.

	Parameters
	----------
	lv : object
		the ListView.

	decorated : bool
		set True to show expand/collapse controls or False otherwise (default).

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListView Tree", guitk.constants.BCOnExitDestroy
		    )
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], False)
		    # create group A
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 1, "Group A31")
		    addPart(groupA, "Bumper", "A31_1001", "8")
		    addPart(groupA, "Decklid", "A31_1002", "12")
		    # create group B
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 1, "Group B12")
		    addPart(groupB, "Roof rack", "B12_1004", "6")
		    addPart(groupB, "Spoiler", "B12_1005", "2")
		    # enabled sorting after all items added for performance reasons
		    guitk.BCListViewSetSortingColumn(treeView, 0, True)
		    # item expand/collapse controllers display only at first column ('Part name' in this case)
		    guitk.BCListViewSetRootIsDecorated(treeView, True)
		    guitk.BCListViewSetItemsExpanded(treeView, True)
		    guitk.BCListViewMoveColumn(treeView, 1, 0)
		    guitk.BCShow(window)
		
		
		def addPart(parentItem, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(parentItem)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCBlockSignals(w: object, block: bool) -> None:

	"""

	Function is obsolete. Use BCBlockCallBackFunctions() instead.
	This function is not supported under VR mode.

	Parameters
	----------
	w : object
		the widget.

	block : bool
		set this parameter to True to block widget events, or to False to unblock them.

	Returns
	-------
	None

	See Also
	--------
	BCBlockCallBackFunctions

	"""

def BCListViewItemComboBoxSetEditable(item: object, col: int, editable: bool) -> None:

	"""

	Sets whether the combobox items can be edited by the user (default false).
	Editable ComboBox allow the user to modify each item in the list.
	The new value will be inserted after the last item in the ComboBox (any input is accepted).
	NOTE: Duplicates are not allowed.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	editable : bool
		set this parameter to 1 to make item ComboBox editable; 0 otherwise.

	Returns
	-------
	None

	See Also
	--------
	BCListViewItemComboBoxText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "Example ListViewItem ComboBox Editable", guitk.constants.BCOnExitDestroy
		    )
		    listView = guitk.BCListViewCreate(window, 3, ["ID", "Part name", "Quantity"], 0)
		    addPart(listView, "1001", "Bumper")
		    addPart(listView, "1002", "Decklid")
		    addPart(listView, "1003", "Pillar")
		    addPart(listView, "1004", "Roof rack")
		    addPart(listView, "1005", "Spoiler")
		    guitk.BCShow(window)
		
		
		def addPart(parent, pid, name):
		    item = guitk.BCListViewAddTopLevelItem(parent)
		    guitk.BCListViewItemSetText(item, 0, pid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    guitk.BCListViewItemSetComboBox(
		        item, 2, ["10", "20", "100"], comboBoxActivatedFunct, False
		    )
		    guitk.BCListViewItemComboBoxSetEditable(item, 2, True)
		    return item
		
		
		def comboBoxActivatedFunct(item, col, index, noData):
		    text = guitk.BCListViewItemComboBoxText(item, col, index)
		    print(guitk.BCListViewItemGetText(item, 1) + " value is = " + str(text))
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCListViewItemComboBoxIsEditable(item: object, col: int) -> bool:

	"""

	Returns 1 in case the comboBox item in ListViewItem item, found in column col is editable; 0 otherwise.
	NOTE: If there is no comboBox at item at column col, this function returns 0.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		1 in case the comboBox item in ListViewItem item, found in column col is editable; 0 otherwise.

	See Also
	--------
	BCListViewItemComboBoxSetEditable

	"""

def BCListViewItemCheckBoxIsDim(item: object, col: int) -> bool:

	"""

	Returns whether the checkBox at item item is in dim state (partially checked).
	Check box can be drawn dimmed only when it is checked.
	This function is not supported under VR mode.

	Parameters
	----------
	item : object
		the ListViewItem.

	col : int
		the column index.

	Returns
	-------
	bool
		1 if the checkBox is partially checked, 0 otherwise.

	See Also
	--------
	BCListViewItemCheckBoxSetDim

	"""

def BCAnimationMessageCreate(p: object, a: int=guitk.constants.BCOnExitHide) -> object:

	"""

	Creates a box container enabled to provides short piece of text together with a widget. 
	The message is not shown until you call BCAnimationMessageShowText() or BCAnimationMessageShowTextTimeout().
	Message is displayed at the bottom of parent widget and can be aligned left or right.
	Message is provided with a close button but you can also hide it with BCAnimationMessageSetClosable().
	You can define the close behavior (hide or destroy) when Message cleared with [x] or timed-out.
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	a : int, optional
		describes what will happen to the widget when closed (cleared with [x]). See BCEnumExitAction for details.
		
		guitk.constants BCEnumExitAction
		This enum type defines what will happen to the window when its filter returns 1 (i.e. on
		exit). Exit action is used with BCWindowCreate for example.
		 - guitk.constants.BCOnExitHide
		hides the window.
		
		WARNING: var BCOnExitHide take no action when script ends.After script ends the window destroyed with var BCOnExitDestroy.
		var BCOnExitHide has action only if script not ends.
		
		WARNING: Take special care when you use this enumerator.
		You should destroy the window yourself in order to free the memory it holds.
		 - guitk.constants.BCOnExitDestroy
		destroys the window.

	Returns
	-------
	object
		The created message container.

	See Also
	--------
	BCAnimationMessageShowText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCAnimationMessage example", guitk.constants.BCOnExitDestroy
		    )
		    # create the ListView
		    listview = guitk.BCListViewCreate(window, 2, ["Color Id", "Color name"], False)
		    addColor(listview, "0", "red")
		    addColor(listview, "1", "green")
		    addColor(listview, "2", "blue")
		    addColor(listview, "3", "white")
		    # create a standing popup message
		    animMsg = guitk.BCAnimationMessageCreate(listview, guitk.constants.BCOnExitHide)
		    guitk.BCListViewSetSelectionChangedFunction(
		        listview, listViewSelectionChanged, animMsg
		    )
		    guitk.BCShow(window)
		
		
		def addColor(listview, cid, name):
		    item = guitk.BCListViewAddTopLevelItem(listview)
		    guitk.BCListViewItemSetText(item, 0, cid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def listViewSelectionChanged(listview, animMsg):
		    print("ListView selection item changed")
		    item = guitk.BCListViewGetSelectedItem(listview)
		    if item:
		        text = "Selected item is " + guitk.BCListViewItemGetText(item, 1)
		        guitk.BCAnimationMessageShowText(animMsg, text)
		    else:
		        guitk.BCAnimationMessageClear(animMsg)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAnimationMessageShowText(animMsg: object, text: str) -> None:

	"""

	Animates the widget to display text text.
	If you pass an empty text, AnimationMessage will be cleared.
	This function is not supported under VR mode.

	Parameters
	----------
	animMsg : object
		the animation message.

	text : str
		the short piece of text to be displayed.

	Returns
	-------
	None

	See Also
	--------
	BCAnimationMessageShowTextTimeout

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCAnimationMessage example", guitk.constants.BCOnExitDestroy
		    )
		    # create the ListView
		    listview = guitk.BCListViewCreate(window, 2, ["Color Id", "Color name"], False)
		    addColor(listview, "0", "red")
		    addColor(listview, "1", "green")
		    addColor(listview, "2", "blue")
		    addColor(listview, "3", "white")
		    # create a standing popup message
		    animMsg = guitk.BCAnimationMessageCreate(listview, guitk.constants.BCOnExitHide)
		    guitk.BCListViewSetSelectionChangedFunction(
		        listview, listViewSelectionChanged, animMsg
		    )
		    guitk.BCShow(window)
		
		
		def addColor(listview, cid, name):
		    item = guitk.BCListViewAddTopLevelItem(listview)
		    guitk.BCListViewItemSetText(item, 0, cid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def listViewSelectionChanged(listview, animMsg):
		    print("ListView selection item changed")
		    item = guitk.BCListViewGetSelectedItem(listview)
		    if item:
		        text = "Selected item is " + guitk.BCListViewItemGetText(item, 1)
		        guitk.BCAnimationMessageShowText(animMsg, text)
		    else:
		        guitk.BCAnimationMessageClear(animMsg)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAnimationMessageShowTextTimeout(animMsg: object, text: str, ms: int) -> None:

	"""

	Animates the AnimationMessage and text text is displayed for ms milli seconds and then message is cleared.
	If you pass an empty text, AnimationMessage will be cleared.
	This function is not supported under VR mode.

	Parameters
	----------
	animMsg : object
		the animation message.

	text : str
		the short piece of text to be displayed.

	ms : int
		the number of milliseconds after which the message will be cleared.

	Returns
	-------
	None

	See Also
	--------
	BCAnimationMessageShowText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCAnimationMessage example", guitk.constants.BCOnExitDestroy
		    )
		    frame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    # create the listView
		    listView = guitk.BCListViewCreate(frame, 2, ["Color Id", "Color name"], 0)
		    addColor(listView, "0", "red")
		    addColor(listView, "1", "green")
		    addColor(listView, "2", "blue")
		    addColor(listView, "3", "white")
		    guitk.BCPushButtonCreate(frame, "Update", updateButtonClicked, listView)
		    guitk.BCShow(window)
		
		
		def addColor(listView, colorId, name):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, colorId)
		    guitk.BCListViewItemSetText(item, 1, name)
		
		
		def updateButtonClicked(button, listView):
		    animMsg = guitk.BCAnimationMessageCreate(listView, guitk.constants.BCOnExitDestroy)
		    guitk.BCAnimationMessageSetAlignment(animMsg, guitk.constants.BCAlignRight)
		    guitk.BCAnimationMessageShowTextTimeout(animMsg, "Colors updated", 3000)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAnimationMessageClear(animMsg: object) -> None:

	"""

	Clears (hides) the AnimationMessage.
	Standard AnimationMessage is provided with a close button.
	This function is not supported under VR mode.

	Parameters
	----------
	animMsg : object
		the animation message.

	Returns
	-------
	None

	See Also
	--------
	BCAnimationMessageSetClosable

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCAnimationMessage example", guitk.constants.BCOnExitDestroy
		    )
		    # create the ListView
		    listview = guitk.BCListViewCreate(window, 2, ["Color Id", "Color name"], False)
		    addColor(listview, "0", "red")
		    addColor(listview, "1", "green")
		    addColor(listview, "2", "blue")
		    addColor(listview, "3", "white")
		    # create a standing popup message
		    animMsg = guitk.BCAnimationMessageCreate(listview, guitk.constants.BCOnExitHide)
		    guitk.BCListViewSetSelectionChangedFunction(
		        listview, listViewSelectionChanged, animMsg
		    )
		    guitk.BCShow(window)
		
		
		def addColor(listview, cid, name):
		    item = guitk.BCListViewAddTopLevelItem(listview)
		    guitk.BCListViewItemSetText(item, 0, cid)
		    guitk.BCListViewItemSetText(item, 1, name)
		    return item
		
		
		def listViewSelectionChanged(listview, animMsg):
		    print("ListView selection item changed")
		    item = guitk.BCListViewGetSelectedItem(listview)
		    if item:
		        text = "Selected item is " + guitk.BCListViewItemGetText(item, 1)
		        guitk.BCAnimationMessageShowText(animMsg, text)
		    else:
		        guitk.BCAnimationMessageClear(animMsg)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAnimationMessageSetWidget(animMsg: object, w: object=None) -> None:

	"""

	Sets the given widget w to be displayed at the right of the text.
	AnimationMessage takes ownership of the widget. If you set a None widget, any previous 
	widget will be deleted. If you set another widget the previous will be deleted (replace).
	NOTE: Theoretically, any widget can be inserted into the AnimationMessage. In practise, this only makes sense with certain widgets (buttons, checkboxes etc)
	This function is not supported under VR mode.

	Parameters
	----------
	animMsg : object
		the animation message.

	w : object, optional
		the widget.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCAnimationMessage Widget Example", guitk.constants.BCOnExitDestroy
		    )
		    chkBox = guitk.BCCheckBoxCreate(window, "CheckBox")
		    animMsg = guitk.BCAnimationMessageCreate(window, guitk.constants.BCOnExitHide)
		    guitk.BCAnimationMessageSetClosable(animMsg, False)
		    guitk.BCCheckBoxSetToggledFunction(chkBox, chkBoxToggled, animMsg)
		    btnUndo = guitk.BCPushButtonCreate(animMsg, "Undo", undoChkBox, (chkBox, animMsg))
		    guitk.BCAnimationMessageSetWidget(animMsg, btnUndo)
		    guitk.BCShow(window)
		
		
		def chkBoxToggled(chkBox, state, animMsg):
		    guitk.BCAnimationMessageShowText(
		        animMsg, "CheckBox Toggled To " + ("on" if state else "off")
		    )
		    return 0
		
		
		def undoChkBox(btn, data):
		    chkBox, animMsg = data
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBox, not guitk.BCCheckBoxIsChecked(chkBox))
		    guitk.BCAnimationMessageClear(animMsg)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAnimationMessageSetAlignment(animMsg: object, align: int) -> None:

	"""

	Aligns AnimationMessage bottom left (default) or right.
	Message is located at the bottom of its parent geometry.
	This function is not supported under VR mode.

	Parameters
	----------
	animMsg : object
		the animation message.

	align : int
		BCAlignLeft or BCAlignRight is only enabled.

	Returns
	-------
	None

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCAnimationMessage example", guitk.constants.BCOnExitDestroy
		    )
		    frame = guitk.BCFrameCreate(window)
		    guitk.BCBoxLayoutCreate(frame, guitk.constants.BCHorizontal)
		    # create the listView
		    listView = guitk.BCListViewCreate(frame, 2, ["Color Id", "Color name"], 0)
		    addColor(listView, "0", "red")
		    addColor(listView, "1", "green")
		    addColor(listView, "2", "blue")
		    addColor(listView, "3", "white")
		    guitk.BCPushButtonCreate(frame, "Update", updateButtonClicked, listView)
		    guitk.BCShow(window)
		
		
		def addColor(listView, colorId, name):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, colorId)
		    guitk.BCListViewItemSetText(item, 1, name)
		
		
		def updateButtonClicked(button, listView):
		    animMsg = guitk.BCAnimationMessageCreate(listView, guitk.constants.BCOnExitDestroy)
		    guitk.BCAnimationMessageSetAlignment(animMsg, guitk.constants.BCAlignRight)
		    guitk.BCAnimationMessageShowTextTimeout(animMsg, "Colors updated", 3000)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCAnimationMessageSetClosable(animMsg: object, closable: bool) -> None:

	"""

	Sets whether the close action (button [x]) is enabled to the user (default is enabled).
	This function is not supported under VR mode.

	Parameters
	----------
	animMsg : object
		the animation message.

	closable : bool
		set 0 to hide the button or 1 to show it (default).

	Returns
	-------
	None

	See Also
	--------
	BCAnimationMessageShowText

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "BCAnimationMessage Widget Example", guitk.constants.BCOnExitDestroy
		    )
		    chkBox = guitk.BCCheckBoxCreate(window, "CheckBox")
		    animMsg = guitk.BCAnimationMessageCreate(window, guitk.constants.BCOnExitHide)
		    guitk.BCAnimationMessageSetClosable(animMsg, False)
		    guitk.BCCheckBoxSetToggledFunction(chkBox, chkBoxToggled, animMsg)
		    btnUndo = guitk.BCPushButtonCreate(animMsg, "Undo", undoChkBox, (chkBox, animMsg))
		    guitk.BCAnimationMessageSetWidget(animMsg, btnUndo)
		    guitk.BCShow(window)
		
		
		def chkBoxToggled(chkBox, state, animMsg):
		    guitk.BCAnimationMessageShowText(
		        animMsg, "CheckBox Toggled To " + ("on" if state else "off")
		    )
		    return 0
		
		
		def undoChkBox(btn, data):
		    chkBox, animMsg = data
		    guitk.BCCheckBoxSetCheckedNoCallBack(chkBox, not guitk.BCCheckBoxIsChecked(chkBox))
		    guitk.BCAnimationMessageClear(animMsg)
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewStatusBarCreate(p: object, view: object) -> object:

	"""

	Creates a horizontal line with 3 labels able to provide useful information about item views (ListView ).
	The middle and right label updates automatically while the left most label can be used for customized information.
	StatusBar shows the total and the selected items of a view (multi selection).
	If the view is single selection mode, statusBar shows visible items. 
	When view is a tree, standard ItemViewStatusBar counts the total top level items, but this can be customized with BCItemViewStatusBarSetTotalCounterMode(). 
	You can also provide custom texts to ItemViewStatusBar using BCItemViewStatusBarBlockAutoUpdates() and BCItemViewStatusBarSetText().
	This function is not supported under VR mode.

	Parameters
	----------
	p : object
		the parent widget or layout.

	view : object
		the ListView for which the created ItemViewStatusBar will display info.

	Returns
	-------
	object
		the created ItemViewStatusBar.

	See Also
	--------
	BCItemViewStatusBarUpdate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ItemViewStatusBar Example", guitk.constants.BCOnExitDestroy
		    )
		
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], 0)
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 0, "Group A31")
		    groupAddPart(groupA, "Spoiler", "A31_1001", "8")
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 0, "Group B12")
		    groupAddPart(groupB, "Roof rack", "B12_1005", "2")
		    guitk.BCListViewSetSortingColumn(treeView, 0, 1)
		    guitk.BCListViewSetRootIsDecorated(treeView, 1)
		    guitk.BCListViewSetItemsExpanded(treeView, 1)
		
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewRestoreSortState(listView)
		
		    statusBar = guitk.BCItemViewStatusBarCreate(window, treeView)
		    guitk.BCItemViewStatusBarSetText(statusBar, 0, "Showing TreeView Info: ")
		
		    chBoxChangeList = guitk.BCCheckBoxCreate(window, "Show Info for ListView")
		    guitk.BCCheckBoxSetToggledFunction(
		        chBoxChangeList, changeList, [statusBar, listView, treeView]
		    )
		    # Text is changed only if BCCheckBox is checked.
		    chBoxChangeText = guitk.BCCheckBoxCreate(window, "Change text of field 'visible'")
		    guitk.BCCheckBoxSetToggledFunction(chBoxChangeText, changeText, statusBar)
		    # Count only top level items is the default mode. ONLY  for treeView
		    chBoxAll = guitk.BCCheckBoxCreate(window, "Count children items on total, too")
		    guitk.BCCheckBoxSetToggledFunction(chBoxAll, countChildrenOnTotalFunct, statusBar)
		    guitk.BCCheckBoxAddManagedWidget(
		        chBoxChangeList,
		        chBoxAll,
		        guitk.constants.BCManagedDisable,
		        guitk.constants.BCManagedEnable,
		    )
		
		    guitk.BCShow(window)
		
		
		def groupAddPart(group, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(group)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addPart(listView, name, pid, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def countChildrenOnTotalFunct(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 1)
		    else:
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 0)
		    return 0
		
		
		def changeText(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, True)
		        guitk.BCItemViewStatusBarSetText(statusBar, 2, "New text for field 'visible' ")
		    else:
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, False)
		        guitk.BCItemViewStatusBarUpdate(statusBar)
		    return 0
		
		
		def changeList(chBox, state, data):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetView(data[0], data[1])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing ListView Info: ")
		    else:
		        guitk.BCItemViewStatusBarSetView(data[0], data[2])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing TreeView Info: ")
		    guitk.BCItemViewStatusBarUpdate(data[0])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewStatusBarUpdate(statusBar: object) -> None:

	"""

	Updates the information displayed on the ItemViewStatusBar of ListView lv.
	You will need this function if you modify the views programmatically.
	This function is not supported under VR mode.

	Parameters
	----------
	statusBar : object
		the ItemViewStatusBar

	Returns
	-------
	None

	See Also
	--------
	BCListViewBlockUpdates

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ItemViewStatusBar Example", guitk.constants.BCOnExitDestroy
		    )
		
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], 0)
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 0, "Group A31")
		    groupAddPart(groupA, "Spoiler", "A31_1001", "8")
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 0, "Group B12")
		    groupAddPart(groupB, "Roof rack", "B12_1005", "2")
		    guitk.BCListViewSetSortingColumn(treeView, 0, 1)
		    guitk.BCListViewSetRootIsDecorated(treeView, 1)
		    guitk.BCListViewSetItemsExpanded(treeView, 1)
		
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewRestoreSortState(listView)
		
		    statusBar = guitk.BCItemViewStatusBarCreate(window, treeView)
		    guitk.BCItemViewStatusBarSetText(statusBar, 0, "Showing TreeView Info: ")
		
		    chBoxChangeList = guitk.BCCheckBoxCreate(window, "Show Info for ListView")
		    guitk.BCCheckBoxSetToggledFunction(
		        chBoxChangeList, changeList, [statusBar, listView, treeView]
		    )
		    # Text is changed only if BCCheckBox is checked.
		    chBoxChangeText = guitk.BCCheckBoxCreate(window, "Change text of field 'visible'")
		    guitk.BCCheckBoxSetToggledFunction(chBoxChangeText, changeText, statusBar)
		    # Count only top level items is the default mode. ONLY  for treeView
		    chBoxAll = guitk.BCCheckBoxCreate(window, "Count children items on total, too")
		    guitk.BCCheckBoxSetToggledFunction(chBoxAll, countChildrenOnTotalFunct, statusBar)
		    guitk.BCCheckBoxAddManagedWidget(
		        chBoxChangeList,
		        chBoxAll,
		        guitk.constants.BCManagedDisable,
		        guitk.constants.BCManagedEnable,
		    )
		
		    guitk.BCShow(window)
		
		
		def groupAddPart(group, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(group)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addPart(listView, name, pid, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def countChildrenOnTotalFunct(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 1)
		    else:
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 0)
		    return 0
		
		
		def changeText(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, True)
		        guitk.BCItemViewStatusBarSetText(statusBar, 2, "New text for field 'visible' ")
		    else:
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, False)
		        guitk.BCItemViewStatusBarUpdate(statusBar)
		    return 0
		
		
		def changeList(chBox, state, data):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetView(data[0], data[1])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing ListView Info: ")
		    else:
		        guitk.BCItemViewStatusBarSetView(data[0], data[2])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing TreeView Info: ")
		    guitk.BCItemViewStatusBarUpdate(data[0])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewStatusBarBlockAutoUpdates(statusBar: object, index: int, block: bool) -> None:

	"""

	Sets the section with index index of the ItemViewStatusBar associated with ListView lv to be updated automatically or manually.
	This function actually blocks/unblocks automatic updates. InfoBox has 3 sections given indices from 0 to 2 starting from the left most section. By default, the middle section provides information about "Total" items. The right most displays "Selected" items when BCMulti selection is applied to the managed ListView or "Visible" items when BCSingle selection is applied.
	WARNING: If you use this function with block 1 you will disable automatic update for the specific field. Thus you are responsible for the correct information that is displayed.
	This function is not supported under VR mode.

	Parameters
	----------
	statusBar : object
		the ItemViewStatusBar

	index : int
		set 0 to manually update left most field, 1 for the middle one and 2 for the field on the right.

	block : bool
		set True for manual updates or False for auto updates.

	Returns
	-------
	None

	See Also
	--------
	BCItemViewStatusBarCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ItemViewStatusBar Example", guitk.constants.BCOnExitDestroy
		    )
		
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], 0)
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 0, "Group A31")
		    groupAddPart(groupA, "Spoiler", "A31_1001", "8")
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 0, "Group B12")
		    groupAddPart(groupB, "Roof rack", "B12_1005", "2")
		    guitk.BCListViewSetSortingColumn(treeView, 0, 1)
		    guitk.BCListViewSetRootIsDecorated(treeView, 1)
		    guitk.BCListViewSetItemsExpanded(treeView, 1)
		
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewRestoreSortState(listView)
		
		    statusBar = guitk.BCItemViewStatusBarCreate(window, treeView)
		    guitk.BCItemViewStatusBarSetText(statusBar, 0, "Showing TreeView Info: ")
		
		    chBoxChangeList = guitk.BCCheckBoxCreate(window, "Show Info for ListView")
		    guitk.BCCheckBoxSetToggledFunction(
		        chBoxChangeList, changeList, [statusBar, listView, treeView]
		    )
		    # Text is changed only if BCCheckBox is checked.
		    chBoxChangeText = guitk.BCCheckBoxCreate(window, "Change text of field 'visible'")
		    guitk.BCCheckBoxSetToggledFunction(chBoxChangeText, changeText, statusBar)
		    # Count only top level items is the default mode. ONLY  for treeView
		    chBoxAll = guitk.BCCheckBoxCreate(window, "Count children items on total, too")
		    guitk.BCCheckBoxSetToggledFunction(chBoxAll, countChildrenOnTotalFunct, statusBar)
		    guitk.BCCheckBoxAddManagedWidget(
		        chBoxChangeList,
		        chBoxAll,
		        guitk.constants.BCManagedDisable,
		        guitk.constants.BCManagedEnable,
		    )
		
		    guitk.BCShow(window)
		
		
		def groupAddPart(group, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(group)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addPart(listView, name, pid, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def countChildrenOnTotalFunct(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 1)
		    else:
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 0)
		    return 0
		
		
		def changeText(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, True)
		        guitk.BCItemViewStatusBarSetText(statusBar, 2, "New text for field 'visible' ")
		    else:
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, False)
		        guitk.BCItemViewStatusBarUpdate(statusBar)
		    return 0
		
		
		def changeList(chBox, state, data):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetView(data[0], data[1])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing ListView Info: ")
		    else:
		        guitk.BCItemViewStatusBarSetView(data[0], data[2])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing TreeView Info: ")
		    guitk.BCItemViewStatusBarUpdate(data[0])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewStatusBarSetText(statusBar: object, index: int, text: str) -> None:

	"""

	Sets the text text to be displayed on the section with index index of the ItemViewStatusBar.
	Left most section can be modified directly with this function. Middle and right field can be set after you block auto updates using BCItemViewStatusBarBlockAutoUpdates().
	This function is not supported under VR mode.

	Parameters
	----------
	statusBar : object
		the ItemViewStatusBar

	index : int
		set 0 for the left most field, 1 for the middle one and 2 for the field on the right.

	text : str
		the message to be displayed.

	Returns
	-------
	None

	See Also
	--------
	BCItemViewStatusBarCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ItemViewStatusBar Example", guitk.constants.BCOnExitDestroy
		    )
		
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], 0)
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 0, "Group A31")
		    groupAddPart(groupA, "Spoiler", "A31_1001", "8")
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 0, "Group B12")
		    groupAddPart(groupB, "Roof rack", "B12_1005", "2")
		    guitk.BCListViewSetSortingColumn(treeView, 0, 1)
		    guitk.BCListViewSetRootIsDecorated(treeView, 1)
		    guitk.BCListViewSetItemsExpanded(treeView, 1)
		
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewRestoreSortState(listView)
		
		    statusBar = guitk.BCItemViewStatusBarCreate(window, treeView)
		    guitk.BCItemViewStatusBarSetText(statusBar, 0, "Showing TreeView Info: ")
		
		    chBoxChangeList = guitk.BCCheckBoxCreate(window, "Show Info for ListView")
		    guitk.BCCheckBoxSetToggledFunction(
		        chBoxChangeList, changeList, [statusBar, listView, treeView]
		    )
		    # Text is changed only if BCCheckBox is checked.
		    chBoxChangeText = guitk.BCCheckBoxCreate(window, "Change text of field 'visible'")
		    guitk.BCCheckBoxSetToggledFunction(chBoxChangeText, changeText, statusBar)
		    # Count only top level items is the default mode. ONLY  for treeView
		    chBoxAll = guitk.BCCheckBoxCreate(window, "Count children items on total, too")
		    guitk.BCCheckBoxSetToggledFunction(chBoxAll, countChildrenOnTotalFunct, statusBar)
		    guitk.BCCheckBoxAddManagedWidget(
		        chBoxChangeList,
		        chBoxAll,
		        guitk.constants.BCManagedDisable,
		        guitk.constants.BCManagedEnable,
		    )
		
		    guitk.BCShow(window)
		
		
		def groupAddPart(group, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(group)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addPart(listView, name, pid, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def countChildrenOnTotalFunct(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 1)
		    else:
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 0)
		    return 0
		
		
		def changeText(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, True)
		        guitk.BCItemViewStatusBarSetText(statusBar, 2, "New text for field 'visible' ")
		    else:
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, False)
		        guitk.BCItemViewStatusBarUpdate(statusBar)
		    return 0
		
		
		def changeList(chBox, state, data):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetView(data[0], data[1])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing ListView Info: ")
		    else:
		        guitk.BCItemViewStatusBarSetView(data[0], data[2])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing TreeView Info: ")
		    guitk.BCItemViewStatusBarUpdate(data[0])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewStatusBarSetTotalCounterMode(statusBar: object, mode: int) -> None:

	"""

	Sets whether the ItemViewStatusBar counts as total, all (children) or only the top level items.
	Standard ItemViewStatusBar counts top level items.
	This mode only makes sense for trees.
	This function is not supported under VR mode.

	Parameters
	----------
	statusBar : object
		the ItemViewStatusBar.

	mode : int
		set 1 to count all items of tree ListViews or 0 for top-level items only.

	Returns
	-------
	None

	See Also
	--------
	BCItemViewStatusBarCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ItemViewStatusBar Example", guitk.constants.BCOnExitDestroy
		    )
		
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], 0)
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 0, "Group A31")
		    groupAddPart(groupA, "Spoiler", "A31_1001", "8")
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 0, "Group B12")
		    groupAddPart(groupB, "Roof rack", "B12_1005", "2")
		    guitk.BCListViewSetSortingColumn(treeView, 0, 1)
		    guitk.BCListViewSetRootIsDecorated(treeView, 1)
		    guitk.BCListViewSetItemsExpanded(treeView, 1)
		
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewRestoreSortState(listView)
		
		    statusBar = guitk.BCItemViewStatusBarCreate(window, treeView)
		    guitk.BCItemViewStatusBarSetText(statusBar, 0, "Showing TreeView Info: ")
		
		    chBoxChangeList = guitk.BCCheckBoxCreate(window, "Show Info for ListView")
		    guitk.BCCheckBoxSetToggledFunction(
		        chBoxChangeList, changeList, [statusBar, listView, treeView]
		    )
		    # Text is changed only if BCCheckBox is checked.
		    chBoxChangeText = guitk.BCCheckBoxCreate(window, "Change text of field 'visible'")
		    guitk.BCCheckBoxSetToggledFunction(chBoxChangeText, changeText, statusBar)
		    # Count only top level items is the default mode. ONLY  for treeView
		    chBoxAll = guitk.BCCheckBoxCreate(window, "Count children items on total, too")
		    guitk.BCCheckBoxSetToggledFunction(chBoxAll, countChildrenOnTotalFunct, statusBar)
		    guitk.BCCheckBoxAddManagedWidget(
		        chBoxChangeList,
		        chBoxAll,
		        guitk.constants.BCManagedDisable,
		        guitk.constants.BCManagedEnable,
		    )
		
		    guitk.BCShow(window)
		
		
		def groupAddPart(group, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(group)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addPart(listView, name, pid, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def countChildrenOnTotalFunct(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 1)
		    else:
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 0)
		    return 0
		
		
		def changeText(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, True)
		        guitk.BCItemViewStatusBarSetText(statusBar, 2, "New text for field 'visible' ")
		    else:
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, False)
		        guitk.BCItemViewStatusBarUpdate(statusBar)
		    return 0
		
		
		def changeList(chBox, state, data):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetView(data[0], data[1])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing ListView Info: ")
		    else:
		        guitk.BCItemViewStatusBarSetView(data[0], data[2])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing TreeView Info: ")
		    guitk.BCItemViewStatusBarUpdate(data[0])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

def BCItemViewStatusBarSetView(statusBar: object, view: object) -> None:

	"""

	Set the view for which the information will be displayed.
	This function is not supported under VR mode.

	Parameters
	----------
	statusBar : object
		the ItemViewStatusBar.

	view : object
		the ListView  for which the ItemViewStatusBar will display info.

	Returns
	-------
	None

	See Also
	--------
	BCItemViewStatusBarCreate

	Examples
	--------
	::

		from sdm import guitk
		
		
		def main():
		    window = guitk.BCWindowCreate(
		        "ItemViewStatusBar Example", guitk.constants.BCOnExitDestroy
		    )
		
		    treeView = guitk.BCListViewCreate(window, 3, ["Part name", "ID", "Quantity"], 0)
		    groupA = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupA, 0, "Group A31")
		    groupAddPart(groupA, "Spoiler", "A31_1001", "8")
		    groupB = guitk.BCListViewAddTopLevelItem(treeView)
		    guitk.BCListViewItemSetText(groupB, 0, "Group B12")
		    groupAddPart(groupB, "Roof rack", "B12_1005", "2")
		    guitk.BCListViewSetSortingColumn(treeView, 0, 1)
		    guitk.BCListViewSetRootIsDecorated(treeView, 1)
		    guitk.BCListViewSetItemsExpanded(treeView, 1)
		
		    listView = guitk.BCListViewCreate(
		        window, 4, ["ID", "Part name", "Version", "Manufactured"], 1
		    )
		    guitk.BCListViewSaveSortStateAndDisableSorting(listView)
		    addPart(listView, "1001", "Bumper", "3A", "South Korea")
		    addPart(listView, "1002", "Decklid", "4A", "Germany")
		    guitk.BCListViewRestoreSortState(listView)
		
		    statusBar = guitk.BCItemViewStatusBarCreate(window, treeView)
		    guitk.BCItemViewStatusBarSetText(statusBar, 0, "Showing TreeView Info: ")
		
		    chBoxChangeList = guitk.BCCheckBoxCreate(window, "Show Info for ListView")
		    guitk.BCCheckBoxSetToggledFunction(
		        chBoxChangeList, changeList, [statusBar, listView, treeView]
		    )
		    # Text is changed only if BCCheckBox is checked.
		    chBoxChangeText = guitk.BCCheckBoxCreate(window, "Change text of field 'visible'")
		    guitk.BCCheckBoxSetToggledFunction(chBoxChangeText, changeText, statusBar)
		    # Count only top level items is the default mode. ONLY  for treeView
		    chBoxAll = guitk.BCCheckBoxCreate(window, "Count children items on total, too")
		    guitk.BCCheckBoxSetToggledFunction(chBoxAll, countChildrenOnTotalFunct, statusBar)
		    guitk.BCCheckBoxAddManagedWidget(
		        chBoxChangeList,
		        chBoxAll,
		        guitk.constants.BCManagedDisable,
		        guitk.constants.BCManagedEnable,
		    )
		
		    guitk.BCShow(window)
		
		
		def groupAddPart(group, name, pid, quantity):
		    item = guitk.BCListViewItemAddChild(group)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, quantity)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_Int)
		    return item
		
		
		def addPart(listView, name, pid, version, manufactured):
		    item = guitk.BCListViewAddTopLevelItem(listView)
		    guitk.BCListViewItemSetText(item, 0, name)
		    guitk.BCListViewItemSetText(item, 1, pid)
		    guitk.BCListViewItemSetText(item, 2, version)
		    guitk.BCListViewItemSetText(item, 3, manufactured)
		    guitk.BCListViewItemSetRenameType(item, 1, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 2, guitk.constants.BCRenameType_String)
		    guitk.BCListViewItemSetRenameType(item, 3, guitk.constants.BCRenameType_String)
		    return item
		
		
		def countChildrenOnTotalFunct(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 1)
		    else:
		        guitk.BCItemViewStatusBarSetTotalCounterMode(statusBar, 0)
		    return 0
		
		
		def changeText(chBox, state, statusBar):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, True)
		        guitk.BCItemViewStatusBarSetText(statusBar, 2, "New text for field 'visible' ")
		    else:
		        guitk.BCItemViewStatusBarBlockAutoUpdates(statusBar, 2, False)
		        guitk.BCItemViewStatusBarUpdate(statusBar)
		    return 0
		
		
		def changeList(chBox, state, data):
		    if guitk.BCCheckBoxIsChecked(chBox):
		        guitk.BCItemViewStatusBarSetView(data[0], data[1])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing ListView Info: ")
		    else:
		        guitk.BCItemViewStatusBarSetView(data[0], data[2])
		        guitk.BCItemViewStatusBarSetText(data[0], 0, "Showing TreeView Info: ")
		    guitk.BCItemViewStatusBarUpdate(data[0])
		    return 0
		
		
		if __name__ == "__main__":
		    main()


	"""

